[
  {
    "function_name": "sslEncKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "647-907",
    "snippet": "void sslEncKey(char *path, int mode) {\n\tchar *openssl = find_openssl_bin();\n\tchar *scr, *cert = NULL, *tca, *cdir = NULL;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tint tmp_fd, incert, info_only = 0, delete_only = 0, listlong = 0;\n\tstruct stat sbuf;\n\tFILE *file;\n\tstatic int depth = 0;\n\n\tif (depth > 0) {\n\t\t/* get_saved_pem may call us back. */\n\t\treturn;\n\t}\n\n\tif (! path) {\n\t\treturn;\n\t}\n\n\tdepth++;\n\n\tif (mode == 1) {\n\t\tinfo_only = 1;\n\t} else if (mode == 2) {\n\t\tdelete_only = 1;\n\t}\n\n\tif (! openssl) {\n\t\texit(1);\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tca);\n\tif (! cdir || ! tca) {\n\t\tfprintf(stderr, \"could not find Cert dir\\n\");\n\t\texit(1);\n\t}\n\n\tif (!strcasecmp(path, \"LL\") || !strcasecmp(path, \"LISTL\")) {\n\t\tlistlong = 1;\n\t\tpath = \"LIST\";\n\t}\n\n\tif (strstr(path, \"SAVE\") == path) {\n\t\tchar *p = get_saved_pem(path, 0);\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"could not find saved pem \"\n\t\t\t    \"matching: %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tpath = p;\n\n\t} else if (!strcmp(path, \"CA\")) {\n\t\ttca = (char *) malloc(strlen(cdir)+strlen(\"/CA/cacert.pem\")+1);\n\t\tsprintf(tca, \"%s/CA/cacert.pem\", cdir);\n\t\tpath = tca;\n\n\t} else if (info_only && (!strcasecmp(path, \"LIST\") ||\n\t    !strcasecmp(path, \"LS\") || !strcasecmp(path, \"ALL\"))) {\n\n\t\tif (! program_name || strchr(program_name, ' ')) {\n\t\t\tfprintf(stderr, \"bad program name.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (strchr(cdir, '\\'')) {\n\t\t\tfprintf(stderr, \"bad certdir char: %s\\n\", cdir);\n\t\t\texit(1);\n\t\t}\n\n\t\ttca = (char *) malloc(2*strlen(cdir)+strlen(program_name)+1000);\n\n\t\tsprintf(tca, \"find '%s' | egrep '/(CA|tmp|clients)$|\"\n\t\t    \"\\\\.(crt|pem|key|req)$' | grep -v CA/newcerts\", cdir);\n\n\t\tif (!strcasecmp(path, \"ALL\")) {\n\t\t\t/* ugh.. */\n\t\t\tstrcat(tca, \" | egrep -v 'private/cakey.pem|\"\n\t\t\t    \"(CA|tmp|clients)$' | xargs -n1 \");\n\t\t\tstrcat(tca, program_name);\n\t\t\tstrcat(tca, \" -ssldir '\");\n\t\t\tstrcat(tca, cdir);\n\t\t\tstrcat(tca, \"' -sslCertInfo 2>&1 \");\n\t\t} else if (listlong) {\n\t\t\tstrcat(tca, \" | xargs ls -ld \");\n\t\t}\n\t\tsystem(tca);\n\t\tfree(tca);\n\n\t\tdepth--;\n\t\treturn;\n\n\t} else if (info_only && (!strcasecmp(path, \"HASHON\")\n\t    || !strcasecmp(path, \"HASHOFF\"))) {\n\n\t\ttmp_fd = mkstemp(tmp);\n\t\tif (tmp_fd < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\twrite(tmp_fd, genCert, strlen(genCert));\n\t\tclose(tmp_fd);\n\n\t\tscr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\t\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\t\tset_env(\"BASE_DIR\", cdir);\n\t\tset_env(\"OPENSSL\", openssl);\n\t\tset_env(\"TYPE\", \"server\");\n\t\tif (!strcasecmp(path, \"HASHON\")) {\n\t\t\tset_env(\"HASHON\", \"1\");\n\t\t} else {\n\t\t\tset_env(\"HASHOFF\", \"1\");\n\t\t}\n\t\tsystem(scr);\n\t\tunlink(tmp);\n\t\tfree(scr);\n\n\t\tdepth--;\n\t\treturn;\n\t}\n\n\n\tif (stat(path, &sbuf) != 0) {\n\t    if (strstr(path, \"client\") || strchr(path, '/') == NULL) {\n\t\tint i;\n\t\ttca = (char *) malloc(strlen(cdir) + strlen(path) + 100);\n\t\tfor (i = 1; i <= 15; i++)  {\n\t\t\ttca[0] = '\\0';\n\t\t\tif (       i == 1) {\n\t\t\t    sprintf(tca, \"%s/%s\", cdir, path); \n\t\t\t} else if (i == 2 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/%s.crt\", cdir, path); \n\t\t\t} else if (i == 3) {\n\t\t\t    sprintf(tca, \"%s/%s.pem\", cdir, path); \n\t\t\t} else if (i == 4 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.req\", cdir, path); \n\t\t\t} else if (i == 5 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.key\", cdir, path); \n\t\t\t} else if (i == 6) {\n\t\t\t    sprintf(tca, \"%s/clients/%s\", cdir, path); \n\t\t\t} else if (i == 7 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.crt\", cdir, path); \n\t\t\t} else if (i == 8) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.pem\", cdir, path); \n\t\t\t} else if (i == 9 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.req\", cdir, path); \n\t\t\t} else if (i == 10 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.key\", cdir, path); \n\t\t\t} else if (i == 11) {\n\t\t\t    sprintf(tca, \"%s/server-%s\", cdir, path); \n\t\t\t} else if (i == 12 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/server-%s.crt\", cdir, path); \n\t\t\t} else if (i == 13) {\n\t\t\t    sprintf(tca, \"%s/server-%s.pem\", cdir, path); \n\t\t\t} else if (i == 14 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.req\", cdir, path); \n\t\t\t} else if (i == 15 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.key\", cdir, path); \n\t\t\t}\n\t\t\tif (tca[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(tca, &sbuf) == 0) {\n\t\t\t\tpath = tca;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\tif (stat(path, &sbuf) != 0) {\n\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\trfbLogPerror(\"stat\");\n\t\texit(1);\n\t}\n\n\tif (! info_only) {\n\t\tcert = (char *) malloc(2*(sbuf.st_size + 1024));\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\tincert = 0;\n\t\tcert[0] = '\\0';\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 1;\n\t\t\t}\n\t\t\tif (incert) {\n\t\t\t\tif (strlen(cert)+strlen(line) <\n\t\t\t\t    2 * (size_t) sbuf.st_size) {\n\t\t\t\t\tstrcat(cert, line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\texit(1);\n\t}\n\n\twrite(tmp_fd, genCert, strlen(genCert));\n\tclose(tmp_fd);\n\n        scr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\tset_env(\"BASE_DIR\", \"/no/such/dir\");\n\tset_env(\"OPENSSL\", openssl);\n\tset_env(\"TYPE\", \"server\");\n\tif (info_only) {\n\t\tset_env(\"INFO_ONLY\", path);\n\t} else if (delete_only) {\n\t\tset_env(\"DELETE_ONLY\", path);\n\t} else {\n\t\tset_env(\"ENCRYPT_ONLY\", path);\n\t}\n\tsystem(scr);\n\tunlink(tmp);\n\n\tif (! mode && cert && cert[0] != '\\0') {\n\t\tint got_cert = 0;\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t\tif (got_cert < 2) {\n\t\t\tfile = fopen(path, \"a\");\n\t\t\tif (file == NULL) {\n\t\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfprintf(file, \"%s\", cert);\n\t\t\tfclose(file);\n\t\t}\n\t\tfree(cert);\n\t}\n\n\tdepth--;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sslGenCA(char *cdir);",
      "void sslEncKey(char *path, int info_only);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cert"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "file",
            "\"%s\"",
            "cert"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslEncKey: %s\\n\"",
            "path"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"a\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"-----END CERTIFICATE-----\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"-----BEGIN CERTIFICATE-----\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "file"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslEncKey: %s\\n\"",
            "path"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "scr"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"ENCRYPT_ONLY\"",
            "path"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "scr",
            "\"/bin/sh %s\"",
            "tmp"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"/bin/sh \") + strlen(tmp) + 1"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/bin/sh \""
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "tmp_fd"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "tmp_fd",
            "genCert",
            "strlen(genCert)"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "genCert"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"-----END CERTIFICATE-----\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cert",
            "line"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cert"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"-----BEGIN CERTIFICATE-----\""
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "file"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslEncKey: %s\\n\"",
            "path"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2*(sbuf.st_size + 1024)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"stat\""
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslEncKey: %s\\n\"",
            "path"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sbuf"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/server-%s.key\"",
            "cdir",
            "path"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/server-%s.req\"",
            "cdir",
            "path"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/server-%s.pem\"",
            "cdir",
            "path"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/server-%s.crt\"",
            "cdir",
            "path"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/server-%s\"",
            "cdir",
            "path"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/clients/%s.key\"",
            "cdir",
            "path"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/clients/%s.req\"",
            "cdir",
            "path"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/clients/%s.pem\"",
            "cdir",
            "path"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/clients/%s.crt\"",
            "cdir",
            "path"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/clients/%s\"",
            "cdir",
            "path"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/%s.key\"",
            "cdir",
            "path"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/%s.req\"",
            "cdir",
            "path"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/%s.pem\"",
            "cdir",
            "path"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/%s.crt\"",
            "cdir",
            "path"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/%s\"",
            "cdir",
            "path"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(cdir) + strlen(path) + 100"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cdir"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "path",
            "\"client\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "scr"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"HASHON\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "scr",
            "\"/bin/sh %s\"",
            "tmp"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"/bin/sh \") + strlen(tmp) + 1"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/bin/sh \""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "genCert"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"HASHOFF\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"HASHON\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "tca"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tca",
            "\" | xargs ls -ld \""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tca",
            "\"' -sslCertInfo 2>&1 \""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tca",
            "cdir"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tca",
            "\" -ssldir '\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tca",
            "program_name"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tca",
            "\" | egrep -v 'private/cakey.pem|\"\n\t\t\t    \"(CA|tmp|clients)$' | xargs -n1 \""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"ALL\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"find '%s' | egrep '/(CA|tmp|clients)$|\"\n\t\t    \"\\\\.(crt|pem|key|req)$' | grep -v CA/newcerts\"",
            "cdir"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2*strlen(cdir)+strlen(program_name)+1000"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "program_name"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cdir"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bad certdir char: %s\\n\"",
            "cdir"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cdir",
            "'\\''"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bad program name.\\n\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "program_name",
            "' '"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"ALL\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"LS\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"LIST\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tca",
            "\"%s/CA/cacert.pem\"",
            "cdir"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(cdir)+strlen(\"/CA/cacert.pem\")+1"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/CA/cacert.pem\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cdir"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "path",
            "\"CA\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not find saved pem \"\n\t\t\t    \"matching: %s\\n\"",
            "path"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_saved_pem",
          "args": [
            "path",
            "0"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "get_saved_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "88-168",
          "snippet": "char *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_saved_pem(char *string, int create);",
            "char *create_tmp_pem(char *path, int prompt);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_saved_pem(char *string, int create);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "path",
            "\"SAVE\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"LISTL\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "path",
            "\"LL\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not find Cert dir\\n\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_Cert_dir",
          "args": [
            "NULL",
            "&tca"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "get_Cert_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "482-543",
          "snippet": "char *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_Cert_dir(char *cdir_in, char **tmp_in);",
            "void sslGenCA(char *cdir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in);\nvoid sslGenCA(char *cdir);\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openssl_bin",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "find_openssl_bin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "194-234",
          "snippet": "char *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *find_openssl_bin(void);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *find_openssl_bin(void);\nstatic char *get_input(char *tag, char **in);\n\nchar *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\nvoid sslEncKey(char *path, int info_only);\n\nvoid sslEncKey(char *path, int mode) {\n\tchar *openssl = find_openssl_bin();\n\tchar *scr, *cert = NULL, *tca, *cdir = NULL;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tint tmp_fd, incert, info_only = 0, delete_only = 0, listlong = 0;\n\tstruct stat sbuf;\n\tFILE *file;\n\tstatic int depth = 0;\n\n\tif (depth > 0) {\n\t\t/* get_saved_pem may call us back. */\n\t\treturn;\n\t}\n\n\tif (! path) {\n\t\treturn;\n\t}\n\n\tdepth++;\n\n\tif (mode == 1) {\n\t\tinfo_only = 1;\n\t} else if (mode == 2) {\n\t\tdelete_only = 1;\n\t}\n\n\tif (! openssl) {\n\t\texit(1);\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tca);\n\tif (! cdir || ! tca) {\n\t\tfprintf(stderr, \"could not find Cert dir\\n\");\n\t\texit(1);\n\t}\n\n\tif (!strcasecmp(path, \"LL\") || !strcasecmp(path, \"LISTL\")) {\n\t\tlistlong = 1;\n\t\tpath = \"LIST\";\n\t}\n\n\tif (strstr(path, \"SAVE\") == path) {\n\t\tchar *p = get_saved_pem(path, 0);\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"could not find saved pem \"\n\t\t\t    \"matching: %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tpath = p;\n\n\t} else if (!strcmp(path, \"CA\")) {\n\t\ttca = (char *) malloc(strlen(cdir)+strlen(\"/CA/cacert.pem\")+1);\n\t\tsprintf(tca, \"%s/CA/cacert.pem\", cdir);\n\t\tpath = tca;\n\n\t} else if (info_only && (!strcasecmp(path, \"LIST\") ||\n\t    !strcasecmp(path, \"LS\") || !strcasecmp(path, \"ALL\"))) {\n\n\t\tif (! program_name || strchr(program_name, ' ')) {\n\t\t\tfprintf(stderr, \"bad program name.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (strchr(cdir, '\\'')) {\n\t\t\tfprintf(stderr, \"bad certdir char: %s\\n\", cdir);\n\t\t\texit(1);\n\t\t}\n\n\t\ttca = (char *) malloc(2*strlen(cdir)+strlen(program_name)+1000);\n\n\t\tsprintf(tca, \"find '%s' | egrep '/(CA|tmp|clients)$|\"\n\t\t    \"\\\\.(crt|pem|key|req)$' | grep -v CA/newcerts\", cdir);\n\n\t\tif (!strcasecmp(path, \"ALL\")) {\n\t\t\t/* ugh.. */\n\t\t\tstrcat(tca, \" | egrep -v 'private/cakey.pem|\"\n\t\t\t    \"(CA|tmp|clients)$' | xargs -n1 \");\n\t\t\tstrcat(tca, program_name);\n\t\t\tstrcat(tca, \" -ssldir '\");\n\t\t\tstrcat(tca, cdir);\n\t\t\tstrcat(tca, \"' -sslCertInfo 2>&1 \");\n\t\t} else if (listlong) {\n\t\t\tstrcat(tca, \" | xargs ls -ld \");\n\t\t}\n\t\tsystem(tca);\n\t\tfree(tca);\n\n\t\tdepth--;\n\t\treturn;\n\n\t} else if (info_only && (!strcasecmp(path, \"HASHON\")\n\t    || !strcasecmp(path, \"HASHOFF\"))) {\n\n\t\ttmp_fd = mkstemp(tmp);\n\t\tif (tmp_fd < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\twrite(tmp_fd, genCert, strlen(genCert));\n\t\tclose(tmp_fd);\n\n\t\tscr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\t\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\t\tset_env(\"BASE_DIR\", cdir);\n\t\tset_env(\"OPENSSL\", openssl);\n\t\tset_env(\"TYPE\", \"server\");\n\t\tif (!strcasecmp(path, \"HASHON\")) {\n\t\t\tset_env(\"HASHON\", \"1\");\n\t\t} else {\n\t\t\tset_env(\"HASHOFF\", \"1\");\n\t\t}\n\t\tsystem(scr);\n\t\tunlink(tmp);\n\t\tfree(scr);\n\n\t\tdepth--;\n\t\treturn;\n\t}\n\n\n\tif (stat(path, &sbuf) != 0) {\n\t    if (strstr(path, \"client\") || strchr(path, '/') == NULL) {\n\t\tint i;\n\t\ttca = (char *) malloc(strlen(cdir) + strlen(path) + 100);\n\t\tfor (i = 1; i <= 15; i++)  {\n\t\t\ttca[0] = '\\0';\n\t\t\tif (       i == 1) {\n\t\t\t    sprintf(tca, \"%s/%s\", cdir, path); \n\t\t\t} else if (i == 2 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/%s.crt\", cdir, path); \n\t\t\t} else if (i == 3) {\n\t\t\t    sprintf(tca, \"%s/%s.pem\", cdir, path); \n\t\t\t} else if (i == 4 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.req\", cdir, path); \n\t\t\t} else if (i == 5 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.key\", cdir, path); \n\t\t\t} else if (i == 6) {\n\t\t\t    sprintf(tca, \"%s/clients/%s\", cdir, path); \n\t\t\t} else if (i == 7 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.crt\", cdir, path); \n\t\t\t} else if (i == 8) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.pem\", cdir, path); \n\t\t\t} else if (i == 9 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.req\", cdir, path); \n\t\t\t} else if (i == 10 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.key\", cdir, path); \n\t\t\t} else if (i == 11) {\n\t\t\t    sprintf(tca, \"%s/server-%s\", cdir, path); \n\t\t\t} else if (i == 12 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/server-%s.crt\", cdir, path); \n\t\t\t} else if (i == 13) {\n\t\t\t    sprintf(tca, \"%s/server-%s.pem\", cdir, path); \n\t\t\t} else if (i == 14 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.req\", cdir, path); \n\t\t\t} else if (i == 15 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.key\", cdir, path); \n\t\t\t}\n\t\t\tif (tca[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(tca, &sbuf) == 0) {\n\t\t\t\tpath = tca;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\tif (stat(path, &sbuf) != 0) {\n\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\trfbLogPerror(\"stat\");\n\t\texit(1);\n\t}\n\n\tif (! info_only) {\n\t\tcert = (char *) malloc(2*(sbuf.st_size + 1024));\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\tincert = 0;\n\t\tcert[0] = '\\0';\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 1;\n\t\t\t}\n\t\t\tif (incert) {\n\t\t\t\tif (strlen(cert)+strlen(line) <\n\t\t\t\t    2 * (size_t) sbuf.st_size) {\n\t\t\t\t\tstrcat(cert, line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\texit(1);\n\t}\n\n\twrite(tmp_fd, genCert, strlen(genCert));\n\tclose(tmp_fd);\n\n        scr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\tset_env(\"BASE_DIR\", \"/no/such/dir\");\n\tset_env(\"OPENSSL\", openssl);\n\tset_env(\"TYPE\", \"server\");\n\tif (info_only) {\n\t\tset_env(\"INFO_ONLY\", path);\n\t} else if (delete_only) {\n\t\tset_env(\"DELETE_ONLY\", path);\n\t} else {\n\t\tset_env(\"ENCRYPT_ONLY\", path);\n\t}\n\tsystem(scr);\n\tunlink(tmp);\n\n\tif (! mode && cert && cert[0] != '\\0') {\n\t\tint got_cert = 0;\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t\tif (got_cert < 2) {\n\t\t\tfile = fopen(path, \"a\");\n\t\t\tif (file == NULL) {\n\t\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfprintf(file, \"%s\", cert);\n\t\t\tfclose(file);\n\t\t}\n\t\tfree(cert);\n\t}\n\n\tdepth--;\n}"
  },
  {
    "function_name": "sslGenCert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "611-645",
    "snippet": "void sslGenCert(char *ty, char *nm) {\n\tchar *cmd, *scr = getsslscript(NULL, \"gencert\", genCert);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tif (! ty) {\n\t\tset_env(\"TYPE\", \"\");\n\t} else {\n\t\tset_env(\"TYPE\", ty);\n\t}\n\tif (! nm) {\n\t\tset_env(\"NAME\", \"\");\n\t} else {\n\t\tchar *q = strstr(nm, \"SAVE-\");\n\t\tif (!strcmp(nm, \"SAVE\")) {\n\t\t\tset_env(\"NAME\", \"\");\n\t\t} else if (q == nm) {\n\t\t\tq += strlen(\"SAVE-\");\n\t\t\tset_env(\"NAME\", q);\n\t\t} else {\n\t\t\tset_env(\"NAME\", nm);\n\t\t}\n\t}\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sslGenCert(char *ty, char *nm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "scr"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "scr"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"NAME\"",
            "nm"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"SAVE-\""
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "nm",
            "\"SAVE\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "nm",
            "\"SAVE-\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"/bin/sh %s\"",
            "scr"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"/bin/sh \") + strlen(scr) + 1"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "scr"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/bin/sh \""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsslscript",
          "args": [
            "NULL",
            "\"gencert\"",
            "genCert"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "getsslscript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "545-583",
          "snippet": "static char *getsslscript(char *cdir, char *name, char *script) {\n\tchar *openssl = find_openssl_bin();\n\tchar *tmp, *scr, *cdir_use;\n\tFILE *out;\n\n\tif (! openssl || openssl[0] == '\\0') {\n\t\texit(1);\n\t}\n\n\tif (!name || !script) {\n\t\texit(1);\n\t}\n\n\tcdir_use = get_Cert_dir(cdir, &tmp);\n\tif (!cdir_use || !tmp) {\n\t\texit(1);\n\t}\n\n\tscr = (char *) malloc(strlen(tmp) + 1 + strlen(name) + 30);\n\n\tsprintf(scr, \"%s/%s.%d.sh\", tmp, name, getpid());\n\tout = fopen(scr, \"w\");\n\tif (! out) {\n\t\trfbLog(\"could not open: %s\\n\", scr);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\tfprintf(out, \"%s\", script);\n\tfclose(out);\n\n\trfbLog(\"Using openssl:   %s\\n\", openssl);\n\trfbLog(\"Using certs dir: %s\\n\", cdir_use);\n\tfprintf(stderr, \"\\n\");\n\n\tset_env(\"BASE_DIR\", cdir_use);\n\tset_env(\"OPENSSL\", openssl);\n\n\treturn scr;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sslGenCA(char *cdir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\n\nstatic char *getsslscript(char *cdir, char *name, char *script) {\n\tchar *openssl = find_openssl_bin();\n\tchar *tmp, *scr, *cdir_use;\n\tFILE *out;\n\n\tif (! openssl || openssl[0] == '\\0') {\n\t\texit(1);\n\t}\n\n\tif (!name || !script) {\n\t\texit(1);\n\t}\n\n\tcdir_use = get_Cert_dir(cdir, &tmp);\n\tif (!cdir_use || !tmp) {\n\t\texit(1);\n\t}\n\n\tscr = (char *) malloc(strlen(tmp) + 1 + strlen(name) + 30);\n\n\tsprintf(scr, \"%s/%s.%d.sh\", tmp, name, getpid());\n\tout = fopen(scr, \"w\");\n\tif (! out) {\n\t\trfbLog(\"could not open: %s\\n\", scr);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\tfprintf(out, \"%s\", script);\n\tfclose(out);\n\n\trfbLog(\"Using openssl:   %s\\n\", openssl);\n\trfbLog(\"Using certs dir: %s\\n\", cdir_use);\n\tfprintf(stderr, \"\\n\");\n\n\tset_env(\"BASE_DIR\", cdir_use);\n\tset_env(\"OPENSSL\", openssl);\n\n\treturn scr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCert(char *ty, char *nm);\n\nvoid sslGenCert(char *ty, char *nm) {\n\tchar *cmd, *scr = getsslscript(NULL, \"gencert\", genCert);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tif (! ty) {\n\t\tset_env(\"TYPE\", \"\");\n\t} else {\n\t\tset_env(\"TYPE\", ty);\n\t}\n\tif (! nm) {\n\t\tset_env(\"NAME\", \"\");\n\t} else {\n\t\tchar *q = strstr(nm, \"SAVE-\");\n\t\tif (!strcmp(nm, \"SAVE\")) {\n\t\t\tset_env(\"NAME\", \"\");\n\t\t} else if (q == nm) {\n\t\t\tq += strlen(\"SAVE-\");\n\t\t\tset_env(\"NAME\", q);\n\t\t} else {\n\t\t\tset_env(\"NAME\", nm);\n\t\t}\n\t}\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}"
  },
  {
    "function_name": "sslGenCA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "594-609",
    "snippet": "void sslGenCA(char *cdir) {\n\tchar *cmd, *scr = getsslscript(cdir, \"genca\", genCA);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sslGenCA(char *cdir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "scr"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "scr"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"/bin/sh %s\"",
            "scr"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"/bin/sh \") + strlen(scr) + 1"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "scr"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/bin/sh \""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsslscript",
          "args": [
            "cdir",
            "\"genca\"",
            "genCA"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "getsslscript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "545-583",
          "snippet": "static char *getsslscript(char *cdir, char *name, char *script) {\n\tchar *openssl = find_openssl_bin();\n\tchar *tmp, *scr, *cdir_use;\n\tFILE *out;\n\n\tif (! openssl || openssl[0] == '\\0') {\n\t\texit(1);\n\t}\n\n\tif (!name || !script) {\n\t\texit(1);\n\t}\n\n\tcdir_use = get_Cert_dir(cdir, &tmp);\n\tif (!cdir_use || !tmp) {\n\t\texit(1);\n\t}\n\n\tscr = (char *) malloc(strlen(tmp) + 1 + strlen(name) + 30);\n\n\tsprintf(scr, \"%s/%s.%d.sh\", tmp, name, getpid());\n\tout = fopen(scr, \"w\");\n\tif (! out) {\n\t\trfbLog(\"could not open: %s\\n\", scr);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\tfprintf(out, \"%s\", script);\n\tfclose(out);\n\n\trfbLog(\"Using openssl:   %s\\n\", openssl);\n\trfbLog(\"Using certs dir: %s\\n\", cdir_use);\n\tfprintf(stderr, \"\\n\");\n\n\tset_env(\"BASE_DIR\", cdir_use);\n\tset_env(\"OPENSSL\", openssl);\n\n\treturn scr;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sslGenCA(char *cdir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\n\nstatic char *getsslscript(char *cdir, char *name, char *script) {\n\tchar *openssl = find_openssl_bin();\n\tchar *tmp, *scr, *cdir_use;\n\tFILE *out;\n\n\tif (! openssl || openssl[0] == '\\0') {\n\t\texit(1);\n\t}\n\n\tif (!name || !script) {\n\t\texit(1);\n\t}\n\n\tcdir_use = get_Cert_dir(cdir, &tmp);\n\tif (!cdir_use || !tmp) {\n\t\texit(1);\n\t}\n\n\tscr = (char *) malloc(strlen(tmp) + 1 + strlen(name) + 30);\n\n\tsprintf(scr, \"%s/%s.%d.sh\", tmp, name, getpid());\n\tout = fopen(scr, \"w\");\n\tif (! out) {\n\t\trfbLog(\"could not open: %s\\n\", scr);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\tfprintf(out, \"%s\", script);\n\tfclose(out);\n\n\trfbLog(\"Using openssl:   %s\\n\", openssl);\n\trfbLog(\"Using certs dir: %s\\n\", cdir_use);\n\tfprintf(stderr, \"\\n\");\n\n\tset_env(\"BASE_DIR\", cdir_use);\n\tset_env(\"OPENSSL\", openssl);\n\n\treturn scr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\n\nvoid sslGenCA(char *cdir) {\n\tchar *cmd, *scr = getsslscript(cdir, \"genca\", genCA);\n\n\tif (! scr) {\n\t\texit(1);\n\t}\n\n\tcmd = (char *)malloc(strlen(\"/bin/sh \") + strlen(scr) + 1);\n\tsprintf(cmd, \"/bin/sh %s\", scr);\n\n\tsystem(cmd);\n\tunlink(scr);\n\n\tfree(cmd);\n\tfree(scr);\n}"
  },
  {
    "function_name": "sslScripts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "585-592",
    "snippet": "void sslScripts(void) {\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCA script for '-sslGenCA':\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCA);\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCert script for '-sslGenCert', etc.:\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCert);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sslScripts(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "genCert"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"genCert script for '-sslGenCert', etc.:\\n\\n\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"======================================================\\n\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "genCA"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"genCA script for '-sslGenCA':\\n\\n\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"======================================================\\n\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslScripts(void);\n\nvoid sslScripts(void) {\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCA script for '-sslGenCA':\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCA);\n\tfprintf(stdout, \"======================================================\\n\");\n\tfprintf(stdout, \"genCert script for '-sslGenCert', etc.:\\n\\n\");\n\tfprintf(stdout, \"%s\\n\", genCert);\n}"
  },
  {
    "function_name": "getsslscript",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "545-583",
    "snippet": "static char *getsslscript(char *cdir, char *name, char *script) {\n\tchar *openssl = find_openssl_bin();\n\tchar *tmp, *scr, *cdir_use;\n\tFILE *out;\n\n\tif (! openssl || openssl[0] == '\\0') {\n\t\texit(1);\n\t}\n\n\tif (!name || !script) {\n\t\texit(1);\n\t}\n\n\tcdir_use = get_Cert_dir(cdir, &tmp);\n\tif (!cdir_use || !tmp) {\n\t\texit(1);\n\t}\n\n\tscr = (char *) malloc(strlen(tmp) + 1 + strlen(name) + 30);\n\n\tsprintf(scr, \"%s/%s.%d.sh\", tmp, name, getpid());\n\tout = fopen(scr, \"w\");\n\tif (! out) {\n\t\trfbLog(\"could not open: %s\\n\", scr);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\tfprintf(out, \"%s\", script);\n\tfclose(out);\n\n\trfbLog(\"Using openssl:   %s\\n\", openssl);\n\trfbLog(\"Using certs dir: %s\\n\", cdir_use);\n\tfprintf(stderr, \"\\n\");\n\n\tset_env(\"BASE_DIR\", cdir_use);\n\tset_env(\"OPENSSL\", openssl);\n\n\treturn scr;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sslGenCA(char *cdir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"OPENSSL\"",
            "openssl"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Using certs dir: %s\\n\"",
            "cdir_use"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Using openssl:   %s\\n\"",
            "openssl"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "out",
            "\"%s\"",
            "script"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not open: %s\\n\"",
            "scr"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "scr",
            "\"w\""
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "scr",
            "\"%s/%s.%d.sh\"",
            "tmp",
            "name",
            "getpid()"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(tmp) + 1 + strlen(name) + 30"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_Cert_dir",
          "args": [
            "cdir",
            "&tmp"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "get_Cert_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "482-543",
          "snippet": "char *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_Cert_dir(char *cdir_in, char **tmp_in);",
            "void sslGenCA(char *cdir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in);\nvoid sslGenCA(char *cdir);\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openssl_bin",
          "args": [],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "find_openssl_bin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "194-234",
          "snippet": "char *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *find_openssl_bin(void);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *find_openssl_bin(void);\nstatic char *get_input(char *tag, char **in);\n\nchar *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\n\nstatic char *getsslscript(char *cdir, char *name, char *script) {\n\tchar *openssl = find_openssl_bin();\n\tchar *tmp, *scr, *cdir_use;\n\tFILE *out;\n\n\tif (! openssl || openssl[0] == '\\0') {\n\t\texit(1);\n\t}\n\n\tif (!name || !script) {\n\t\texit(1);\n\t}\n\n\tcdir_use = get_Cert_dir(cdir, &tmp);\n\tif (!cdir_use || !tmp) {\n\t\texit(1);\n\t}\n\n\tscr = (char *) malloc(strlen(tmp) + 1 + strlen(name) + 30);\n\n\tsprintf(scr, \"%s/%s.%d.sh\", tmp, name, getpid());\n\tout = fopen(scr, \"w\");\n\tif (! out) {\n\t\trfbLog(\"could not open: %s\\n\", scr);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\tfprintf(out, \"%s\", script);\n\tfclose(out);\n\n\trfbLog(\"Using openssl:   %s\\n\", openssl);\n\trfbLog(\"Using certs dir: %s\\n\", cdir_use);\n\tfprintf(stderr, \"\\n\");\n\n\tset_env(\"BASE_DIR\", cdir_use);\n\tset_env(\"OPENSSL\", openssl);\n\n\treturn scr;\n}"
  },
  {
    "function_name": "get_Cert_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "482-543",
    "snippet": "char *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_Cert_dir(char *cdir_in, char **tmp_in);",
      "void sslGenCA(char *cdir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%s/tmp\"",
            "cdir"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"not a directory: %s\\n\"",
            "tmp"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"mkdir\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not create directory %s\\n\"",
            "tmp"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "tmp",
            "0755"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "tmp",
            "0700"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cases2[i]",
            "\"/tmp\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"creating dir: %s\\n\"",
            "tmp"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "tmp",
            "&sbuf"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%s%s\"",
            "cdir",
            "cases2[i]"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(cdir) + strlen(\"/tmp\") + 1"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/tmp\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cdir"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cdir",
            "\"%s%s\"",
            "home",
            "cases1[1]"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"not a directory: %s\\n\"",
            "cdir"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"mkdir\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not create directory %s\\n\"",
            "cdir"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "cdir",
            "0755"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"creating dir: %s\\n\"",
            "cdir"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cdir",
            "\"%s%s\"",
            "home",
            "cases1[i]"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(home) + strlen(\"/.vnc/certs/CA\") + 1"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/.vnc/certs/CA\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "home"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_home_dir",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "get_home_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "295-314",
          "snippet": "char *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_home_dir(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nchar *get_home_dir(void);\n\nchar *get_home_dir(void) {\n\tchar *home = NULL;\n\n\thome = getenv(\"HOME\");\n\n#if HAVE_PWD_H\n\tif (home == NULL) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw) {\n\t\t\thome = pw->pw_dir;\n\t\t}\n\t}\n#endif\n\n\tif (home) {\n\t\treturn(strdup(home));\n\t} else {\n\t\treturn(strdup(\"/\"));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in);\nvoid sslGenCA(char *cdir);\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}"
  },
  {
    "function_name": "setup_stunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "393-480",
    "snippet": "void setup_stunnel(int rport, int *argc, char **argv) {\n\tint i, xport = 0, hport = 0, xhport = 0;\n\n\tif (! rport && argc && argv) {\n\t\tfor (i=0; i< *argc; i++) {\n\t\t\tif (argv[i] && !strcmp(argv[i], \"-rfbport\")) {\n\t\t\t\tif (i < *argc - 1) {\n\t\t\t\t\trport = atoi(argv[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! rport) {\n\t\t/* we do our own autoprobing then... */\n\t\trport = find_free_port(5900, 5999);\n\t\tif (! rport) {\n\t\t\tgoto stunnel_fail;\n\t\t}\n\t}\n\n\txport = find_free_port(5950, 5999);\n\tif (! xport) {\n\t\tgoto stunnel_fail; \n\t}\n\n\tif (https_port_num > 0) {\n\t\thport = https_port_num;\n\t}\n\n\tif (! hport && argc && argv) {\n\t\tfor (i=0; i< *argc; i++) {\n\t\t\tif (argv[i] && !strcmp(argv[i], \"-httpport\")) {\n\t\t\t\tif (i < *argc - 1) {\n\t\t\t\t\thport = atoi(argv[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! hport && http_try_it) {\n\t\thport = find_free_port(rport-100, rport-1);\n\t\tif (! hport) {\n\t\t\tgoto stunnel_fail;\n\t\t}\n\t}\n\tif (hport) {\n\t\txhport = find_free_port(5850, 5899);\n\t\tif (! xhport) {\n\t\t\tgoto stunnel_fail; \n\t\t}\n\t\tstunnel_http_port = hport;\n\t}\n\t\n\n\tif (start_stunnel(rport, xport, hport, xhport)) {\n\t\tint tweaked = 0;\n\t\tchar tmp[30];\n\t\tsprintf(tmp, \"%d\", xport);\n\t\tif (argc && argv) {\n\t\t\tfor (i=0; i < *argc; i++) {\n\t\t\t\tif (argv[i] && !strcmp(argv[i], \"-rfbport\")) {\n\t\t\t\t\tif (i < *argc - 1) {\n\t\t\t\t\t\t/* replace orig value */\n\t\t\t\t\t\targv[i+i] = strdup(tmp); \n\t\t\t\t\t\ttweaked = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! tweaked) {\n\t\t\t\ti = *argc;\n\t\t\t\targv[i] = strdup(\"-rfbport\");\n\t\t\t\targv[i+1] = strdup(tmp);\n\t\t\t\t*argc += 2;\n\t\t\t\tgot_rfbport = 1;\n\t\t\t\tgot_rfbport_val = atoi(tmp);\n\t\t\t}\n\t\t}\n\t\tstunnel_port = rport;\n\t\tssl_initialized = 1;\n\t\treturn;\n\t}\n\n\tstunnel_fail:\n\trfbLog(\"failed to start stunnel.\\n\");\n\tclean_up_exit(1);\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void setup_stunnel(int rport, int *argc, char **argv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to start stunnel.\\n\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "tmp"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"-rfbport\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "tmp"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-rfbport\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%d\"",
            "xport"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_stunnel",
          "args": [
            "rport",
            "xport",
            "hport",
            "xhport"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "start_stunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "90-376",
          "snippet": "int start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport) {\n#ifdef SSLCMDS\n\tchar extra[] = \":/usr/sbin:/usr/local/sbin:/dist/sbin\";\n\tchar *path, *p, *exe;\n\tchar *stunnel_path = NULL;\n\tstruct stat verify_buf;\n\tstruct stat crl_buf;\n\tint status, tmp_pem = 0;\n\n\tif (stunnel_pid) {\n\t\tstop_stunnel();\n\t}\n\tstunnel_pid = 0;\n\n\tpath = getenv(\"PATH\");\n\tif (! path) {\n\t\tpath = strdup(extra+1);\n\t} else {\n\t\tchar *pt = path;\n\t\tpath = (char *) malloc(strlen(path)+strlen(extra)+1);\n\t\tif (! path) {\n\t\t\treturn 0;\n\t\t}\n\t\tstrcpy(path, pt);\n\t\tstrcat(path, extra);\n\t}\n\n\texe = (char *) malloc(strlen(path) + 1 + strlen(\"stunnel4\") + 1);\n\n\tp = strtok(path, \":\");\n\n\texe[0] = '\\0';\n\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel4\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tif (path) {\n\t\tfree(path);\n\t}\n\n\tif (getenv(\"STUNNEL_PROG\")) {\n\t\tfree(exe);\n\t\texe = strdup(getenv(\"STUNNEL_PROG\"));\n\t\tstunnel_path = exe;\n\t}\n\n\tif (! stunnel_path) {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\tif (stunnel_path[0] == '\\0') {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\t/* stunnel */\n\tif (no_external_cmds || !cmd_ok(\"stunnel\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"start_stunnel: cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", stunnel_path);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"starting ssl tunnel: %s  %d -> %d\\n\", stunnel_path,\n\t\t    stunnel_port, x11vnc_port);\n\t}\n\n\tif (stunnel_pem && strstr(stunnel_pem, \"SAVE\") == stunnel_pem) {\n\t\tstunnel_pem = get_saved_pem(stunnel_pem, 1);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create or open\"\n\t\t\t    \" saved PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (!stunnel_pem) {\n\t\tstunnel_pem = create_tmp_pem(NULL, 0);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(stunnel_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ssl_verify) {\n\t\tchar *file = get_ssl_verify_file(ssl_verify);\n\t\tif (file) {\n\t\t\tssl_verify = file;\n\t\t}\n\t\tif (stat(ssl_verify, &verify_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_verify);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (ssl_crl) {\n\t\tif (stat(ssl_crl, &crl_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_crl);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tstunnel_pid = fork();\n\n\tif (stunnel_pid < 0) {\n\t\tstunnel_pid = 0;\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\tif (stunnel_pid == 0) {\n\t\tFILE *in;\n\t\tchar fd[20];\n\t\tint i;\n\t\tchar *st_if = getenv(\"STUNNEL_LISTEN\");\n\n\t\tif (st_if == NULL) {\n\t\t\tst_if = \"\";\n\t\t} else {\n\t\t\tst_if = (char *) malloc(strlen(st_if) + 2);\n\t\t\tsprintf(st_if, \"%s:\", getenv(\"STUNNEL_LISTEN\"));\n\t\t}\n\n\n\t\tfor (i=3; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\n\t\tif (use_stunnel == 3) {\n\t\t\tchar sp[30], xp[30], *a = NULL;\n\t\t\tchar *st = stunnel_path;\n\t\t\tchar *pm = stunnel_pem;\n\t\t\tchar *sv = ssl_verify;\n\n\t\t\tsprintf(sp, \"%d\", stunnel_port);\n\t\t\tsprintf(xp, \"%d\", x11vnc_port);\n\n\t\t\tif (ssl_verify) {\n\t\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\t\ta = \"-a\";\n\t\t\t\t} else {\n\t\t\t\t\ta = \"-A\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ssl_crl) {\n\t\t\t\trfbLog(\"stunnel: stunnel3 does not support CRL. %s\\n\", ssl_crl);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (stunnel_pem && ssl_verify) {\n\t\t\t\t/* XXX double check -v 2 */\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm, a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (stunnel_pem && !ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm,\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (!stunnel_pem && ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", (char *) NULL);\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\n\t\tin = tmpfile();\n\t\tif (! in) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfprintf(in, \"foreground = yes\\n\");\n\t\tfprintf(in, \"pid =\\n\");\n\t\tif (stunnel_pem) {\n\t\t\tfprintf(in, \"cert = %s\\n\", stunnel_pem);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\tif(S_ISDIR(crl_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CRLpath = %s\\n\", ssl_crl);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CRLfile = %s\\n\", ssl_crl);\n\t\t\t}\n\t\t}\n\t\tif (ssl_verify) {\n\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CApath = %s\\n\", ssl_verify);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CAfile = %s\\n\", ssl_verify);\n\t\t\t}\n\t\t\tfprintf(in, \"verify = 2\\n\");\n\t\t}\n\t\tfprintf(in, \";debug = 7\\n\\n\");\n\t\tfprintf(in, \"[x11vnc_stunnel]\\n\");\n\t\tfprintf(in, \"accept = %s%d\\n\", st_if, stunnel_port);\n\t\tfprintf(in, \"connect = %d\\n\", x11vnc_port);\n\n\t\tif (hport > 0 && x11vnc_hport > 0) {\n\t\t\tfprintf(in, \"\\n[x11vnc_http]\\n\");\n\t\t\tfprintf(in, \"accept = %s%d\\n\", st_if, hport);\n\t\t\tfprintf(in, \"connect = %d\\n\", x11vnc_hport);\n\t\t}\n\n\t\tfflush(in);\n\t\trewind(in);\n\n\t\tif (getenv(\"STUNNEL_DEBUG\")) {\n\t\t\tchar line[1000];\n\t\t\tfprintf(stderr, \"\\nstunnel config contents:\\n\\n\");\n\t\t\twhile (fgets(line, sizeof(line), in) != NULL) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\trewind(in);\n\t\t}\n\t\t\n\t\tsprintf(fd, \"%d\", fileno(in));\n\t\texeclp(stunnel_path, stunnel_path, \"-fd\", fd, (char *) NULL);\n\t\texit(1);\n\t}\n\n\tfree(exe);\n\tusleep(750 * 1000);\n\n\twaitpid(stunnel_pid, &status, WNOHANG); \n\n\tif (ssl_verify && strstr(ssl_verify, \"/sslverify-tmp-load-\")) {\n\t\t/* temporary file */\n\t\tusleep(1000 * 1000);\n\t\tunlink(ssl_verify);\n\t}\n\tif (tmp_pem) {\n\t\t/* temporary cert */\n\t\tusleep(1500 * 1000);\n\t\tunlink(stunnel_pem);\n\t}\n\n\tif (kill(stunnel_pid, 0) != 0) {\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n\t\tstunnel_pid = 0;\n\t\treturn 0;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"stunnel pid is: %d\\n\", (int) stunnel_pid);\n\t}\n\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSLCMDS"
          ],
          "globals_used": [
            "int start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport);",
            "void stop_stunnel(void);",
            "static pid_t stunnel_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nint start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport);\nvoid stop_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nint start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport) {\n#ifdef SSLCMDS\n\tchar extra[] = \":/usr/sbin:/usr/local/sbin:/dist/sbin\";\n\tchar *path, *p, *exe;\n\tchar *stunnel_path = NULL;\n\tstruct stat verify_buf;\n\tstruct stat crl_buf;\n\tint status, tmp_pem = 0;\n\n\tif (stunnel_pid) {\n\t\tstop_stunnel();\n\t}\n\tstunnel_pid = 0;\n\n\tpath = getenv(\"PATH\");\n\tif (! path) {\n\t\tpath = strdup(extra+1);\n\t} else {\n\t\tchar *pt = path;\n\t\tpath = (char *) malloc(strlen(path)+strlen(extra)+1);\n\t\tif (! path) {\n\t\t\treturn 0;\n\t\t}\n\t\tstrcpy(path, pt);\n\t\tstrcat(path, extra);\n\t}\n\n\texe = (char *) malloc(strlen(path) + 1 + strlen(\"stunnel4\") + 1);\n\n\tp = strtok(path, \":\");\n\n\texe[0] = '\\0';\n\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel4\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tif (path) {\n\t\tfree(path);\n\t}\n\n\tif (getenv(\"STUNNEL_PROG\")) {\n\t\tfree(exe);\n\t\texe = strdup(getenv(\"STUNNEL_PROG\"));\n\t\tstunnel_path = exe;\n\t}\n\n\tif (! stunnel_path) {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\tif (stunnel_path[0] == '\\0') {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\t/* stunnel */\n\tif (no_external_cmds || !cmd_ok(\"stunnel\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"start_stunnel: cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", stunnel_path);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"starting ssl tunnel: %s  %d -> %d\\n\", stunnel_path,\n\t\t    stunnel_port, x11vnc_port);\n\t}\n\n\tif (stunnel_pem && strstr(stunnel_pem, \"SAVE\") == stunnel_pem) {\n\t\tstunnel_pem = get_saved_pem(stunnel_pem, 1);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create or open\"\n\t\t\t    \" saved PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (!stunnel_pem) {\n\t\tstunnel_pem = create_tmp_pem(NULL, 0);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(stunnel_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ssl_verify) {\n\t\tchar *file = get_ssl_verify_file(ssl_verify);\n\t\tif (file) {\n\t\t\tssl_verify = file;\n\t\t}\n\t\tif (stat(ssl_verify, &verify_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_verify);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (ssl_crl) {\n\t\tif (stat(ssl_crl, &crl_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_crl);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tstunnel_pid = fork();\n\n\tif (stunnel_pid < 0) {\n\t\tstunnel_pid = 0;\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\tif (stunnel_pid == 0) {\n\t\tFILE *in;\n\t\tchar fd[20];\n\t\tint i;\n\t\tchar *st_if = getenv(\"STUNNEL_LISTEN\");\n\n\t\tif (st_if == NULL) {\n\t\t\tst_if = \"\";\n\t\t} else {\n\t\t\tst_if = (char *) malloc(strlen(st_if) + 2);\n\t\t\tsprintf(st_if, \"%s:\", getenv(\"STUNNEL_LISTEN\"));\n\t\t}\n\n\n\t\tfor (i=3; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\n\t\tif (use_stunnel == 3) {\n\t\t\tchar sp[30], xp[30], *a = NULL;\n\t\t\tchar *st = stunnel_path;\n\t\t\tchar *pm = stunnel_pem;\n\t\t\tchar *sv = ssl_verify;\n\n\t\t\tsprintf(sp, \"%d\", stunnel_port);\n\t\t\tsprintf(xp, \"%d\", x11vnc_port);\n\n\t\t\tif (ssl_verify) {\n\t\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\t\ta = \"-a\";\n\t\t\t\t} else {\n\t\t\t\t\ta = \"-A\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ssl_crl) {\n\t\t\t\trfbLog(\"stunnel: stunnel3 does not support CRL. %s\\n\", ssl_crl);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (stunnel_pem && ssl_verify) {\n\t\t\t\t/* XXX double check -v 2 */\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm, a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (stunnel_pem && !ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm,\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (!stunnel_pem && ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", (char *) NULL);\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\n\t\tin = tmpfile();\n\t\tif (! in) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfprintf(in, \"foreground = yes\\n\");\n\t\tfprintf(in, \"pid =\\n\");\n\t\tif (stunnel_pem) {\n\t\t\tfprintf(in, \"cert = %s\\n\", stunnel_pem);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\tif(S_ISDIR(crl_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CRLpath = %s\\n\", ssl_crl);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CRLfile = %s\\n\", ssl_crl);\n\t\t\t}\n\t\t}\n\t\tif (ssl_verify) {\n\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CApath = %s\\n\", ssl_verify);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CAfile = %s\\n\", ssl_verify);\n\t\t\t}\n\t\t\tfprintf(in, \"verify = 2\\n\");\n\t\t}\n\t\tfprintf(in, \";debug = 7\\n\\n\");\n\t\tfprintf(in, \"[x11vnc_stunnel]\\n\");\n\t\tfprintf(in, \"accept = %s%d\\n\", st_if, stunnel_port);\n\t\tfprintf(in, \"connect = %d\\n\", x11vnc_port);\n\n\t\tif (hport > 0 && x11vnc_hport > 0) {\n\t\t\tfprintf(in, \"\\n[x11vnc_http]\\n\");\n\t\t\tfprintf(in, \"accept = %s%d\\n\", st_if, hport);\n\t\t\tfprintf(in, \"connect = %d\\n\", x11vnc_hport);\n\t\t}\n\n\t\tfflush(in);\n\t\trewind(in);\n\n\t\tif (getenv(\"STUNNEL_DEBUG\")) {\n\t\t\tchar line[1000];\n\t\t\tfprintf(stderr, \"\\nstunnel config contents:\\n\\n\");\n\t\t\twhile (fgets(line, sizeof(line), in) != NULL) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\trewind(in);\n\t\t}\n\t\t\n\t\tsprintf(fd, \"%d\", fileno(in));\n\t\texeclp(stunnel_path, stunnel_path, \"-fd\", fd, (char *) NULL);\n\t\texit(1);\n\t}\n\n\tfree(exe);\n\tusleep(750 * 1000);\n\n\twaitpid(stunnel_pid, &status, WNOHANG); \n\n\tif (ssl_verify && strstr(ssl_verify, \"/sslverify-tmp-load-\")) {\n\t\t/* temporary file */\n\t\tusleep(1000 * 1000);\n\t\tunlink(ssl_verify);\n\t}\n\tif (tmp_pem) {\n\t\t/* temporary cert */\n\t\tusleep(1500 * 1000);\n\t\tunlink(stunnel_pem);\n\t}\n\n\tif (kill(stunnel_pid, 0) != 0) {\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n\t\tstunnel_pid = 0;\n\t\treturn 0;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"stunnel pid is: %d\\n\", (int) stunnel_pid);\n\t}\n\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_free_port",
          "args": [
            "5850",
            "5899"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_port6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "431-447",
          "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int find_free_port(int start, int end);",
            "int find_free_port6(int start, int end);",
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[i+1]"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-httpport\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[i+1]"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-rfbport\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid setup_stunnel(int rport, int *argc, char **argv);\n\nvoid setup_stunnel(int rport, int *argc, char **argv) {\n\tint i, xport = 0, hport = 0, xhport = 0;\n\n\tif (! rport && argc && argv) {\n\t\tfor (i=0; i< *argc; i++) {\n\t\t\tif (argv[i] && !strcmp(argv[i], \"-rfbport\")) {\n\t\t\t\tif (i < *argc - 1) {\n\t\t\t\t\trport = atoi(argv[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! rport) {\n\t\t/* we do our own autoprobing then... */\n\t\trport = find_free_port(5900, 5999);\n\t\tif (! rport) {\n\t\t\tgoto stunnel_fail;\n\t\t}\n\t}\n\n\txport = find_free_port(5950, 5999);\n\tif (! xport) {\n\t\tgoto stunnel_fail; \n\t}\n\n\tif (https_port_num > 0) {\n\t\thport = https_port_num;\n\t}\n\n\tif (! hport && argc && argv) {\n\t\tfor (i=0; i< *argc; i++) {\n\t\t\tif (argv[i] && !strcmp(argv[i], \"-httpport\")) {\n\t\t\t\tif (i < *argc - 1) {\n\t\t\t\t\thport = atoi(argv[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! hport && http_try_it) {\n\t\thport = find_free_port(rport-100, rport-1);\n\t\tif (! hport) {\n\t\t\tgoto stunnel_fail;\n\t\t}\n\t}\n\tif (hport) {\n\t\txhport = find_free_port(5850, 5899);\n\t\tif (! xhport) {\n\t\t\tgoto stunnel_fail; \n\t\t}\n\t\tstunnel_http_port = hport;\n\t}\n\t\n\n\tif (start_stunnel(rport, xport, hport, xhport)) {\n\t\tint tweaked = 0;\n\t\tchar tmp[30];\n\t\tsprintf(tmp, \"%d\", xport);\n\t\tif (argc && argv) {\n\t\t\tfor (i=0; i < *argc; i++) {\n\t\t\t\tif (argv[i] && !strcmp(argv[i], \"-rfbport\")) {\n\t\t\t\t\tif (i < *argc - 1) {\n\t\t\t\t\t\t/* replace orig value */\n\t\t\t\t\t\targv[i+i] = strdup(tmp); \n\t\t\t\t\t\ttweaked = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (! tweaked) {\n\t\t\t\ti = *argc;\n\t\t\t\targv[i] = strdup(\"-rfbport\");\n\t\t\t\targv[i+1] = strdup(tmp);\n\t\t\t\t*argc += 2;\n\t\t\t\tgot_rfbport = 1;\n\t\t\t\tgot_rfbport_val = atoi(tmp);\n\t\t\t}\n\t\t}\n\t\tstunnel_port = rport;\n\t\tssl_initialized = 1;\n\t\treturn;\n\t}\n\n\tstunnel_fail:\n\trfbLog(\"failed to start stunnel.\\n\");\n\tclean_up_exit(1);\n}"
  },
  {
    "function_name": "stop_stunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "378-391",
    "snippet": "void stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SSLCMDS"
    ],
    "globals_used": [
      "void stop_stunnel(void);",
      "static pid_t stunnel_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "stunnel_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "stunnel_pid",
            "SIGKILL"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "150 * 1000"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nvoid stop_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nvoid stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}"
  },
  {
    "function_name": "start_stunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "90-376",
    "snippet": "int start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport) {\n#ifdef SSLCMDS\n\tchar extra[] = \":/usr/sbin:/usr/local/sbin:/dist/sbin\";\n\tchar *path, *p, *exe;\n\tchar *stunnel_path = NULL;\n\tstruct stat verify_buf;\n\tstruct stat crl_buf;\n\tint status, tmp_pem = 0;\n\n\tif (stunnel_pid) {\n\t\tstop_stunnel();\n\t}\n\tstunnel_pid = 0;\n\n\tpath = getenv(\"PATH\");\n\tif (! path) {\n\t\tpath = strdup(extra+1);\n\t} else {\n\t\tchar *pt = path;\n\t\tpath = (char *) malloc(strlen(path)+strlen(extra)+1);\n\t\tif (! path) {\n\t\t\treturn 0;\n\t\t}\n\t\tstrcpy(path, pt);\n\t\tstrcat(path, extra);\n\t}\n\n\texe = (char *) malloc(strlen(path) + 1 + strlen(\"stunnel4\") + 1);\n\n\tp = strtok(path, \":\");\n\n\texe[0] = '\\0';\n\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel4\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tif (path) {\n\t\tfree(path);\n\t}\n\n\tif (getenv(\"STUNNEL_PROG\")) {\n\t\tfree(exe);\n\t\texe = strdup(getenv(\"STUNNEL_PROG\"));\n\t\tstunnel_path = exe;\n\t}\n\n\tif (! stunnel_path) {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\tif (stunnel_path[0] == '\\0') {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\t/* stunnel */\n\tif (no_external_cmds || !cmd_ok(\"stunnel\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"start_stunnel: cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", stunnel_path);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"starting ssl tunnel: %s  %d -> %d\\n\", stunnel_path,\n\t\t    stunnel_port, x11vnc_port);\n\t}\n\n\tif (stunnel_pem && strstr(stunnel_pem, \"SAVE\") == stunnel_pem) {\n\t\tstunnel_pem = get_saved_pem(stunnel_pem, 1);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create or open\"\n\t\t\t    \" saved PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (!stunnel_pem) {\n\t\tstunnel_pem = create_tmp_pem(NULL, 0);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(stunnel_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ssl_verify) {\n\t\tchar *file = get_ssl_verify_file(ssl_verify);\n\t\tif (file) {\n\t\t\tssl_verify = file;\n\t\t}\n\t\tif (stat(ssl_verify, &verify_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_verify);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (ssl_crl) {\n\t\tif (stat(ssl_crl, &crl_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_crl);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tstunnel_pid = fork();\n\n\tif (stunnel_pid < 0) {\n\t\tstunnel_pid = 0;\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\tif (stunnel_pid == 0) {\n\t\tFILE *in;\n\t\tchar fd[20];\n\t\tint i;\n\t\tchar *st_if = getenv(\"STUNNEL_LISTEN\");\n\n\t\tif (st_if == NULL) {\n\t\t\tst_if = \"\";\n\t\t} else {\n\t\t\tst_if = (char *) malloc(strlen(st_if) + 2);\n\t\t\tsprintf(st_if, \"%s:\", getenv(\"STUNNEL_LISTEN\"));\n\t\t}\n\n\n\t\tfor (i=3; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\n\t\tif (use_stunnel == 3) {\n\t\t\tchar sp[30], xp[30], *a = NULL;\n\t\t\tchar *st = stunnel_path;\n\t\t\tchar *pm = stunnel_pem;\n\t\t\tchar *sv = ssl_verify;\n\n\t\t\tsprintf(sp, \"%d\", stunnel_port);\n\t\t\tsprintf(xp, \"%d\", x11vnc_port);\n\n\t\t\tif (ssl_verify) {\n\t\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\t\ta = \"-a\";\n\t\t\t\t} else {\n\t\t\t\t\ta = \"-A\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ssl_crl) {\n\t\t\t\trfbLog(\"stunnel: stunnel3 does not support CRL. %s\\n\", ssl_crl);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (stunnel_pem && ssl_verify) {\n\t\t\t\t/* XXX double check -v 2 */\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm, a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (stunnel_pem && !ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm,\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (!stunnel_pem && ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", (char *) NULL);\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\n\t\tin = tmpfile();\n\t\tif (! in) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfprintf(in, \"foreground = yes\\n\");\n\t\tfprintf(in, \"pid =\\n\");\n\t\tif (stunnel_pem) {\n\t\t\tfprintf(in, \"cert = %s\\n\", stunnel_pem);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\tif(S_ISDIR(crl_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CRLpath = %s\\n\", ssl_crl);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CRLfile = %s\\n\", ssl_crl);\n\t\t\t}\n\t\t}\n\t\tif (ssl_verify) {\n\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CApath = %s\\n\", ssl_verify);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CAfile = %s\\n\", ssl_verify);\n\t\t\t}\n\t\t\tfprintf(in, \"verify = 2\\n\");\n\t\t}\n\t\tfprintf(in, \";debug = 7\\n\\n\");\n\t\tfprintf(in, \"[x11vnc_stunnel]\\n\");\n\t\tfprintf(in, \"accept = %s%d\\n\", st_if, stunnel_port);\n\t\tfprintf(in, \"connect = %d\\n\", x11vnc_port);\n\n\t\tif (hport > 0 && x11vnc_hport > 0) {\n\t\t\tfprintf(in, \"\\n[x11vnc_http]\\n\");\n\t\t\tfprintf(in, \"accept = %s%d\\n\", st_if, hport);\n\t\t\tfprintf(in, \"connect = %d\\n\", x11vnc_hport);\n\t\t}\n\n\t\tfflush(in);\n\t\trewind(in);\n\n\t\tif (getenv(\"STUNNEL_DEBUG\")) {\n\t\t\tchar line[1000];\n\t\t\tfprintf(stderr, \"\\nstunnel config contents:\\n\\n\");\n\t\t\twhile (fgets(line, sizeof(line), in) != NULL) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\trewind(in);\n\t\t}\n\t\t\n\t\tsprintf(fd, \"%d\", fileno(in));\n\t\texeclp(stunnel_path, stunnel_path, \"-fd\", fd, (char *) NULL);\n\t\texit(1);\n\t}\n\n\tfree(exe);\n\tusleep(750 * 1000);\n\n\twaitpid(stunnel_pid, &status, WNOHANG); \n\n\tif (ssl_verify && strstr(ssl_verify, \"/sslverify-tmp-load-\")) {\n\t\t/* temporary file */\n\t\tusleep(1000 * 1000);\n\t\tunlink(ssl_verify);\n\t}\n\tif (tmp_pem) {\n\t\t/* temporary cert */\n\t\tusleep(1500 * 1000);\n\t\tunlink(stunnel_pem);\n\t}\n\n\tif (kill(stunnel_pid, 0) != 0) {\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n\t\tstunnel_pid = 0;\n\t\treturn 0;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"stunnel pid is: %d\\n\", (int) stunnel_pid);\n\t}\n\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SSLCMDS"
    ],
    "globals_used": [
      "int start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport);",
      "void stop_stunnel(void);",
      "static pid_t stunnel_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"stunnel pid is: %d\\n\"",
            "(int) stunnel_pid"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "stunnel_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "stunnel_pid",
            "0"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "stunnel_pem"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1500 * 1000"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "ssl_verify"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000 * 1000"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "ssl_verify",
            "\"/sslverify-tmp-load-\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "stunnel_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "750 * 1000"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "exe"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "stunnel_path",
            "stunnel_path",
            "\"-fd\"",
            "fd",
            "(char *) NULL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fd",
            "\"%d\"",
            "fileno(in)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "in"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rewind",
          "args": [
            "in"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "line"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "in"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nstunnel config contents:\\n\\n\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"STUNNEL_DEBUG\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rewind",
          "args": [
            "in"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "in"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"connect = %d\\n\"",
            "x11vnc_hport"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"accept = %s%d\\n\"",
            "st_if",
            "hport"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"\\n[x11vnc_http]\\n\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"connect = %d\\n\"",
            "x11vnc_port"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"accept = %s%d\\n\"",
            "st_if",
            "stunnel_port"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"[x11vnc_stunnel]\\n\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\";debug = 7\\n\\n\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"verify = 2\\n\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"CAfile = %s\\n\"",
            "ssl_verify"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"CApath = %s\\n\"",
            "ssl_verify"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "verify_buf.st_mode"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"CRLfile = %s\\n\"",
            "ssl_crl"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"CRLpath = %s\\n\"",
            "ssl_crl"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "crl_buf.st_mode"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"cert = %s\\n\"",
            "stunnel_pem"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"pid =\\n\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "in",
            "\"foreground = yes\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmpfile",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "st",
            "st",
            "\"-f\"",
            "\"-d\"",
            "sp",
            "\"-r\"",
            "xp",
            "\"-P\"",
            "\"none\"",
            "(char *) NULL"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "st",
            "st",
            "\"-f\"",
            "\"-d\"",
            "sp",
            "\"-r\"",
            "xp",
            "\"-P\"",
            "\"none\"",
            "a",
            "sv",
            "\"-v\"",
            "\"2\"",
            "(char *) NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "st",
            "st",
            "\"-f\"",
            "\"-d\"",
            "sp",
            "\"-r\"",
            "xp",
            "\"-P\"",
            "\"none\"",
            "\"-p\"",
            "pm",
            "(char *) NULL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "st",
            "st",
            "\"-f\"",
            "\"-d\"",
            "sp",
            "\"-r\"",
            "xp",
            "\"-P\"",
            "\"none\"",
            "\"-p\"",
            "pm",
            "a",
            "sv",
            "\"-v\"",
            "\"2\"",
            "(char *) NULL"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"stunnel: stunnel3 does not support CRL. %s\\n\"",
            "ssl_crl"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "verify_buf.st_mode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xp",
            "\"%d\"",
            "x11vnc_port"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "sp",
            "\"%d\"",
            "stunnel_port"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "i"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "st_if",
            "\"%s:\"",
            "getenv(\"STUNNEL_LISTEN\")"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"STUNNEL_LISTEN\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(st_if) + 2"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "st_if"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"STUNNEL_LISTEN\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"stunnel: %s does not exist.\\n\"",
            "ssl_crl"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "ssl_crl",
            "&crl_buf"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"stunnel: %s does not exist.\\n\"",
            "ssl_verify"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ssl_verify_file",
          "args": [
            "ssl_verify"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "get_ssl_verify_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "547-664",
          "snippet": "char *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_ssl_verify_file(char *str_in);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_ssl_verify_file(char *str_in);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "line"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "in"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "stunnel_pem",
            "\"r\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SHOW_TMP_PEM\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"start_stunnel: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_tmp_pem",
          "args": [
            "NULL",
            "0"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "create_tmp_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "238-517",
          "snippet": "char *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK",
            "#define DO_DH 0"
          ],
          "globals_used": [
            "char *get_saved_pem(char *string, int create);",
            "char *find_openssl_bin(void);",
            "char *create_tmp_pem(char *path, int prompt);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n#define DO_DH 0\n\nchar *get_saved_pem(char *string, int create);\nchar *find_openssl_bin(void);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"start_stunnel: could not create or open\"\n\t\t\t    \" saved PEM.\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_saved_pem",
          "args": [
            "stunnel_pem",
            "1"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "get_saved_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "88-168",
          "snippet": "char *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_saved_pem(char *string, int create);",
            "char *create_tmp_pem(char *path, int prompt);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_saved_pem(char *string, int create);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "stunnel_pem",
            "\"SAVE\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"starting ssl tunnel: %s  %d -> %d\\n\"",
            "stunnel_path",
            "stunnel_port",
            "x11vnc_port"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   exiting.\\n\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "stunnel_path"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"start_stunnel: cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"stunnel\""
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"STUNNEL_PROG\")"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"STUNNEL_PROG\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"STUNNEL_PROG\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "exe",
            "\"%s/%s\"",
            "p",
            "\"stunnel\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "exe",
            "\"%s/%s\"",
            "p",
            "\"stunnel4\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path",
            "\":\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(path) + 1 + strlen(\"stunnel4\") + 1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"stunnel4\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "path",
            "extra"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "path",
            "pt"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(path)+strlen(extra)+1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "extra"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "extra+1"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_stunnel",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "stop_stunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "378-391",
          "snippet": "void stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSLCMDS"
          ],
          "globals_used": [
            "void stop_stunnel(void);",
            "static pid_t stunnel_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nvoid stop_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nvoid stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nint start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport);\nvoid stop_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nint start_stunnel(int stunnel_port, int x11vnc_port, int hport, int x11vnc_hport) {\n#ifdef SSLCMDS\n\tchar extra[] = \":/usr/sbin:/usr/local/sbin:/dist/sbin\";\n\tchar *path, *p, *exe;\n\tchar *stunnel_path = NULL;\n\tstruct stat verify_buf;\n\tstruct stat crl_buf;\n\tint status, tmp_pem = 0;\n\n\tif (stunnel_pid) {\n\t\tstop_stunnel();\n\t}\n\tstunnel_pid = 0;\n\n\tpath = getenv(\"PATH\");\n\tif (! path) {\n\t\tpath = strdup(extra+1);\n\t} else {\n\t\tchar *pt = path;\n\t\tpath = (char *) malloc(strlen(path)+strlen(extra)+1);\n\t\tif (! path) {\n\t\t\treturn 0;\n\t\t}\n\t\tstrcpy(path, pt);\n\t\tstrcat(path, extra);\n\t}\n\n\texe = (char *) malloc(strlen(path) + 1 + strlen(\"stunnel4\") + 1);\n\n\tp = strtok(path, \":\");\n\n\texe[0] = '\\0';\n\n\twhile (p) {\n\t\tstruct stat sbuf;\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel4\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsprintf(exe, \"%s/%s\", p, \"stunnel\");\n\t\tif (! stunnel_path && stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tstunnel_path = exe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp = strtok(NULL, \":\");\n\t}\n\tif (path) {\n\t\tfree(path);\n\t}\n\n\tif (getenv(\"STUNNEL_PROG\")) {\n\t\tfree(exe);\n\t\texe = strdup(getenv(\"STUNNEL_PROG\"));\n\t\tstunnel_path = exe;\n\t}\n\n\tif (! stunnel_path) {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\tif (stunnel_path[0] == '\\0') {\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\t/* stunnel */\n\tif (no_external_cmds || !cmd_ok(\"stunnel\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"start_stunnel: cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", stunnel_path);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"starting ssl tunnel: %s  %d -> %d\\n\", stunnel_path,\n\t\t    stunnel_port, x11vnc_port);\n\t}\n\n\tif (stunnel_pem && strstr(stunnel_pem, \"SAVE\") == stunnel_pem) {\n\t\tstunnel_pem = get_saved_pem(stunnel_pem, 1);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create or open\"\n\t\t\t    \" saved PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (!stunnel_pem) {\n\t\tstunnel_pem = create_tmp_pem(NULL, 0);\n\t\tif (! stunnel_pem) {\n\t\t\trfbLog(\"start_stunnel: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(stunnel_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ssl_verify) {\n\t\tchar *file = get_ssl_verify_file(ssl_verify);\n\t\tif (file) {\n\t\t\tssl_verify = file;\n\t\t}\n\t\tif (stat(ssl_verify, &verify_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_verify);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (ssl_crl) {\n\t\tif (stat(ssl_crl, &crl_buf) != 0) {\n\t\t\trfbLog(\"stunnel: %s does not exist.\\n\", ssl_crl);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\n\tstunnel_pid = fork();\n\n\tif (stunnel_pid < 0) {\n\t\tstunnel_pid = 0;\n\t\tfree(exe);\n\t\treturn 0;\n\t}\n\n\tif (stunnel_pid == 0) {\n\t\tFILE *in;\n\t\tchar fd[20];\n\t\tint i;\n\t\tchar *st_if = getenv(\"STUNNEL_LISTEN\");\n\n\t\tif (st_if == NULL) {\n\t\t\tst_if = \"\";\n\t\t} else {\n\t\t\tst_if = (char *) malloc(strlen(st_if) + 2);\n\t\t\tsprintf(st_if, \"%s:\", getenv(\"STUNNEL_LISTEN\"));\n\t\t}\n\n\n\t\tfor (i=3; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\n\t\tif (use_stunnel == 3) {\n\t\t\tchar sp[30], xp[30], *a = NULL;\n\t\t\tchar *st = stunnel_path;\n\t\t\tchar *pm = stunnel_pem;\n\t\t\tchar *sv = ssl_verify;\n\n\t\t\tsprintf(sp, \"%d\", stunnel_port);\n\t\t\tsprintf(xp, \"%d\", x11vnc_port);\n\n\t\t\tif (ssl_verify) {\n\t\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\t\ta = \"-a\";\n\t\t\t\t} else {\n\t\t\t\t\ta = \"-A\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ssl_crl) {\n\t\t\t\trfbLog(\"stunnel: stunnel3 does not support CRL. %s\\n\", ssl_crl);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (stunnel_pem && ssl_verify) {\n\t\t\t\t/* XXX double check -v 2 */\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm, a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (stunnel_pem && !ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", \"-p\", pm,\n\t\t\t\t    (char *) NULL);\n\t\t\t} else if (!stunnel_pem && ssl_verify) {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", a, sv, \"-v\", \"2\",\n\t\t\t\t    (char *) NULL);\n\t\t\t} else {\n\t\t\t\texeclp(st, st, \"-f\", \"-d\", sp, \"-r\", xp, \"-P\",\n\t\t\t\t    \"none\", (char *) NULL);\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\n\t\tin = tmpfile();\n\t\tif (! in) {\n\t\t\texit(1);\n\t\t}\n\n\t\tfprintf(in, \"foreground = yes\\n\");\n\t\tfprintf(in, \"pid =\\n\");\n\t\tif (stunnel_pem) {\n\t\t\tfprintf(in, \"cert = %s\\n\", stunnel_pem);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\tif(S_ISDIR(crl_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CRLpath = %s\\n\", ssl_crl);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CRLfile = %s\\n\", ssl_crl);\n\t\t\t}\n\t\t}\n\t\tif (ssl_verify) {\n\t\t\tif(S_ISDIR(verify_buf.st_mode)) {\n\t\t\t\tfprintf(in, \"CApath = %s\\n\", ssl_verify);\n\t\t\t} else {\n\t\t\t\tfprintf(in, \"CAfile = %s\\n\", ssl_verify);\n\t\t\t}\n\t\t\tfprintf(in, \"verify = 2\\n\");\n\t\t}\n\t\tfprintf(in, \";debug = 7\\n\\n\");\n\t\tfprintf(in, \"[x11vnc_stunnel]\\n\");\n\t\tfprintf(in, \"accept = %s%d\\n\", st_if, stunnel_port);\n\t\tfprintf(in, \"connect = %d\\n\", x11vnc_port);\n\n\t\tif (hport > 0 && x11vnc_hport > 0) {\n\t\t\tfprintf(in, \"\\n[x11vnc_http]\\n\");\n\t\t\tfprintf(in, \"accept = %s%d\\n\", st_if, hport);\n\t\t\tfprintf(in, \"connect = %d\\n\", x11vnc_hport);\n\t\t}\n\n\t\tfflush(in);\n\t\trewind(in);\n\n\t\tif (getenv(\"STUNNEL_DEBUG\")) {\n\t\t\tchar line[1000];\n\t\t\tfprintf(stderr, \"\\nstunnel config contents:\\n\\n\");\n\t\t\twhile (fgets(line, sizeof(line), in) != NULL) {\n\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\trewind(in);\n\t\t}\n\t\t\n\t\tsprintf(fd, \"%d\", fileno(in));\n\t\texeclp(stunnel_path, stunnel_path, \"-fd\", fd, (char *) NULL);\n\t\texit(1);\n\t}\n\n\tfree(exe);\n\tusleep(750 * 1000);\n\n\twaitpid(stunnel_pid, &status, WNOHANG); \n\n\tif (ssl_verify && strstr(ssl_verify, \"/sslverify-tmp-load-\")) {\n\t\t/* temporary file */\n\t\tusleep(1000 * 1000);\n\t\tunlink(ssl_verify);\n\t}\n\tif (tmp_pem) {\n\t\t/* temporary cert */\n\t\tusleep(1500 * 1000);\n\t\tunlink(stunnel_pem);\n\t}\n\n\tif (kill(stunnel_pid, 0) != 0) {\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n\t\tstunnel_pid = 0;\n\t\treturn 0;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"stunnel pid is: %d\\n\", (int) stunnel_pid);\n\t}\n\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "check_stunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
    "lines": "63-88",
    "snippet": "void check_stunnel(void) {\n\tstatic time_t last_check = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_check + 3 >= now) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\t/* double check that stunnel is still running: */\n\n\tif (stunnel_pid > 0) {\n\t\tint status;\n#ifdef SSLCMDS\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\tif (kill(stunnel_pid, 0) != 0) {\n#ifdef SSLCMDS\n\t\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\t\trfbLog(\"stunnel subprocess %d died.\\n\", stunnel_pid); \n\t\t\tstunnel_pid = 0;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"connections.h\"",
      "#include \"ssltools.h\"",
      "#include \"sslhelper.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SSLCMDS"
    ],
    "globals_used": [
      "void check_stunnel(void);",
      "static pid_t stunnel_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"stunnel subprocess %d died.\\n\"",
            "stunnel_pid"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "stunnel_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "stunnel_pid",
            "0"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "stunnel_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nvoid check_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nvoid check_stunnel(void) {\n\tstatic time_t last_check = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_check + 3 >= now) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\t/* double check that stunnel is still running: */\n\n\tif (stunnel_pid > 0) {\n\t\tint status;\n#ifdef SSLCMDS\n\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\tif (kill(stunnel_pid, 0) != 0) {\n#ifdef SSLCMDS\n\t\t\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\t\t\trfbLog(\"stunnel subprocess %d died.\\n\", stunnel_pid); \n\t\t\tstunnel_pid = 0;\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n}"
  }
]