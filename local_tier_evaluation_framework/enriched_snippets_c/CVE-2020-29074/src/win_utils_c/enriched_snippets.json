[
  {
    "function_name": "find_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "860-885",
    "snippet": "Window find_client(Display * dpy, Window root, Window subwin)\n{\n#if NO_X11\n    return None;\n#else\n    Window win;\n\n    if (atom_wm_state == None) {\n        atom_wm_state = XInternAtom(dpy, \"WM_STATE\", False);\n        if (!atom_wm_state)\n            return subwin;\n    }\n\n    /* Check if subwin has WM_STATE */\n    if (window_has_property(dpy, subwin, atom_wm_state))\n        return subwin;\n\n    /* Attempt to find a client window in subwin's children */\n    win = find_client_in_children(dpy, subwin);\n    if (win != None)\n        return win;             /* Found a client */\n\n    /* Did not find a client */\n    return subwin;\n#endif\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Atom atom_wm_state = None;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_client_in_children",
          "args": [
            "dpy",
            "subwin"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "find_client_in_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "811-855",
          "snippet": "static Window find_client_in_children(Display * dpy, Window win)\n{\n#if NO_X11\n    return None;\n#else\n    Window root, parent;\n    Window *children;\n    unsigned int n_children;\n    int i;\n\n    if (!XQueryTree(dpy, win, &root, &parent, &children, &n_children))\n        return None;\n    if (!children)\n        return None;\n\n    /* Check each child for WM_STATE and other validity */\n    win = None;\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (!window_is_viewable(dpy, children[i])) {\n            children[i] = None; /* Don't bother descending into this one */\n            continue;\n        }\n        if (!window_has_property(dpy, children[i], atom_wm_state))\n            continue;\n\n        /* Got one */\n        win = children[i];\n        goto done;\n    }\n\n    /* No children matched, now descend into each child */\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (children[i] == None)\n            continue;\n        win = find_client_in_children(dpy, children[i]);\n        if (win != None)\n            break;\n    }\n\n  done:\n    XFree(children);\n\n    return win;\n#endif\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Atom atom_wm_state = None;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic Atom atom_wm_state = None;\n\nstatic Window find_client_in_children(Display * dpy, Window win)\n{\n#if NO_X11\n    return None;\n#else\n    Window root, parent;\n    Window *children;\n    unsigned int n_children;\n    int i;\n\n    if (!XQueryTree(dpy, win, &root, &parent, &children, &n_children))\n        return None;\n    if (!children)\n        return None;\n\n    /* Check each child for WM_STATE and other validity */\n    win = None;\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (!window_is_viewable(dpy, children[i])) {\n            children[i] = None; /* Don't bother descending into this one */\n            continue;\n        }\n        if (!window_has_property(dpy, children[i], atom_wm_state))\n            continue;\n\n        /* Got one */\n        win = children[i];\n        goto done;\n    }\n\n    /* No children matched, now descend into each child */\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (children[i] == None)\n            continue;\n        win = find_client_in_children(dpy, children[i]);\n        if (win != None)\n            break;\n    }\n\n  done:\n    XFree(children);\n\n    return win;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "window_has_property",
          "args": [
            "dpy",
            "subwin",
            "atom_wm_state"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "window_has_property",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "763-783",
          "snippet": "Bool window_has_property(Display * dpy, Window win, Atom atom)\n{\n#if NO_X11\n    return False;\n#else\n    Atom type_ret;\n    int format_ret;\n    unsigned char *prop_ret;\n    unsigned long bytes_after, num_ret;\n\n    type_ret = None;\n    prop_ret = NULL;\n    XGetWindowProperty(dpy, win, atom, 0, 0, False, AnyPropertyType,\n                       &type_ret, &format_ret, &num_ret,\n                       &bytes_after, &prop_ret);\n    if (prop_ret)\n        XFree(prop_ret);\n\n    return (type_ret != None) ? True : False;\n#endif\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool window_has_property(Display * dpy, Window win, Atom atom)\n{\n#if NO_X11\n    return False;\n#else\n    Atom type_ret;\n    int format_ret;\n    unsigned char *prop_ret;\n    unsigned long bytes_after, num_ret;\n\n    type_ret = None;\n    prop_ret = NULL;\n    XGetWindowProperty(dpy, win, atom, 0, 0, False, AnyPropertyType,\n                       &type_ret, &format_ret, &num_ret,\n                       &bytes_after, &prop_ret);\n    if (prop_ret)\n        XFree(prop_ret);\n\n    return (type_ret != None) ? True : False;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"WM_STATE\"",
            "False"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic Atom atom_wm_state = None;\n\nWindow find_client(Display * dpy, Window root, Window subwin)\n{\n#if NO_X11\n    return None;\n#else\n    Window win;\n\n    if (atom_wm_state == None) {\n        atom_wm_state = XInternAtom(dpy, \"WM_STATE\", False);\n        if (!atom_wm_state)\n            return subwin;\n    }\n\n    /* Check if subwin has WM_STATE */\n    if (window_has_property(dpy, subwin, atom_wm_state))\n        return subwin;\n\n    /* Attempt to find a client window in subwin's children */\n    win = find_client_in_children(dpy, subwin);\n    if (win != None)\n        return win;             /* Found a client */\n\n    /* Did not find a client */\n    return subwin;\n#endif\n}"
  },
  {
    "function_name": "find_client_in_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "811-855",
    "snippet": "static Window find_client_in_children(Display * dpy, Window win)\n{\n#if NO_X11\n    return None;\n#else\n    Window root, parent;\n    Window *children;\n    unsigned int n_children;\n    int i;\n\n    if (!XQueryTree(dpy, win, &root, &parent, &children, &n_children))\n        return None;\n    if (!children)\n        return None;\n\n    /* Check each child for WM_STATE and other validity */\n    win = None;\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (!window_is_viewable(dpy, children[i])) {\n            children[i] = None; /* Don't bother descending into this one */\n            continue;\n        }\n        if (!window_has_property(dpy, children[i], atom_wm_state))\n            continue;\n\n        /* Got one */\n        win = children[i];\n        goto done;\n    }\n\n    /* No children matched, now descend into each child */\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (children[i] == None)\n            continue;\n        win = find_client_in_children(dpy, children[i]);\n        if (win != None)\n            break;\n    }\n\n  done:\n    XFree(children);\n\n    return win;\n#endif\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Atom atom_wm_state = None;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree",
          "args": [
            "children"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_client_in_children",
          "args": [
            "dpy",
            "children[i]"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "find_client_in_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "811-855",
          "snippet": "static Window find_client_in_children(Display * dpy, Window win)\n{\n#if NO_X11\n    return None;\n#else\n    Window root, parent;\n    Window *children;\n    unsigned int n_children;\n    int i;\n\n    if (!XQueryTree(dpy, win, &root, &parent, &children, &n_children))\n        return None;\n    if (!children)\n        return None;\n\n    /* Check each child for WM_STATE and other validity */\n    win = None;\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (!window_is_viewable(dpy, children[i])) {\n            children[i] = None; /* Don't bother descending into this one */\n            continue;\n        }\n        if (!window_has_property(dpy, children[i], atom_wm_state))\n            continue;\n\n        /* Got one */\n        win = children[i];\n        goto done;\n    }\n\n    /* No children matched, now descend into each child */\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (children[i] == None)\n            continue;\n        win = find_client_in_children(dpy, children[i]);\n        if (win != None)\n            break;\n    }\n\n  done:\n    XFree(children);\n\n    return win;\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "window_has_property",
          "args": [
            "dpy",
            "children[i]",
            "atom_wm_state"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "window_has_property",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "763-783",
          "snippet": "Bool window_has_property(Display * dpy, Window win, Atom atom)\n{\n#if NO_X11\n    return False;\n#else\n    Atom type_ret;\n    int format_ret;\n    unsigned char *prop_ret;\n    unsigned long bytes_after, num_ret;\n\n    type_ret = None;\n    prop_ret = NULL;\n    XGetWindowProperty(dpy, win, atom, 0, 0, False, AnyPropertyType,\n                       &type_ret, &format_ret, &num_ret,\n                       &bytes_after, &prop_ret);\n    if (prop_ret)\n        XFree(prop_ret);\n\n    return (type_ret != None) ? True : False;\n#endif\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool window_has_property(Display * dpy, Window win, Atom atom)\n{\n#if NO_X11\n    return False;\n#else\n    Atom type_ret;\n    int format_ret;\n    unsigned char *prop_ret;\n    unsigned long bytes_after, num_ret;\n\n    type_ret = None;\n    prop_ret = NULL;\n    XGetWindowProperty(dpy, win, atom, 0, 0, False, AnyPropertyType,\n                       &type_ret, &format_ret, &num_ret,\n                       &bytes_after, &prop_ret);\n    if (prop_ret)\n        XFree(prop_ret);\n\n    return (type_ret != None) ? True : False;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "window_is_viewable",
          "args": [
            "dpy",
            "children[i]"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "window_is_viewable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "788-802",
          "snippet": "Bool window_is_viewable(Display * dpy, Window win)\n{\n#if NO_X11\n    return False;\n#else\n    Bool ok;\n    XWindowAttributes xwa;\n\n    XGetWindowAttributes(dpy, win, &xwa);\n\n    ok = (xwa.class == InputOutput) && (xwa.map_state == IsViewable);\n\n    return ok;\n#endif\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool window_is_viewable(Display * dpy, Window win)\n{\n#if NO_X11\n    return False;\n#else\n    Bool ok;\n    XWindowAttributes xwa;\n\n    XGetWindowAttributes(dpy, win, &xwa);\n\n    ok = (xwa.class == InputOutput) && (xwa.map_state == IsViewable);\n\n    return ok;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree",
          "args": [
            "dpy",
            "win",
            "&root",
            "&parent",
            "&children",
            "&n_children"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nstatic Atom atom_wm_state = None;\n\nstatic Window find_client_in_children(Display * dpy, Window win)\n{\n#if NO_X11\n    return None;\n#else\n    Window root, parent;\n    Window *children;\n    unsigned int n_children;\n    int i;\n\n    if (!XQueryTree(dpy, win, &root, &parent, &children, &n_children))\n        return None;\n    if (!children)\n        return None;\n\n    /* Check each child for WM_STATE and other validity */\n    win = None;\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (!window_is_viewable(dpy, children[i])) {\n            children[i] = None; /* Don't bother descending into this one */\n            continue;\n        }\n        if (!window_has_property(dpy, children[i], atom_wm_state))\n            continue;\n\n        /* Got one */\n        win = children[i];\n        goto done;\n    }\n\n    /* No children matched, now descend into each child */\n    for (i = (int) n_children - 1; i >= 0; i--) {\n        if (children[i] == None)\n            continue;\n        win = find_client_in_children(dpy, children[i]);\n        if (win != None)\n            break;\n    }\n\n  done:\n    XFree(children);\n\n    return win;\n#endif\n}"
  },
  {
    "function_name": "window_is_viewable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "788-802",
    "snippet": "Bool window_is_viewable(Display * dpy, Window win)\n{\n#if NO_X11\n    return False;\n#else\n    Bool ok;\n    XWindowAttributes xwa;\n\n    XGetWindowAttributes(dpy, win, &xwa);\n\n    ok = (xwa.class == InputOutput) && (xwa.map_state == IsViewable);\n\n    return ok;\n#endif\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XGetWindowAttributes",
          "args": [
            "dpy",
            "win",
            "&xwa"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool window_is_viewable(Display * dpy, Window win)\n{\n#if NO_X11\n    return False;\n#else\n    Bool ok;\n    XWindowAttributes xwa;\n\n    XGetWindowAttributes(dpy, win, &xwa);\n\n    ok = (xwa.class == InputOutput) && (xwa.map_state == IsViewable);\n\n    return ok;\n#endif\n}"
  },
  {
    "function_name": "window_has_property",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "763-783",
    "snippet": "Bool window_has_property(Display * dpy, Window win, Atom atom)\n{\n#if NO_X11\n    return False;\n#else\n    Atom type_ret;\n    int format_ret;\n    unsigned char *prop_ret;\n    unsigned long bytes_after, num_ret;\n\n    type_ret = None;\n    prop_ret = NULL;\n    XGetWindowProperty(dpy, win, atom, 0, 0, False, AnyPropertyType,\n                       &type_ret, &format_ret, &num_ret,\n                       &bytes_after, &prop_ret);\n    if (prop_ret)\n        XFree(prop_ret);\n\n    return (type_ret != None) ? True : False;\n#endif\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree",
          "args": [
            "prop_ret"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "win",
            "atom",
            "0",
            "0",
            "False",
            "AnyPropertyType",
            "&type_ret",
            "&format_ret",
            "&num_ret",
            "&bytes_after",
            "&prop_ret"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool window_has_property(Display * dpy, Window win, Atom atom)\n{\n#if NO_X11\n    return False;\n#else\n    Atom type_ret;\n    int format_ret;\n    unsigned char *prop_ret;\n    unsigned long bytes_after, num_ret;\n\n    type_ret = None;\n    prop_ret = NULL;\n    XGetWindowProperty(dpy, win, atom, 0, 0, False, AnyPropertyType,\n                       &type_ret, &format_ret, &num_ret,\n                       &bytes_after, &prop_ret);\n    if (prop_ret)\n        XFree(prop_ret);\n\n    return (type_ret != None) ? True : False;\n#endif\n}"
  },
  {
    "function_name": "id_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "600-756",
    "snippet": "void id_cmd(char *cmd) {\n\tint rc, dx = 0, dy = 0, dw = 0, dh = 0;\n\tint x0, y0, w0, h0;\n\tint x, y, w, h, do_move = 0, do_resize = 0;\n\tint disp_x = DisplayWidth(dpy, scr);\n\tint disp_y = DisplayHeight(dpy, scr);\n\tWindow win = subwin;\n\tXWindowAttributes attr;\n\tXErrorHandler old_handler = NULL;\n\tWindow twin;\n\n\tif (!cmd || !strcmp(cmd, \"\")) { \n\t\treturn;\n\t}\n\tif (strstr(cmd, \"win=\") == cmd) {\n\t\tif (! scan_hexdec(cmd + strlen(\"win=\"), &win)) {\n\t\t\trfbLog(\"id_cmd: incorrect win= hex/dec number: %s\\n\", cmd);\n\t\t\treturn;\n\t\t} else {\n\t\t\tchar *q = strchr(cmd, ':');\n\t\t\tif (!q) {\n\t\t\t\trfbLog(\"id_cmd: incorrect win=...: hex/dec number: %s\\n\", cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLog(\"id_cmd:%s set window id to 0x%lx\\n\", cmd, win);\n\t\t\tcmd = q+1;\n\t\t}\n\t}\n\tif (!win) {\n\t\trfbLog(\"id_cmd:%s not in sub-window mode or no win=0xNNNN.\\n\", cmd);\n\t\treturn;\n\t}\n#if !NO_X11\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tw0 = w = attr.width;\n\th0 = h = attr.height;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tXTranslateCoordinates(dpy, win, rootwin, 0, 0, &x, &y, &twin);\n\tx0 = x;\n\ty0 = y;\n\tif (strstr(cmd, \"move:\") == cmd) {\n\t\tif (sscanf(cmd, \"move:%d%d\", &dx, &dy) == 2) {\n\t\t\tx = x + dx;\n\t\t\ty = y + dy;\n\t\t\tdo_move = 1;\n\t\t}\n\t} else if (strstr(cmd, \"resize:\") == cmd) {\n\t\tif (sscanf(cmd, \"resize:%d%d\", &dw, &dh) == 2) {\n\t\t\tw = w + dw;\n\t\t\th = h + dh;\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t}\n\t} else if (strstr(cmd, \"geom:\") == cmd) {\n\t\tif (parse_geom(cmd+strlen(\"geom:\"), &w, &h, &x, &y, disp_x, disp_y)) {\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t\tif (w <= 0) {\n\t\t\t\tw = w0;\n\t\t\t}\n\t\t\tif (h <= 0) {\n\t\t\t\th = h0;\n\t\t\t}\n\t\t\tif (scaling && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t\tx /= scale_fac_x;\n\t\t\t\ty /= scale_fac_y;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(cmd, \"raise\")) {\n\t\trc = XRaiseWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"lower\")) {\n\t\trc = XLowerWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"map\")) {\n\t\trc= XMapRaised(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"unmap\")) {\n\t\trc= XUnmapWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"iconify\")) {\n\t\trc= XIconifyWindow(dpy, win, scr);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"wm_name:\") == cmd) {\n\t\trc= XStoreName(dpy, win, cmd+strlen(\"wm_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"icon_name:\") == cmd) {\n\t\trc= XSetIconName(dpy, win, cmd+strlen(\"icon_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"wm_delete\")) {\n\t\tXClientMessageEvent ev;\n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tev.type = ClientMessage;\n\t\tev.send_event = True;\n\t\tev.display = dpy;\n\t\tev.window = win;\n\t\tev.message_type = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\t\tev.format = 32;\n\t\tev.data.l[0] = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\t\trc = XSendEvent(dpy, win, False, 0, (XEvent *) &ev);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else {\n\t\trfbLog(\"id_cmd:%s unrecognized command.\\n\", cmd);\n\t}\n\tif (do_move || do_resize) {\n\t\tif (w >= disp_x) {\n\t\t\tw = disp_x - 4;\n\t\t}\n\t\tif (h >= disp_y) {\n\t\t\th = disp_y - 4;\n\t\t}\n\t\tif (w < 1) {\n\t\t\tw = 1;\n\t\t}\n\t\tif (h < 1) {\n\t\t\th = 1;\n\t\t}\n\t\tif (x + w > disp_x) {\n\t\t\tx = disp_x - w - 1;\n\t\t}\n\t\tif (y + h > disp_y) {\n\t\t\ty = disp_y - h - 1;\n\t\t}\n\t\tif (x < 0) {\n\t\t\tx = 1;\n\t\t}\n\t\tif (y < 0) {\n\t\t\ty = 1;\n\t\t}\n\t\trc = 0;\n\t\trc += XMoveWindow(dpy, win, x, y);\n\t\toff_x = x;\n\t\toff_y = y;\n\n\t\trc += XResizeWindow(dpy, win, w, h);\n\n\t\trfbLog(\"id_cmd:%s rc=%d dx=%d dy=%d dw=%d dh=%d %dx%d+%d+%d -> %dx%d+%d+%d\\n\",\n\t\t    cmd, rc, dx, dy, dw, dh, w0, h0, x0, y0, w, h, x, h);\n\t}\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trfbLog(\"id_cmd:%s trapped_xerror.\\n\", cmd);\n\t}\n\ttrapped_xerror = 0;\n\tif (do_resize) {\n\t\trfbLog(\"id_cmd:%s calling check_xrandr_event.\\n\", cmd);\n\t\tcheck_xrandr_event(\"id_cmd\");\n\t}\n\tX_UNLOCK;\n#endif\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_xrandr_event",
          "args": [
            "\"id_cmd\""
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrandr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "184-290",
          "snippet": "int check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrandr_present = 0;",
            "int xrandr_width  = -1;",
            "int xrandr_height = -1;",
            "int xrandr_rotation = -1;",
            "Time xrandr_timestamp = 0;",
            "Time xrandr_cfg_time = 0;",
            "int check_xrandr_event(char *msg);",
            "int known_xrandr_mode(char *s);",
            "static int handle_subwin_resize(char *msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nTime xrandr_timestamp = 0;\nTime xrandr_cfg_time = 0;\nint check_xrandr_event(char *msg);\nint known_xrandr_mode(char *s);\nstatic int handle_subwin_resize(char *msg);\n\nint check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s calling check_xrandr_event.\\n\"",
            "cmd"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s trapped_xerror.\\n\"",
            "cmd"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d dx=%d dy=%d dw=%d dh=%d %dx%d+%d+%d -> %dx%d+%d+%d\\n\"",
            "cmd",
            "rc",
            "dx",
            "dy",
            "dw",
            "dh",
            "w0",
            "h0",
            "x0",
            "y0",
            "w",
            "h",
            "x",
            "h"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XResizeWindow",
          "args": [
            "dpy",
            "win",
            "w",
            "h"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMoveWindow",
          "args": [
            "dpy",
            "win",
            "x",
            "y"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s unrecognized command.\\n\"",
            "cmd"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSendEvent",
          "args": [
            "dpy",
            "win",
            "False",
            "0",
            "(XEvent *) &ev"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"WM_DELETE_WINDOW\"",
            "False"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"WM_PROTOCOLS\"",
            "False"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ev",
            "0",
            "sizeof(ev)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"wm_delete\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetIconName",
          "args": [
            "dpy",
            "win",
            "cmd+strlen(\"icon_name:\")"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"icon_name:\""
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"icon_name:\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XStoreName",
          "args": [
            "dpy",
            "win",
            "cmd+strlen(\"wm_name:\")"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"wm_name:\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"wm_name:\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIconifyWindow",
          "args": [
            "dpy",
            "win",
            "scr"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"iconify\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUnmapWindow",
          "args": [
            "dpy",
            "win"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"unmap\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapRaised",
          "args": [
            "dpy",
            "win"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"map\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLowerWindow",
          "args": [
            "dpy",
            "win"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"lower\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s rc=%d\\n\"",
            "cmd",
            "rc"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRaiseWindow",
          "args": [
            "dpy",
            "win"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"raise\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_ACTIVE\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_geom",
          "args": [
            "cmd+strlen(\"geom:\")",
            "&w",
            "&h",
            "&x",
            "&y",
            "disp_x",
            "disp_y"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "parse_geom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "210-237",
          "snippet": "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dabs(double x);",
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dabs(double x);\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H);\n\nint parse_geom(char *str, int *wp, int *hp, int *xp, int *yp, int W, int H) {\n\tint w, h, x, y;\n\tif (! str) {\n\t\treturn 0;\n\t}\n\t/* handle +/-x and +/-y */\n\tif (sscanf(str, \"%dx%d+%d+%d\", &w, &h, &x, &y) == 4) {\n\t\t;\n\t} else if (sscanf(str, \"%dx%d-%d+%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\tx = W - x - w;\n\t} else if (sscanf(str, \"%dx%d+%d-%d\", &w, &h, &x, &y) == 4) {\n\t\th = nabs(h);\n\t\ty = H - y - h;\n\t} else if (sscanf(str, \"%dx%d-%d-%d\", &w, &h, &x, &y) == 4) {\n\t\tw = nabs(w);\n\t\th = nabs(h);\n\t\tx = W - x - w;\n\t\ty = H - y - h;\n\t} else {\n\t\treturn 0;\n\t}\n\t*wp = w;\n\t*hp = h;\n\t*xp = x;\n\t*yp = y;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"geom:\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"geom:\""
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cmd",
            "\"resize:%d%d\"",
            "&dw",
            "&dh"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"resize:\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cmd",
            "\"move:%d%d\"",
            "&dx",
            "&dy"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"move:\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTranslateCoordinates",
          "args": [
            "dpy",
            "win",
            "rootwin",
            "0",
            "0",
            "&x",
            "&y",
            "&twin"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s not in sub-window mode or no win=0xNNNN.\\n\"",
            "cmd"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd:%s set window id to 0x%lx\\n\"",
            "cmd",
            "win"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd: incorrect win=...: hex/dec number: %s\\n\"",
            "cmd"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cmd",
            "':'"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"id_cmd: incorrect win= hex/dec number: %s\\n\"",
            "cmd"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_hexdec",
          "args": [
            "cmd + strlen(\"win=\")",
            "&win"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "scan_hexdec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "201-208",
          "snippet": "int scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "int scan_hexdec(char *str, unsigned long *num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nint scan_hexdec(char *str, unsigned long *num);\n\nint scan_hexdec(char *str, unsigned long *num) {\n\tif (sscanf(str, \"0x%lx\", num) != 1) {\n\t\tif (sscanf(str, \"%lu\", num) != 1) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"win=\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cmd",
            "\"win=\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "\"\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayHeight",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayWidth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid id_cmd(char *cmd) {\n\tint rc, dx = 0, dy = 0, dw = 0, dh = 0;\n\tint x0, y0, w0, h0;\n\tint x, y, w, h, do_move = 0, do_resize = 0;\n\tint disp_x = DisplayWidth(dpy, scr);\n\tint disp_y = DisplayHeight(dpy, scr);\n\tWindow win = subwin;\n\tXWindowAttributes attr;\n\tXErrorHandler old_handler = NULL;\n\tWindow twin;\n\n\tif (!cmd || !strcmp(cmd, \"\")) { \n\t\treturn;\n\t}\n\tif (strstr(cmd, \"win=\") == cmd) {\n\t\tif (! scan_hexdec(cmd + strlen(\"win=\"), &win)) {\n\t\t\trfbLog(\"id_cmd: incorrect win= hex/dec number: %s\\n\", cmd);\n\t\t\treturn;\n\t\t} else {\n\t\t\tchar *q = strchr(cmd, ':');\n\t\t\tif (!q) {\n\t\t\t\trfbLog(\"id_cmd: incorrect win=...: hex/dec number: %s\\n\", cmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trfbLog(\"id_cmd:%s set window id to 0x%lx\\n\", cmd, win);\n\t\t\tcmd = q+1;\n\t\t}\n\t}\n\tif (!win) {\n\t\trfbLog(\"id_cmd:%s not in sub-window mode or no win=0xNNNN.\\n\", cmd);\n\t\treturn;\n\t}\n#if !NO_X11\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tw0 = w = attr.width;\n\th0 = h = attr.height;\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tXTranslateCoordinates(dpy, win, rootwin, 0, 0, &x, &y, &twin);\n\tx0 = x;\n\ty0 = y;\n\tif (strstr(cmd, \"move:\") == cmd) {\n\t\tif (sscanf(cmd, \"move:%d%d\", &dx, &dy) == 2) {\n\t\t\tx = x + dx;\n\t\t\ty = y + dy;\n\t\t\tdo_move = 1;\n\t\t}\n\t} else if (strstr(cmd, \"resize:\") == cmd) {\n\t\tif (sscanf(cmd, \"resize:%d%d\", &dw, &dh) == 2) {\n\t\t\tw = w + dw;\n\t\t\th = h + dh;\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t}\n\t} else if (strstr(cmd, \"geom:\") == cmd) {\n\t\tif (parse_geom(cmd+strlen(\"geom:\"), &w, &h, &x, &y, disp_x, disp_y)) {\n\t\t\tdo_move = 1;\n\t\t\tdo_resize = 1;\n\t\t\tif (w <= 0) {\n\t\t\t\tw = w0;\n\t\t\t}\n\t\t\tif (h <= 0) {\n\t\t\t\th = h0;\n\t\t\t}\n\t\t\tif (scaling && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t\tx /= scale_fac_x;\n\t\t\t\ty /= scale_fac_y;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(cmd, \"raise\")) {\n\t\trc = XRaiseWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"lower\")) {\n\t\trc = XLowerWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"map\")) {\n\t\trc= XMapRaised(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"unmap\")) {\n\t\trc= XUnmapWindow(dpy, win);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"iconify\")) {\n\t\trc= XIconifyWindow(dpy, win, scr);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"wm_name:\") == cmd) {\n\t\trc= XStoreName(dpy, win, cmd+strlen(\"wm_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (strstr(cmd, \"icon_name:\") == cmd) {\n\t\trc= XSetIconName(dpy, win, cmd+strlen(\"icon_name:\"));\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else if (!strcmp(cmd, \"wm_delete\")) {\n\t\tXClientMessageEvent ev;\n\t\tmemset(&ev, 0, sizeof(ev));\n\t\tev.type = ClientMessage;\n\t\tev.send_event = True;\n\t\tev.display = dpy;\n\t\tev.window = win;\n\t\tev.message_type = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\t\tev.format = 32;\n\t\tev.data.l[0] = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\t\trc = XSendEvent(dpy, win, False, 0, (XEvent *) &ev);\n\t\trfbLog(\"id_cmd:%s rc=%d\\n\", cmd, rc);\n\t} else {\n\t\trfbLog(\"id_cmd:%s unrecognized command.\\n\", cmd);\n\t}\n\tif (do_move || do_resize) {\n\t\tif (w >= disp_x) {\n\t\t\tw = disp_x - 4;\n\t\t}\n\t\tif (h >= disp_y) {\n\t\t\th = disp_y - 4;\n\t\t}\n\t\tif (w < 1) {\n\t\t\tw = 1;\n\t\t}\n\t\tif (h < 1) {\n\t\t\th = 1;\n\t\t}\n\t\tif (x + w > disp_x) {\n\t\t\tx = disp_x - w - 1;\n\t\t}\n\t\tif (y + h > disp_y) {\n\t\t\ty = disp_y - h - 1;\n\t\t}\n\t\tif (x < 0) {\n\t\t\tx = 1;\n\t\t}\n\t\tif (y < 0) {\n\t\t\ty = 1;\n\t\t}\n\t\trc = 0;\n\t\trc += XMoveWindow(dpy, win, x, y);\n\t\toff_x = x;\n\t\toff_y = y;\n\n\t\trc += XResizeWindow(dpy, win, w, h);\n\n\t\trfbLog(\"id_cmd:%s rc=%d dx=%d dy=%d dw=%d dh=%d %dx%d+%d+%d -> %dx%d+%d+%d\\n\",\n\t\t    cmd, rc, dx, dy, dw, dh, w0, h0, x0, y0, w, h, x, h);\n\t}\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trfbLog(\"id_cmd:%s trapped_xerror.\\n\", cmd);\n\t}\n\ttrapped_xerror = 0;\n\tif (do_resize) {\n\t\trfbLog(\"id_cmd:%s calling check_xrandr_event.\\n\", cmd);\n\t\tcheck_xrandr_event(\"id_cmd\");\n\t}\n\tX_UNLOCK;\n#endif\n}"
  },
  {
    "function_name": "descend_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "480-598",
    "snippet": "Window descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "nm_cache",
            "name_info",
            "nm_cache_len"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "c",
            "&r",
            "&c",
            "&rx",
            "&ry",
            "&wx",
            "&wy",
            "&m"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "classhint->res_name"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "store",
            "classhint->res_name"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "store",
            "\"++\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "store",
            "classhint->res_class"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "store",
            "\"##\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "classhint->res_name"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "classhint->res_class"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetClassHint",
          "args": [
            "dpy",
            "clast",
            "classhint"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "store",
            "name"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "store",
            "\"^^\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFetchName",
          "args": [
            "dpy",
            "clast",
            "&name"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "name_info",
            "nm_cache",
            "len"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nm_cache_len"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "nm_cache"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "1024"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XAllocClassHint",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow descend_pointer(int depth, Window start, char *name_info, int len) {\n#if NO_X11\n\tRAWFB_RET(None)\n\tif (!depth || !start || !name_info || !len) {}\n\treturn None;\n#else\n\tWindow r, c, clast = None;\n\tint i, rx, ry, wx, wy;\n\tint written = 0, filled = 0;\n\tchar *store = NULL;\n\tunsigned int m;\n\tstatic XClassHint *classhint = NULL;\n\tstatic char *nm_cache = NULL;\n\tstatic int nm_cache_len = 0;\n\tstatic Window prev_start = None;\n\n\tRAWFB_RET(None)\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\tif (! nm_cache) {\n\t\tnm_cache = (char *) malloc(1024);\n\t\tnm_cache_len = 1024;\n\t\tnm_cache[0] = '\\0';\n\t}\n\tif (name_info && nm_cache_len < len) {\n\t\tif (nm_cache) {\n\t\t\tfree(nm_cache);\n\t\t}\n\t\tnm_cache_len = 2*len;\n\t\tnm_cache = (char *) malloc(nm_cache_len);\n\t}\n\n\tif (name_info) {\n\t\tif (start != None && start == prev_start) {\n\t\t\tstore = NULL;\n\t\t\tstrncpy(name_info, nm_cache, len);\n\t\t} else {\n\t\t\tstore = name_info;\n\t\t\tname_info[0] = '\\0';\n\t\t}\n\t}\n\n\tif (start != None) {\n\t\tc = start;\n\t\tif (name_info) {\n\t\t\tprev_start = start;\n\t\t}\n\t} else {\n\t\tc = rootwin;\t\n\t}\n\n\tfor (i=0; i<depth; i++) {\n\t\tclast = c;\n\t\tif (store && ! filled) {\n\t\t\tchar *name;\n\t\t\tif (XFetchName(dpy, clast, &name) && name != NULL) {\n\t\t\t\tint l = strlen(name);\n\t\t\t\tif (written + l+2 < len) {\n\t\t\t\t\tstrcat(store, \"^^\");\n\t\t\t\t\twritten += 2;\n\t\t\t\t\tstrcat(store, name);\n\t\t\t\t\twritten += l;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (store && classhint && ! filled) {\n\t\t\tclasshint->res_name = NULL;\n\t\t\tclasshint->res_class = NULL;\n\t\t\tif (XGetClassHint(dpy, clast, classhint)) {\n\t\t\t\tint l = 0;\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tl += strlen(classhint->res_class); \n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tl += strlen(classhint->res_name); \n\t\t\t\t}\n\t\t\t\tif (written + l+4 < len) {\n\t\t\t\t\tstrcat(store, \"##\");\n\t\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_class);\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(store, \"++\");\n\t\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\t\tstrcat(store,\n\t\t\t\t\t\t    classhint->res_name);\n\t\t\t\t\t}\n\t\t\t\t\twritten += l+4;\n\t\t\t\t} else {\n\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t\tif (classhint->res_class) {\n\t\t\t\t\tXFree_wr(classhint->res_class);\n\t\t\t\t}\n\t\t\t\tif (classhint->res_name) {\n\t\t\t\t\tXFree_wr(classhint->res_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (! XQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &m)) {\n\t\t\tbreak;\n\t\t}\n\t\tif (! c) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (start != None && name_info) {\n\t\tstrncpy(nm_cache, name_info, nm_cache_len);\n\t}\n\n\treturn clast;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "pick_windowid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "405-478",
    "snippet": "int pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  Picked: 0x%lx\\n\\n\"",
            "tmp"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"0x%lx \"",
            "&tmp"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\" id: 0x\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "512",
            "p"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fileno(p)+1",
            "&set",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "p"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fileno(p)",
            "&set"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "p"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&set"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  by clicking the mouse in that window.\\n\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  Please select the window for x11vnc to poll\\n\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "\"xwininfo\"",
            "\"r\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   exiting.\\n\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "\"xwininfo\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"id\""
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "use_dpy"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint pick_windowid(unsigned long *num) {\n\tchar line[512];\n\tint ok = 0, n = 0, msec = 10, secmax = 15;\n\tFILE *p;\n\n\tRAWFB_RET(0)\n\n\tif (use_dpy) {\n\t\tset_env(\"DISPLAY\", use_dpy);\n\t}\n\t/* id */\n\tif (no_external_cmds || !cmd_ok(\"id\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", \"xwininfo\");\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tclose_exec_fds();\n\tp = popen(\"xwininfo\", \"r\");\n\n\tif (! p) {\n\t\treturn 0;\n\t}\n\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  Please select the window for x11vnc to poll\\n\");\n\tfprintf(stderr, \"  by clicking the mouse in that window.\\n\");\n\tfprintf(stderr, \"\\n\");\n\n\twhile (msec * n++ < 1000 * secmax) {\n\t\tunsigned long tmp;\n\t\tchar *q;\n\t\tfd_set set;\n\t\tstruct timeval tv;\n\n\t\tif (screen && screen->clientHead) {\n\t\t\t/* they may be doing the pointer-pick thru vnc: */\n\t\t\tint nfds;\n\t\t\ttv.tv_sec = 0;\n\t\t\ttv.tv_usec = msec * 1000;\n\t\t\tFD_ZERO(&set);\n\t\t\tFD_SET(fileno(p), &set);\n\n\t\t\tnfds = select(fileno(p)+1, &set, NULL, NULL, &tv);\n\t\t\t\n\t\t\tif (nfds == 0 || nfds < 0) {\n\t\t\t\t/* \n\t\t\t\t * select timedout or error.\n\t\t\t\t * note this rfbPE takes about 30ms too:\n\t\t\t\t */\n\t\t\t\trfbPE(-1);\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (fgets(line, 512, p) == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tq = strstr(line, \" id: 0x\"); \n\t\tif (q) {\n\t\t\tq += 5;\n\t\t\tif (sscanf(q, \"0x%lx \", &tmp) == 1) {\n\t\t\t\tok = 1;\n\t\t\t\t*num = tmp;\n\t\t\t\tfprintf(stderr, \"  Picked: 0x%lx\\n\\n\", tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpclose(p);\n\treturn ok;\n}"
  },
  {
    "function_name": "mask_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "386-403",
    "snippet": "unsigned int mask_state(void) {\n#if NO_X11\n\tRAWFB_RET(0)\n\treturn 0;\n#else\n\tWindow r, c;\t\n\tint rx, ry, wx, wy;\n\tunsigned int mask;\n\n\tRAWFB_RET(0)\n\n\tif (XQueryPointer_wr(dpy, rootwin, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn mask;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&c",
            "&rx",
            "&ry",
            "&wx",
            "&wy",
            "&mask"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nunsigned int mask_state(void) {\n#if NO_X11\n\tRAWFB_RET(0)\n\treturn 0;\n#else\n\tWindow r, c;\t\n\tint rx, ry, wx, wy;\n\tunsigned int mask;\n\n\tRAWFB_RET(0)\n\n\tif (XQueryPointer_wr(dpy, rootwin, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn mask;\n\t} else {\n\t\treturn 0;\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "query_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "355-384",
    "snippet": "Window query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "start",
            "&r",
            "&c",
            "&rx",
            "&ry",
            "&wx",
            "&wy",
            "&mask"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_get_cursor_pos",
          "args": [
            "&rx",
            "&ry"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_get_cursor_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "361-368",
          "snippet": "int macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_cursor_pos(int *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor_pos(int *, int *);\n\nint macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "update_stack_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "307-353",
    "snippet": "void update_stack_list(void) {\n\tint k;\n\tdouble now;\n\tXWindowAttributes attr;\n\tint boff, bwin;\n\n\tif (! stack_list) {\n\t\treturn;\n\t}\n\tif (! stack_list_num) {\n\t\treturn;\n\t}\n\n\tdtime0(&now);\n\n\tboff = get_boff();\n\tbwin = get_bwin();\n\t\n\tX_LOCK;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow win = stack_list[k].win;\n\t\tif (win != None && boff <= (int) win && (int) win < boff + bwin) {\n\t\t\t;\t/* special, blackout */\n\t\t} else if (!valid_window(win, &attr, 1)) {\n\t\t\tstack_list[k].valid = 0;\n\t\t} else {\n\t\t\tstack_list[k].valid = 1;\n\t\t\tstack_list[k].x = attr.x;\n\t\t\tstack_list[k].y = attr.y;\n\t\t\tstack_list[k].width = attr.width;\n\t\t\tstack_list[k].height = attr.height;\n\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\tstack_list[k].depth = attr.depth;\n\t\t\tstack_list[k].class = attr.class;\n\t\t\tstack_list[k].backing_store = attr.backing_store;\n\t\t\tstack_list[k].map_state = attr.map_state;\n\n\t\t\t/* root_x, root_y not used for stack_list usage: */\n\t\t\tstack_list[k].rx = -1;\n\t\t\tstack_list[k].ry = -1;\n\t\t}\n\t\tstack_list[k].fetched = 1;\n\t\tstack_list[k].time = now;\n\t}\n\tX_UNLOCK;\nif (0) fprintf(stderr, \"update_stack_list[%d]: %.4f  %.4f\\n\", stack_list_num, now - x11vnc_start, dtime(&now));\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "winattr_t *stack_list = NULL;",
      "int stack_list_num = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"update_stack_list[%d]: %.4f  %.4f\\n\"",
            "stack_list_num",
            "now - x11vnc_start",
            "dtime(&now)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&now"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bwin",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "get_bwin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "303-305",
          "snippet": "int get_bwin(void) {\n\treturn 10;\t\t\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_bwin(void) {\n\treturn 10;\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_boff",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "get_boff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "295-301",
          "snippet": "int get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_num = 0;\n\nvoid update_stack_list(void) {\n\tint k;\n\tdouble now;\n\tXWindowAttributes attr;\n\tint boff, bwin;\n\n\tif (! stack_list) {\n\t\treturn;\n\t}\n\tif (! stack_list_num) {\n\t\treturn;\n\t}\n\n\tdtime0(&now);\n\n\tboff = get_boff();\n\tbwin = get_bwin();\n\t\n\tX_LOCK;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow win = stack_list[k].win;\n\t\tif (win != None && boff <= (int) win && (int) win < boff + bwin) {\n\t\t\t;\t/* special, blackout */\n\t\t} else if (!valid_window(win, &attr, 1)) {\n\t\t\tstack_list[k].valid = 0;\n\t\t} else {\n\t\t\tstack_list[k].valid = 1;\n\t\t\tstack_list[k].x = attr.x;\n\t\t\tstack_list[k].y = attr.y;\n\t\t\tstack_list[k].width = attr.width;\n\t\t\tstack_list[k].height = attr.height;\n\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\tstack_list[k].depth = attr.depth;\n\t\t\tstack_list[k].class = attr.class;\n\t\t\tstack_list[k].backing_store = attr.backing_store;\n\t\t\tstack_list[k].map_state = attr.map_state;\n\n\t\t\t/* root_x, root_y not used for stack_list usage: */\n\t\t\tstack_list[k].rx = -1;\n\t\t\tstack_list[k].ry = -1;\n\t\t}\n\t\tstack_list[k].fetched = 1;\n\t\tstack_list[k].time = now;\n\t}\n\tX_UNLOCK;\nif (0) fprintf(stderr, \"update_stack_list[%d]: %.4f  %.4f\\n\", stack_list_num, now - x11vnc_start, dtime(&now));\n}"
  },
  {
    "function_name": "get_bwin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "303-305",
    "snippet": "int get_bwin(void) {\n\treturn 10;\t\t\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_bwin(void) {\n\treturn 10;\t\t\n}"
  },
  {
    "function_name": "get_boff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "295-301",
    "snippet": "int get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}"
  },
  {
    "function_name": "snapshot_stack_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "192-293",
    "snippet": "void snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "winattr_t *stack_list = NULL;",
      "int stack_list_len = 0;",
      "int stack_list_num = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "list"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"snapshot_stack_list: num=%d len=%d\\n\"",
            "stack_list_num",
            "stack_list_len"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"blackr: %d %dx%d+%d+%d\\n\"",
            "i",
            "stack_list[j-1].width",
            "stack_list[j-1].height",
            "stack_list[j-1].x",
            "stack_list[j-1].y"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_boff",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "get_boff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "295-301",
          "snippet": "int get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_boff(void) {\n\tif (macosx_console) {\n\t\treturn 0x1000000;\n\t} else {\n\t\treturn 0;\t\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "n*sizeof(winattr_t)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "stack_list"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&w",
            "&list",
            "&ui"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&now"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "256*sizeof(winattr_t)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_len = 0;\nint stack_list_num = 0;\n\nvoid snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "get_window_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "175-185",
    "snippet": "int get_window_size(Window win, int *w, int *h) {\n\tXWindowAttributes attr;\n\t/* valid_window? */\n\tif (valid_window(win, &attr, 1)) {\n\t\t*w = attr.width;\n\t\t*h = attr.height;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_window_size(Window win, int *w, int *h) {\n\tXWindowAttributes attr;\n\t/* valid_window? */\n\tif (valid_window(win, &attr, 1)) {\n\t\t*w = attr.width;\n\t\t*h = attr.height;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "xtranslate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "142-173",
    "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"xtranslate: trapped XError: %s (0x%lx)\\n\"",
            "xerror_string(trapped_xerror_event)",
            "src"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xerror_string",
          "args": [
            "trapped_xerror_event"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "xerror_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "425-435",
          "snippet": "char *xerror_string(XErrorEvent *error) {\n\tint index = -1;\n\tif (error) {\n\t\tindex = (int) error->error_code;\n\t}\n\tif (0 <= index && index <= xerrors_max) {\n\t\treturn xerrors[index];\n\t} else {\n\t\treturn xerrors[xerrors_max+1];\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int trap_xerror(Display *d, XErrorEvent *error);",
            "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
            "char *xerror_string(XErrorEvent *error);",
            "static int Xerror(Display *d, XErrorEvent *error);",
            "static char *xerrors[] = {\n\t\"Success\",\n\t\"BadRequest\",\n\t\"BadValue\",\n\t\"BadWindow\",\n\t\"BadPixmap\",\n\t\"BadAtom\",\n\t\"BadCursor\",\n\t\"BadFont\",\n\t\"BadMatch\",\n\t\"BadDrawable\",\n\t\"BadAccess\",\n\t\"BadAlloc\",\n\t\"BadColor\",\n\t\"BadGC\",\n\t\"BadIDChoice\",\n\t\"BadName\",\n\t\"BadLength\",\n\t\"BadImplementation\",\n\t\"unknown\"\n};",
            "static int xerrors_max = BadImplementation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic char *xerrors[] = {\n\t\"Success\",\n\t\"BadRequest\",\n\t\"BadValue\",\n\t\"BadWindow\",\n\t\"BadPixmap\",\n\t\"BadAtom\",\n\t\"BadCursor\",\n\t\"BadFont\",\n\t\"BadMatch\",\n\t\"BadDrawable\",\n\t\"BadAccess\",\n\t\"BadAlloc\",\n\t\"BadColor\",\n\t\"BadGC\",\n\t\"BadIDChoice\",\n\t\"BadName\",\n\t\"BadLength\",\n\t\"BadImplementation\",\n\t\"unknown\"\n};\nstatic int xerrors_max = BadImplementation;\n\nchar *xerror_string(XErrorEvent *error) {\n\tint index = -1;\n\tif (error) {\n\t\tindex = (int) error->error_code;\n\t}\n\tif (0 <= index && index <= xerrors_max) {\n\t\treturn xerrors[index];\n\t} else {\n\t\treturn xerrors[xerrors_max+1];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTranslateCoordinates",
          "args": [
            "dpy",
            "src",
            "dst",
            "src_x",
            "src_y",
            "dst_x",
            "dst_y",
            "child"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nox11_exit",
          "args": [
            "1"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "nox11_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1711-1718",
          "snippet": "void nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "valid_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "92-140",
    "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"valid_window: trapped XError: %s (0x%lx)\\n\"",
            "xerror_string(trapped_xerror_event)",
            "win"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xerror_string",
          "args": [
            "trapped_xerror_event"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "xerror_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "425-435",
          "snippet": "char *xerror_string(XErrorEvent *error) {\n\tint index = -1;\n\tif (error) {\n\t\tindex = (int) error->error_code;\n\t}\n\tif (0 <= index && index <= xerrors_max) {\n\t\treturn xerrors[index];\n\t} else {\n\t\treturn xerrors[xerrors_max+1];\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int trap_xerror(Display *d, XErrorEvent *error);",
            "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
            "char *xerror_string(XErrorEvent *error);",
            "static int Xerror(Display *d, XErrorEvent *error);",
            "static char *xerrors[] = {\n\t\"Success\",\n\t\"BadRequest\",\n\t\"BadValue\",\n\t\"BadWindow\",\n\t\"BadPixmap\",\n\t\"BadAtom\",\n\t\"BadCursor\",\n\t\"BadFont\",\n\t\"BadMatch\",\n\t\"BadDrawable\",\n\t\"BadAccess\",\n\t\"BadAlloc\",\n\t\"BadColor\",\n\t\"BadGC\",\n\t\"BadIDChoice\",\n\t\"BadName\",\n\t\"BadLength\",\n\t\"BadImplementation\",\n\t\"unknown\"\n};",
            "static int xerrors_max = BadImplementation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic char *xerrors[] = {\n\t\"Success\",\n\t\"BadRequest\",\n\t\"BadValue\",\n\t\"BadWindow\",\n\t\"BadPixmap\",\n\t\"BadAtom\",\n\t\"BadCursor\",\n\t\"BadFont\",\n\t\"BadMatch\",\n\t\"BadDrawable\",\n\t\"BadAccess\",\n\t\"BadAlloc\",\n\t\"BadColor\",\n\t\"BadGC\",\n\t\"BadIDChoice\",\n\t\"BadName\",\n\t\"BadLength\",\n\t\"BadImplementation\",\n\t\"unknown\"\n};\nstatic int xerrors_max = BadImplementation;\n\nchar *xerror_string(XErrorEvent *error) {\n\tint index = -1;\n\tif (error) {\n\t\tindex = (int) error->error_code;\n\t}\n\tif (0 <= index && index <= xerrors_max) {\n\t\treturn xerrors[index];\n\t} else {\n\t\treturn xerrors[xerrors_max+1];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetWindowAttributes",
          "args": [
            "dpy",
            "win",
            "pattr"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nox11_exit",
          "args": [
            "1"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "nox11_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1711-1718",
          "snippet": "void nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_valid_window",
          "args": [
            "win",
            "attr_ret"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "585-644",
          "snippet": "int macosx_valid_window(Window w, XWindowAttributes* a) {\n\tstatic int last_idx = -1;\n\tint win = (int) w;\n\tint i, k, idx = -1;\n\n\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\tif (macwins[last_idx].win == win) {\n\t\t\tidx = last_idx;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_get_qlook(w);\n\t\tif (idx >= 0 && idx < macwinmax) {\n\t\t\tif (macwins[idx].win != win) {\n\t\t\t\tidx = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tidx = -1;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tfor (i = 0; i<macwinmax; i++) {\n\t\t\tk = i;\n\t\t\tif (i == -1)  {\n\t\t\t\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\t\t\t\tk = last_idx;\n\t\t\t\t} else {\n\t\t\t\t\tlast_idx = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (macwins[k].win == win) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\ta->x = macwins[idx].x;\n\ta->y = macwins[idx].y;\n\ta->width  = macwins[idx].width;\n\ta->height = macwins[idx].height;\n\ta->depth = depth;\n\ta->border_width = 0;\n\ta->backing_store = 0;\n\tif (macwins[idx].mapped) {\n\t\ta->map_state = IsViewable;\n\t} else {\n\t\ta->map_state = IsUnmapped;\n\t}\n\n\tlast_idx = idx;\n\t\n\treturn 1;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_valid_window(Window, XWindowAttributes*);",
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_valid_window(Window, XWindowAttributes*);\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_valid_window(Window w, XWindowAttributes* a) {\n\tstatic int last_idx = -1;\n\tint win = (int) w;\n\tint i, k, idx = -1;\n\n\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\tif (macwins[last_idx].win == win) {\n\t\t\tidx = last_idx;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_get_qlook(w);\n\t\tif (idx >= 0 && idx < macwinmax) {\n\t\t\tif (macwins[idx].win != win) {\n\t\t\t\tidx = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tidx = -1;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tfor (i = 0; i<macwinmax; i++) {\n\t\t\tk = i;\n\t\t\tif (i == -1)  {\n\t\t\t\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\t\t\t\tk = last_idx;\n\t\t\t\t} else {\n\t\t\t\t\tlast_idx = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (macwins[k].win == win) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\ta->x = macwins[idx].x;\n\ta->y = macwins[idx].y;\n\ta->width  = macwins[idx].width;\n\ta->height = macwins[idx].height;\n\ta->depth = depth;\n\ta->border_width = 0;\n\ta->backing_store = 0;\n\tif (macwins[idx].mapped) {\n\t\ta->map_state = IsViewable;\n\t} else {\n\t\ta->map_state = IsUnmapped;\n\t}\n\n\tlast_idx = idx;\n\t\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "parent_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
    "lines": "51-89",
    "snippet": "Window parent_window(Window win, char **name) {\n#if !NO_X11\n\tWindow r, parent;\n\tWindow *list;\n\tXErrorHandler old_handler;\n\tunsigned int nchild;\n\tint rc;\n#endif\n\n\tif (name != NULL) {\n\t\t*name = NULL;\n\t}\n\tRAWFB_RET(None)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!name || !win) {}\n\treturn None;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XQueryTree_wr(dpy, win, &r, &parent, &list, &nchild);\n\tXSetErrorHandler(old_handler);\n\n\tif (! rc || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn None;\n\t}\n\ttrapped_xerror = 0;\n\n\tif (list) {\n\t\tXFree_wr(list);\n\t}\n\tif (parent && name) {\n\t\tXFetchName(dpy, parent, name);\n\t}\n\treturn parent;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"macosx.h\"",
      "#include \"xrandr.h\"",
      "#include \"connections.h\"",
      "#include \"xwrappers.h\"",
      "#include \"cleanup.h\"",
      "#include \"winattr_t.h\"",
      "#include \"xinerama.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFetchName",
          "args": [
            "dpy",
            "parent",
            "name"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "list"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "win",
            "&r",
            "&parent",
            "&list",
            "&nchild"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "nox11_exit",
          "args": [
            "1"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "nox11_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1711-1718",
          "snippet": "void nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow parent_window(Window win, char **name) {\n#if !NO_X11\n\tWindow r, parent;\n\tWindow *list;\n\tXErrorHandler old_handler;\n\tunsigned int nchild;\n\tint rc;\n#endif\n\n\tif (name != NULL) {\n\t\t*name = NULL;\n\t}\n\tRAWFB_RET(None)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!name || !win) {}\n\treturn None;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XQueryTree_wr(dpy, win, &r, &parent, &list, &nchild);\n\tXSetErrorHandler(old_handler);\n\n\tif (! rc || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn None;\n\t}\n\ttrapped_xerror = 0;\n\n\tif (list) {\n\t\tXFree_wr(list);\n\t}\n\tif (parent && name) {\n\t\tXFetchName(dpy, parent, name);\n\t}\n\treturn parent;\n#endif\t/* NO_X11 */\n}"
  }
]