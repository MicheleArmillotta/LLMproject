[
  {
    "function_name": "known_xrandr_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
    "lines": "292-305",
    "snippet": "int known_xrandr_mode(char *s) {\n/*\n * default:\t\n * resize:\tthe default\n * exit:\tshutdown clients and exit.\n * newfbsize:\tshutdown clients that do not support NewFBSize encoding.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"resize\") && \n\t    strcmp(s, \"exit\") && strcmp(s, \"newfbsize\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"screen.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_xrandr_mode(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"newfbsize\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"exit\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"resize\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"default\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint known_xrandr_mode(char *s);\n\nint known_xrandr_mode(char *s) {\n/*\n * default:\t\n * resize:\tthe default\n * exit:\tshutdown clients and exit.\n * newfbsize:\tshutdown clients that do not support NewFBSize encoding.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"resize\") && \n\t    strcmp(s, \"exit\") && strcmp(s, \"newfbsize\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "check_xrandr_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
    "lines": "184-290",
    "snippet": "int check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"screen.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrandr_present = 0;",
      "int xrandr_width  = -1;",
      "int xrandr_height = -1;",
      "int xrandr_rotation = -1;",
      "Time xrandr_timestamp = 0;",
      "Time xrandr_cfg_time = 0;",
      "int check_xrandr_event(char *msg);",
      "int known_xrandr_mode(char *s);",
      "static int handle_subwin_resize(char *msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: current  WxH: %dx%d\\n\"",
            "XDisplayWidth(dpy, scr)",
            "XDisplayHeight(dpy, scr)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDisplayHeight",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDisplayWidth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_xrandr_change",
          "args": [
            "rev->width",
            "rev->height"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "handle_xrandr_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "140-182",
          "snippet": "static void handle_xrandr_change(int new_x, int new_y) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tRAWFB_RET_VOID\n\n\t/* assumes no X_LOCK */\n\n\t/* sanity check xrandr_mode */\n\tif (! xrandr_mode) {\n\t\txrandr_mode = strdup(\"default\");\n\t} else if (! known_xrandr_mode(xrandr_mode)) {\n\t\tfree(xrandr_mode);\n\t\txrandr_mode = strdup(\"default\");\n\t}\n\trfbLog(\"xrandr_mode: %s\\n\", xrandr_mode);\n\tif (!strcmp(xrandr_mode, \"exit\")) {\n\t\tclose_all_clients();\n\t\trfbLog(\"  shutting down due to XRANDR event.\\n\");\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(xrandr_mode, \"newfbsize\") && screen) {\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tif (cl->useNewFBSize) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"  closing client %s (no useNewFBSize\"\n\t\t\t    \" support).\\n\", cl->host);\n\t\t\trfbCloseClient(cl);\n\t\t\trfbClientConnectionGone(cl);\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n\t\n\t/* default, resize, and newfbsize create a new fb: */\n\trfbLog(\"check_xrandr_event: trying to create new framebuffer...\\n\");\n\tif (new_x < wdpy_x || new_y < wdpy_y) {\n\t\tcheck_black_fb();\n\t}\n\tdo_new_fb(1);\n\trfbLog(\"check_xrandr_event: fb       WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_xrandr_mode(char *s);",
            "static void handle_xrandr_change(int new_x, int new_y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint known_xrandr_mode(char *s);\nstatic void handle_xrandr_change(int new_x, int new_y);\n\nstatic void handle_xrandr_change(int new_x, int new_y) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tRAWFB_RET_VOID\n\n\t/* assumes no X_LOCK */\n\n\t/* sanity check xrandr_mode */\n\tif (! xrandr_mode) {\n\t\txrandr_mode = strdup(\"default\");\n\t} else if (! known_xrandr_mode(xrandr_mode)) {\n\t\tfree(xrandr_mode);\n\t\txrandr_mode = strdup(\"default\");\n\t}\n\trfbLog(\"xrandr_mode: %s\\n\", xrandr_mode);\n\tif (!strcmp(xrandr_mode, \"exit\")) {\n\t\tclose_all_clients();\n\t\trfbLog(\"  shutting down due to XRANDR event.\\n\");\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(xrandr_mode, \"newfbsize\") && screen) {\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tif (cl->useNewFBSize) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"  closing client %s (no useNewFBSize\"\n\t\t\t    \" support).\\n\", cl->host);\n\t\t\trfbCloseClient(cl);\n\t\t\trfbClientConnectionGone(cl);\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n\t\n\t/* default, resize, and newfbsize create a new fb: */\n\trfbLog(\"check_xrandr_event: trying to create new framebuffer...\\n\");\n\tif (new_x < wdpy_x || new_y < wdpy_y) {\n\t\tcheck_black_fb();\n\t}\n\tdo_new_fb(1);\n\trfbLog(\"check_xrandr_event: fb       WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRRUpdateConfiguration",
          "args": [
            "&xev"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: updating config...\\n\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: no change detected.\\n\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: previous WxH: %dx%d\\n\"",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  mheight:         %d mm\\n\"",
            "(int) rev->mheight"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  mwidth:          %d mm\\n\"",
            "(int) rev->mwidth"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  height:          %d\\n\"",
            "(int) rev->height"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  width:           %d\\n\"",
            "(int) rev->width"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  rotation:        %d\\n\"",
            "(int) rev->rotation"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  sub_pixel:       %d\\n\"",
            "(int) rev->subpixel_order"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  size_id:         %d\\n\"",
            "(int) rev->size_index"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  cfg_timestamp:   %d\\n\"",
            "(int) rev->config_timestamp"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  timestamp:       %d\\n\"",
            "(int) rev->timestamp"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  serial:          %d\\n\"",
            "(int) rev->serial"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Detected XRANDR event at location '%s':\\n\"",
            "msg"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event():\\n\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_XRANDR\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xrandr_base_event_type + RRScreenChangeNotify",
            "&xev"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_subwin_resize",
          "args": [
            "msg"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "handle_subwin_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "86-138",
          "snippet": "static int handle_subwin_resize(char *msg) {\n\tint new_x, new_y;\n\tint i, check = 10, ms = 250;\t/* 2.5 secs total... */\n\n\tif (msg) {}\t/* unused vars warning: */\n\tif (! subwin) {\n\t\treturn 0;\t/* hmmm... */\n\t}\n\tif (! valid_window(subwin, NULL, 0)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"subwin 0x%lx went away!\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (! get_window_size(subwin, &new_x, &new_y)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (wdpy_x == new_x && wdpy_y == new_y) {\n\t\t/* no change */\n\t\treturn 0;\n\t}\n\n\t/* window may still be changing (e.g. drag resize) */\n\tfor (i=0; i < check; i++) {\n\t\tint newer_x, newer_y;\n\t\tusleep(ms * 1000);\n\n\t\tif (! get_window_size(subwin, &newer_x, &newer_y)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (new_x == newer_x && new_y == newer_y) {\n\t\t\t/* go for it... */\n\t\t\tbreak;\n\t\t} else {\n\t\t\trfbLog(\"subwin 0x%lx still changing size...\\n\", subwin);\n\t\t\tnew_x = newer_x;\n\t\t\tnew_y = newer_y;\n\t\t}\n\t}\n\n\trfbLog(\"subwin 0x%lx new size: x: %d -> %d, y: %d -> %d\\n\",\n\t    subwin, wdpy_x, new_x, wdpy_y, new_y);\n\trfbLog(\"calling handle_xrandr_change() for resizing\\n\");\n\n\tX_UNLOCK;\n\thandle_xrandr_change(new_x, new_y);\n\treturn 1;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_xrandr_event(char *msg);",
            "static int handle_subwin_resize(char *msg);",
            "static void handle_xrandr_change(int new_x, int new_y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint check_xrandr_event(char *msg);\nstatic int handle_subwin_resize(char *msg);\nstatic void handle_xrandr_change(int new_x, int new_y);\n\nstatic int handle_subwin_resize(char *msg) {\n\tint new_x, new_y;\n\tint i, check = 10, ms = 250;\t/* 2.5 secs total... */\n\n\tif (msg) {}\t/* unused vars warning: */\n\tif (! subwin) {\n\t\treturn 0;\t/* hmmm... */\n\t}\n\tif (! valid_window(subwin, NULL, 0)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"subwin 0x%lx went away!\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (! get_window_size(subwin, &new_x, &new_y)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (wdpy_x == new_x && wdpy_y == new_y) {\n\t\t/* no change */\n\t\treturn 0;\n\t}\n\n\t/* window may still be changing (e.g. drag resize) */\n\tfor (i=0; i < check; i++) {\n\t\tint newer_x, newer_y;\n\t\tusleep(ms * 1000);\n\n\t\tif (! get_window_size(subwin, &newer_x, &newer_y)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (new_x == newer_x && new_y == newer_y) {\n\t\t\t/* go for it... */\n\t\t\tbreak;\n\t\t} else {\n\t\t\trfbLog(\"subwin 0x%lx still changing size...\\n\", subwin);\n\t\t\tnew_x = newer_x;\n\t\t\tnew_y = newer_y;\n\t\t}\n\t}\n\n\trfbLog(\"subwin 0x%lx new size: x: %d -> %d, y: %d -> %d\\n\",\n\t    subwin, wdpy_x, new_x, wdpy_y, new_y);\n\trfbLog(\"calling handle_xrandr_change() for resizing\\n\");\n\n\tX_UNLOCK;\n\thandle_xrandr_change(new_x, new_y);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nTime xrandr_timestamp = 0;\nTime xrandr_cfg_time = 0;\nint check_xrandr_event(char *msg);\nint known_xrandr_mode(char *s);\nstatic int handle_subwin_resize(char *msg);\n\nint check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_xrandr_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
    "lines": "140-182",
    "snippet": "static void handle_xrandr_change(int new_x, int new_y) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tRAWFB_RET_VOID\n\n\t/* assumes no X_LOCK */\n\n\t/* sanity check xrandr_mode */\n\tif (! xrandr_mode) {\n\t\txrandr_mode = strdup(\"default\");\n\t} else if (! known_xrandr_mode(xrandr_mode)) {\n\t\tfree(xrandr_mode);\n\t\txrandr_mode = strdup(\"default\");\n\t}\n\trfbLog(\"xrandr_mode: %s\\n\", xrandr_mode);\n\tif (!strcmp(xrandr_mode, \"exit\")) {\n\t\tclose_all_clients();\n\t\trfbLog(\"  shutting down due to XRANDR event.\\n\");\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(xrandr_mode, \"newfbsize\") && screen) {\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tif (cl->useNewFBSize) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"  closing client %s (no useNewFBSize\"\n\t\t\t    \" support).\\n\", cl->host);\n\t\t\trfbCloseClient(cl);\n\t\t\trfbClientConnectionGone(cl);\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n\t\n\t/* default, resize, and newfbsize create a new fb: */\n\trfbLog(\"check_xrandr_event: trying to create new framebuffer...\\n\");\n\tif (new_x < wdpy_x || new_y < wdpy_y) {\n\t\tcheck_black_fb();\n\t}\n\tdo_new_fb(1);\n\trfbLog(\"check_xrandr_event: fb       WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"screen.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_xrandr_mode(char *s);",
      "static void handle_xrandr_change(int new_x, int new_y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: fb       WxH: %dx%d\\n\"",
            "wdpy_x",
            "wdpy_y"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_black_fb",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "check_black_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "337-347",
          "snippet": "void check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_black_fb(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid check_black_fb(void);\n\nvoid check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xrandr_event: trying to create new framebuffer...\\n\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientConnectionGone",
          "args": [
            "cl"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "cl"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  closing client %s (no useNewFBSize\"\n\t\t\t    \" support).\\n\"",
            "cl->host"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xrandr_mode",
            "\"newfbsize\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "0"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  shutting down due to XRANDR event.\\n\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_all_clients",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "close_all_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "251-265",
          "snippet": "void close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\n\nvoid close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xrandr_mode",
            "\"exit\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"xrandr_mode: %s\\n\"",
            "xrandr_mode"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"default\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xrandr_mode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"default\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint known_xrandr_mode(char *s);\nstatic void handle_xrandr_change(int new_x, int new_y);\n\nstatic void handle_xrandr_change(int new_x, int new_y) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tRAWFB_RET_VOID\n\n\t/* assumes no X_LOCK */\n\n\t/* sanity check xrandr_mode */\n\tif (! xrandr_mode) {\n\t\txrandr_mode = strdup(\"default\");\n\t} else if (! known_xrandr_mode(xrandr_mode)) {\n\t\tfree(xrandr_mode);\n\t\txrandr_mode = strdup(\"default\");\n\t}\n\trfbLog(\"xrandr_mode: %s\\n\", xrandr_mode);\n\tif (!strcmp(xrandr_mode, \"exit\")) {\n\t\tclose_all_clients();\n\t\trfbLog(\"  shutting down due to XRANDR event.\\n\");\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(xrandr_mode, \"newfbsize\") && screen) {\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tif (cl->useNewFBSize) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"  closing client %s (no useNewFBSize\"\n\t\t\t    \" support).\\n\", cl->host);\n\t\t\trfbCloseClient(cl);\n\t\t\trfbClientConnectionGone(cl);\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n\t\n\t/* default, resize, and newfbsize create a new fb: */\n\trfbLog(\"check_xrandr_event: trying to create new framebuffer...\\n\");\n\tif (new_x < wdpy_x || new_y < wdpy_y) {\n\t\tcheck_black_fb();\n\t}\n\tdo_new_fb(1);\n\trfbLog(\"check_xrandr_event: fb       WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n}"
  },
  {
    "function_name": "handle_subwin_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
    "lines": "86-138",
    "snippet": "static int handle_subwin_resize(char *msg) {\n\tint new_x, new_y;\n\tint i, check = 10, ms = 250;\t/* 2.5 secs total... */\n\n\tif (msg) {}\t/* unused vars warning: */\n\tif (! subwin) {\n\t\treturn 0;\t/* hmmm... */\n\t}\n\tif (! valid_window(subwin, NULL, 0)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"subwin 0x%lx went away!\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (! get_window_size(subwin, &new_x, &new_y)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (wdpy_x == new_x && wdpy_y == new_y) {\n\t\t/* no change */\n\t\treturn 0;\n\t}\n\n\t/* window may still be changing (e.g. drag resize) */\n\tfor (i=0; i < check; i++) {\n\t\tint newer_x, newer_y;\n\t\tusleep(ms * 1000);\n\n\t\tif (! get_window_size(subwin, &newer_x, &newer_y)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (new_x == newer_x && new_y == newer_y) {\n\t\t\t/* go for it... */\n\t\t\tbreak;\n\t\t} else {\n\t\t\trfbLog(\"subwin 0x%lx still changing size...\\n\", subwin);\n\t\t\tnew_x = newer_x;\n\t\t\tnew_y = newer_y;\n\t\t}\n\t}\n\n\trfbLog(\"subwin 0x%lx new size: x: %d -> %d, y: %d -> %d\\n\",\n\t    subwin, wdpy_x, new_x, wdpy_y, new_y);\n\trfbLog(\"calling handle_xrandr_change() for resizing\\n\");\n\n\tX_UNLOCK;\n\thandle_xrandr_change(new_x, new_y);\n\treturn 1;\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"screen.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int check_xrandr_event(char *msg);",
      "static int handle_subwin_resize(char *msg);",
      "static void handle_xrandr_change(int new_x, int new_y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_xrandr_change",
          "args": [
            "new_x",
            "new_y"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "handle_xrandr_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "140-182",
          "snippet": "static void handle_xrandr_change(int new_x, int new_y) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tRAWFB_RET_VOID\n\n\t/* assumes no X_LOCK */\n\n\t/* sanity check xrandr_mode */\n\tif (! xrandr_mode) {\n\t\txrandr_mode = strdup(\"default\");\n\t} else if (! known_xrandr_mode(xrandr_mode)) {\n\t\tfree(xrandr_mode);\n\t\txrandr_mode = strdup(\"default\");\n\t}\n\trfbLog(\"xrandr_mode: %s\\n\", xrandr_mode);\n\tif (!strcmp(xrandr_mode, \"exit\")) {\n\t\tclose_all_clients();\n\t\trfbLog(\"  shutting down due to XRANDR event.\\n\");\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(xrandr_mode, \"newfbsize\") && screen) {\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tif (cl->useNewFBSize) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"  closing client %s (no useNewFBSize\"\n\t\t\t    \" support).\\n\", cl->host);\n\t\t\trfbCloseClient(cl);\n\t\t\trfbClientConnectionGone(cl);\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n\t\n\t/* default, resize, and newfbsize create a new fb: */\n\trfbLog(\"check_xrandr_event: trying to create new framebuffer...\\n\");\n\tif (new_x < wdpy_x || new_y < wdpy_y) {\n\t\tcheck_black_fb();\n\t}\n\tdo_new_fb(1);\n\trfbLog(\"check_xrandr_event: fb       WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_xrandr_mode(char *s);",
            "static void handle_xrandr_change(int new_x, int new_y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint known_xrandr_mode(char *s);\nstatic void handle_xrandr_change(int new_x, int new_y);\n\nstatic void handle_xrandr_change(int new_x, int new_y) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tRAWFB_RET_VOID\n\n\t/* assumes no X_LOCK */\n\n\t/* sanity check xrandr_mode */\n\tif (! xrandr_mode) {\n\t\txrandr_mode = strdup(\"default\");\n\t} else if (! known_xrandr_mode(xrandr_mode)) {\n\t\tfree(xrandr_mode);\n\t\txrandr_mode = strdup(\"default\");\n\t}\n\trfbLog(\"xrandr_mode: %s\\n\", xrandr_mode);\n\tif (!strcmp(xrandr_mode, \"exit\")) {\n\t\tclose_all_clients();\n\t\trfbLog(\"  shutting down due to XRANDR event.\\n\");\n\t\tclean_up_exit(0);\n\t}\n\tif (!strcmp(xrandr_mode, \"newfbsize\") && screen) {\n\t\titer = rfbGetClientIterator(screen);\n\t\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\tif (cl->useNewFBSize) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"  closing client %s (no useNewFBSize\"\n\t\t\t    \" support).\\n\", cl->host);\n\t\t\trfbCloseClient(cl);\n\t\t\trfbClientConnectionGone(cl);\n\t\t}\n\t\trfbReleaseClientIterator(iter);\n\t}\n\t\n\t/* default, resize, and newfbsize create a new fb: */\n\trfbLog(\"check_xrandr_event: trying to create new framebuffer...\\n\");\n\tif (new_x < wdpy_x || new_y < wdpy_y) {\n\t\tcheck_black_fb();\n\t}\n\tdo_new_fb(1);\n\trfbLog(\"check_xrandr_event: fb       WxH: %dx%d\\n\", wdpy_x, wdpy_y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"calling handle_xrandr_change() for resizing\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"subwin 0x%lx new size: x: %d -> %d, y: %d -> %d\\n\"",
            "subwin",
            "wdpy_x",
            "new_x",
            "wdpy_y",
            "new_y"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"subwin 0x%lx still changing size...\\n\"",
            "subwin"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not get size of subwin 0x%lx\\n\"",
            "subwin"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_window_size",
          "args": [
            "subwin",
            "&newer_x",
            "&newer_y"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "get_window_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "175-185",
          "snippet": "int get_window_size(Window win, int *w, int *h) {\n\tXWindowAttributes attr;\n\t/* valid_window? */\n\tif (valid_window(win, &attr, 1)) {\n\t\t*w = attr.width;\n\t\t*h = attr.height;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint get_window_size(Window win, int *w, int *h) {\n\tXWindowAttributes attr;\n\t/* valid_window? */\n\tif (valid_window(win, &attr, 1)) {\n\t\t*w = attr.width;\n\t\t*h = attr.height;\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not get size of subwin 0x%lx\\n\"",
            "subwin"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"subwin 0x%lx went away!\\n\"",
            "subwin"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "subwin",
            "NULL",
            "0"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint check_xrandr_event(char *msg);\nstatic int handle_subwin_resize(char *msg);\nstatic void handle_xrandr_change(int new_x, int new_y);\n\nstatic int handle_subwin_resize(char *msg) {\n\tint new_x, new_y;\n\tint i, check = 10, ms = 250;\t/* 2.5 secs total... */\n\n\tif (msg) {}\t/* unused vars warning: */\n\tif (! subwin) {\n\t\treturn 0;\t/* hmmm... */\n\t}\n\tif (! valid_window(subwin, NULL, 0)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"subwin 0x%lx went away!\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (! get_window_size(subwin, &new_x, &new_y)) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\tif (wdpy_x == new_x && wdpy_y == new_y) {\n\t\t/* no change */\n\t\treturn 0;\n\t}\n\n\t/* window may still be changing (e.g. drag resize) */\n\tfor (i=0; i < check; i++) {\n\t\tint newer_x, newer_y;\n\t\tusleep(ms * 1000);\n\n\t\tif (! get_window_size(subwin, &newer_x, &newer_y)) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"could not get size of subwin 0x%lx\\n\", subwin);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (new_x == newer_x && new_y == newer_y) {\n\t\t\t/* go for it... */\n\t\t\tbreak;\n\t\t} else {\n\t\t\trfbLog(\"subwin 0x%lx still changing size...\\n\", subwin);\n\t\t\tnew_x = newer_x;\n\t\t\tnew_y = newer_y;\n\t\t}\n\t}\n\n\trfbLog(\"subwin 0x%lx new size: x: %d -> %d, y: %d -> %d\\n\",\n\t    subwin, wdpy_x, new_x, wdpy_y, new_y);\n\trfbLog(\"calling handle_xrandr_change() for resizing\\n\");\n\n\tX_UNLOCK;\n\thandle_xrandr_change(new_x, new_y);\n\treturn 1;\n}"
  },
  {
    "function_name": "initialize_xrandr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
    "lines": "61-84",
    "snippet": "void initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}",
    "includes": [
      "#include \"win_utils.h\"",
      "#include \"screen.h\"",
      "#include \"remote.h\"",
      "#include \"connections.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xrandr_present = 0;",
      "int xrandr_width  = -1;",
      "int xrandr_height = -1;",
      "int xrandr_rotation = -1;",
      "void initialize_xrandr(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-xrandr mode specified, but no RANDR support on\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRRSelectInput",
          "args": [
            "dpy",
            "rootwin",
            "0"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRRSelectInput",
          "args": [
            "dpy",
            "rootwin",
            "RRScreenChangeNotifyMask"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XRRRotations",
          "args": [
            "dpy",
            "scr",
            "&rot"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDisplayHeight",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDisplayWidth",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nvoid initialize_xrandr(void);\n\nvoid initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}"
  }
]