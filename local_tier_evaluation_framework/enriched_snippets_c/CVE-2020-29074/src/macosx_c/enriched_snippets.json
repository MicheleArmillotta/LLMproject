[
  {
    "function_name": "macosx_check_clipped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "708-748",
    "snippet": "int macosx_check_clipped(int win, int *list, int n) {\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, x2, y2;\n\tint ret = 0;\n\tint k, j, i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\tsraRgnAnd(r1, r0);\n\n\tfor (k = 0; k < n; k++) {\n\t\tj = macosxCGS_find_index(list[k]);\t/* XXX slow? */\n\t\tif (j < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[j].x;\n\t\ty1 = macwins[j].y;\n\t\tx2 = macwins[j].x + macwins[j].width;\n\t\ty2 = macwins[j].y + macwins[j].height;\n\t\tr2 = sraRgnCreateRect(x1, y1, x2, y2);\n\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\tret = 1;\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r2"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r2",
            "r1"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCGS_find_index",
          "args": [
            "list[k]"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_find_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "143-168",
          "snippet": "int macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_check_clipped(int win, int *list, int n) {\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, x2, y2;\n\tint ret = 0;\n\tint k, j, i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\tsraRgnAnd(r1, r0);\n\n\tfor (k = 0; k < n; k++) {\n\t\tj = macosxCGS_find_index(list[k]);\t/* XXX slow? */\n\t\tif (j < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[j].x;\n\t\ty1 = macwins[j].y;\n\t\tx2 = macwins[j].x + macwins[j].width;\n\t\ty2 = macwins[j].y + macwins[j].height;\n\t\tr2 = sraRgnCreateRect(x1, y1, x2, y2);\n\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\tret = 1;\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "macosx_check_offscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "679-706",
    "snippet": "int macosx_check_offscreen(int win) {\n\tsraRegionPtr r0, r1;\n\tint x1, y1, x2, y2;\n\tint ret;\n\tint i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\n\tif (sraRgnAnd(r1, r0)) {\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r1"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "r0"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "r1",
            "r0"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCGS_find_index",
          "args": [
            "win"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_find_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "143-168",
          "snippet": "int macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_check_offscreen(int win) {\n\tsraRegionPtr r0, r1;\n\tint x1, y1, x2, y2;\n\tint ret;\n\tint i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\n\tif (sraRgnAnd(r1, r0)) {\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "macosx_xquerytree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "652-677",
    "snippet": "Status macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return) {\n\n\tint i, n, k;\n\n\t*root_return = (Window) 0;\n\t*parent_return = (Window) 0;\n\tif (!w) {}\n\n\tmacosxCGS_get_all_windows();\n\n\tn = 0;\n\tfor (k = CGS_levelmax - 1; k >= 0; k--) {\n\t\tfor (i = macwinmax - 1; i >= 0; i--) {\n\t\t\tif (n >= QTMAX) break;\n\t\t\tif (macwins[i].level == CGS_levels[k]) {\nif (0) fprintf(stderr, \"k=%d i=%d n=%d\\n\", k, i, n);\n\t\t\t\tcret[n++] = (Window) macwins[i].win;\n\t\t\t}\n\t\t}\n\t}\n\t*children_return = cret;\n\t*nchildren_return = (unsigned int) macwinmax;\n\n\treturn (Status) 1;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define QTMAX 2048"
    ],
    "globals_used": [
      "Status macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return);",
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"k=%d i=%d n=%d\\n\"",
            "k",
            "i",
            "n"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCGS_get_all_windows",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_get_all_windows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "262-521",
          "snippet": "void macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define WINHISTMAX 4",
            "#define WINHISTNUM 32768",
            "#define MAXWINDAT 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTMAX 4\n#define WINHISTNUM 32768\n#define MAXWINDAT 4096\n\nvoid macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define QTMAX 2048\n\nStatus macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return);\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nStatus macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return) {\n\n\tint i, n, k;\n\n\t*root_return = (Window) 0;\n\t*parent_return = (Window) 0;\n\tif (!w) {}\n\n\tmacosxCGS_get_all_windows();\n\n\tn = 0;\n\tfor (k = CGS_levelmax - 1; k >= 0; k--) {\n\t\tfor (i = macwinmax - 1; i >= 0; i--) {\n\t\t\tif (n >= QTMAX) break;\n\t\t\tif (macwins[i].level == CGS_levels[k]) {\nif (0) fprintf(stderr, \"k=%d i=%d n=%d\\n\", k, i, n);\n\t\t\t\tcret[n++] = (Window) macwins[i].win;\n\t\t\t}\n\t\t}\n\t}\n\t*children_return = cret;\n\t*nchildren_return = (unsigned int) macwinmax;\n\n\treturn (Status) 1;\n}"
  },
  {
    "function_name": "macosx_valid_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "585-644",
    "snippet": "int macosx_valid_window(Window w, XWindowAttributes* a) {\n\tstatic int last_idx = -1;\n\tint win = (int) w;\n\tint i, k, idx = -1;\n\n\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\tif (macwins[last_idx].win == win) {\n\t\t\tidx = last_idx;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_get_qlook(w);\n\t\tif (idx >= 0 && idx < macwinmax) {\n\t\t\tif (macwins[idx].win != win) {\n\t\t\t\tidx = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tidx = -1;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tfor (i = 0; i<macwinmax; i++) {\n\t\t\tk = i;\n\t\t\tif (i == -1)  {\n\t\t\t\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\t\t\t\tk = last_idx;\n\t\t\t\t} else {\n\t\t\t\t\tlast_idx = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (macwins[k].win == win) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\ta->x = macwins[idx].x;\n\ta->y = macwins[idx].y;\n\ta->width  = macwins[idx].width;\n\ta->height = macwins[idx].height;\n\ta->depth = depth;\n\ta->border_width = 0;\n\ta->backing_store = 0;\n\tif (macwins[idx].mapped) {\n\t\ta->map_state = IsViewable;\n\t} else {\n\t\ta->map_state = IsUnmapped;\n\t}\n\n\tlast_idx = idx;\n\t\n\treturn 1;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_valid_window(Window, XWindowAttributes*);",
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCGS_get_qlook",
          "args": [
            "w"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_get_qlook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "136-141",
          "snippet": "int macosxCGS_get_qlook(int w) {\n\tif (w >= WINHISTNUM) {\n\t\treturn -1;\n\t}\n\treturn qlook[w];\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define WINHISTNUM 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTNUM 32768\n\nint macosxCGS_get_qlook(int w) {\n\tif (w >= WINHISTNUM) {\n\t\treturn -1;\n\t}\n\treturn qlook[w];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_valid_window(Window, XWindowAttributes*);\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_valid_window(Window w, XWindowAttributes* a) {\n\tstatic int last_idx = -1;\n\tint win = (int) w;\n\tint i, k, idx = -1;\n\n\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\tif (macwins[last_idx].win == win) {\n\t\t\tidx = last_idx;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_get_qlook(w);\n\t\tif (idx >= 0 && idx < macwinmax) {\n\t\t\tif (macwins[idx].win != win) {\n\t\t\t\tidx = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tidx = -1;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tfor (i = 0; i<macwinmax; i++) {\n\t\t\tk = i;\n\t\t\tif (i == -1)  {\n\t\t\t\tif (last_idx >= 0 && last_idx < macwinmax) {\n\t\t\t\t\tk = last_idx;\n\t\t\t\t} else {\n\t\t\t\t\tlast_idx = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (macwins[k].win == win) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\ta->x = macwins[idx].x;\n\ta->y = macwins[idx].y;\n\ta->width  = macwins[idx].width;\n\ta->height = macwins[idx].height;\n\ta->depth = depth;\n\ta->border_width = 0;\n\ta->backing_store = 0;\n\tif (macwins[idx].mapped) {\n\t\ta->map_state = IsViewable;\n\t} else {\n\t\ta->map_state = IsUnmapped;\n\t}\n\n\tlast_idx = idx;\n\t\n\treturn 1;\n}"
  },
  {
    "function_name": "macosx_get_wm_frame_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "543-583",
    "snippet": "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n\tstatic int last_idx = -1;\n\tint x1, x2, y1, y2;\n\tint idx = -1, k;\n\tmacosxCGS_get_all_windows();\n\tmacosxCG_get_cursor_pos(px, py);\n\n\tfor (k = 0; k<macwinmax; k++) {\n\t\tif (! macwins[k].mapped) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[k].x;\n\t\tx2 = macwins[k].x + macwins[k].width;\n\t\ty1 = macwins[k].y;\n\t\ty2 = macwins[k].y + macwins[k].height;\nif (debug_wireframe) fprintf(stderr, \"%d/%d:\t%d %d %d  - %d %d %d\\n\", k, macwins[k].win, x1, *px, x2, y1, *py, y2);\n\t\tif (x1 <= *px && *px < x2) {\n\t\t\tif (y1 <= *py && *py < y2) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\t*x = macwins[idx].x;\n\t*y = macwins[idx].y;\n\t*w = macwins[idx].width;\n\t*h = macwins[idx].height;\n\t*frame = (Window) macwins[idx].win;\n\tif (win != NULL) {\n\t\t*win = *frame;\n\t}\n\n\tlast_idx = idx;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d/%d:\t%d %d %d  - %d %d %d\\n\"",
            "k",
            "macwins[k].win",
            "x1",
            "*px",
            "x2",
            "y1",
            "*py",
            "y2"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_get_cursor_pos",
          "args": [
            "px",
            "py"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_get_cursor_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "452-457",
          "snippet": "int macosxCG_get_cursor_pos(int *x, int *y) {\n\tCGPoint pos = current_cursor_pos();\n\t*x = pos.x;\n\t*y = pos.y;\n\treturn 1;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_get_cursor_pos(int *x, int *y) {\n\tCGPoint pos = current_cursor_pos();\n\t*x = pos.x;\n\t*y = pos.y;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGS_get_all_windows",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_get_all_windows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "262-521",
          "snippet": "void macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define WINHISTMAX 4",
            "#define WINHISTNUM 32768",
            "#define MAXWINDAT 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTMAX 4\n#define WINHISTNUM 32768\n#define MAXWINDAT 4096\n\nvoid macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n\tstatic int last_idx = -1;\n\tint x1, x2, y1, y2;\n\tint idx = -1, k;\n\tmacosxCGS_get_all_windows();\n\tmacosxCG_get_cursor_pos(px, py);\n\n\tfor (k = 0; k<macwinmax; k++) {\n\t\tif (! macwins[k].mapped) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[k].x;\n\t\tx2 = macwins[k].x + macwins[k].width;\n\t\ty1 = macwins[k].y;\n\t\ty2 = macwins[k].y + macwins[k].height;\nif (debug_wireframe) fprintf(stderr, \"%d/%d:\t%d %d %d  - %d %d %d\\n\", k, macwins[k].win, x1, *px, x2, y1, *py, y2);\n\t\tif (x1 <= *px && *px < x2) {\n\t\t\tif (y1 <= *py && *py < y2) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\t*x = macwins[idx].x;\n\t*y = macwins[idx].y;\n\t*w = macwins[idx].width;\n\t*h = macwins[idx].height;\n\t*frame = (Window) macwins[idx].win;\n\tif (win != NULL) {\n\t\t*win = *frame;\n\t}\n\n\tlast_idx = idx;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "macosx_checkevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "495-528",
    "snippet": "int macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_EVENTS 1024"
    ],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "int macosx_checkevent(XEvent *ev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unknown macosx_checkevent: %d\\n\"",
            "mac_events[i].type"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}"
  },
  {
    "function_name": "macosx_add_visnotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "473-493",
    "snippet": "void macosx_add_visnotify(Window win, int level, int obscured) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = VisibilityNotify;\n\tmac_events[i].map = -1;\n\n\tmac_events[i].vis = 1;\n\tif (obscured == 0) {\n\t\tmac_events[i].vis = VisibilityUnobscured;\n\t} else if (obscured == 1) {\n\t\tmac_events[i].vis = VisibilityPartiallyObscured;\n\t} else if (obscured == 2) {\n\t\tmac_events[i].vis = VisibilityFullyObscured; \t/* NI */\n\t}\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_EVENTS 1024"
    ],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_mapnotify(Window win, int level, int map);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);",
      "void macosx_add_visnotify(Window win, int level, int obscured);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\nvoid macosx_add_visnotify(Window win, int level, int obscured);\n\nvoid macosx_add_visnotify(Window win, int level, int obscured) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = VisibilityNotify;\n\tmac_events[i].map = -1;\n\n\tmac_events[i].vis = 1;\n\tif (obscured == 0) {\n\t\tmac_events[i].vis = VisibilityUnobscured;\n\t} else if (obscured == 1) {\n\t\tmac_events[i].vis = VisibilityPartiallyObscured;\n\t} else if (obscured == 2) {\n\t\tmac_events[i].vis = VisibilityFullyObscured; \t/* NI */\n\t}\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
  },
  {
    "function_name": "macosx_add_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "459-471",
    "snippet": "void macosx_add_destroy(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = DestroyNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_EVENTS 1024"
    ],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_mapnotify(Window win, int level, int map);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_destroy(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = DestroyNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
  },
  {
    "function_name": "macosx_add_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "445-457",
    "snippet": "void macosx_add_create(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = CreateNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_EVENTS 1024"
    ],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_mapnotify(Window win, int level, int map);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_create(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = CreateNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
  },
  {
    "function_name": "macosx_add_mapnotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "427-443",
    "snippet": "void macosx_add_mapnotify(Window win, int level, int map) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tif (map) {\n\t\tmac_events[i].type = MapNotify;\n\t} else {\n\t\tmac_events[i].type = UnmapNotify;\n\t}\n\tmac_events[i].map = map;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define MAX_EVENTS 1024"
    ],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_mapnotify(Window win, int level, int map);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_mapnotify(Window win, int level, int map) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tif (map) {\n\t\tmac_events[i].type = MapNotify;\n\t} else {\n\t\tmac_events[i].type = UnmapNotify;\n\t}\n\tmac_events[i].map = map;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
  },
  {
    "function_name": "macosx_get_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "410-412",
    "snippet": "int macosx_get_cursor(void) {\n\treturn macosxCG_get_cursor();\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_cursor(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCG_get_cursor",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_get_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "462-542",
          "snippet": "int macosxCG_get_cursor(void) {\n\tint last_idx = (int) get_cursor_serial(1);\n\tint which = 1;\n\tCGError err;\n\tint datasize, row_bytes, cdepth, comps, bpcomp;\n\tCGRect rect;\n\tCGPoint hot;\n\tunsigned char *data;\n\tint cursor_seed;\n\tstatic int last_cursor_seed = -1;\n\tstatic time_t last_fetch = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_idx) {\n\t\twhich = last_idx;\n\t}\n\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn which;\n\t\t}\n\t}\n\n\t/* XXX all of these interfaces are undocumented. */\n\n\tcursor_seed = CGSCurrentCursorSeed();\n\tif (last_idx && cursor_seed == last_cursor_seed) {\n\t\tif (now < last_fetch + 2) {\n\t\t\treturn which;\n\t\t}\n\t}\n\tlast_cursor_seed = cursor_seed;\n\tlast_fetch = now;\n\n\tif (CGSGetGlobalCursorDataSize(conn, &datasize) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorDataSize error\\n\");\n\t\treturn which;\n\t}\n\n\tdata = (unsigned char*) malloc(datasize);\n\n\terr = CGSGetGlobalCursorData(conn, data, &datasize, &row_bytes,\n\t    &rect, &hot, &cdepth, &comps, &bpcomp);\n#if 0\n\tfprintf(stderr, \"datasize: %d row_bytes: %d cdepth: %d comps: %d bpcomp: %d w: %d h: %d\\n\",\n\t  datasize, row_bytes, cdepth, comps, bpcomp, (int) rect.size.width, (int) rect.size.height);\n#endif\n\tif (err != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorData error\\n\");\n\t\treturn which;\n\t}\n\n\tif (cdepth == 24) {\n\t\tcdepth = 32;\n\t}\n\n\tif (sizeof(long) == 8 && comps * bpcomp <= 32) {\n\t\t/* pad it out to unsigned long array size (like xfixes) */\n\t\tint i;\n\t\tunsigned char *dsave;\n\t\tunsigned char *data64 = (unsigned char*) malloc(2 *datasize);\n\t\tunsigned int  *uI = (unsigned int  *) data;\n\t\tunsigned long *uL = (unsigned long *) data64;\n\t\tfor (i=0; i < datasize/4; i++) {\n\t\t\tuL[i] = uI[i];\n\t\t}\n\t\tdsave = data;\n\t\tdata = data64;\n\t\tfree(dsave);\n\t}\n\n\twhich = store_cursor(cursor_seed, (unsigned long*) data,\n\t    (int) rect.size.width, (int) rect.size.height, cdepth, (int) hot.x, (int) hot.y);\n\n\tfree(data);\n\treturn(which);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_get_cursor(void) {\n\tint last_idx = (int) get_cursor_serial(1);\n\tint which = 1;\n\tCGError err;\n\tint datasize, row_bytes, cdepth, comps, bpcomp;\n\tCGRect rect;\n\tCGPoint hot;\n\tunsigned char *data;\n\tint cursor_seed;\n\tstatic int last_cursor_seed = -1;\n\tstatic time_t last_fetch = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_idx) {\n\t\twhich = last_idx;\n\t}\n\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn which;\n\t\t}\n\t}\n\n\t/* XXX all of these interfaces are undocumented. */\n\n\tcursor_seed = CGSCurrentCursorSeed();\n\tif (last_idx && cursor_seed == last_cursor_seed) {\n\t\tif (now < last_fetch + 2) {\n\t\t\treturn which;\n\t\t}\n\t}\n\tlast_cursor_seed = cursor_seed;\n\tlast_fetch = now;\n\n\tif (CGSGetGlobalCursorDataSize(conn, &datasize) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorDataSize error\\n\");\n\t\treturn which;\n\t}\n\n\tdata = (unsigned char*) malloc(datasize);\n\n\terr = CGSGetGlobalCursorData(conn, data, &datasize, &row_bytes,\n\t    &rect, &hot, &cdepth, &comps, &bpcomp);\n#if 0\n\tfprintf(stderr, \"datasize: %d row_bytes: %d cdepth: %d comps: %d bpcomp: %d w: %d h: %d\\n\",\n\t  datasize, row_bytes, cdepth, comps, bpcomp, (int) rect.size.width, (int) rect.size.height);\n#endif\n\tif (err != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorData error\\n\");\n\t\treturn which;\n\t}\n\n\tif (cdepth == 24) {\n\t\tcdepth = 32;\n\t}\n\n\tif (sizeof(long) == 8 && comps * bpcomp <= 32) {\n\t\t/* pad it out to unsigned long array size (like xfixes) */\n\t\tint i;\n\t\tunsigned char *dsave;\n\t\tunsigned char *data64 = (unsigned char*) malloc(2 *datasize);\n\t\tunsigned int  *uI = (unsigned int  *) data;\n\t\tunsigned long *uL = (unsigned long *) data64;\n\t\tfor (i=0; i < datasize/4; i++) {\n\t\t\tuL[i] = uI[i];\n\t\t}\n\t\tdsave = data;\n\t\tdata = data64;\n\t\tfree(dsave);\n\t}\n\n\twhich = store_cursor(cursor_seed, (unsigned long*) data,\n\t    (int) rect.size.width, (int) rect.size.height, cdepth, (int) hot.x, (int) hot.y);\n\n\tfree(data);\n\treturn(which);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor(void);\n\nint macosx_get_cursor(void) {\n\treturn macosxCG_get_cursor();\n}"
  },
  {
    "function_name": "macosx_set_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "392-408",
    "snippet": "void macosx_set_sel(char *str, int len) {\n\tif (screen && all_clients_initialized()) {\n\t\tif (cutlen <= len) {\n\t\t\tif (cuttext) {\n\t\t\t\tfree(cuttext);\n\t\t\t}\n\t\t\tcutlen = 2*(len+1);\n\t\t\tcuttext = (char *) calloc(cutlen, 1);\n\t\t}\n\t\tmemcpy(cuttext, str, (size_t) len);\n\t\tcuttext[len] = '\\0';\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"macosx_set_sel: %d\\n\", len);\n\t\t}\n\t\tmacosxGCS_set_pasteboard(str, len);\n\t}\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_set_sel(char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxGCS_set_pasteboard",
          "args": [
            "str",
            "len"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "macosxGCS_set_pasteboard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "544-558",
          "snippet": "void macosxGCS_set_pasteboard(char *str, int len) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tif (pbcnt != 0) {\n\t\t[pblock lock];\n\t\t[cuttext release];\n\t\tcuttext = [[NSString alloc] initWithData:[NSData dataWithBytes:str length:len] encoding: pbenc];\n\t\tif ([[NSPasteboard generalPasteboard] declareTypes:[NSArray arrayWithObject:NSStringPboardType] owner:nil]) {\n\t\t\tNS_DURING\n\t\t\t\t[[NSPasteboard generalPasteboard] setString:cuttext forType:NSStringPboardType];\n\t\t\tNS_HANDLER\n\t\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t\tNS_ENDHANDLER\n\t\t} else {\n\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxGCS_set_pasteboard(char *str, int len) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tif (pbcnt != 0) {\n\t\t[pblock lock];\n\t\t[cuttext release];\n\t\tcuttext = [[NSString alloc] initWithData:[NSData dataWithBytes:str length:len] encoding: pbenc];\n\t\tif ([[NSPasteboard generalPasteboard] declareTypes:[NSArray arrayWithObject:NSStringPboardType] owner:nil]) {\n\t\t\tNS_DURING\n\t\t\t\t[[NSPasteboard generalPasteboard] setString:cuttext forType:NSStringPboardType];\n\t\t\tNS_HANDLER\n\t\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t\tNS_ENDHANDLER\n\t\t} else {\n\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"macosx_set_sel: %d\\n\"",
            "len"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cuttext",
            "str",
            "(size_t) len"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "cutlen",
            "1"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cuttext"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_set_sel(char *, int);\n\nvoid macosx_set_sel(char *str, int len) {\n\tif (screen && all_clients_initialized()) {\n\t\tif (cutlen <= len) {\n\t\t\tif (cuttext) {\n\t\t\t\tfree(cuttext);\n\t\t\t}\n\t\t\tcutlen = 2*(len+1);\n\t\t\tcuttext = (char *) calloc(cutlen, 1);\n\t\t}\n\t\tmemcpy(cuttext, str, (size_t) len);\n\t\tcuttext[len] = '\\0';\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"macosx_set_sel: %d\\n\", len);\n\t\t}\n\t\tmacosxGCS_set_pasteboard(str, len);\n\t}\n}"
  },
  {
    "function_name": "macosx_send_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "373-390",
    "snippet": "void macosx_send_sel(char *str, int len) {\n\tif (screen && all_clients_initialized()) {\n\t\tif (cuttext) {\n\t\t\tint n = cutlen;\n\t\t\tif (len < n) {\n\t\t\t\tn = len;\n\t\t\t}\n\t\t\tif (!memcmp(str, cuttext, (size_t) n)) {\n\t\t\t\t/* the same text we set pasteboard to ... */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"macosx_send_sel: %d\\n\", len);\n\t\t}\n\t\trfbSendServerCutText(screen, str, len);\n\t}\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_send_sel(char *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSendServerCutText",
          "args": [
            "screen",
            "str",
            "len"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"macosx_send_sel: %d\\n\"",
            "len"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str",
            "cuttext",
            "(size_t) n"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_send_sel(char *, int);\n\nvoid macosx_send_sel(char *str, int len) {\n\tif (screen && all_clients_initialized()) {\n\t\tif (cuttext) {\n\t\t\tint n = cutlen;\n\t\t\tif (len < n) {\n\t\t\t\tn = len;\n\t\t\t}\n\t\t\tif (!memcmp(str, cuttext, (size_t) n)) {\n\t\t\t\t/* the same text we set pasteboard to ... */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"macosx_send_sel: %d\\n\", len);\n\t\t}\n\t\trfbSendServerCutText(screen, str, len);\n\t}\n}"
  },
  {
    "function_name": "macosx_get_cursor_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "361-368",
    "snippet": "int macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_cursor_pos(int *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxGCS_poll_pb",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "macosxGCS_poll_pb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "568-598",
          "snippet": "void macosxGCS_poll_pb(void) {\n\n\tstatic double dlast = 0.0;\n\tdouble now = dnow();\n\n\tif (now < dlast + 0.2) {\n\t\treturn;\n\t}\n\tdlast = now;\n\n   {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\t[pblock lock];\n\tif (pbcnt != [[NSPasteboard generalPasteboard] changeCount]) {\n\t\tpbcnt = [[NSPasteboard generalPasteboard] changeCount];\n\t\t[pbstr release];\n\t\tpbstr = nil;\n\t\tif ([[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]]) {\n\t\t\tpbstr = [[[NSPasteboard generalPasteboard] stringForType:NSStringPboardType] copy];\n\t\t\tif (pbstr) {\n\t\t\t\tNSData *str = [pbstr dataUsingEncoding:pbenc allowLossyConversion:YES];\n\t\t\t\tif ([str length]) {\n\t\t\t\t\tmacosx_send_sel((char *) [str bytes], [str length]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t[pblock unlock];\n\t[pool release];\n   }\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxGCS_poll_pb(void) {\n\n\tstatic double dlast = 0.0;\n\tdouble now = dnow();\n\n\tif (now < dlast + 0.2) {\n\t\treturn;\n\t}\n\tdlast = now;\n\n   {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\t[pblock lock];\n\tif (pbcnt != [[NSPasteboard generalPasteboard] changeCount]) {\n\t\tpbcnt = [[NSPasteboard generalPasteboard] changeCount];\n\t\t[pbstr release];\n\t\tpbstr = nil;\n\t\tif ([[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]]) {\n\t\t\tpbstr = [[[NSPasteboard generalPasteboard] stringForType:NSStringPboardType] copy];\n\t\t\tif (pbstr) {\n\t\t\t\tNSData *str = [pbstr dataUsingEncoding:pbenc allowLossyConversion:YES];\n\t\t\t\tif ([str length]) {\n\t\t\t\t\tmacosx_send_sel((char *) [str bytes], [str length]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t[pblock unlock];\n\t[pool release];\n   }\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_get_cursor_pos",
          "args": [
            "x",
            "y"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_get_cursor_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "452-457",
          "snippet": "int macosxCG_get_cursor_pos(int *x, int *y) {\n\tCGPoint pos = current_cursor_pos();\n\t*x = pos.x;\n\t*y = pos.y;\n\treturn 1;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_get_cursor_pos(int *x, int *y) {\n\tCGPoint pos = current_cursor_pos();\n\t*x = pos.x;\n\t*y = pos.y;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor_pos(int *, int *);\n\nint macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "macosx_key_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "343-357",
    "snippet": "void macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tallowed_input_t input;\n\tif (debug_keyboard) fprintf(stderr, \"macosx_key_command: %d %s\\n\", (int) keysym, down ? \"down\" : \"up\");\n\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\treturn;\n\t}\n\n\tinit_key_table();\n\tmacosxCG_keysym_inject((int) down, (unsigned int) keysym);\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
      "void macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCG_keysym_inject",
          "args": [
            "(int) down",
            "(unsigned int) keysym"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_keysym_inject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "963-985",
          "snippet": "void macosxCG_keysym_inject(int down, unsigned int keysym) {\n\tCGKeyCode keyCode = keyTable[(unsigned short)keysym];\n\tCGCharCode keyChar = 0;\n#if 0\n\tint pressModsForKeys = FALSE;\n\tUInt32 modsForKey = keyTableMods[keysym] << 8;\n#endif\n\n\tinit_key_table();\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject(down=%d, keysym=%d)\\n\", down, (int) keysym);\n\n\tif (keysym < 0xFF && macosx_us_kbd) {\n\t\tkeyChar = (CGCharCode) keysym;\n\t\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject keyChar=>%d\\n\", (int) keyChar);\n\t}\n\tif (keyCode == 0xFFFF) {\n\t\treturn;\n\t}\n\tmacosxCGP_undim();\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_keysym_inject(int down, unsigned int keysym) {\n\tCGKeyCode keyCode = keyTable[(unsigned short)keysym];\n\tCGCharCode keyChar = 0;\n#if 0\n\tint pressModsForKeys = FALSE;\n\tUInt32 modsForKey = keyTableMods[keysym] << 8;\n#endif\n\n\tinit_key_table();\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject(down=%d, keysym=%d)\\n\", down, (int) keysym);\n\n\tif (keysym < 0xFF && macosx_us_kbd) {\n\t\tkeyChar = (CGCharCode) keysym;\n\t\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject keyChar=>%d\\n\", (int) keyChar);\n\t}\n\tif (keyCode == 0xFFFF) {\n\t\treturn;\n\t}\n\tmacosxCGP_undim();\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_key_table",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "init_key_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "339-341",
          "snippet": "void init_key_table(void) {\n\tmacosxCG_init_key_table();\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid init_key_table(void) {\n\tmacosxCG_init_key_table();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_allowed_input",
          "args": [
            "client",
            "&input"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "get_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2791-2847",
          "snippet": "void get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\n\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"macosx_key_command: %d %s\\n\"",
            "(int) keysym",
            "down ? \"down\" : \"up\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nvoid macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);\n\nvoid macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tallowed_input_t input;\n\tif (debug_keyboard) fprintf(stderr, \"macosx_key_command: %d %s\\n\", (int) keysym, down ? \"down\" : \"up\");\n\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\treturn;\n\t}\n\n\tinit_key_table();\n\tmacosxCG_keysym_inject((int) down, (unsigned int) keysym);\n}"
  },
  {
    "function_name": "init_key_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "339-341",
    "snippet": "void init_key_table(void) {\n\tmacosxCG_init_key_table();\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCG_init_key_table",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_init_key_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "897-917",
          "snippet": "void macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define keyTableSize 0xFFFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define keyTableSize 0xFFFF\n\nvoid macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid init_key_table(void) {\n\tmacosxCG_init_key_table();\n}"
  },
  {
    "function_name": "macosx_pointer_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "263-337",
    "snippet": "void macosx_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tstatic int last_mask = 0;\n\tint rc;\n\n\tif (0) fprintf(stderr, \"macosx_pointer_command: %d %d - %d\\n\", x, y, mask);\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (view_only) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (! input.motion || ! input.button) {\n\t\t/* XXX fix me with last_x, last_y, etc. */\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\t\tlast_pointer_time = time(NULL);\n\t}\n\tif (last_mask != mask) {\n\t\tif (0) fprintf(stderr, \"about to inject mask change %d -> %d: %.4f\\n\", last_mask, mask, dnowx());\n\t\tif (mask) {\n\t\t\tint px, py, x, y, w, h;\n\t\t\tmacosx_click_frame = None;\n\t\t\tif (!macosx_get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &macosx_click_frame, NULL)) {\n\t\t\t\tmacosx_click_frame = None;\n\t\t\t}\n\t\t}\n\t}\n\n\tmacosxCG_pointer_inject(mask, x, y);\n\n\tif (cursor_x != x || cursor_y != y) {\n\t\tlast_pointer_motion_time = dnow();\n\t}\n\n\tcursor_x = x;\n\tcursor_y = y;\n\n\tif (last_mask != mask) {\n\t\tlast_pointer_click_time = dnow();\n\t\tif (ncache > 0) {\n\t\t\t/* XXX Y */\n\t\t\tint i;\nif (0) fprintf(stderr, \"about to get all windows:           %.4f\\n\", dnowx());\n\t\t\tfor (i=0; i < 2; i++) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tif (0) fprintf(stderr, \"!\");\n\t\t\t\tif (macosx_checkevent(NULL)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nif (0) fprintf(stderr, \"\\ndone:                               %.4f\\n\", dnowx());\n\t\t}\n\t}\n\tlast_mask = mask;\n\n\t/* record the x, y position for the rfb screen as well. */\n\tcursor_position(x, y, client);\n\n\t/* change the cursor shape if necessary */\n\trc = set_cursor(x, y, get_which_cursor());\n\tcursor_changes += rc;\n\n\tlast_event = last_input = last_pointer_input = time(NULL);\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
      "void macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cursor",
          "args": [
            "x",
            "y",
            "get_which_cursor()"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "set_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1963-1979",
          "snippet": "int set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\n\nint set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_which_cursor",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "get_which_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1512-1640",
          "snippet": "int get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int use_xfixes = 1;",
            "int get_which_cursor(void);",
            "int set_cursor(int x, int y, int which);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_rfb_cursor(int which);",
            "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint use_xfixes = 1;\nint get_which_cursor(void);\nint set_cursor(int x, int y, int which);\nunsigned long get_cursor_serial(int mode);\nstatic void set_rfb_cursor(int which);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\n\nint get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cursor_position",
          "args": [
            "x",
            "y",
            "client"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "cursor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1811-1936",
          "snippet": "void cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\ndone:                               %.4f\\n\"",
            "dnowx()"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_checkevent",
          "args": [
            "NULL"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_checkevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "495-528",
          "snippet": "int macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "int macosx_checkevent(XEvent *ev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tint i = mac_events_ptr;\n\n\tif (mac_events_ptr == mac_events_last) {\n\t\treturn 0;\n\t}\n\tif (ev == NULL) {\n\t\treturn mac_events[i].type;\n\t}\n\n\tev->xany.window = mac_events[i].win;\n\n\tif (mac_events[i].type == CreateNotify) {\n\t\tev->type = CreateNotify;\n\t\tev->xany.window = rootwin;\n\t\tev->xcreatewindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == DestroyNotify) {\n\t\tev->type = DestroyNotify;\n\t\tev->xdestroywindow.window = mac_events[i].win;\n\t} else if (mac_events[i].type == VisibilityNotify) {\n\t\tev->type = VisibilityNotify;\n\t\tev->xvisibility.state = mac_events[i].vis;\n\t} else if (mac_events[i].type == MapNotify) {\n\t\tev->type = MapNotify;\n\t} else if (mac_events[i].type == UnmapNotify) {\n\t\tev->type = UnmapNotify;\n\t} else {\n\t\tfprintf(stderr, \"unknown macosx_checkevent: %d\\n\", mac_events[i].type);\n\t}\n\tmac_events_ptr++;\n\tmac_events_ptr = mac_events_ptr % MAX_EVENTS;\n\n\treturn mac_events[i].type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"!\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCGS_get_all_windows",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_get_all_windows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "262-521",
          "snippet": "void macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define WINHISTMAX 4",
            "#define WINHISTNUM 32768",
            "#define MAXWINDAT 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTMAX 4\n#define WINHISTNUM 32768\n#define MAXWINDAT 4096\n\nvoid macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"about to get all windows:           %.4f\\n\"",
            "dnowx()"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_pointer_inject",
          "args": [
            "mask",
            "x",
            "y"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_pointer_inject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "671-715",
          "snippet": "void macosxCG_pointer_inject(int mask, int x, int y) {\n\tint swap23 = macosx_swap23;\n\tint s1 = 0, s2 = 1, s3 = 2, s4 = 3, s5 = 4;\n\tCGPoint loc;\n\tint wheel_distance = macosx_mouse_wheel_speed;\n\tstatic int cnt = 0;\n\tstatic int first = 1, prev1 = 0, prev2 = 0, prev3 = 0; \n\tint curr1, curr2, curr3;\n\n\tif (swap23) {\n\t\ts2 = 2;\n\t\ts3 = 1;\n\t}\n\n\tloc.x = x + off_x + coff_x;\n\tloc.y = y + off_y + coff_y;\n\n\tif ((cnt++ % 10) == 0) {\n\t\tmacosxCGP_undim();\n\t}\n\n\tif ((mask & (1 << s4))) {\n\t\tCGPostScrollWheelEvent_wr(1,  wheel_distance);\n\t}\n\tif ((mask & (1 << s5))) {\n\t\tCGPostScrollWheelEvent_wr(1, -wheel_distance);\n\t}\n\n\tcurr1 = (mask & (1 << s1)) ? TRUE : FALSE;\n\tcurr2 = (mask & (1 << s2)) ? TRUE : FALSE;\n\tcurr3 = (mask & (1 << s3)) ? TRUE : FALSE;\n\n\tif (first) {\n\t\tprev1 = curr1;\n\t\tprev2 = curr2;\n\t\tprev3 = curr3;\n\t\tfirst = 0;\n\t}\n\n\tCGPostMouseEvent_wr(loc, TRUE, 3, curr1, curr2, curr3, prev1, prev2, prev3);\n\n\tprev1 = curr1;\n\tprev2 = curr2;\n\tprev3 = curr3;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_pointer_inject(int mask, int x, int y) {\n\tint swap23 = macosx_swap23;\n\tint s1 = 0, s2 = 1, s3 = 2, s4 = 3, s5 = 4;\n\tCGPoint loc;\n\tint wheel_distance = macosx_mouse_wheel_speed;\n\tstatic int cnt = 0;\n\tstatic int first = 1, prev1 = 0, prev2 = 0, prev3 = 0; \n\tint curr1, curr2, curr3;\n\n\tif (swap23) {\n\t\ts2 = 2;\n\t\ts3 = 1;\n\t}\n\n\tloc.x = x + off_x + coff_x;\n\tloc.y = y + off_y + coff_y;\n\n\tif ((cnt++ % 10) == 0) {\n\t\tmacosxCGP_undim();\n\t}\n\n\tif ((mask & (1 << s4))) {\n\t\tCGPostScrollWheelEvent_wr(1,  wheel_distance);\n\t}\n\tif ((mask & (1 << s5))) {\n\t\tCGPostScrollWheelEvent_wr(1, -wheel_distance);\n\t}\n\n\tcurr1 = (mask & (1 << s1)) ? TRUE : FALSE;\n\tcurr2 = (mask & (1 << s2)) ? TRUE : FALSE;\n\tcurr3 = (mask & (1 << s3)) ? TRUE : FALSE;\n\n\tif (first) {\n\t\tprev1 = curr1;\n\t\tprev2 = curr2;\n\t\tprev3 = curr3;\n\t\tfirst = 0;\n\t}\n\n\tCGPostMouseEvent_wr(loc, TRUE, 3, curr1, curr2, curr3, prev1, prev2, prev3);\n\n\tprev1 = curr1;\n\tprev2 = curr2;\n\tprev3 = curr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_get_wm_frame_pos",
          "args": [
            "&px",
            "&py",
            "&x",
            "&y",
            "&w",
            "&h",
            "&macosx_click_frame",
            "NULL"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_get_wm_frame_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "543-583",
          "snippet": "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n\tstatic int last_idx = -1;\n\tint x1, x2, y1, y2;\n\tint idx = -1, k;\n\tmacosxCGS_get_all_windows();\n\tmacosxCG_get_cursor_pos(px, py);\n\n\tfor (k = 0; k<macwinmax; k++) {\n\t\tif (! macwins[k].mapped) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[k].x;\n\t\tx2 = macwins[k].x + macwins[k].width;\n\t\ty1 = macwins[k].y;\n\t\ty2 = macwins[k].y + macwins[k].height;\nif (debug_wireframe) fprintf(stderr, \"%d/%d:\t%d %d %d  - %d %d %d\\n\", k, macwins[k].win, x1, *px, x2, y1, *py, y2);\n\t\tif (x1 <= *px && *px < x2) {\n\t\t\tif (y1 <= *py && *py < y2) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\t*x = macwins[idx].x;\n\t*y = macwins[idx].y;\n\t*w = macwins[idx].width;\n\t*h = macwins[idx].height;\n\t*frame = (Window) macwins[idx].win;\n\tif (win != NULL) {\n\t\t*win = *frame;\n\t}\n\n\tlast_idx = idx;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win) {\n\tstatic int last_idx = -1;\n\tint x1, x2, y1, y2;\n\tint idx = -1, k;\n\tmacosxCGS_get_all_windows();\n\tmacosxCG_get_cursor_pos(px, py);\n\n\tfor (k = 0; k<macwinmax; k++) {\n\t\tif (! macwins[k].mapped) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[k].x;\n\t\tx2 = macwins[k].x + macwins[k].width;\n\t\ty1 = macwins[k].y;\n\t\ty2 = macwins[k].y + macwins[k].height;\nif (debug_wireframe) fprintf(stderr, \"%d/%d:\t%d %d %d  - %d %d %d\\n\", k, macwins[k].win, x1, *px, x2, y1, *py, y2);\n\t\tif (x1 <= *px && *px < x2) {\n\t\t\tif (y1 <= *py && *py < y2) {\n\t\t\t\tidx = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\t*x = macwins[idx].x;\n\t*y = macwins[idx].y;\n\t*w = macwins[idx].width;\n\t*h = macwins[idx].height;\n\t*frame = (Window) macwins[idx].win;\n\tif (win != NULL) {\n\t\t*win = *frame;\n\t}\n\n\tlast_idx = idx;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"about to inject mask change %d -> %d: %.4f\\n\"",
            "last_mask",
            "mask",
            "dnowx()"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_allowed_input",
          "args": [
            "client",
            "&input"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "get_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2791-2847",
          "snippet": "void get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\n\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"macosx_pointer_command: %d %d - %d\\n\"",
            "x",
            "y",
            "mask"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nvoid macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);\n\nvoid macosx_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tstatic int last_mask = 0;\n\tint rc;\n\n\tif (0) fprintf(stderr, \"macosx_pointer_command: %d %d - %d\\n\", x, y, mask);\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (view_only) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (! input.motion || ! input.button) {\n\t\t/* XXX fix me with last_x, last_y, etc. */\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\t\tlast_pointer_time = time(NULL);\n\t}\n\tif (last_mask != mask) {\n\t\tif (0) fprintf(stderr, \"about to inject mask change %d -> %d: %.4f\\n\", last_mask, mask, dnowx());\n\t\tif (mask) {\n\t\t\tint px, py, x, y, w, h;\n\t\t\tmacosx_click_frame = None;\n\t\t\tif (!macosx_get_wm_frame_pos(&px, &py, &x, &y, &w, &h, &macosx_click_frame, NULL)) {\n\t\t\t\tmacosx_click_frame = None;\n\t\t\t}\n\t\t}\n\t}\n\n\tmacosxCG_pointer_inject(mask, x, y);\n\n\tif (cursor_x != x || cursor_y != y) {\n\t\tlast_pointer_motion_time = dnow();\n\t}\n\n\tcursor_x = x;\n\tcursor_y = y;\n\n\tif (last_mask != mask) {\n\t\tlast_pointer_click_time = dnow();\n\t\tif (ncache > 0) {\n\t\t\t/* XXX Y */\n\t\t\tint i;\nif (0) fprintf(stderr, \"about to get all windows:           %.4f\\n\", dnowx());\n\t\t\tfor (i=0; i < 2; i++) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tif (0) fprintf(stderr, \"!\");\n\t\t\t\tif (macosx_checkevent(NULL)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\nif (0) fprintf(stderr, \"\\ndone:                               %.4f\\n\", dnowx());\n\t\t}\n\t}\n\tlast_mask = mask;\n\n\t/* record the x, y position for the rfb screen as well. */\n\tcursor_position(x, y, client);\n\n\t/* change the cursor shape if necessary */\n\trc = set_cursor(x, y, get_which_cursor());\n\tcursor_changes += rc;\n\n\tlast_event = last_input = last_pointer_input = time(NULL);\n}"
  },
  {
    "function_name": "macosx_console_guess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "169-259",
    "snippet": "char *macosx_console_guess(char *str, int *fd) {\n\tchar *q, *in = strdup(str);\n\tchar *atparms = NULL, *file = NULL;\n\n\tmacosxCG_init();\n\n\tif (strstr(in, \"console\") != in) {\n\t\trfbLog(\"console_guess: unrecognized console/fb format: %s\\n\", str);\n\t\tfree(in);\n\t\treturn NULL;\n\t}\n\n\t*fd = -1;\n\n\tq = strrchr(in, '@');\n\tif (q) {\n\t\tatparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tq = strrchr(in, ':');\n\tif (q) {\n\t\tfile = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tif (! file || file[0] == '\\0')  {\n\t\tfile = strdup(\"/dev/null\");\n\t}\n\trfbLog(\"console_guess: file is %s\\n\", file);\n\n\tif (! pipeinput_str) {\n\t\tpipeinput_str = strdup(\"MACOSX\");\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (! atparms) {\n\t\tint w, h, b, bps, dep;\n\t\tunsigned long rm = 0, gm = 0, bm = 0;\n\n\t\tif (macosx_read_opengl) {\n\t\t\tw = macosx_opengl_get_width();\n\t\t\th = macosx_opengl_get_height();\n\t\t\tb = macosx_opengl_get_bpp();\n\n\t\t\tbps = macosx_opengl_get_bps();\n\t\t\tdep = macosx_opengl_get_spp() * bps;\n\t\t\t\n\t\t} else {\n\t\t\tw = macosxCG_CGDisplayPixelsWide();\n\t\t\th = macosxCG_CGDisplayPixelsHigh();\n\t\t\tb = macosxCG_CGDisplayBitsPerPixel();\n\n\t\t\tbps = macosxCG_CGDisplayBitsPerSample();\n\t\t\tdep = macosxCG_CGDisplaySamplesPerPixel() * bps;\n\t\t}\n\n\t\trm = (1 << bps) - 1;\n\t\tgm = (1 << bps) - 1;\n\t\tbm = (1 << bps) - 1;\n\t\trm = rm << 2 * bps;\n\t\tgm = gm << 1 * bps;\n\t\tbm = bm << 0 * bps;\n\n\t\tif (b == 8 && rm == 0xff && gm == 0xff && bm == 0xff) {\n\t\t\t/* I don't believe it... */\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t\t\n\t\t/* @66666x66666x32:0xffffffff:... */\n\t\tatparms = (char *) malloc(200);\n\t\tsprintf(atparms, \"%dx%dx%d:%lx/%lx/%lx\", w, h, b, rm, gm, bm);\n\t}\n\tif (atparms) {\n\t\tint gw, gh, gb;\n\t\tif (sscanf(atparms, \"%dx%dx%d\", &gw, &gh, &gb) == 3)  {\n\t\t\tfb_x = gw;\t\n\t\t\tfb_y = gh;\t\n\t\t\tfb_b = gb;\t\n\t\t}\n\t}\n\tif (! atparms) {\n\t\trfbLog(\"console_guess: could not get @ parameters.\\n\");\n\t\treturn NULL;\n\t}\n\n\tq = (char *) malloc(strlen(\"map:macosx:\") + strlen(file) + 1 + strlen(atparms) + 1);\n\tsprintf(q, \"map:macosx:%s@%s\", file, atparms);\n\tfree(atparms);\n\treturn q;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *macosx_console_guess(char *str, int *fd);",
      "void macosx_add_mapnotify(Window win, int level, int map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "atparms"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "q",
            "\"map:macosx:%s@%s\"",
            "file",
            "atparms"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"map:macosx:\") + strlen(file) + 1 + strlen(atparms) + 1"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "atparms"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "file"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"map:macosx:\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"console_guess: could not get @ parameters.\\n\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "atparms",
            "\"%dx%dx%d\"",
            "&gw",
            "&gh",
            "&gb"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "atparms",
            "\"%dx%dx%d:%lx/%lx/%lx\"",
            "w",
            "h",
            "b",
            "rm",
            "gm",
            "bm"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "200"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplaySamplesPerPixel",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplaySamplesPerPixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "379-384",
          "snippet": "int macosxCG_CGDisplaySamplesPerPixel(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_spp();\n\t}\n\treturn (int) CGDisplaySamplesPerPixel(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplaySamplesPerPixel(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_spp();\n\t}\n\treturn (int) CGDisplaySamplesPerPixel(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayBitsPerSample",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayBitsPerSample",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "373-378",
          "snippet": "int macosxCG_CGDisplayBitsPerSample(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bps();\n\t}\n\treturn (int) CGDisplayBitsPerSample(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBitsPerSample(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bps();\n\t}\n\treturn (int) CGDisplayBitsPerSample(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayBitsPerPixel",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayBitsPerPixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "367-372",
          "snippet": "int macosxCG_CGDisplayBitsPerPixel(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bpp();\n\t}\n\treturn (int) CGDisplayBitsPerPixel(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBitsPerPixel(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bpp();\n\t}\n\treturn (int) CGDisplayBitsPerPixel(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayPixelsHigh",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayPixelsHigh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "361-366",
          "snippet": "int macosxCG_CGDisplayPixelsHigh(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_height();\n\t}\n\treturn (int) CGDisplayPixelsHigh(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsHigh(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_height();\n\t}\n\treturn (int) CGDisplayPixelsHigh(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayPixelsWide",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayPixelsWide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "355-360",
          "snippet": "int macosxCG_CGDisplayPixelsWide(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width();\n\t}\n\treturn (int) CGDisplayPixelsWide(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsWide(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width();\n\t}\n\treturn (int) CGDisplayPixelsWide(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_spp",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_spp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "78-80",
          "snippet": "int macosx_opengl_get_spp(void) {\n\treturn 3;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_spp(void) {\n\treturn 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_bps",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "74-76",
          "snippet": "int macosx_opengl_get_bps(void) {\n\treturn 8;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bps(void) {\n\treturn 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_bpp",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "70-72",
          "snippet": "int macosx_opengl_get_bpp(void) {\n\treturn 32;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bpp(void) {\n\treturn 32;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_height",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_height",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "63-68",
          "snippet": "int macosx_opengl_get_height(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[3];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_height(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[3];\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_width",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "56-61",
          "snippet": "int macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_pipeinput",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_pipeinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "1007-1229",
          "snippet": "void initialize_pipeinput(void) {\n\tchar *p = NULL;\n\n\tif (pipeinput_fh != NULL) {\n\t\trfbLog(\"closing pipeinput stream: %p\\n\", pipeinput_fh);\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tpipeinput_tee = 0;\n\tif (pipeinput_opts) {\n\t\tfree(pipeinput_opts);\n\t\tpipeinput_opts = NULL;\n\t}\n\n\tif (! pipeinput_str) {\n\t\treturn;\n\t}\n\n\t/* look for options:  tee, reopen, ... */\n\tif (strstr(pipeinput_str, \"UINPUT\") == pipeinput_str) {\n\t\t;\n\t} else {\n\t\tp = strchr(pipeinput_str, ':');\n\t}\n\tif (p != NULL) {\n\t\tchar *str, *opt, *q;\n\t\tint got = 0;\n\t\t*p = '\\0';\n\t\tstr = strdup(pipeinput_str);\n\t\topt = strdup(pipeinput_str);\n\t\t*p = ':';\n\t\tq = strtok(str, \",\");\n\t\twhile (q) {\n\t\t\tif (!strcmp(q, \"key\") || !strcmp(q, \"keycodes\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"reopen\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"tee\")) {\n\t\t\t\tpipeinput_tee = 1;\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tq = strtok(NULL, \",\");\n\t\t}\n\t\tif (got) {\n\t\t\tpipeinput_opts = opt;\n\t\t} else {\n\t\t\tfree(opt);\n\t\t}\n\t\tfree(str);\n\t\tp++;\n\t} else {\n\t\tp = pipeinput_str;\n\t}\nif (0) fprintf(stderr, \"initialize_pipeinput: %s -- %s\\n\", pipeinput_str, p);\n\n\tif (!strcmp(p, \"VID\")) {\n\t\tpipeinput_int = PIPEINPUT_VID;\n\t\treturn;\n\t} else if (strstr(p, \"CONSOLE\") == p) {\n\t\tint tty = 0, n;\n\t\tchar dev[32];\n\t\tif (sscanf(p, \"CONSOLE%d\", &n) == 1) {\n\t\t\ttty = n;\n\t\t}\n\t\tsprintf(dev, \"/dev/tty%d\", tty);\n\t\tpipeinput_cons_fd = open(dev, O_WRONLY);\n\t\tif (pipeinput_cons_fd >= 0) {\n\t\t\trfbLog(\"pipeinput: using linux console: %s\\n\", dev);\n\t\t\tif (pipeinput_cons_dev) {\n\t\t\t\tfree(pipeinput_cons_dev);\n\t\t\t}\n\t\t\tpipeinput_cons_dev = strdup(dev);\n\t\t\tpipeinput_int = PIPEINPUT_CONSOLE;\n\t\t} else {\n\t\t\trfbLog(\"pipeinput: could not open: %s\\n\", dev);\n\t\t\trfbLogPerror(\"open\");\n\t\t\trfbLog(\"You may need to be root to open %s.\\n\", dev);\n\t\t\trfbLog(\"\\n\");\n\t\t}\n\t\treturn;\n\t} else if (strstr(p, \"UINPUT\") == p) {\n\t\tchar *q = strchr(p, ':');\n\t\tif (q) {\n\t\t\tparse_uinput_str(q+1);\n\t\t}\n\t\tpipeinput_int = PIPEINPUT_UINPUT;\n\t\tinitialize_uinput();\n\t\treturn;\n\t} else if (strstr(p, \"MACOSX\") == p) {\n\t\tpipeinput_int = PIPEINPUT_MACOSX;\n\t\treturn;\n\t} else if (strstr(p, \"VNC\") == p) {\n\t\tpipeinput_int = PIPEINPUT_VNC;\n\t\treturn;\n\t}\n\n\tset_child_info();\n\t/* pipeinput */\n\tif (no_external_cmds || !cmd_ok(\"pipeinput\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", p);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"pipeinput: starting: \\\"%s\\\"...\\n\", p);\n\tclose_exec_fds();\n\tpipeinput_fh = popen(p, \"w\");\n\n\tif (! pipeinput_fh) {\n\t\trfbLog(\"popen(\\\"%s\\\", \\\"w\\\") failed.\\n\", p);\n\t\trfbLogPerror(\"popen\");\n\t\trfbLog(\"Disabling -pipeinput mode.\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(pipeinput_fh, \"%s\",\n\"# \\n\"\n\"# Format of the -pipeinput stream:\\n\"\n\"# --------------------------------\\n\"\n\"#\\n\"\n\"# Lines like these beginning with '#' are to be ignored.\\n\"\n\"#\\n\"\n\"# Pointer events (mouse motion and button clicks) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Pointer <client#> <x> <y> <mask> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is a decimal integer uniquely identifying the client\\n\"\n\"# that generated the event.  If it is negative that means this event\\n\"\n\"# would have been discarded since the client was viewonly.\\n\"\n\"#\\n\"\n\"# <x> and <y> are decimal integers reflecting the position on the screen\\n\"\n\"# the event took place at.\\n\"\n\"#\\n\"\n\"# <mask> is the button mask indicating the button press state, as normal\\n\"\n\"# 0 means no buttons pressed, 1 means button 1 is down 3 (11) means buttons\\n\"\n\"# 1 and 2 are down, etc.\\n\"\n\"#\\n\"\n\"# <hint> is a string containing no spaces and may be ignored.\\n\"\n\"# It contains some interpretation about what has happened.\\n\"\n\"# It can be:\\n\"\n\"#\\n\"\n\"#\tNone\t\t(nothing to report)\\n\"\n\"#\tButtonPress-N\t(this event will cause button-N to be pressed) \\n\"\n\"#\tButtonRelease-N\t(this event will cause button-N to be released) \\n\"\n\"#\\n\"\n\"# if two more more buttons change state in one event they are listed\\n\"\n\"# separated by commas.\\n\"\n\"#\\n\"\n\"# One might parse a Pointer line with:\\n\"\n\"#\\n\"\n\"# int client, x, y, mask; char hint[100];\\n\"\n\"# sscanf(line, \\\"Pointer %d %d %d %d %s\\\", &client, &x, &y, &mask, hint);\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym events (keyboard presses and releases) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym <client#> <down> <keysym#> <keysym-name> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is as with Pointer.\\n\"\n\"#\\n\"\n\"# <down> is a decimal either 1 or 0 indicating KeyPress or KeyRelease,\\n\"\n\"# respectively.\\n\"\n\"#\\n\"\n\"# <keysym#> is a decimal integer incidating the Keysym of the event.\\n\"\n\"#\\n\"\n\"# <keysym-name> is the corresponding Keysym name.\\n\"\n\"#\\n\"\n\"# See the file /usr/include/X11/keysymdef.h for the mappings.\\n\"\n\"# You basically remove the leading 'XK_' prefix from the macro name in\\n\"\n\"# that file to get the Keysym name.\\n\"\n\"#\\n\"\n\"# One might parse a Keysym line with:\\n\"\n\"#\\n\"\n\"# int client, down, keysym; char name[100], hint[100];\\n\"\n\"# sscanf(line, \\\"Keysym %d %d %d %s %s\\\", &client, &down, &keysym, name, hint);\\n\"\n\"#\\n\"\n\"# The <hint> value is currently just None, KeyPress, or KeyRelease.\\n\"\n\"#\\n\"\n\"# In the future <hint> will provide a hint for the sequence of KeyCodes\\n\"\n\"# (i.e. keyboard scancodes) that x11vnc would inject to an X display to\\n\"\n\"# simulate the Keysym.\\n\"\n\"#\\n\"\n\"# You see, some Keysyms will require more than one injected Keycode to\\n\"\n\"# generate the symbol.  E.g. the Keysym \\\"ampersand\\\" going down usually\\n\"\n\"# requires a Shift key going down, then the key with the \\\"&\\\" on it going\\n\"\n\"# down, and, perhaps, the Shift key going up (that is how x11vnc does it).\\n\"\n\"#\\n\"\n\"# The Keysym => Keycode(s) stuff gets pretty messy.  Hopefully the Keysym\\n\"\n\"# info will be enough for most purposes (having identical keyboards on\\n\"\n\"# both sides helps).\\n\"\n\"#\\n\"\n\"# Parsing example for perl:\\n\"\n\"#\\n\"\n\"# while (<>) {\\n\"\n\"#     chomp;\\n\"\n\"#     if (/^Pointer/) {\\n\"\n\"#         my ($p, $client, $x, $y, $mask, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_pointer($client, $x, $y, $mask, $hint);\\n\"\n\"#     } elsif (/^Keysym/) {\\n\"\n\"#         my ($k, $client, $down, $keysym, $name, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_keysym($client, $down, $keysym, $name, $hint);\\n\"\n\"#     }\\n\"\n\"# }\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Here comes your stream.  The following token will always indicate the\\n\"\n\"# end of this informational text:\\n\"\n\"# END_OF_TOP\\n\"\n);\n\tfflush(pipeinput_fh);\n\tif (raw_fb_str) {\n\t\t/* the pipe program may actually create the fb */\n\t\tsleep(1);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void initialize_pipeinput(void);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void buttonparse(int from, char **s);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid initialize_pipeinput(void);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void buttonparse(int from, char **s);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid initialize_pipeinput(void) {\n\tchar *p = NULL;\n\n\tif (pipeinput_fh != NULL) {\n\t\trfbLog(\"closing pipeinput stream: %p\\n\", pipeinput_fh);\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tpipeinput_tee = 0;\n\tif (pipeinput_opts) {\n\t\tfree(pipeinput_opts);\n\t\tpipeinput_opts = NULL;\n\t}\n\n\tif (! pipeinput_str) {\n\t\treturn;\n\t}\n\n\t/* look for options:  tee, reopen, ... */\n\tif (strstr(pipeinput_str, \"UINPUT\") == pipeinput_str) {\n\t\t;\n\t} else {\n\t\tp = strchr(pipeinput_str, ':');\n\t}\n\tif (p != NULL) {\n\t\tchar *str, *opt, *q;\n\t\tint got = 0;\n\t\t*p = '\\0';\n\t\tstr = strdup(pipeinput_str);\n\t\topt = strdup(pipeinput_str);\n\t\t*p = ':';\n\t\tq = strtok(str, \",\");\n\t\twhile (q) {\n\t\t\tif (!strcmp(q, \"key\") || !strcmp(q, \"keycodes\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"reopen\")) {\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tif (!strcmp(q, \"tee\")) {\n\t\t\t\tpipeinput_tee = 1;\n\t\t\t\tgot = 1;\n\t\t\t}\n\t\t\tq = strtok(NULL, \",\");\n\t\t}\n\t\tif (got) {\n\t\t\tpipeinput_opts = opt;\n\t\t} else {\n\t\t\tfree(opt);\n\t\t}\n\t\tfree(str);\n\t\tp++;\n\t} else {\n\t\tp = pipeinput_str;\n\t}\nif (0) fprintf(stderr, \"initialize_pipeinput: %s -- %s\\n\", pipeinput_str, p);\n\n\tif (!strcmp(p, \"VID\")) {\n\t\tpipeinput_int = PIPEINPUT_VID;\n\t\treturn;\n\t} else if (strstr(p, \"CONSOLE\") == p) {\n\t\tint tty = 0, n;\n\t\tchar dev[32];\n\t\tif (sscanf(p, \"CONSOLE%d\", &n) == 1) {\n\t\t\ttty = n;\n\t\t}\n\t\tsprintf(dev, \"/dev/tty%d\", tty);\n\t\tpipeinput_cons_fd = open(dev, O_WRONLY);\n\t\tif (pipeinput_cons_fd >= 0) {\n\t\t\trfbLog(\"pipeinput: using linux console: %s\\n\", dev);\n\t\t\tif (pipeinput_cons_dev) {\n\t\t\t\tfree(pipeinput_cons_dev);\n\t\t\t}\n\t\t\tpipeinput_cons_dev = strdup(dev);\n\t\t\tpipeinput_int = PIPEINPUT_CONSOLE;\n\t\t} else {\n\t\t\trfbLog(\"pipeinput: could not open: %s\\n\", dev);\n\t\t\trfbLogPerror(\"open\");\n\t\t\trfbLog(\"You may need to be root to open %s.\\n\", dev);\n\t\t\trfbLog(\"\\n\");\n\t\t}\n\t\treturn;\n\t} else if (strstr(p, \"UINPUT\") == p) {\n\t\tchar *q = strchr(p, ':');\n\t\tif (q) {\n\t\t\tparse_uinput_str(q+1);\n\t\t}\n\t\tpipeinput_int = PIPEINPUT_UINPUT;\n\t\tinitialize_uinput();\n\t\treturn;\n\t} else if (strstr(p, \"MACOSX\") == p) {\n\t\tpipeinput_int = PIPEINPUT_MACOSX;\n\t\treturn;\n\t} else if (strstr(p, \"VNC\") == p) {\n\t\tpipeinput_int = PIPEINPUT_VNC;\n\t\treturn;\n\t}\n\n\tset_child_info();\n\t/* pipeinput */\n\tif (no_external_cmds || !cmd_ok(\"pipeinput\")) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", p);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"pipeinput: starting: \\\"%s\\\"...\\n\", p);\n\tclose_exec_fds();\n\tpipeinput_fh = popen(p, \"w\");\n\n\tif (! pipeinput_fh) {\n\t\trfbLog(\"popen(\\\"%s\\\", \\\"w\\\") failed.\\n\", p);\n\t\trfbLogPerror(\"popen\");\n\t\trfbLog(\"Disabling -pipeinput mode.\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(pipeinput_fh, \"%s\",\n\"# \\n\"\n\"# Format of the -pipeinput stream:\\n\"\n\"# --------------------------------\\n\"\n\"#\\n\"\n\"# Lines like these beginning with '#' are to be ignored.\\n\"\n\"#\\n\"\n\"# Pointer events (mouse motion and button clicks) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Pointer <client#> <x> <y> <mask> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is a decimal integer uniquely identifying the client\\n\"\n\"# that generated the event.  If it is negative that means this event\\n\"\n\"# would have been discarded since the client was viewonly.\\n\"\n\"#\\n\"\n\"# <x> and <y> are decimal integers reflecting the position on the screen\\n\"\n\"# the event took place at.\\n\"\n\"#\\n\"\n\"# <mask> is the button mask indicating the button press state, as normal\\n\"\n\"# 0 means no buttons pressed, 1 means button 1 is down 3 (11) means buttons\\n\"\n\"# 1 and 2 are down, etc.\\n\"\n\"#\\n\"\n\"# <hint> is a string containing no spaces and may be ignored.\\n\"\n\"# It contains some interpretation about what has happened.\\n\"\n\"# It can be:\\n\"\n\"#\\n\"\n\"#\tNone\t\t(nothing to report)\\n\"\n\"#\tButtonPress-N\t(this event will cause button-N to be pressed) \\n\"\n\"#\tButtonRelease-N\t(this event will cause button-N to be released) \\n\"\n\"#\\n\"\n\"# if two more more buttons change state in one event they are listed\\n\"\n\"# separated by commas.\\n\"\n\"#\\n\"\n\"# One might parse a Pointer line with:\\n\"\n\"#\\n\"\n\"# int client, x, y, mask; char hint[100];\\n\"\n\"# sscanf(line, \\\"Pointer %d %d %d %d %s\\\", &client, &x, &y, &mask, hint);\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym events (keyboard presses and releases) come in the form:\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Keysym <client#> <down> <keysym#> <keysym-name> <hint>\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# The <client#> is as with Pointer.\\n\"\n\"#\\n\"\n\"# <down> is a decimal either 1 or 0 indicating KeyPress or KeyRelease,\\n\"\n\"# respectively.\\n\"\n\"#\\n\"\n\"# <keysym#> is a decimal integer incidating the Keysym of the event.\\n\"\n\"#\\n\"\n\"# <keysym-name> is the corresponding Keysym name.\\n\"\n\"#\\n\"\n\"# See the file /usr/include/X11/keysymdef.h for the mappings.\\n\"\n\"# You basically remove the leading 'XK_' prefix from the macro name in\\n\"\n\"# that file to get the Keysym name.\\n\"\n\"#\\n\"\n\"# One might parse a Keysym line with:\\n\"\n\"#\\n\"\n\"# int client, down, keysym; char name[100], hint[100];\\n\"\n\"# sscanf(line, \\\"Keysym %d %d %d %s %s\\\", &client, &down, &keysym, name, hint);\\n\"\n\"#\\n\"\n\"# The <hint> value is currently just None, KeyPress, or KeyRelease.\\n\"\n\"#\\n\"\n\"# In the future <hint> will provide a hint for the sequence of KeyCodes\\n\"\n\"# (i.e. keyboard scancodes) that x11vnc would inject to an X display to\\n\"\n\"# simulate the Keysym.\\n\"\n\"#\\n\"\n\"# You see, some Keysyms will require more than one injected Keycode to\\n\"\n\"# generate the symbol.  E.g. the Keysym \\\"ampersand\\\" going down usually\\n\"\n\"# requires a Shift key going down, then the key with the \\\"&\\\" on it going\\n\"\n\"# down, and, perhaps, the Shift key going up (that is how x11vnc does it).\\n\"\n\"#\\n\"\n\"# The Keysym => Keycode(s) stuff gets pretty messy.  Hopefully the Keysym\\n\"\n\"# info will be enough for most purposes (having identical keyboards on\\n\"\n\"# both sides helps).\\n\"\n\"#\\n\"\n\"# Parsing example for perl:\\n\"\n\"#\\n\"\n\"# while (<>) {\\n\"\n\"#     chomp;\\n\"\n\"#     if (/^Pointer/) {\\n\"\n\"#         my ($p, $client, $x, $y, $mask, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_pointer($client, $x, $y, $mask, $hint);\\n\"\n\"#     } elsif (/^Keysym/) {\\n\"\n\"#         my ($k, $client, $down, $keysym, $name, $hint) = split(' ', $_, 6);\\n\"\n\"#         do_keysym($client, $down, $keysym, $name, $hint);\\n\"\n\"#     }\\n\"\n\"# }\\n\"\n\"#\\n\"\n\"#\\n\"\n\"# Here comes your stream.  The following token will always indicate the\\n\"\n\"# end of this informational text:\\n\"\n\"# END_OF_TOP\\n\"\n);\n\tfflush(pipeinput_fh);\n\tif (raw_fb_str) {\n\t\t/* the pipe program may actually create the fb */\n\t\tsleep(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"MACOSX\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"console_guess: file is %s\\n\"",
            "file"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/dev/null\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "in",
            "':'"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "in",
            "'@'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"console_guess: unrecognized console/fb format: %s\\n\"",
            "str"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "in",
            "\"console\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_init",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_init_key_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "897-917",
          "snippet": "void macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define keyTableSize 0xFFFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define keyTableSize 0xFFFF\n\nvoid macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nchar *macosx_console_guess(char *str, int *fd);\nvoid macosx_add_mapnotify(Window win, int level, int map);\n\nchar *macosx_console_guess(char *str, int *fd) {\n\tchar *q, *in = strdup(str);\n\tchar *atparms = NULL, *file = NULL;\n\n\tmacosxCG_init();\n\n\tif (strstr(in, \"console\") != in) {\n\t\trfbLog(\"console_guess: unrecognized console/fb format: %s\\n\", str);\n\t\tfree(in);\n\t\treturn NULL;\n\t}\n\n\t*fd = -1;\n\n\tq = strrchr(in, '@');\n\tif (q) {\n\t\tatparms = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tq = strrchr(in, ':');\n\tif (q) {\n\t\tfile = strdup(q+1);\n\t\t*q = '\\0';\n\t}\n\tif (! file || file[0] == '\\0')  {\n\t\tfile = strdup(\"/dev/null\");\n\t}\n\trfbLog(\"console_guess: file is %s\\n\", file);\n\n\tif (! pipeinput_str) {\n\t\tpipeinput_str = strdup(\"MACOSX\");\n\t\tinitialize_pipeinput();\n\t}\n\n\tif (! atparms) {\n\t\tint w, h, b, bps, dep;\n\t\tunsigned long rm = 0, gm = 0, bm = 0;\n\n\t\tif (macosx_read_opengl) {\n\t\t\tw = macosx_opengl_get_width();\n\t\t\th = macosx_opengl_get_height();\n\t\t\tb = macosx_opengl_get_bpp();\n\n\t\t\tbps = macosx_opengl_get_bps();\n\t\t\tdep = macosx_opengl_get_spp() * bps;\n\t\t\t\n\t\t} else {\n\t\t\tw = macosxCG_CGDisplayPixelsWide();\n\t\t\th = macosxCG_CGDisplayPixelsHigh();\n\t\t\tb = macosxCG_CGDisplayBitsPerPixel();\n\n\t\t\tbps = macosxCG_CGDisplayBitsPerSample();\n\t\t\tdep = macosxCG_CGDisplaySamplesPerPixel() * bps;\n\t\t}\n\n\t\trm = (1 << bps) - 1;\n\t\tgm = (1 << bps) - 1;\n\t\tbm = (1 << bps) - 1;\n\t\trm = rm << 2 * bps;\n\t\tgm = gm << 1 * bps;\n\t\tbm = bm << 0 * bps;\n\n\t\tif (b == 8 && rm == 0xff && gm == 0xff && bm == 0xff) {\n\t\t\t/* I don't believe it... */\n\t\t\trm = 0x07;\n\t\t\tgm = 0x38;\n\t\t\tbm = 0xc0;\n\t\t}\n\t\t\n\t\t/* @66666x66666x32:0xffffffff:... */\n\t\tatparms = (char *) malloc(200);\n\t\tsprintf(atparms, \"%dx%dx%d:%lx/%lx/%lx\", w, h, b, rm, gm, bm);\n\t}\n\tif (atparms) {\n\t\tint gw, gh, gb;\n\t\tif (sscanf(atparms, \"%dx%dx%d\", &gw, &gh, &gb) == 3)  {\n\t\t\tfb_x = gw;\t\n\t\t\tfb_y = gh;\t\n\t\t\tfb_b = gb;\t\n\t\t}\n\t}\n\tif (! atparms) {\n\t\trfbLog(\"console_guess: could not get @ parameters.\\n\");\n\t\treturn NULL;\n\t}\n\n\tq = (char *) malloc(strlen(\"map:macosx:\") + strlen(file) + 1 + strlen(atparms) + 1);\n\tsprintf(q, \"map:macosx:%s@%s\", file, atparms);\n\tfree(atparms);\n\treturn q;\n}"
  },
  {
    "function_name": "macosx_get_fb_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "158-161",
    "snippet": "char *macosx_get_fb_addr(void) {\n\tmacosxCG_init();\n\treturn macosxCG_get_fb_addr();\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *macosx_get_fb_addr(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCG_get_fb_addr",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_get_fb_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "339-353",
          "snippet": "char *macosxCG_get_fb_addr(void) {\n\tif (x11vnc_macosx_no_deprecated_framebuffer) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by env. var\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_no_rawfb) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by user.\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_read_opengl) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by OpenGL.\\n\");\n\t\treturn NULL;\n\t}\n\treturn (char *) CGDisplayBaseAddress(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nchar *macosxCG_get_fb_addr(void) {\n\tif (x11vnc_macosx_no_deprecated_framebuffer) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by env. var\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_no_rawfb) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by user.\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_read_opengl) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by OpenGL.\\n\");\n\t\treturn NULL;\n\t}\n\treturn (char *) CGDisplayBaseAddress(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_init",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_init_key_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "897-917",
          "snippet": "void macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define keyTableSize 0xFFFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define keyTableSize 0xFFFF\n\nvoid macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nchar *macosx_get_fb_addr(void);\n\nchar *macosx_get_fb_addr(void) {\n\tmacosxCG_init();\n\treturn macosxCG_get_fb_addr();\n}"
  },
  {
    "function_name": "macosx_event_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "154-156",
    "snippet": "void macosx_event_loop(void) {\n\tmacosxCG_event_loop();\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCG_event_loop",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_event_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "242-303",
          "snippet": "void macosxCG_event_loop(void) {\n\tOSStatus rc;\n\tint nbpp;\n\tstatic int nbpp_save = -1;\n\n\tmacosxGCS_poll_pb();\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\trc = RunCurrentEventLoop(kEventDurationSecond/30);\n\n\tif (client_count) {\n\t\tmacosxCG_refresh_callback_on();\n\t} else {\n\t\tmacosxCG_refresh_callback_off();\n\t}\n\n\tnbpp = macosxCG_CGDisplayBitsPerPixel();\n\n\tif (nbpp_save < 0) {\n\t\tnbpp_save = nbpp;\n\t}\n\t\t\n\tif (nbpp > 0 && nbpp != nbpp_save) {\n\t\tnbpp_save = nbpp;\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t} else if (wdpy_x != macosxCG_CGDisplayPixelsWide()) {\n\t    if (wdpy_y != macosxCG_CGDisplayPixelsHigh()) {\n\t\tif (macosx_wait_for_switch) {\n\t\t\tint cnt = 0;\n\t\t\twhile (1) {\n\t\t\t\tif(macosxCG_CGDisplayPixelsWide() > 0) {\n\t\t\t\t\tif(macosxCG_CGDisplayPixelsHigh() > 0) {\n\t\t\t\t\t\tusleep(500*1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((cnt++ % 120) == 0) {\n\t\t\t\t\tmacosx_log(\"waiting for user to \"\n\t\t\t\t\t    \"switch back..\\n\");\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\tif (wdpy_x == macosxCG_CGDisplayPixelsWide()) {\n\t\t\t\tif (wdpy_y == macosxCG_CGDisplayPixelsHigh()) {\n\t\t\t\t\tmacosx_log(\"we're back...\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t    }\n\t}\n\tif (nbpp > 0) {\n\t\tnbpp_save = nbpp;\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_event_loop(void) {\n\tOSStatus rc;\n\tint nbpp;\n\tstatic int nbpp_save = -1;\n\n\tmacosxGCS_poll_pb();\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\trc = RunCurrentEventLoop(kEventDurationSecond/30);\n\n\tif (client_count) {\n\t\tmacosxCG_refresh_callback_on();\n\t} else {\n\t\tmacosxCG_refresh_callback_off();\n\t}\n\n\tnbpp = macosxCG_CGDisplayBitsPerPixel();\n\n\tif (nbpp_save < 0) {\n\t\tnbpp_save = nbpp;\n\t}\n\t\t\n\tif (nbpp > 0 && nbpp != nbpp_save) {\n\t\tnbpp_save = nbpp;\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t} else if (wdpy_x != macosxCG_CGDisplayPixelsWide()) {\n\t    if (wdpy_y != macosxCG_CGDisplayPixelsHigh()) {\n\t\tif (macosx_wait_for_switch) {\n\t\t\tint cnt = 0;\n\t\t\twhile (1) {\n\t\t\t\tif(macosxCG_CGDisplayPixelsWide() > 0) {\n\t\t\t\t\tif(macosxCG_CGDisplayPixelsHigh() > 0) {\n\t\t\t\t\t\tusleep(500*1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((cnt++ % 120) == 0) {\n\t\t\t\t\tmacosx_log(\"waiting for user to \"\n\t\t\t\t\t    \"switch back..\\n\");\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\tif (wdpy_x == macosxCG_CGDisplayPixelsWide()) {\n\t\t\t\tif (wdpy_y == macosxCG_CGDisplayPixelsHigh()) {\n\t\t\t\t\tmacosx_log(\"we're back...\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t    }\n\t}\n\tif (nbpp > 0) {\n\t\tnbpp_save = nbpp;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_event_loop(void) {\n\tmacosxCG_event_loop();\n}"
  },
  {
    "function_name": "macosx_checkevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "146-149",
    "snippet": "int macosx_checkevent(XEvent *ev) {\n\tif (!ev) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_checkevent(XEvent *ev);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_checkevent(XEvent *ev);\n\nint macosx_checkevent(XEvent *ev) {\n\tif (!ev) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "macosx_add_visnotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "141-144",
    "snippet": "void macosx_add_visnotify(Window win, int level, int obscured) {\n\tif (!win || !level || !obscured) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);",
      "void macosx_add_visnotify(Window win, int level, int obscured);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\nvoid macosx_add_visnotify(Window win, int level, int obscured);\n\nvoid macosx_add_visnotify(Window win, int level, int obscured) {\n\tif (!win || !level || !obscured) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_add_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "137-140",
    "snippet": "void macosx_add_destroy(Window win, int level) {\n\tif (!win || !level) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_destroy(Window win, int level) {\n\tif (!win || !level) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_add_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "133-136",
    "snippet": "void macosx_add_create(Window win, int level) {\n\tif (!win || !level) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_create(Window win, int level) {\n\tif (!win || !level) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_add_mapnotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "129-132",
    "snippet": "void macosx_add_mapnotify(Window win, int level, int map) {\n\tif (!win || !level || !map) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
      "void macosx_add_mapnotify(Window win, int level, int map);",
      "void macosx_add_create(Window win, int level);",
      "void macosx_add_destroy(Window win, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_mapnotify(Window win, int level, int map) {\n\tif (!win || !level || !map) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_xquerytree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "124-128",
    "snippet": "Status macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return) {\n\tif (!w || !root_return || !parent_return || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Status macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nStatus macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return);\n\nStatus macosx_xquerytree(Window w, Window *root_return, Window *parent_return,\n    Window **children_return, unsigned int *nchildren_return) {\n\tif (!w || !root_return || !parent_return || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n}"
  },
  {
    "function_name": "macosx_valid_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "120-123",
    "snippet": "int macosx_valid_window(Window w, XWindowAttributes* a) {\n\tif (!w || !a) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_valid_window(Window, XWindowAttributes*);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_valid_window(Window, XWindowAttributes*);\n\nint macosx_valid_window(Window w, XWindowAttributes* a) {\n\tif (!w || !a) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "macosx_set_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "116-119",
    "snippet": "void macosx_set_sel(char * str, int len) {\n\tif (!str || !len) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_set_sel(char *, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_set_sel(char *, int);\n\nvoid macosx_set_sel(char * str, int len) {\n\tif (!str || !len) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_send_sel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "112-115",
    "snippet": "void macosx_send_sel(char * str, int len) {\n\tif (!str || !len) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_send_sel(char *, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_send_sel(char *, int);\n\nvoid macosx_send_sel(char * str, int len) {\n\tif (!str || !len) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_get_cursor_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "108-111",
    "snippet": "int macosx_get_cursor_pos(int *x, int *y) {\n\tif (!x || !y) {}\n\treturn 0;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_cursor_pos(int *, int *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor_pos(int *, int *);\n\nint macosx_get_cursor_pos(int *x, int *y) {\n\tif (!x || !y) {}\n\treturn 0;\n}"
  },
  {
    "function_name": "macosx_get_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "105-107",
    "snippet": "int macosx_get_cursor(void) {\n\treturn 0;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int macosx_get_cursor(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor(void);\n\nint macosx_get_cursor(void) {\n\treturn 0;\n}"
  },
  {
    "function_name": "macosx_get_fb_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "102-104",
    "snippet": "char *macosx_get_fb_addr(void) {\n\treturn NULL;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *macosx_get_fb_addr(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nchar *macosx_get_fb_addr(void);\n\nchar *macosx_get_fb_addr(void) {\n\treturn NULL;\n}"
  },
  {
    "function_name": "macosx_pointer_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "98-101",
    "snippet": "void macosx_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\tif (!mask || !x || !y || !client) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
      "void macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nvoid macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);\n\nvoid macosx_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\tif (!mask || !x || !y || !client) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_key_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "94-97",
    "snippet": "void macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tif (!down || !keysym || !client) {}\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
      "void macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nvoid macosx_pointer_command(int mask, int x, int y, rfbClientPtr client);\n\nvoid macosx_key_command(rfbBool down, rfbKeySym keysym, rfbClientPtr client) {\n\tif (!down || !keysym || !client) {}\n\treturn;\n}"
  },
  {
    "function_name": "macosx_console_guess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "90-93",
    "snippet": "char *macosx_console_guess(char *str, int *fd) {\n\tif (!str || !fd) {}\n\treturn NULL;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *macosx_console_guess(char *str, int *fd);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nchar *macosx_console_guess(char *str, int *fd);\n\nchar *macosx_console_guess(char *str, int *fd) {\n\tif (!str || !fd) {}\n\treturn NULL;\n}"
  },
  {
    "function_name": "macosx_event_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "87-89",
    "snippet": "void macosx_event_loop(void) {\n\treturn;\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_event_loop(void) {\n\treturn;\n}"
  },
  {
    "function_name": "macosx_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
    "lines": "81-83",
    "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
    "includes": [
      "#include \"macosxCGS.h\"",
      "#include \"macosxCGP.h\"",
      "#include \"macosxCG.h\"",
      "#include \"connections.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"allowed_input_t.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void macosx_log(char *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "str"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
  }
]