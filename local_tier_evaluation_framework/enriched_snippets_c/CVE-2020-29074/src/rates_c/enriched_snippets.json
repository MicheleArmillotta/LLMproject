[
  {
    "function_name": "measure_send_rates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "337-729",
    "snippet": "void measure_send_rates(int init) {\n\tdouble cmp_rate, raw_rate;\n\tstatic double now, start = 0.0;\n\tstatic rfbDisplayHookPtr orig_display_hook = NULL;\n\tdouble cmp_max = 1.0e+08;\t/* 100 MB/sec */\n\tdouble cmp_min = 1000.0;\t/* 9600baud */\n\tdouble lat_max = 5.0;\t\t/* 5 sec */\n\tdouble lat_min = .0005;\t\t/* 0.5 ms */\n\tint min_cmp = 10000, nclients;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl0, cl;\n\tint msg = 0, clcnt0 = 0, cc;\n\tint db = 0, ouch_db = 0, ouch = 0;\n\n\tif (! measure_speeds) {\n\t\treturn;\n\t}\n\tif (speeds_net_rate && speeds_net_latency) {\n\t\treturn;\n\t}\n\tif (!client_count) {\n\t\treturn;\n\t}\n\n\tif (! orig_display_hook) {\n\t\torig_display_hook = screen->displayHook;\n\t}\n\n\tif (start == 0.0) {\n\t\tdtime(&start);\n\t}\n\n\tdtime0(&now);\n\tif (now < last_client_gone+4.0) {\n\t\treturn;\n\t}\n\tnow = now - start;\n\n\tnclients = 0;\n\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tcl0 = NULL;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate > 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->onHold) {\n\t\t\tcontinue;\n\t\t}\n\t\tnclients++;\n\t\tif (cl0 == NULL)  {\n\t\t\tcl0 = cl;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl = cl0;\n\tcc = 0;\n\n\twhile (cl != NULL && cc++ == 0) {\n\t\tint defer, i, cbs, rbs;\n\t\tchar *httpdir;\n\t\tdouble dt, dt1 = 0.0, dt2, dt3;\n\t\tdouble tm, spin_max = 15.0, spin_lat_max = 1.5;\n\t\tint got_t2 = 0, got_t3 = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n#if 0\n\t\tfor (i=0; i<MAX_ENCODINGS; i++) {\n\t\t\tcbs += cl->bytesSent[i];\n\t\t}\n\t\trbs = cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tcbs = rfbStatGetSentBytes(cl);\n\t\trbs = rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\n\t\tif (init) {\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\t\tcd->timer = dnow();\n\t\t\tcd->cmp_bytes_sent = cbs;\n\t\t\tcd->raw_bytes_sent = rbs;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first part of the bulk transfer of initial screen */\n\t\tdt1 = dtime(&cd->timer);\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\tif (dt1 <= 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcbs = cbs - cd->cmp_bytes_sent;\n\t\trbs = rbs - cd->raw_bytes_sent;\n\n\t\tif (cbs < min_cmp) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ouch_db) fprintf(stderr, \"START-OUCH: %d\\n\", client_count);\n\t\tclcnt0 = client_count;\n#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )\n\n\t\trfbPE(1000);\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-A\\n\");\n\t\tif (OUCH) continue;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (sraRgnCountRects(cl->modifiedRegion)) {\n\t\t\trfbPE(1000);\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-B\\n\");\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\tif (OUCH) continue;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\tdefer = screen->deferUpdateTime;\n\t\thttpdir = screen->httpDir;\n\t\tscreen->deferUpdateTime = 0;\n\t\tscreen->httpDir = NULL;\n\n\t\t/* mark a small rectangle: */\n\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\n\t\tdtime0(&tm);\n\n\t\tdt2 = 0.0;\n\t\tdt3 = 0.0;\n\n\t\tif (dt1 < 0.25) {\n\t\t\t/* try to cut it down to avoid long pauses. */\n\t\t\tspin_max = 5.0;\n\t\t}\n\n\t\t/* when req1 = 1 mod1 == 0, end of 2nd part of bulk transfer */\n\t\twhile (1) {\n\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C1\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(1000);\n\t\t\t} else {\n\t\t\t\tif (mod0) {\n\t\t\t\t\trfbPE(1000);\n\t\t\t\t} else {\n\t\t\t\t\trfbCFD(1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tdt2 += dt;\n\t\t\tif (dt2 > spin_max) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C2\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt2 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt2, tm);\n\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\tgot_t2 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-D\\n\");\n\t\tif (OUCH) goto ouch;\n\n\t\tif (! got_t2) {\n\t\t\tdt2 = 0.0;\n\t\t} else {\n\t\t\tint tr, trm = 3;\n\t\t\tdouble dts[10];\n\t\t\t\n\t\t\t/*\n\t\t\t * Note: since often select(2) cannot sleep\n\t\t\t * less than 1/HZ (e.g. 10ms), the resolution\n\t\t\t * of the latency may be messed up by something\n\t\t\t * of this order.  Effect may occur on both ends,\n\t\t\t * i.e. the viewer may not respond immediately.\n\t\t\t */\n\t\t\n\t\t\tfor (tr = 0; tr < trm; tr++) {\n\t\t\t\tusleep(5000);\n\n\t\t\t\t/* mark a 2nd small rectangle: */\n\t\t\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\t\t\t\ti = 0;\n\t\t\t\tdtime0(&tm);\n\t\t\t\tdt3 = 0.0;\n\n\t\t\t\t/*\n\t\t\t\t * when req1 > 0 and mod1 == 0, we say\n\t\t\t\t * that is the \"ping\" time.\n\t\t\t\t */\n\t\t\t\twhile (1) {\n\t\t\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (use_threads) {\n\t\t\t\t\t\t\tusleep(1000);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* try to get it all */\n\t\t\t\t\t\t\trfbCFD(1000*1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-E\\n\");\n\t\t\t\t\tif (OUCH) goto ouch;\n\t\t\t\t\tdt = dtime(&tm);\n\t\t\t\t\ti++;\n\n\t\t\t\t\tdt3 += dt;\n\t\t\t\t\tif (dt3 > spin_lat_max) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt3 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt3, tm);\n\n\t\t\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\t\t\tdts[got_t3++] = dt3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (! got_t3) {\n\t\t\t\tdt3 = 0.0;\n\t\t\t} else {\n\t\t\t\tif (got_t3 == 1) {\n\t\t\t\t\tdt3 = dts[0];\n\t\t\t\t} else if (got_t3 == 2) {\n\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t} else {\n\t\t\t\t\tif (dts[2] > 0.0) {\n\t\t\t\t\t\tdouble rat = dts[1]/dts[2];\n\t\t\t\t\t\tif (rat > 0.5 && rat < 2.0) {\n\t\t\t\t\t\t\tdt3 = dts[1]+dts[2];\n\t\t\t\t\t\t\tdt3 *= 0.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\touch:\n\t\t\n\t\tscreen->deferUpdateTime = defer;\n\t\tscreen->httpDir = httpdir;\n\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-F\\n\");\n\t\tif (OUCH) break;\n\n\t\tdt = dt1 + dt2;\n\n\n\t\tif (dt3 <= dt2/2.0) {\n\t\t\t/* guess only 1/2 a ping for reply... */\n\t\t\tdt = dt - dt3/2.0;\n\t\t}\n\n\t\tcmp_rate = cbs/dt;\n\t\traw_rate = rbs/dt;\n\n\t\tif (cmp_rate > cmp_max) {\n\t\t\tcmp_rate = cmp_max;\n\t\t}\n\t\tif (cmp_rate <= cmp_min) {\n\t\t\tcmp_rate = cmp_min;\n\t\t}\n\n\t\tcd->send_cmp_rate = cmp_rate;\n\t\tcd->send_raw_rate = raw_rate;\n\n\t\tif (dt3 > lat_max) {\n\t\t\tdt3 = lat_max;\n\t\t}\n\t\tif (dt3 <= lat_min) {\n\t\t\tdt3 = lat_min;\n\t\t}\n\n\t\tcd->latency = dt3;\n\t\t\n\t\trfbLog(\"client %d network rate %.1f KB/sec (%.1f eff KB/sec)\\n\",\n\t\t    cd->uid, cmp_rate/1000.0, raw_rate/1000.0);\n\t\trfbLog(\"client %d latency:  %.1f ms\\n\", cd->uid, 1000.0*dt3);\n\t\trfbLog(\"dt1: %.4f, dt2: %.4f dt3: %.4f bytes: %d\\n\",\n\t\t    dt1, dt2, dt3, cbs);\n\t\tmsg = 1;\n\t}\n\n\tif (msg) {\n\t\tint link, latency, netrate;\n\t\tchar *str = \"error\";\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_UNSET) {\n\t\t\tstr = \"LR_UNSET\";\n\t\t} else if (link == LR_UNKNOWN) {\n\t\t\tstr = \"LR_UNKNOWN\";\n\t\t} else if (link == LR_DIALUP) {\n\t\t\tstr = \"LR_DIALUP\";\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tstr = \"LR_BROADBAND\";\n\t\t} else if (link == LR_LAN) {\n\t\t\tstr = \"LR_LAN\";\n\t\t}\n\t\trfbLog(\"link_rate: %s - %d ms, %d KB/s\\n\", str, latency,\n\t\t    netrate);\n\t}\n\n\tif (init) {\n\t\tif (nclients) {\n\t\t\tscreen->displayHook = measure_display_hook;\n\t\t}\n\t} else {\n\t\tscreen->displayHook = orig_display_hook;\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )"
    ],
    "globals_used": [
      "int measure_speeds = 1;",
      "int speeds_net_rate = 0;",
      "int speeds_net_latency = 0;",
      "int link_rate(int *latency, int *netrate);",
      "void measure_send_rates(int init);",
      "static void measure_display_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"link_rate: %s - %d ms, %d KB/s\\n\"",
            "str",
            "latency",
            "netrate"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_rate",
          "args": [
            "&latency",
            "&netrate"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "link_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "282-307",
          "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int link_rate(int *latency, int *netrate);",
            "int get_net_rate(void);",
            "int get_net_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"dt1: %.4f, dt2: %.4f dt3: %.4f bytes: %d\\n\"",
            "dt1",
            "dt2",
            "dt3",
            "cbs"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"client %d latency:  %.1f ms\\n\"",
            "cd->uid",
            "1000.0*dt3"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"client %d network rate %.1f KB/sec (%.1f eff KB/sec)\\n\"",
            "cd->uid",
            "cmp_rate/1000.0",
            "raw_rate/1000.0"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***OUCH-F\\n\""
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dt3 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt3: %.4f  tm: %.4f\\n\"",
            "req0",
            "req1",
            "mod0",
            "mod1",
            "rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate)",
            "#else\"dt: %.4f dt3: %.4f  tm: %.4f\\n\"",
            "req0",
            "req1",
            "mod0",
            "mod1",
            "#endifdt",
            "dt3",
            "tm"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbStatGetMessageCountSent",
          "args": [
            "cl",
            "rfbFramebufferUpdate"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***OUCH-E\\n\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCFD",
          "args": [
            "1000*1000"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "rfbCFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "621-671",
          "snippet": "void rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nvoid rfbCFD(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tif (! screen) {\n\t\treturn;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\tstatic int msgs = 0;\n\t\tstatic double last_reset = 0.0;\n\t\tif (dnow() > last_reset + 5.0) {\n\t\t\tmsgs = 0;\n\t\t\tlast_reset = dnow();\n\t\t}\n\t\tif (msgs++ < 10) {\n\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD\\n\");\n\t\t\tif (msgs == 10) {\n\t\t\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbCFD ...\\n\");\n\t\t\t}\n\t\t}\n \t\treturn;\n \t}\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbCFD(%d) t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\n\tif (! use_threads) {\n\t\tif (all_input) {\n\t\t\tdo_allinput(usec);\n\t\t} else {\n\t\t\tif (handle_events_eagerly) {\n\t\t\t\tscreen->handleEventsEagerly = TRUE;\n\t\t\t} else {\n\t\t\t\tscreen->handleEventsEagerly = FALSE;\n\t\t\t}\n\t\t\trfbCheckFds(screen, usec);\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbCFD: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "0"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "16",
            "16",
            "1"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "5000"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***OUCH-D\\n\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dt2 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt2: %.4f  tm: %.4f\\n\"",
            "req0",
            "req1",
            "mod0",
            "mod1",
            "rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate)",
            "#else\"dt: %.4f dt2: %.4f  tm: %.4f\\n\"",
            "req0",
            "req1",
            "mod0",
            "mod1",
            "#endifdt",
            "dt2",
            "tm"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbStatGetMessageCountSent",
          "args": [
            "cl",
            "rfbFramebufferUpdate"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***OUCH-C2\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***OUCH-C1\\n\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***OUCH-B\\n\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"***OUCH-A\\n\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"START-OUCH: %d\\n\"",
            "client_count"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\"",
            "init",
            "(int) sraRgnCountRects(cl->requestedRegion)",
            "(int) sraRgnCountRects(cl->modifiedRegion)",
            "cbs",
            "rbs",
            "dt1",
            "now"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\"",
            "init",
            "(int) sraRgnCountRects(cl->requestedRegion)",
            "(int) sraRgnCountRects(cl->modifiedRegion)",
            "cbs",
            "rbs",
            "dt1",
            "now"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->modifiedRegion"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCountRects",
          "args": [
            "cl->requestedRegion"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbStatGetSentBytesIfRaw",
          "args": [
            "cl"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbStatGetSentBytes",
          "args": [
            "cl"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )\n\nint measure_speeds = 1;\nint speeds_net_rate = 0;\nint speeds_net_latency = 0;\nint link_rate(int *latency, int *netrate);\nvoid measure_send_rates(int init);\nstatic void measure_display_hook(rfbClientPtr cl);\n\nvoid measure_send_rates(int init) {\n\tdouble cmp_rate, raw_rate;\n\tstatic double now, start = 0.0;\n\tstatic rfbDisplayHookPtr orig_display_hook = NULL;\n\tdouble cmp_max = 1.0e+08;\t/* 100 MB/sec */\n\tdouble cmp_min = 1000.0;\t/* 9600baud */\n\tdouble lat_max = 5.0;\t\t/* 5 sec */\n\tdouble lat_min = .0005;\t\t/* 0.5 ms */\n\tint min_cmp = 10000, nclients;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl0, cl;\n\tint msg = 0, clcnt0 = 0, cc;\n\tint db = 0, ouch_db = 0, ouch = 0;\n\n\tif (! measure_speeds) {\n\t\treturn;\n\t}\n\tif (speeds_net_rate && speeds_net_latency) {\n\t\treturn;\n\t}\n\tif (!client_count) {\n\t\treturn;\n\t}\n\n\tif (! orig_display_hook) {\n\t\torig_display_hook = screen->displayHook;\n\t}\n\n\tif (start == 0.0) {\n\t\tdtime(&start);\n\t}\n\n\tdtime0(&now);\n\tif (now < last_client_gone+4.0) {\n\t\treturn;\n\t}\n\tnow = now - start;\n\n\tnclients = 0;\n\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tcl0 = NULL;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate > 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->onHold) {\n\t\t\tcontinue;\n\t\t}\n\t\tnclients++;\n\t\tif (cl0 == NULL)  {\n\t\t\tcl0 = cl;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl = cl0;\n\tcc = 0;\n\n\twhile (cl != NULL && cc++ == 0) {\n\t\tint defer, i, cbs, rbs;\n\t\tchar *httpdir;\n\t\tdouble dt, dt1 = 0.0, dt2, dt3;\n\t\tdouble tm, spin_max = 15.0, spin_lat_max = 1.5;\n\t\tint got_t2 = 0, got_t3 = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n#if 0\n\t\tfor (i=0; i<MAX_ENCODINGS; i++) {\n\t\t\tcbs += cl->bytesSent[i];\n\t\t}\n\t\trbs = cl->rawBytesEquivalent;\n#else\n#if LIBVNCSERVER_HAS_STATS\n\t\tcbs = rfbStatGetSentBytes(cl);\n\t\trbs = rfbStatGetSentBytesIfRaw(cl);\n#endif\n#endif\n\n\t\tif (init) {\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\t\tcd->timer = dnow();\n\t\t\tcd->cmp_bytes_sent = cbs;\n\t\t\tcd->raw_bytes_sent = rbs;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first part of the bulk transfer of initial screen */\n\t\tdt1 = dtime(&cd->timer);\n\nif (db) fprintf(stderr, \"%d client num rects req: %d  mod: %d  cbs: %d  \"\n    \"rbs: %d  dt1: %.3f  t: %.3f\\n\", init,\n    (int) sraRgnCountRects(cl->requestedRegion),\n    (int) sraRgnCountRects(cl->modifiedRegion), cbs, rbs, dt1, now);\n\n\t\tif (dt1 <= 0.0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcbs = cbs - cd->cmp_bytes_sent;\n\t\trbs = rbs - cd->raw_bytes_sent;\n\n\t\tif (cbs < min_cmp) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ouch_db) fprintf(stderr, \"START-OUCH: %d\\n\", client_count);\n\t\tclcnt0 = client_count;\n#define OUCH ( ouch || (ouch = (!client_count || client_count != clcnt0 || dnow() < last_client_gone+4.0)) )\n\n\t\trfbPE(1000);\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-A\\n\");\n\t\tif (OUCH) continue;\n\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\tif (sraRgnCountRects(cl->modifiedRegion)) {\n\t\t\trfbPE(1000);\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-B\\n\");\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\tif (OUCH) continue;\n\t\t}\n\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\tdefer = screen->deferUpdateTime;\n\t\thttpdir = screen->httpDir;\n\t\tscreen->deferUpdateTime = 0;\n\t\tscreen->httpDir = NULL;\n\n\t\t/* mark a small rectangle: */\n\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\n\t\tdtime0(&tm);\n\n\t\tdt2 = 0.0;\n\t\tdt3 = 0.0;\n\n\t\tif (dt1 < 0.25) {\n\t\t\t/* try to cut it down to avoid long pauses. */\n\t\t\tspin_max = 5.0;\n\t\t}\n\n\t\t/* when req1 = 1 mod1 == 0, end of 2nd part of bulk transfer */\n\t\twhile (1) {\n\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C1\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\tif (use_threads) {\n\t\t\t\tusleep(1000);\n\t\t\t} else {\n\t\t\t\tif (mod0) {\n\t\t\t\t\trfbPE(1000);\n\t\t\t\t} else {\n\t\t\t\t\trfbCFD(1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tdt2 += dt;\n\t\t\tif (dt2 > spin_max) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-C2\\n\");\n\t\t\tif (OUCH) break;\n\n\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt2 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt2: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt2, tm);\n\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\tgot_t2 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-D\\n\");\n\t\tif (OUCH) goto ouch;\n\n\t\tif (! got_t2) {\n\t\t\tdt2 = 0.0;\n\t\t} else {\n\t\t\tint tr, trm = 3;\n\t\t\tdouble dts[10];\n\t\t\t\n\t\t\t/*\n\t\t\t * Note: since often select(2) cannot sleep\n\t\t\t * less than 1/HZ (e.g. 10ms), the resolution\n\t\t\t * of the latency may be messed up by something\n\t\t\t * of this order.  Effect may occur on both ends,\n\t\t\t * i.e. the viewer may not respond immediately.\n\t\t\t */\n\t\t\n\t\t\tfor (tr = 0; tr < trm; tr++) {\n\t\t\t\tusleep(5000);\n\n\t\t\t\t/* mark a 2nd small rectangle: */\n\t\t\t\tmark_rect_as_modified(0, 0, 16, 16, 1);\n\t\t\t\ti = 0;\n\t\t\t\tdtime0(&tm);\n\t\t\t\tdt3 = 0.0;\n\n\t\t\t\t/*\n\t\t\t\t * when req1 > 0 and mod1 == 0, we say\n\t\t\t\t * that is the \"ping\" time.\n\t\t\t\t */\n\t\t\t\twhile (1) {\n\t\t\t\t\tint req0, req1, mod0, mod1;\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq0 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod0 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (use_threads) {\n\t\t\t\t\t\t\tusleep(1000);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* try to get it all */\n\t\t\t\t\t\t\trfbCFD(1000*1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-E\\n\");\n\t\t\t\t\tif (OUCH) goto ouch;\n\t\t\t\t\tdt = dtime(&tm);\n\t\t\t\t\ti++;\n\n\t\t\t\t\tdt3 += dt;\n\t\t\t\t\tif (dt3 > spin_lat_max) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (use_threads) LOCK(cl->updateMutex);\n\n\t\t\t\t\treq1 = sraRgnCountRects(cl->requestedRegion);\n\t\t\t\t\tmod1 = sraRgnCountRects(cl->modifiedRegion);\n\n\t\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\nif (db) fprintf(stderr, \"dt3 calc: num rects req: %d/%d mod: %d/%d  \"\n#if LIBVNCSERVER_HAS_STATS\n    \"fbu-sent: %d  dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n    rfbStatGetMessageCountSent(cl, rfbFramebufferUpdate),\n#else\n    \"dt: %.4f dt3: %.4f  tm: %.4f\\n\",\n    req0, req1, mod0, mod1,\n#endif\n    dt, dt3, tm);\n\n\t\t\t\t\tif (req1 != 0 && mod1 == 0) {\n\t\t\t\t\t\tdts[got_t3++] = dt3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (! got_t3) {\n\t\t\t\tdt3 = 0.0;\n\t\t\t} else {\n\t\t\t\tif (got_t3 == 1) {\n\t\t\t\t\tdt3 = dts[0];\n\t\t\t\t} else if (got_t3 == 2) {\n\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t} else {\n\t\t\t\t\tif (dts[2] > 0.0) {\n\t\t\t\t\t\tdouble rat = dts[1]/dts[2];\n\t\t\t\t\t\tif (rat > 0.5 && rat < 2.0) {\n\t\t\t\t\t\t\tdt3 = dts[1]+dts[2];\n\t\t\t\t\t\t\tdt3 *= 0.5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdt3 = dts[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\touch:\n\t\t\n\t\tscreen->deferUpdateTime = defer;\n\t\tscreen->httpDir = httpdir;\n\n\t\tif (OUCH && ouch_db) fprintf(stderr, \"***OUCH-F\\n\");\n\t\tif (OUCH) break;\n\n\t\tdt = dt1 + dt2;\n\n\n\t\tif (dt3 <= dt2/2.0) {\n\t\t\t/* guess only 1/2 a ping for reply... */\n\t\t\tdt = dt - dt3/2.0;\n\t\t}\n\n\t\tcmp_rate = cbs/dt;\n\t\traw_rate = rbs/dt;\n\n\t\tif (cmp_rate > cmp_max) {\n\t\t\tcmp_rate = cmp_max;\n\t\t}\n\t\tif (cmp_rate <= cmp_min) {\n\t\t\tcmp_rate = cmp_min;\n\t\t}\n\n\t\tcd->send_cmp_rate = cmp_rate;\n\t\tcd->send_raw_rate = raw_rate;\n\n\t\tif (dt3 > lat_max) {\n\t\t\tdt3 = lat_max;\n\t\t}\n\t\tif (dt3 <= lat_min) {\n\t\t\tdt3 = lat_min;\n\t\t}\n\n\t\tcd->latency = dt3;\n\t\t\n\t\trfbLog(\"client %d network rate %.1f KB/sec (%.1f eff KB/sec)\\n\",\n\t\t    cd->uid, cmp_rate/1000.0, raw_rate/1000.0);\n\t\trfbLog(\"client %d latency:  %.1f ms\\n\", cd->uid, 1000.0*dt3);\n\t\trfbLog(\"dt1: %.4f, dt2: %.4f dt3: %.4f bytes: %d\\n\",\n\t\t    dt1, dt2, dt3, cbs);\n\t\tmsg = 1;\n\t}\n\n\tif (msg) {\n\t\tint link, latency, netrate;\n\t\tchar *str = \"error\";\n\n\t\tlink = link_rate(&latency, &netrate);\n\t\tif (link == LR_UNSET) {\n\t\t\tstr = \"LR_UNSET\";\n\t\t} else if (link == LR_UNKNOWN) {\n\t\t\tstr = \"LR_UNKNOWN\";\n\t\t} else if (link == LR_DIALUP) {\n\t\t\tstr = \"LR_DIALUP\";\n\t\t} else if (link == LR_BROADBAND) {\n\t\t\tstr = \"LR_BROADBAND\";\n\t\t} else if (link == LR_LAN) {\n\t\t\tstr = \"LR_LAN\";\n\t\t}\n\t\trfbLog(\"link_rate: %s - %d ms, %d KB/s\\n\", str, latency,\n\t\t    netrate);\n\t}\n\n\tif (init) {\n\t\tif (nclients) {\n\t\t\tscreen->displayHook = measure_display_hook;\n\t\t}\n\t} else {\n\t\tscreen->displayHook = orig_display_hook;\n\t}\n}"
  },
  {
    "function_name": "get_net_latency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "323-335",
    "snippet": "int get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int speeds_net_latency = 0;",
      "int speeds_net_latency_measured = 0;",
      "int get_net_latency(void);",
      "static int get_latency(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_latency",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "get_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "133-187",
          "snippet": "static int get_latency(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ilat, ilat_min = 1;\t/* 1 ms */\n\tint ilat_max = 2000;\t/* 2 sec */\n\tdouble slowest = -1.0, lat;\n\tstatic double save_lat = ((double) LATENCY0)/1000.0;\n\tint count = 0;\n\t\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\t\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->latency == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\n\t\tlat = cd->latency;\n\t\tif (slowest == -1.0 || lat > slowest) {\n\t\t\tslowest = lat;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn LATENCY0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_lat;\n\t} else {\n\t\tsave_lat = slowest;\n\t}\n\n\tilat = (int) (slowest * 1000.0);\n\tif (ilat < ilat_min) {\n\t\tilat = ilat_min;\n\t}\n\tif (ilat > ilat_max) {\n\t\tilat = ilat_max;\n\t}\n\n\treturn ilat;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void measure_display_hook(rfbClientPtr cl);",
            "static int get_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void measure_display_hook(rfbClientPtr cl);\nstatic int get_latency(void);\n\nstatic int get_latency(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ilat, ilat_min = 1;\t/* 1 ms */\n\tint ilat_max = 2000;\t/* 2 sec */\n\tdouble slowest = -1.0, lat;\n\tstatic double save_lat = ((double) LATENCY0)/1000.0;\n\tint count = 0;\n\t\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\t\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->latency == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\n\t\tlat = cd->latency;\n\t\tif (slowest == -1.0 || lat > slowest) {\n\t\t\tslowest = lat;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn LATENCY0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_lat;\n\t} else {\n\t\tsave_lat = slowest;\n\t}\n\n\tilat = (int) (slowest * 1000.0);\n\tif (ilat < ilat_min) {\n\t\tilat = ilat_min;\n\t}\n\tif (ilat > ilat_max) {\n\t\tilat = ilat_max;\n\t}\n\n\treturn ilat;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_latency = 0;\nint speeds_net_latency_measured = 0;\nint get_net_latency(void);\nstatic int get_latency(void);\n\nint get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_net_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "309-321",
    "snippet": "int get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int speeds_net_rate = 0;",
      "int speeds_net_rate_measured = 0;",
      "int get_cmp_rate(void);",
      "int get_net_rate(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cmp_rate",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "get_cmp_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "189-191",
          "snippet": "int get_cmp_rate(void) {\n\treturn get_rate(0);\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_cmp_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_cmp_rate(void);\n\nint get_cmp_rate(void) {\n\treturn get_rate(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_rate = 0;\nint speeds_net_rate_measured = 0;\nint get_cmp_rate(void);\nint get_net_rate(void);\n\nint get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "link_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "282-307",
    "snippet": "int link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int link_rate(int *latency, int *netrate);",
      "int get_net_rate(void);",
      "int get_net_latency(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "speeds_str",
            "\"lan\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "speeds_str",
            "\"dsl\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "speeds_str",
            "\"modem\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net_rate",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "get_net_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "309-321",
          "snippet": "int get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_rate = 0;",
            "int speeds_net_rate_measured = 0;",
            "int get_cmp_rate(void);",
            "int get_net_rate(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_rate = 0;\nint speeds_net_rate_measured = 0;\nint get_cmp_rate(void);\nint get_net_rate(void);\n\nint get_net_rate(void) {\n\tint spm = speeds_net_rate_measured;\n\tif (speeds_net_rate) {\n\t\treturn speeds_net_rate;\n\t}\n\tif (! spm || spm == NETRATE0) {\n\t\tspeeds_net_rate_measured = get_cmp_rate();\n\t}\n\tif (speeds_net_rate_measured) {\n\t\treturn speeds_net_rate_measured;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_net_latency",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "get_net_latency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "323-335",
          "snippet": "int get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int speeds_net_latency = 0;",
            "int speeds_net_latency_measured = 0;",
            "int get_net_latency(void);",
            "static int get_latency(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_latency = 0;\nint speeds_net_latency_measured = 0;\nint get_net_latency(void);\nstatic int get_latency(void);\n\nint get_net_latency(void) {\n\tint spm = speeds_net_latency_measured;\n\tif (speeds_net_latency) {\n\t\treturn speeds_net_latency;\n\t}\n\tif (! spm || spm == LATENCY0) {\n\t\tspeeds_net_latency_measured = get_latency();\n\t}\n\tif (speeds_net_latency_measured) {\n\t\treturn speeds_net_latency_measured;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint link_rate(int *latency, int *netrate);\nint get_net_rate(void);\nint get_net_latency(void);\n\nint link_rate(int *latency, int *netrate) {\n\t*latency = get_net_latency();\n\t*netrate = get_net_rate();\n\n\tif (speeds_str) {\n\t\tif (!strcmp(speeds_str, \"modem\")) {\n\t\t\treturn LR_DIALUP;\n\t\t} else if (!strcmp(speeds_str, \"dsl\")) {\n\t\t\treturn LR_BROADBAND;\n\t\t} else if (!strcmp(speeds_str, \"lan\")) {\n\t\t\treturn LR_LAN;\n\t\t}\n\t}\n\n\tif (*latency == LATENCY0 && *netrate == NETRATE0)  {\n\t\treturn LR_UNSET;\n\t} else if (*latency > 150 || *netrate < 20) {\n\t\treturn LR_DIALUP;\n\t} else if (*latency > 50 || *netrate < 150) {\n\t\treturn LR_BROADBAND;\n\t} else if (*latency < 10 && *netrate > 300) {\n\t\treturn LR_LAN;\n\t} else {\n\t\treturn LR_UNKNOWN;\n\t}\n}"
  },
  {
    "function_name": "get_read_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "272-280",
    "snippet": "int get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int speeds_read_rate = 0;",
      "int speeds_read_rate_measured = 0;",
      "int get_read_rate(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_read_rate = 0;\nint speeds_read_rate_measured = 0;\nint get_read_rate(void);\n\nint get_read_rate(void) {\n\tif (speeds_read_rate) {\n\t\treturn speeds_read_rate;\n\t}\n\tif (speeds_read_rate_measured) {\n\t\treturn speeds_read_rate_measured;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "initialize_speeds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "197-270",
    "snippet": "void initialize_speeds(void) {\n\tchar *s, *s_in, *p;\n\tint i;\n\n\tspeeds_read_rate = 0;\n\tspeeds_net_rate = 0;\n\tspeeds_net_latency = 0;\n\tif (! speeds_str || *speeds_str == '\\0') {\n\t\ts_in = strdup(\"\");\n\t} else {\n\t\ts_in = strdup(speeds_str);\n\t}\n\n\tif (!strcmp(s_in, \"modem\")) {\n\t\ts = strdup(\"6,4,200\");\n\t} else if (!strcmp(s_in, \"dsl\")) {\n\t\ts = strdup(\"6,100,50\");\n\t} else if (!strcmp(s_in, \"lan\")) {\n\t\ts = strdup(\"6,5000,1\");\n\t} else {\n\t\ts = strdup(s_in);\n\t}\n\n\tp = strtok(s, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tdouble val;\n\t\tif (*p != '\\0') {\n\t\t\tval = atof(p);\n\t\t\tif (i==0) {\n\t\t\t\tspeeds_read_rate = (int) 1000000 * val;\n\t\t\t} else if (i==1) {\n\t\t\t\tspeeds_net_rate = (int) 1000 * val;\n\t\t\t} else if (i==2) {\n\t\t\t\tspeeds_net_latency = (int) val;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\tfree(s_in);\n\n\tif (! speeds_read_rate) {\n\t\tint n = 0;\n\t\tdouble dt, timer;\n#ifdef MACOSX\n\t\tif (macosx_console && macosx_read_opengl && fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tusleep(10 * 1000);\n\t\t}\n#endif\n\n\t\tdtime0(&timer);\n\t\tif (fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tn = fullscreen->bytes_per_line * fullscreen->height;\n\t\t} else if (scanline) {\n\t\t\tcopy_image(scanline, 0, 0, 0, 0);\n\t\t\tn = scanline->bytes_per_line * scanline->height;\n\t\t}\n\t\tdt = dtime(&timer);\n\t\tif (n && dt > 0.0) {\n\t\t\tdouble rate = ((double) n) / dt;\n\t\t\tspeeds_read_rate_measured = (int) (rate/1000000.0);\n\t\t\tif (speeds_read_rate_measured < 1) {\n\t\t\t\tspeeds_read_rate_measured = 1;\n\t\t\t} else {\n\t\t\t\trfbLog(\"fb read rate: %d MB/sec\\n\",\n\t\t\t\t    speeds_read_rate_measured);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int speeds_net_rate = 0;",
      "int speeds_net_latency = 0;",
      "int speeds_read_rate = 0;",
      "int speeds_read_rate_measured = 0;",
      "void initialize_speeds(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"fb read rate: %d MB/sec\\n\"",
            "speeds_read_rate_measured"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&timer"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_image",
          "args": [
            "scanline",
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "copy_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "832-868",
          "snippet": "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);",
            "void copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h);\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\nvoid copy_raw_fb(XImage *dest, int x, int y, unsigned int w, unsigned int h);\n\nvoid copy_image(XImage *dest, int x, int y, unsigned int w, unsigned int h) {\n\t/* default (w=0, h=0) is the fill the entire XImage */\n\tif (dest == NULL) {\n\t\treturn;\n\t}\n\tif (w < 1)  {\n\t\tw = dest->width;\n\t}\n\tif (h < 1)  {\n\t\th = dest->height;\n\t}\n\n\tif (raw_fb) {\n\t\tcopy_raw_fb(dest, x, y, w, h);\n\n\t} else if (use_snapfb && snap_fb && dest != snaprect) {\n\t\tchar *src, *dst;\n\t\tunsigned int line;\n\t\tint pixelsize = bpp/8;\n\n\t\tsrc = snap->data + snap->bytes_per_line*y + pixelsize*x;\n\t\tdst = dest->data;\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += snap->bytes_per_line;\n\t\t\tdst += dest->bytes_per_line;\n\t\t}\n\n\t} else if ((using_shm && ! xform24to32) && (int) w == dest->width &&\n\t    (int) h == dest->height) {\n\t\tXShmGetImage_wr(dpy, window, dest, x, y, AllPlanes);\n\n\t} else {\n\t\tXGetSubImage_wr(dpy, window, x, y, w, h, AllPlanes,\n\t\t    ZPixmap, dest, 0, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s_in"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "s",
            "\",\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s_in"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"6,5000,1\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s_in",
            "\"lan\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"6,100,50\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s_in",
            "\"dsl\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"6,4,200\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s_in",
            "\"modem\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "speeds_str"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint speeds_net_rate = 0;\nint speeds_net_latency = 0;\nint speeds_read_rate = 0;\nint speeds_read_rate_measured = 0;\nvoid initialize_speeds(void);\n\nvoid initialize_speeds(void) {\n\tchar *s, *s_in, *p;\n\tint i;\n\n\tspeeds_read_rate = 0;\n\tspeeds_net_rate = 0;\n\tspeeds_net_latency = 0;\n\tif (! speeds_str || *speeds_str == '\\0') {\n\t\ts_in = strdup(\"\");\n\t} else {\n\t\ts_in = strdup(speeds_str);\n\t}\n\n\tif (!strcmp(s_in, \"modem\")) {\n\t\ts = strdup(\"6,4,200\");\n\t} else if (!strcmp(s_in, \"dsl\")) {\n\t\ts = strdup(\"6,100,50\");\n\t} else if (!strcmp(s_in, \"lan\")) {\n\t\ts = strdup(\"6,5000,1\");\n\t} else {\n\t\ts = strdup(s_in);\n\t}\n\n\tp = strtok(s, \",\");\n\ti = 0;\n\twhile (p) {\n\t\tdouble val;\n\t\tif (*p != '\\0') {\n\t\t\tval = atof(p);\n\t\t\tif (i==0) {\n\t\t\t\tspeeds_read_rate = (int) 1000000 * val;\n\t\t\t} else if (i==1) {\n\t\t\t\tspeeds_net_rate = (int) 1000 * val;\n\t\t\t} else if (i==2) {\n\t\t\t\tspeeds_net_latency = (int) val;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\tfree(s_in);\n\n\tif (! speeds_read_rate) {\n\t\tint n = 0;\n\t\tdouble dt, timer;\n#ifdef MACOSX\n\t\tif (macosx_console && macosx_read_opengl && fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tusleep(10 * 1000);\n\t\t}\n#endif\n\n\t\tdtime0(&timer);\n\t\tif (fullscreen) {\n\t\t\tcopy_image(fullscreen, 0, 0, 0, 0);\n\t\t\tn = fullscreen->bytes_per_line * fullscreen->height;\n\t\t} else if (scanline) {\n\t\t\tcopy_image(scanline, 0, 0, 0, 0);\n\t\t\tn = scanline->bytes_per_line * scanline->height;\n\t\t}\n\t\tdt = dtime(&timer);\n\t\tif (n && dt > 0.0) {\n\t\t\tdouble rate = ((double) n) / dt;\n\t\t\tspeeds_read_rate_measured = (int) (rate/1000000.0);\n\t\t\tif (speeds_read_rate_measured < 1) {\n\t\t\t\tspeeds_read_rate_measured = 1;\n\t\t\t} else {\n\t\t\t\trfbLog(\"fb read rate: %d MB/sec\\n\",\n\t\t\t\t    speeds_read_rate_measured);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_raw_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "193-195",
    "snippet": "int get_raw_rate(void) {\n\treturn get_rate(1);\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_raw_rate(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_rate",
          "args": [
            "1"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "get_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "71-131",
          "snippet": "static int get_rate(int which) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint irate, irate_min = 1;\t/* 1 KB/sec */\n\tint irate_max = 100000;\t\t/* 100 MB/sec */\n\tint count = 0;\n\tdouble slowest = -1.0, rate;\n\tstatic double save_rate = 1000 * NETRATE0;\n\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate == 0.0 || cd->send_raw_rate == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t\t\n\t\tif (which == 0) {\n\t\t\trate = cd->send_cmp_rate;\n\t\t} else {\n\t\t\trate = cd->send_raw_rate;\n\t\t}\n\t\tif (slowest == -1.0 || rate < slowest) {\n\t\t\tslowest = rate;\n\t\t}\n\t\t\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn NETRATE0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_rate;\n\t} else {\n\t\tsave_rate = slowest;\n\t}\n\n\tirate = (int) (slowest/1000.0);\n\tif (irate < irate_min) {\n\t\tirate = irate_min;\n\t}\n\tif (irate > irate_max) {\n\t\tirate = irate_max;\n\t}\nif (0) fprintf(stderr, \"get_rate(%d) %d %.3f/%.3f\\n\", which, irate, save_rate, slowest); \n\n\treturn irate;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void measure_display_hook(rfbClientPtr cl);",
            "static int get_rate(int which);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void measure_display_hook(rfbClientPtr cl);\nstatic int get_rate(int which);\n\nstatic int get_rate(int which) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint irate, irate_min = 1;\t/* 1 KB/sec */\n\tint irate_max = 100000;\t\t/* 100 MB/sec */\n\tint count = 0;\n\tdouble slowest = -1.0, rate;\n\tstatic double save_rate = 1000 * NETRATE0;\n\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate == 0.0 || cd->send_raw_rate == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t\t\n\t\tif (which == 0) {\n\t\t\trate = cd->send_cmp_rate;\n\t\t} else {\n\t\t\trate = cd->send_raw_rate;\n\t\t}\n\t\tif (slowest == -1.0 || rate < slowest) {\n\t\t\tslowest = rate;\n\t\t}\n\t\t\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn NETRATE0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_rate;\n\t} else {\n\t\tsave_rate = slowest;\n\t}\n\n\tirate = (int) (slowest/1000.0);\n\tif (irate < irate_min) {\n\t\tirate = irate_min;\n\t}\n\tif (irate > irate_max) {\n\t\tirate = irate_max;\n\t}\nif (0) fprintf(stderr, \"get_rate(%d) %d %.3f/%.3f\\n\", which, irate, save_rate, slowest); \n\n\treturn irate;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_raw_rate(void);\n\nint get_raw_rate(void) {\n\treturn get_rate(1);\n}"
  },
  {
    "function_name": "get_cmp_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "189-191",
    "snippet": "int get_cmp_rate(void) {\n\treturn get_rate(0);\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_cmp_rate(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_rate",
          "args": [
            "0"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "get_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
          "lines": "71-131",
          "snippet": "static int get_rate(int which) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint irate, irate_min = 1;\t/* 1 KB/sec */\n\tint irate_max = 100000;\t\t/* 100 MB/sec */\n\tint count = 0;\n\tdouble slowest = -1.0, rate;\n\tstatic double save_rate = 1000 * NETRATE0;\n\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate == 0.0 || cd->send_raw_rate == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t\t\n\t\tif (which == 0) {\n\t\t\trate = cd->send_cmp_rate;\n\t\t} else {\n\t\t\trate = cd->send_raw_rate;\n\t\t}\n\t\tif (slowest == -1.0 || rate < slowest) {\n\t\t\tslowest = rate;\n\t\t}\n\t\t\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn NETRATE0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_rate;\n\t} else {\n\t\tsave_rate = slowest;\n\t}\n\n\tirate = (int) (slowest/1000.0);\n\tif (irate < irate_min) {\n\t\tirate = irate_min;\n\t}\n\tif (irate > irate_max) {\n\t\tirate = irate_max;\n\t}\nif (0) fprintf(stderr, \"get_rate(%d) %d %.3f/%.3f\\n\", which, irate, save_rate, slowest); \n\n\treturn irate;\n}",
          "includes": [
            "#include \"scan.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void measure_display_hook(rfbClientPtr cl);",
            "static int get_rate(int which);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void measure_display_hook(rfbClientPtr cl);\nstatic int get_rate(int which);\n\nstatic int get_rate(int which) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint irate, irate_min = 1;\t/* 1 KB/sec */\n\tint irate_max = 100000;\t\t/* 100 MB/sec */\n\tint count = 0;\n\tdouble slowest = -1.0, rate;\n\tstatic double save_rate = 1000 * NETRATE0;\n\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate == 0.0 || cd->send_raw_rate == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t\t\n\t\tif (which == 0) {\n\t\t\trate = cd->send_cmp_rate;\n\t\t} else {\n\t\t\trate = cd->send_raw_rate;\n\t\t}\n\t\tif (slowest == -1.0 || rate < slowest) {\n\t\t\tslowest = rate;\n\t\t}\n\t\t\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn NETRATE0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_rate;\n\t} else {\n\t\tsave_rate = slowest;\n\t}\n\n\tirate = (int) (slowest/1000.0);\n\tif (irate < irate_min) {\n\t\tirate = irate_min;\n\t}\n\tif (irate > irate_max) {\n\t\tirate = irate_max;\n\t}\nif (0) fprintf(stderr, \"get_rate(%d) %d %.3f/%.3f\\n\", which, irate, save_rate, slowest); \n\n\treturn irate;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_cmp_rate(void);\n\nint get_cmp_rate(void) {\n\treturn get_rate(0);\n}"
  },
  {
    "function_name": "get_latency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "133-187",
    "snippet": "static int get_latency(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ilat, ilat_min = 1;\t/* 1 ms */\n\tint ilat_max = 2000;\t/* 2 sec */\n\tdouble slowest = -1.0, lat;\n\tstatic double save_lat = ((double) LATENCY0)/1000.0;\n\tint count = 0;\n\t\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\t\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->latency == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\n\t\tlat = cd->latency;\n\t\tif (slowest == -1.0 || lat > slowest) {\n\t\t\tslowest = lat;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn LATENCY0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_lat;\n\t} else {\n\t\tsave_lat = slowest;\n\t}\n\n\tilat = (int) (slowest * 1000.0);\n\tif (ilat < ilat_min) {\n\t\tilat = ilat_min;\n\t}\n\tif (ilat > ilat_max) {\n\t\tilat = ilat_max;\n\t}\n\n\treturn ilat;\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void measure_display_hook(rfbClientPtr cl);",
      "static int get_latency(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void measure_display_hook(rfbClientPtr cl);\nstatic int get_latency(void);\n\nstatic int get_latency(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ilat, ilat_min = 1;\t/* 1 ms */\n\tint ilat_max = 2000;\t/* 2 sec */\n\tdouble slowest = -1.0, lat;\n\tstatic double save_lat = ((double) LATENCY0)/1000.0;\n\tint count = 0;\n\t\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\t\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->latency == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\n\t\tlat = cd->latency;\n\t\tif (slowest == -1.0 || lat > slowest) {\n\t\t\tslowest = lat;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn LATENCY0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_lat;\n\t} else {\n\t\tsave_lat = slowest;\n\t}\n\n\tilat = (int) (slowest * 1000.0);\n\tif (ilat < ilat_min) {\n\t\tilat = ilat_min;\n\t}\n\tif (ilat > ilat_max) {\n\t\tilat = ilat_max;\n\t}\n\n\treturn ilat;\n}"
  },
  {
    "function_name": "get_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "71-131",
    "snippet": "static int get_rate(int which) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint irate, irate_min = 1;\t/* 1 KB/sec */\n\tint irate_max = 100000;\t\t/* 100 MB/sec */\n\tint count = 0;\n\tdouble slowest = -1.0, rate;\n\tstatic double save_rate = 1000 * NETRATE0;\n\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate == 0.0 || cd->send_raw_rate == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t\t\n\t\tif (which == 0) {\n\t\t\trate = cd->send_cmp_rate;\n\t\t} else {\n\t\t\trate = cd->send_raw_rate;\n\t\t}\n\t\tif (slowest == -1.0 || rate < slowest) {\n\t\t\tslowest = rate;\n\t\t}\n\t\t\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn NETRATE0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_rate;\n\t} else {\n\t\tsave_rate = slowest;\n\t}\n\n\tirate = (int) (slowest/1000.0);\n\tif (irate < irate_min) {\n\t\tirate = irate_min;\n\t}\n\tif (irate > irate_max) {\n\t\tirate = irate_max;\n\t}\nif (0) fprintf(stderr, \"get_rate(%d) %d %.3f/%.3f\\n\", which, irate, save_rate, slowest); \n\n\treturn irate;\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void measure_display_hook(rfbClientPtr cl);",
      "static int get_rate(int which);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_rate(%d) %d %.3f/%.3f\\n\"",
            "which",
            "irate",
            "save_rate",
            "slowest"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void measure_display_hook(rfbClientPtr cl);\nstatic int get_rate(int which);\n\nstatic int get_rate(int which) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint irate, irate_min = 1;\t/* 1 KB/sec */\n\tint irate_max = 100000;\t\t/* 100 MB/sec */\n\tint count = 0;\n\tdouble slowest = -1.0, rate;\n\tstatic double save_rate = 1000 * NETRATE0;\n\n\tif (!screen) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->send_cmp_rate == 0.0 || cd->send_raw_rate == 0.0) {\n\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t\t\n\t\tif (which == 0) {\n\t\t\trate = cd->send_cmp_rate;\n\t\t} else {\n\t\t\trate = cd->send_raw_rate;\n\t\t}\n\t\tif (slowest == -1.0 || rate < slowest) {\n\t\t\tslowest = rate;\n\t\t}\n\t\t\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (! count) {\n\t\treturn NETRATE0;\n\t}\n\n\tif (slowest == -1.0) {\n\t\tslowest = save_rate;\n\t} else {\n\t\tsave_rate = slowest;\n\t}\n\n\tirate = (int) (slowest/1000.0);\n\tif (irate < irate_min) {\n\t\tirate = irate_min;\n\t}\n\tif (irate > irate_max) {\n\t\tirate = irate_max;\n\t}\nif (0) fprintf(stderr, \"get_rate(%d) %d %.3f/%.3f\\n\", which, irate, save_rate, slowest); \n\n\treturn irate;\n}"
  },
  {
    "function_name": "measure_display_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/rates.c",
    "lines": "63-69",
    "snippet": "static void measure_display_hook(rfbClientPtr cl) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif (! cd) {\n\t\treturn;\n\t}\n\tdtime0(&cd->timer);\n}",
    "includes": [
      "#include \"scan.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void measure_display_hook(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtime0",
          "args": [
            "&cd->timer"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scan.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void measure_display_hook(rfbClientPtr cl);\n\nstatic void measure_display_hook(rfbClientPtr cl) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif (! cd) {\n\t\treturn;\n\t}\n\tdtime0(&cd->timer);\n}"
  }
]