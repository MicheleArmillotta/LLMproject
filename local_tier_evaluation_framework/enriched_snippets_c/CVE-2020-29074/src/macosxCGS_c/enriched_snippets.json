[
  {
    "function_name": "macosxGCS_poll_pb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "568-598",
    "snippet": "void macosxGCS_poll_pb(void) {\n\n\tstatic double dlast = 0.0;\n\tdouble now = dnow();\n\n\tif (now < dlast + 0.2) {\n\t\treturn;\n\t}\n\tdlast = now;\n\n   {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\t[pblock lock];\n\tif (pbcnt != [[NSPasteboard generalPasteboard] changeCount]) {\n\t\tpbcnt = [[NSPasteboard generalPasteboard] changeCount];\n\t\t[pbstr release];\n\t\tpbstr = nil;\n\t\tif ([[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]]) {\n\t\t\tpbstr = [[[NSPasteboard generalPasteboard] stringForType:NSStringPboardType] copy];\n\t\t\tif (pbstr) {\n\t\t\t\tNSData *str = [pbstr dataUsingEncoding:pbenc allowLossyConversion:YES];\n\t\t\t\tif ([str length]) {\n\t\t\t\t\tmacosx_send_sel((char *) [str bytes], [str length]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t[pblock unlock];\n\t[pool release];\n   }\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_send_sel",
          "args": [
            "(char *) [str bytes], [str length]"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxGCS_poll_pb(void) {\n\n\tstatic double dlast = 0.0;\n\tdouble now = dnow();\n\n\tif (now < dlast + 0.2) {\n\t\treturn;\n\t}\n\tdlast = now;\n\n   {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\t[pblock lock];\n\tif (pbcnt != [[NSPasteboard generalPasteboard] changeCount]) {\n\t\tpbcnt = [[NSPasteboard generalPasteboard] changeCount];\n\t\t[pbstr release];\n\t\tpbstr = nil;\n\t\tif ([[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]]) {\n\t\t\tpbstr = [[[NSPasteboard generalPasteboard] stringForType:NSStringPboardType] copy];\n\t\t\tif (pbstr) {\n\t\t\t\tNSData *str = [pbstr dataUsingEncoding:pbenc allowLossyConversion:YES];\n\t\t\t\tif ([str length]) {\n\t\t\t\t\tmacosx_send_sel((char *) [str bytes], [str length]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t[pblock unlock];\n\t[pool release];\n   }\n}"
  },
  {
    "function_name": "macosxGCS_set_pasteboard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "544-558",
    "snippet": "void macosxGCS_set_pasteboard(char *str, int len) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tif (pbcnt != 0) {\n\t\t[pblock lock];\n\t\t[cuttext release];\n\t\tcuttext = [[NSString alloc] initWithData:[NSData dataWithBytes:str length:len] encoding: pbenc];\n\t\tif ([[NSPasteboard generalPasteboard] declareTypes:[NSArray arrayWithObject:NSStringPboardType] owner:nil]) {\n\t\t\tNS_DURING\n\t\t\t\t[[NSPasteboard generalPasteboard] setString:cuttext forType:NSStringPboardType];\n\t\t\tNS_HANDLER\n\t\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t\tNS_ENDHANDLER\n\t\t} else {\n\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxGCS_set_pasteboard(char *str, int len) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tif (pbcnt != 0) {\n\t\t[pblock lock];\n\t\t[cuttext release];\n\t\tcuttext = [[NSString alloc] initWithData:[NSData dataWithBytes:str length:len] encoding: pbenc];\n\t\tif ([[NSPasteboard generalPasteboard] declareTypes:[NSArray arrayWithObject:NSStringPboardType] owner:nil]) {\n\t\t\tNS_DURING\n\t\t\t\t[[NSPasteboard generalPasteboard] setString:cuttext forType:NSStringPboardType];\n\t\t\tNS_HANDLER\n\t\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t\tNS_ENDHANDLER\n\t\t} else {\n\t\t\tfprintf(stderr, \"macosxGCS_set_pasteboard: problem writing to pasteboard\\n\");\n\t\t}"
  },
  {
    "function_name": "macosxGCS_initpb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "531-542",
    "snippet": "void macosxGCS_initpb(void) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tpblock = [[NSLock alloc] init];\n\tif (![NSPasteboard generalPasteboard]) {\n\t\tmacosx_log(\"macosxGCS_initpb: **PASTEBOARD INACCESSIBLE**.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Clipboard exchange will NOT work.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Start x11vnc *inside* Aqua for Clipboard.\\n\");\n\t\tpbcnt = 0;\n\t\tpbstr = [[NSString alloc] initWithString:@\"\\e<PASTEBOARD INACCESSIBLE>\\e\"]; \n\t}\n\t[pool release];\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"macosxGCS_initpb: Start x11vnc *inside* Aqua for Clipboard.\\n\""
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxGCS_initpb(void) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tpblock = [[NSLock alloc] init];\n\tif (![NSPasteboard generalPasteboard]) {\n\t\tmacosx_log(\"macosxGCS_initpb: **PASTEBOARD INACCESSIBLE**.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Clipboard exchange will NOT work.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Start x11vnc *inside* Aqua for Clipboard.\\n\");\n\t\tpbcnt = 0;\n\t\tpbstr = [[NSString alloc] initWithString:@\"\\e<PASTEBOARD INACCESSIBLE>\\e\"]; \n\t}\n\t[pool release];\n}"
  },
  {
    "function_name": "macosxCGS_get_all_windows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "262-521",
    "snippet": "void macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [
      "#define WINHISTMAX 4",
      "#define WINHISTNUM 32768",
      "#define MAXWINDAT 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_add_visnotify",
          "args": [
            "nv_win[k]",
            "nv_lvl[k]",
            "nv_vis[k]"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_add_visnotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "473-493",
          "snippet": "void macosx_add_visnotify(Window win, int level, int obscured) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = VisibilityNotify;\n\tmac_events[i].map = -1;\n\n\tmac_events[i].vis = 1;\n\tif (obscured == 0) {\n\t\tmac_events[i].vis = VisibilityUnobscured;\n\t} else if (obscured == 1) {\n\t\tmac_events[i].vis = VisibilityPartiallyObscured;\n\t} else if (obscured == 2) {\n\t\tmac_events[i].vis = VisibilityFullyObscured; \t/* NI */\n\t}\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void macosx_add_mapnotify(Window win, int level, int map);",
            "void macosx_add_create(Window win, int level);",
            "void macosx_add_destroy(Window win, int level);",
            "void macosx_add_visnotify(Window win, int level, int obscured);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\nvoid macosx_add_visnotify(Window win, int level, int obscured);\n\nvoid macosx_add_visnotify(Window win, int level, int obscured) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = VisibilityNotify;\n\tmac_events[i].map = -1;\n\n\tmac_events[i].vis = 1;\n\tif (obscured == 0) {\n\t\tmac_events[i].vis = VisibilityUnobscured;\n\t} else if (obscured == 1) {\n\t\tmac_events[i].vis = VisibilityPartiallyObscured;\n\t} else if (obscured == 2) {\n\t\tmac_events[i].vis = VisibilityFullyObscured; \t/* NI */\n\t}\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_add_destroy",
          "args": [
            "win",
            "lvl"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_add_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "459-471",
          "snippet": "void macosx_add_destroy(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = DestroyNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void macosx_add_mapnotify(Window win, int level, int map);",
            "void macosx_add_create(Window win, int level);",
            "void macosx_add_destroy(Window win, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_destroy(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = DestroyNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "dnowx()",
            "totcnt"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_add_mapnotify",
          "args": [
            "win",
            "lvl",
            "0"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_add_mapnotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "427-443",
          "snippet": "void macosx_add_mapnotify(Window win, int level, int map) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tif (map) {\n\t\tmac_events[i].type = MapNotify;\n\t} else {\n\t\tmac_events[i].type = UnmapNotify;\n\t}\n\tmac_events[i].map = map;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void macosx_add_mapnotify(Window win, int level, int map);",
            "void macosx_add_create(Window win, int level);",
            "void macosx_add_destroy(Window win, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_mapnotify(Window win, int level, int map) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tif (map) {\n\t\tmac_events[i].type = MapNotify;\n\t} else {\n\t\tmac_events[i].type = UnmapNotify;\n\t}\n\tmac_events[i].map = map;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "dnowx()",
            "totcnt"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "totcnt"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibNotify: %d/%d  %d               OBS tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "totcnt"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "totcnt"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"VisibNotify: %d/%d  %d               OBS tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "totcnt"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "dnowx()",
            "totcnt"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_add_create",
          "args": [
            "win",
            "macwins[i].level"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_add_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "445-457",
          "snippet": "void macosx_add_create(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = CreateNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [
            "#define MAX_EVENTS 1024"
          ],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void macosx_add_mapnotify(Window win, int level, int map);",
            "void macosx_add_create(Window win, int level);",
            "void macosx_add_destroy(Window win, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\n#define MAX_EVENTS 1024\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid macosx_add_mapnotify(Window win, int level, int map);\nvoid macosx_add_create(Window win, int level);\nvoid macosx_add_destroy(Window win, int level);\n\nvoid macosx_add_create(Window win, int level) {\n\tint i = mac_events_last++;\n\tmac_events[i].win = win;\n\tmac_events[i].level = level;\n\n\tmac_events[i].type = CreateNotify;\n\tmac_events[i].map = -1;\n\tmac_events[i].vis = -1;\n\n\tmac_events_last = mac_events_last % MAX_EVENTS;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "dnowx()",
            "whist_prv",
            "whist_idx",
            "win",
            "totcnt"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "dnowx()",
            "totcnt"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCGS_follow_animation_win",
          "args": [
            "win",
            "i",
            "1"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_follow_animation_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "176-238",
          "snippet": "int macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\"",
            "prev",
            "curr",
            "win",
            "dnowx()",
            "totcnt"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_offscreen",
          "args": [
            "win"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "check_offscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "255-257",
          "snippet": "static int check_offscreen(int win) {\n\treturn macosx_check_offscreen(win);\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic int check_offscreen(int win) {\n\treturn macosx_check_offscreen(win);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_clipped",
          "args": [
            "win"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "check_clipped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "243-253",
          "snippet": "static int check_clipped(int win) {\n\tint i, n = 0, win2;\n\tfor (i = 0; i < (int) _wins_mapped_cnt; i++) {\n\t\twin2 = (int) _wins_mapped[i];\n\t\tif (win2 == win) {\n\t\t\tbreak;\n\t\t}\n\t\t_wins_int[n++] = win2;\n\t}\n\treturn macosx_check_clipped(win, _wins_int, n);\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic int check_clipped(int win) {\n\tint i, n = 0, win2;\n\tfor (i = 0; i < (int) _wins_mapped_cnt; i++) {\n\t\twin2 = (int) _wins_mapped[i];\n\t\tif (win2 == win) {\n\t\t\tbreak;\n\t\t}\n\t\t_wins_int[n++] = win2;\n\t}\n\treturn macosx_check_clipped(win, _wins_int, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cnt: %d err: %d\\n\"",
            "(int) _wins_mapped_cnt",
            "err"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSGetOnScreenWindowList",
          "args": [
            "cid",
            "NULL",
            "cap",
            "_wins_mapped",
            "&_wins_mapped_cnt"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\"",
            "i",
            "_wins_all[i]",
            "(int) rect.origin.x",
            "(int) rect.origin.y",
            "(int) rect.size.width",
            "(int) rect.size.height",
            "(int) level"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSGetWindowLevel",
          "args": [
            "cid",
            "_wins_all[i]",
            "&level"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSGetScreenRectForWindow",
          "args": [
            "cid",
            "_wins_all[i]",
            "&rect"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cnt: %d err: %d\\n\"",
            "(int) _wins_all_cnt",
            "err"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSGetWindowList",
          "args": [
            "cid",
            "NULL",
            "cap",
            "_wins_all",
            "&_wins_all_cnt"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CGSDefaultConnection",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTMAX 4\n#define WINHISTNUM 32768\n#define MAXWINDAT 4096\n\nvoid macosxCGS_get_all_windows(void) {\n\tstatic double last = 0.0;\n\tstatic int totcnt = 0;\n\tdouble dt = 0.0, now = dnow();\n\tint i, db = 0, whist_prv = 0, maxwin = 0, whist_skip = 0;\n\tCGSWindowCount cap = (CGSWindowCount) MAXWINDAT;\n\tCGSError err; \n\n\tCGS_levelmax = 0;\n\tCGS_levels[CGS_levelmax++] = (int) kCGDraggingWindowLevel;\t/* 500 ? */\n\tif (0) CGS_levels[CGS_levelmax++] = (int) kCGHelpWindowLevel;\t\t/* 102 ? */\n\tif (macosx_ncache_macmenu) CGS_levels[CGS_levelmax++] = (int) kCGPopUpMenuWindowLevel;\t/* 101 pulldown menu */\n\tCGS_levels[CGS_levelmax++] = (int) kCGMainMenuWindowLevelKey;\t/*  24 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGModalPanelWindowLevel;\t/*   8 open dialog box */\n\tCGS_levels[CGS_levelmax++] = (int) kCGFloatingWindowLevel;\t/*   3 ? */\n\tCGS_levels[CGS_levelmax++] = (int) kCGNormalWindowLevel;\t/*   0 regular window */\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (dt > 0.0 && now < last + dt) {\n\t\treturn;\n\t}\n\n\tlast = now;\n\n\tmacwinmax = 0; \n\n\ttotcnt++;\n\n\tif (ncache > 0) {\n\t\twhist_prv = whist_idx++;\n\t\tif (whist_prv < 0) {\n\t\t\twhist_skip = 1;\n\t\t\twhist_prv = 0;\n\t\t}\n\t\twhist_idx = whist_idx % WINHISTMAX;\n\t\tfor (i=0; i < WINHISTNUM; i++) {\n\t\t\twhist[whist_idx][i] = 0;\n\t\t\tqlook[i] = -1;\n\t\t}\n\t}\n\n\terr = CGSGetWindowList(cid, NULL, cap, _wins_all, &_wins_all_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_all_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_all_cnt; i++) {\n\t\tCGSRect rect;\n\t\tCGSWindowLevel level;\n\t\tint j, keepit = 0;\n\t\terr = CGSGetScreenRectForWindow(cid, _wins_all[i], &rect);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (rect.origin.x == 0 && rect.origin.y == 0) {\n\t\t\tif (rect.size.width == dpy_x) {\n\t\t\t\tif (rect.size.height == dpy_y) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terr = CGSGetWindowLevel(cid, _wins_all[i], &level);\n\t\tif (err != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j<CGS_levelmax; j++) {\n\t\t\tif ((int) level == CGS_levels[j]) {\n\t\t\t\tkeepit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! keepit) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmacwins[macwinmax].level  = (int) level;\n\t\tmacwins[macwinmax].win    = (int) _wins_all[i];\n\t\tmacwins[macwinmax].x      = (int) rect.origin.x;\n\t\tmacwins[macwinmax].y      = (int) rect.origin.y;\n\t\tmacwins[macwinmax].width  = (int) rect.size.width;\n\t\tmacwins[macwinmax].height = (int) rect.size.height;\n\t\tmacwins[macwinmax].mapped = 0;\n\t\tmacwins[macwinmax].clipped = 0;\n\t\tmacwins[macwinmax].ncache_only = 0;\n\t\tif (level == kCGPopUpMenuWindowLevel) {\n\t\t\tmacwins[macwinmax].ncache_only = 1;\n\t\t}\n\nif (0 || db) fprintf(stderr, \"i=%03d ID: %06d  x: %03d  y: %03d  w: %03d h: %03d level: %d\\n\", i, _wins_all[i],\n    (int) rect.origin.x, (int) rect.origin.y,(int) rect.size.width, (int) rect.size.height, (int) level);\n\n\t\tif (macwins[macwinmax].win < WINHISTNUM) {\n\t\t\tqlook[macwins[macwinmax].win] = macwinmax;\n\t\t\tif (macwins[macwinmax].win > maxwin) {\n\t\t\t\tmaxwin = macwins[macwinmax].win;\n\t\t\t}\n\t\t}\n\n\t\tmacwinmax++;\n\t}\n\n\terr = CGSGetOnScreenWindowList(cid, NULL, cap, _wins_mapped, &_wins_mapped_cnt);\n\nif (db) fprintf(stderr, \"cnt: %d err: %d\\n\", (int) _wins_mapped_cnt, err);\n\n\tif (err != 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i < (int) _wins_mapped_cnt; i++) {\n\t\tint j, idx = -1;\n\t\tint win = (int) _wins_mapped[i];\n\n\t\tif (0 <= win && win < WINHISTNUM) {\n\t\t\tj = qlook[win];\n\t\t\tif (j >= 0 && macwins[j].win == win) {\n\t\t\t\tidx = j; \n\t\t\t}\n\t\t}\n\t\tif (idx < 0) {\n\t\t\tfor (j=0; j < macwinmax; j++) {\n\t\t\t\tif (macwins[j].win == win) {\n\t\t\t\t\tidx = j; \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (idx >= 0) {\n\t\t\tmacwins[idx].mapped = 1;\n\t\t}\n\t}\n\n\tif (ncache > 0) {\n\t\tint nv= 0, NBMAX = 64;\n\t\tint nv_win[64];\n\t\tint nv_lvl[64];\n\t\tint nv_vis[64];\n\n\t\tfor (i=0; i < macwinmax; i++) {\n\t\t\tint win = macwins[i].win;\n\t\t\tchar prev, curr;\n\n\t\t\tif (win >= WINHISTNUM) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhist[whist_idx][win] |= is_exist;\n\t\t\tif (macwins[i].mapped) {\n\t\t\t\twhist[whist_idx][win] |= is_mapped;\n\t\t\t\tif (check_clipped(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_clipped;\n\t\t\t\t\tmacwins[i].clipped = 1;\n\t\t\t\t}\n\t\t\t\tif (check_offscreen(win)) {\n\t\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhist[whist_idx][win] |= is_offscreen;\n\t\t\t}\n\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if ( !(prev & is_mapped) && (curr & is_mapped)) {\n\t\t\t\t/* MapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\tif (0) macosxCGS_follow_animation_win(win, i, 1);\n\n\t\t\t} else if ( !(curr & is_mapped) && (prev & is_mapped)) {\n\t\t\t\t/* UnmapNotify */\n\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f A tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 0);\n\t\t\t} else if ( !(prev & is_exist) && (curr & is_exist)) {\n\t\t\t\t/* CreateNotify */\n\t\t\t\tif (0) fprintf(stderr, \"CreateNotify:%d/%d  %d               %.4f whist: %d/%d 0x%x tot=%d\\n\", prev, curr, win, dnowx(), whist_prv, whist_idx, win, totcnt); \n\t\t\t\tmacosx_add_create(win, macwins[i].level);\n\t\t\t\tif (curr & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"MapNotify:   %d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, macwins[i].level, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (whist_skip) {\n\t\t\t\t;\n\t\t\t} else if (nv >= NBMAX) {\n\t\t\t\t;\n\t\t\t} else if (!(curr & is_mapped)) {\n\t\t\t\t;\n\t\t\t} else if (!(prev & is_mapped)) {\n\t\t\t\tif (1) {\n\t\t\t\t\t;\n\t\t\t\t} else if (curr & is_clipped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif        ( !(prev & is_clipped) &&  (curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               OBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 1;\n\t\t\t\t} else if (  (prev & is_clipped) && !(curr & is_clipped) ) {\n\t\t\t\t\tif (0) fprintf(stderr, \"VisibNotify: %d/%d  %d               UNOBS tot=%d\\n\", prev, curr, win, totcnt); \n\t\t\t\t\tnv_win[nv] = win;\n\t\t\t\t\tnv_lvl[nv] = macwins[i].level;\n\t\t\t\t\tnv_vis[nv++] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < maxwin; i++) {\n\t\t\tchar prev, curr;\n\t\t\tint win = i;\n\t\t\tint q = qlook[i];\n\t\t\tint lvl = 0;\n\n\t\t\tif (whist_skip) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (q >= 0) {\n\t\t\t\tlvl = macwins[q].level;\t\n\t\t\t}\n\t\t\tcurr = whist[whist_idx][win];\n\t\t\tprev = whist[whist_prv][win];\n\t\t\tif (!(curr & is_exist) && (prev & is_exist)) {\n\t\t\t\tif (prev & is_mapped) {\n\t\t\t\t\tif (0) fprintf(stderr, \"UnmapNotify: %d/%d  %d               %.4f B tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\t\tmacosx_add_mapnotify(win, lvl, 0);\n\t\t\t\t}\n\t\t\t\t/* DestroyNotify */\n\t\t\t\tif (0) fprintf(stderr, \"DestroNotify:%d/%d  %d               %.4f tot=%d\\n\", prev, curr, win, dnowx(), totcnt); \n\t\t\t\tmacosx_add_destroy(win, lvl);\n\t\t\t}\n\t\t}\n\t\tif (nv) {\n\t\t\tint k;\n\t\t\tfor (k = 0; k < nv; k++) {\n\t\t\t\tmacosx_add_visnotify(nv_win[k], nv_lvl[k], nv_vis[k]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_offscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "255-257",
    "snippet": "static int check_offscreen(int win) {\n\treturn macosx_check_offscreen(win);\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_check_offscreen",
          "args": [
            "win"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_check_offscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "679-706",
          "snippet": "int macosx_check_offscreen(int win) {\n\tsraRegionPtr r0, r1;\n\tint x1, y1, x2, y2;\n\tint ret;\n\tint i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\n\tif (sraRgnAnd(r1, r0)) {\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_check_offscreen(int win) {\n\tsraRegionPtr r0, r1;\n\tint x1, y1, x2, y2;\n\tint ret;\n\tint i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\n\tif (sraRgnAnd(r1, r0)) {\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic int check_offscreen(int win) {\n\treturn macosx_check_offscreen(win);\n}"
  },
  {
    "function_name": "check_clipped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "243-253",
    "snippet": "static int check_clipped(int win) {\n\tint i, n = 0, win2;\n\tfor (i = 0; i < (int) _wins_mapped_cnt; i++) {\n\t\twin2 = (int) _wins_mapped[i];\n\t\tif (win2 == win) {\n\t\t\tbreak;\n\t\t}\n\t\t_wins_int[n++] = win2;\n\t}\n\treturn macosx_check_clipped(win, _wins_int, n);\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_check_clipped",
          "args": [
            "win",
            "_wins_int",
            "n"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_check_clipped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "708-748",
          "snippet": "int macosx_check_clipped(int win, int *list, int n) {\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, x2, y2;\n\tint ret = 0;\n\tint k, j, i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\tsraRgnAnd(r1, r0);\n\n\tfor (k = 0; k < n; k++) {\n\t\tj = macosxCGS_find_index(list[k]);\t/* XXX slow? */\n\t\tif (j < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[j].x;\n\t\ty1 = macwins[j].y;\n\t\tx2 = macwins[j].x + macwins[j].width;\n\t\ty2 = macwins[j].y + macwins[j].height;\n\t\tr2 = sraRgnCreateRect(x1, y1, x2, y2);\n\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\tret = 1;\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\n\nint macosx_check_clipped(int win, int *list, int n) {\n\tsraRegionPtr r0, r1, r2;\n\tint x1, y1, x2, y2;\n\tint ret = 0;\n\tint k, j, i = macosxCGS_find_index(win);\n\n\tif (i < 0) {\n\t\treturn 0;\n\t}\n\n\tx1 = macwins[i].x;\n\ty1 = macwins[i].y;\n\tx2 = macwins[i].x + macwins[i].width;\n\ty2 = macwins[i].y + macwins[i].height;\n\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tr1 = sraRgnCreateRect(x1, y1, x2, y2);\n\tsraRgnAnd(r1, r0);\n\n\tfor (k = 0; k < n; k++) {\n\t\tj = macosxCGS_find_index(list[k]);\t/* XXX slow? */\n\t\tif (j < 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = macwins[j].x;\n\t\ty1 = macwins[j].y;\n\t\tx2 = macwins[j].x + macwins[j].width;\n\t\ty2 = macwins[j].y + macwins[j].height;\n\t\tr2 = sraRgnCreateRect(x1, y1, x2, y2);\n\t\tif (sraRgnAnd(r2, r1)) {\n\t\t\tret = 1;\n\t\t\tsraRgnDestroy(r2);\n\t\t\tbreak;\n\t\t}\n\t\tsraRgnDestroy(r2);\n\t}\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(r1);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic int check_clipped(int win) {\n\tint i, n = 0, win2;\n\tfor (i = 0; i < (int) _wins_mapped_cnt; i++) {\n\t\twin2 = (int) _wins_mapped[i];\n\t\tif (win2 == win) {\n\t\t\tbreak;\n\t\t}\n\t\t_wins_int[n++] = win2;\n\t}\n\treturn macosx_check_clipped(win, _wins_int, n);\n}"
  },
  {
    "function_name": "macosxCGS_follow_animation_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "176-238",
    "snippet": "int macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" chase: %03dx%03d+%03d+%03d  %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "win"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSGetScreenRectForWindow",
          "args": [
            "cid",
            "win",
            "&rect"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGS_find_index",
          "args": [
            "win"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_find_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "143-168",
          "snippet": "int macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_CGSDefaultConnection",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_follow_animation_win(int win, int idx, int grow) {\n\tdouble t = dnow();\n\tint diffs = 0;\n\tint x, y, w, h;\n\tint xp = -1, yp = -1, wp = -1, hp = -1;\n\tCGSRect rect;\n\tCGSError err; \n\n\tint reps = 0;\n\n\tif (cid == NULL) {\n\t\tcid = _CGSDefaultConnection();\n\t\tif (cid == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (idx < 0) {\n\t\tidx = macosxCGS_find_index(win); \n\t}\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\n\twhile (dnow() < t + 0.001 * macosx_icon_anim_time)  {\n\t\terr = CGSGetScreenRectForWindow(cid, win, &rect);\n\t\tif (err != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tx = (int) rect.origin.x;\n\t\ty = (int) rect.origin.y;\n\t\tw = (int) rect.size.width;\n\t\th = (int) rect.size.height;\n\n\t\tif (grow) {\n\t\t\tmacwins[idx].x      = x;\n\t\t\tmacwins[idx].y      = y;\n\t\t\tmacwins[idx].width  = w;\n\t\t\tmacwins[idx].height = h;\n\t\t}\n\t\n\t\tif (0) fprintf(stderr, \" chase: %03dx%03d+%03d+%03d  %d\\n\", w, h, x, y, win);\n\t\tif (x == xp && y == yp && w == wp && h == hp)  {\n\t\t\treps++;\n\t\t\tif (reps >= 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdiffs++;\n\t\t\treps = 0;\n\t\t}\n\t\txp = x;\n\t\typ = y;\n\t\twp = w;\n\t\thp = h;\n\t\tusleep(50 * 1000);\n\t}\n\tif (diffs >= 2) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "macosxCGS_find_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "143-168",
    "snippet": "int macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCGS_get_qlook",
          "args": [
            "w"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGS_get_qlook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "136-141",
          "snippet": "int macosxCGS_get_qlook(int w) {\n\tif (w >= WINHISTNUM) {\n\t\treturn -1;\n\t}\n\treturn qlook[w];\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define WINHISTNUM 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTNUM 32768\n\nint macosxCGS_get_qlook(int w) {\n\tif (w >= WINHISTNUM) {\n\t\treturn -1;\n\t}\n\treturn qlook[w];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGS_find_index(int w) {\n\tstatic int last_index = -1;\n\tint idx;\n\n\tif (last_index >= 0) {\n\t\tif (macwins[last_index].win == w) {\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\tidx = macosxCGS_get_qlook(w);\n\tif (idx >= 0) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\n\tfor (idx=0; idx < macwinmax; idx++) {\n\t\tif (macwins[idx].win == w) {\n\t\t\tlast_index = idx;\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "macosxCGS_get_qlook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "136-141",
    "snippet": "int macosxCGS_get_qlook(int w) {\n\tif (w >= WINHISTNUM) {\n\t\treturn -1;\n\t}\n\treturn qlook[w];\n}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [
      "#define WINHISTNUM 32768"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define WINHISTNUM 32768\n\nint macosxCGS_get_qlook(int w) {\n\tif (w >= WINHISTNUM) {\n\t\treturn -1;\n\t}\n\treturn qlook[w];\n}"
  },
  {
    "function_name": "macosxCGS_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
    "lines": "40-40",
    "snippet": "void macosxCGS_unused(void) {}",
    "includes": [
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCGS_unused(void) {}"
  }
]