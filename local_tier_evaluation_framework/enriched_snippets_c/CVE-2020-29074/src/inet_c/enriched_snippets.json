[
  {
    "function_name": "listen_tcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "895-938",
    "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int listen6(int port);",
      "int connect_tcp(char *host, int port);",
      "int listen_tcp(int port, in_addr_t iface, int try6);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "listen6",
          "args": [
            "port"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "listen6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "538-653",
          "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\""
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen_tcp: listen failed\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbListenOnTCPPort",
          "args": [
            "port",
            "iface"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\"",
            "port",
            "try6"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
  },
  {
    "function_name": "connect_tcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "716-893",
    "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *host2ip(char *host);",
      "int ipv6_ip(char *host);",
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);",
      "int listen6(int port);",
      "int accept_unix(int s);",
      "int connect_tcp(char *host, int port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host2"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"connect_tcp[ipv4]: connection failed\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbConnectToTcpAddr",
          "args": [
            "host3",
            "port"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\"",
            "host2"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotted_ip",
          "args": [
            "host3",
            "0"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "dotted_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "175-204",
          "snippet": "int dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "char *raw2host(char *raw, int len);",
            "int ipv6_ip(char *host);",
            "int dotted_ip(char *host, int partial);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint dotted_ip(char *host, int partial);\n\nint dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"::ffff:\""
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "host2",
            "\"::FFFF:\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "host2",
            "\"::ffff:\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "host2",
            "']'"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host+1"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"connect_tcp[ipv6]: connect\""
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: connect OK\\n\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\""
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sock",
            "ap->ai_addr",
            "ap->ai_addrlen"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "enc_connections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1721-2075",
          "snippet": "static void enc_connections(int listen_port, char *connect_host, int connect_port) {\n\tint listen_fd = -1, listen_fd6 = -1, conn1 = -1, conn2 = -1, ret, one = 1;\n\tsocklen_t clen;\n\tstruct hostent *hp;\n\tstruct sockaddr_in client, server;\n\tfd_set fds;\n\tint maxfd = -1;\n\n\t/* zero means use stdio (preferably from socketpair()) */\n\tif (listen_port == 0) {\n\t\tconn1 = fileno(stdin);\n\t\tgoto use_stdio;\n\t}\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto use_stdio;\n\t}\n\n\t/* fd=n,m means use the supplied already established sockets */\n\tif (sscanf(connect_host, \"fd=%d,%d\", &conn1, &conn2) == 2) {\n\t\tgoto use_input_fds;\n\t}\n\n\t/* create the listening socket: */\n\tmemset(&client, 0, sizeof(client));\n\tclient.sin_family = AF_INET;\n\tif (listen_port < 0) {\n\t\t/* negative port means use loopback */\n\t\tclient.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tclient.sin_port = htons(-listen_port);\n\t} else {\n\t\tclient.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tclient.sin_port = htons(listen_port);\n\t}\n\n\tlisten_fd = socket(AF_INET, SOCK_STREAM, 0); \n\tif (listen_fd < 0) {\n\t\tperror(\"socket\");\n\t\tgoto try6;\n\t}\n\n\tret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR,\n\t    (char *)&one, sizeof(one));\n\tif (ret < 0) {\n\t\tperror(\"setsockopt\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = bind(listen_fd, (struct sockaddr *) &client, sizeof(client));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = listen(listen_fd, 2);\n\tif (ret < 0) {\n\t\tperror(\"listen\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\ttry6:\n#ifdef AF_INET6\n\tif (!getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tstruct sockaddr_in6 sin;\n\t\tint one = 1, sock = -1;\n\n\t\tsock = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket6\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 SO_REUSEADDR\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 IPV6_V6ONLY\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n#endif\n\n\t\tmemset((char *)&sin, 0, sizeof(sin));\n\t\tsin.sin6_family = AF_INET6;\n\n\t\tif (listen_port < 0) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t\tsin.sin6_port = htons(-listen_port);\n\t\t} else {\n\t\t\tsin.sin6_addr = in6addr_any;\n\t\t\tsin.sin6_port = htons(listen_port);\n\t\t}\n\n\t\tif (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\t\tperror(\"bind6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (listen(sock, 2) < 0) {\n\t\t\tperror(\"listen6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfail:\n\t\tlisten_fd6 = sock;\n\t}\n#endif\n\n\tif (listen_fd < 0 && listen_fd6 < 0) {\n\t\tfprintf(stderr, \"%s: could not listen on port: %d\\n\",\n\t\t    prog, listen_port);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"%s: waiting for connection on port: %d\\n\",\n\t    prog, listen_port);\n\n\t/* wait for a connection: */\n\tFD_ZERO(&fds);\n\tif (listen_fd >= 0) {\n\t\tFD_SET(listen_fd, &fds);\n\t\tif (listen_fd > maxfd) {\n\t\t\tmaxfd = listen_fd;\n\t\t}\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tFD_SET(listen_fd6, &fds);\n\t\tif (listen_fd6 > maxfd) {\n\t\t\tmaxfd = listen_fd6;\n\t\t}\n\t}\n\tif (select(maxfd+1, &fds, NULL, NULL, NULL) <= 0) {\n\t\tperror(\"select\");\n\t\texit(1);\n\t}\n\n\tif (FD_ISSET(listen_fd, &fds)) {\n\t\tclen = sizeof(client);\n\t\tconn1 = accept(listen_fd, (struct sockaddr *) &client, &clen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t} else if (FD_ISSET(listen_fd6, &fds)) {\n#ifdef AF_INET6\n\t\tstruct sockaddr_in6 addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\n\t\tconn1 = accept(listen_fd6, (struct sockaddr *) &addr, &addrlen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept6\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tfprintf(stderr, \"No IPv6 / AF_INET6 support.\\n\");\n\t\texit(1);\n#endif\n\t}\n\n\tif (setsockopt(conn1, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t\texit(1);\n\t}\n\n\t/* done with the listening socket(s): */\n\tif (listen_fd >= 0) {\n\t\tclose(listen_fd);\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tclose(listen_fd6);\n\t}\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_BG\")) {\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\tfprintf(stderr, \"%s: putting child %d in background.\\n\",\n\t\t\t    prog, p);\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"%s: could not fork\\n\", prog);\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\tfprintf(stderr, \"%s: setsid failed\\n\", prog);\n\t\t\tperror(\"setsid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t}\n\n\tuse_stdio:\n\n\tfprintf(stderr, \"%s: got connection: %d\\n\", prog, conn1);\n\n\t/* now connect to remote server: */\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family = AF_INET;\n\tserver.sin_port = htons(connect_port);\n\n\tif ((server.sin_addr.s_addr = inet_addr(connect_host)) == htonl(INADDR_NONE)) {\n\t\tif (!(hp = gethostbyname(connect_host))) {\n\t\t\tperror(\"gethostbyname\");\n\t\t\tgoto tryconn6;\n\t\t}\n\t\tserver.sin_addr.s_addr = *(unsigned long *)hp->h_addr;\n\t}\n\n\tconn2 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (conn2 < 0) {\n\t\tperror(\"socket\");\n\t\tgoto tryconn6;\n\t}\n\n\tif (connect(conn2, (struct sockaddr *)&server, (sizeof(server))) < 0) {\n\t\tperror(\"connect\");\n\t\tgoto tryconn6;\n\t}\n\n\ttryconn6:\n#ifdef AF_INET6\n\tif (conn2 < 0 && !getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32];\n\n\t\tfprintf(stderr, \"connect[ipv6]: trying to connect via IPv6 to %s\\n\", connect_host);\n\t\tconn2 = -1;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", connect_port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\terr = getaddrinfo(connect_host, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint fd = -1;\n\t\t\t\tfd = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tperror(\"socket6\");\n\t\t\t\t} else {\n\t\t\t\t\tint dmsg = 0; \n\t\t\t\t\tint res = connect(fd, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\tperror(\"connect6\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\tfprintf(stderr, \"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(fd, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tconn2 = fd; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) perror(\"connect6\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t}\n#endif\n\tif (conn2 < 0) {\n\t\tfprintf(stderr, \"could not connect to %s\\n\", connect_host);\n\t\texit(1);\n\t}\n\tif (conn2 >= 0 && setsockopt(conn2, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t}\n\n\tuse_input_fds:\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tshow_cert(conn2);\n\t\tclose(conn2);\n\t\texit(0);\n\t}\n\n\tif (securevnc) {\n\t\tsecurevnc_setup(conn1, conn2);\n\t}\n\n\t/* fork into two processes; one for each direction: */\n\tparent = getpid();\n\t\n\tchild = fork();\n\t\n\tif (child == (pid_t) -1) {\n\t\t/* couldn't fork... */\n\t\tperror(\"fork\");\n\t\tclose(conn1);\n\t\tclose(conn2);\n\t\texit(1);\n\t}\n\n\t/* Do transfer/encode/decode loop: */\n\n\tif (child == 0) {\n\t\t/* encrypter: local-viewer -> remote-server */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn1, conn2);\n\t\t} else {\n\t\t\tenc_xfer(conn1, conn2, 1);\n\t\t}\n\t} else {\n\t\t/* decrypter: remote-server -> local-viewer */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn2, conn1);\n\t\t} else {\n\t\t\tenc_xfer(conn2, conn1, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SOL_IPV6 IPPROTO_IPV6",
            "#define INADDR_NONE ((in_addr_t) 0xffffffff)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SOL_IPV6 IPPROTO_IPV6\n#define INADDR_NONE ((in_addr_t) 0xffffffff)\n\nstatic void enc_connections(int listen_port, char *connect_host, int connect_port) {\n\tint listen_fd = -1, listen_fd6 = -1, conn1 = -1, conn2 = -1, ret, one = 1;\n\tsocklen_t clen;\n\tstruct hostent *hp;\n\tstruct sockaddr_in client, server;\n\tfd_set fds;\n\tint maxfd = -1;\n\n\t/* zero means use stdio (preferably from socketpair()) */\n\tif (listen_port == 0) {\n\t\tconn1 = fileno(stdin);\n\t\tgoto use_stdio;\n\t}\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto use_stdio;\n\t}\n\n\t/* fd=n,m means use the supplied already established sockets */\n\tif (sscanf(connect_host, \"fd=%d,%d\", &conn1, &conn2) == 2) {\n\t\tgoto use_input_fds;\n\t}\n\n\t/* create the listening socket: */\n\tmemset(&client, 0, sizeof(client));\n\tclient.sin_family = AF_INET;\n\tif (listen_port < 0) {\n\t\t/* negative port means use loopback */\n\t\tclient.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tclient.sin_port = htons(-listen_port);\n\t} else {\n\t\tclient.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tclient.sin_port = htons(listen_port);\n\t}\n\n\tlisten_fd = socket(AF_INET, SOCK_STREAM, 0); \n\tif (listen_fd < 0) {\n\t\tperror(\"socket\");\n\t\tgoto try6;\n\t}\n\n\tret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR,\n\t    (char *)&one, sizeof(one));\n\tif (ret < 0) {\n\t\tperror(\"setsockopt\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = bind(listen_fd, (struct sockaddr *) &client, sizeof(client));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = listen(listen_fd, 2);\n\tif (ret < 0) {\n\t\tperror(\"listen\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\ttry6:\n#ifdef AF_INET6\n\tif (!getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tstruct sockaddr_in6 sin;\n\t\tint one = 1, sock = -1;\n\n\t\tsock = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket6\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 SO_REUSEADDR\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 IPV6_V6ONLY\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n#endif\n\n\t\tmemset((char *)&sin, 0, sizeof(sin));\n\t\tsin.sin6_family = AF_INET6;\n\n\t\tif (listen_port < 0) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t\tsin.sin6_port = htons(-listen_port);\n\t\t} else {\n\t\t\tsin.sin6_addr = in6addr_any;\n\t\t\tsin.sin6_port = htons(listen_port);\n\t\t}\n\n\t\tif (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\t\tperror(\"bind6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (listen(sock, 2) < 0) {\n\t\t\tperror(\"listen6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfail:\n\t\tlisten_fd6 = sock;\n\t}\n#endif\n\n\tif (listen_fd < 0 && listen_fd6 < 0) {\n\t\tfprintf(stderr, \"%s: could not listen on port: %d\\n\",\n\t\t    prog, listen_port);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"%s: waiting for connection on port: %d\\n\",\n\t    prog, listen_port);\n\n\t/* wait for a connection: */\n\tFD_ZERO(&fds);\n\tif (listen_fd >= 0) {\n\t\tFD_SET(listen_fd, &fds);\n\t\tif (listen_fd > maxfd) {\n\t\t\tmaxfd = listen_fd;\n\t\t}\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tFD_SET(listen_fd6, &fds);\n\t\tif (listen_fd6 > maxfd) {\n\t\t\tmaxfd = listen_fd6;\n\t\t}\n\t}\n\tif (select(maxfd+1, &fds, NULL, NULL, NULL) <= 0) {\n\t\tperror(\"select\");\n\t\texit(1);\n\t}\n\n\tif (FD_ISSET(listen_fd, &fds)) {\n\t\tclen = sizeof(client);\n\t\tconn1 = accept(listen_fd, (struct sockaddr *) &client, &clen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t} else if (FD_ISSET(listen_fd6, &fds)) {\n#ifdef AF_INET6\n\t\tstruct sockaddr_in6 addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\n\t\tconn1 = accept(listen_fd6, (struct sockaddr *) &addr, &addrlen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept6\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tfprintf(stderr, \"No IPv6 / AF_INET6 support.\\n\");\n\t\texit(1);\n#endif\n\t}\n\n\tif (setsockopt(conn1, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t\texit(1);\n\t}\n\n\t/* done with the listening socket(s): */\n\tif (listen_fd >= 0) {\n\t\tclose(listen_fd);\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tclose(listen_fd6);\n\t}\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_BG\")) {\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\tfprintf(stderr, \"%s: putting child %d in background.\\n\",\n\t\t\t    prog, p);\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"%s: could not fork\\n\", prog);\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\tfprintf(stderr, \"%s: setsid failed\\n\", prog);\n\t\t\tperror(\"setsid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t}\n\n\tuse_stdio:\n\n\tfprintf(stderr, \"%s: got connection: %d\\n\", prog, conn1);\n\n\t/* now connect to remote server: */\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family = AF_INET;\n\tserver.sin_port = htons(connect_port);\n\n\tif ((server.sin_addr.s_addr = inet_addr(connect_host)) == htonl(INADDR_NONE)) {\n\t\tif (!(hp = gethostbyname(connect_host))) {\n\t\t\tperror(\"gethostbyname\");\n\t\t\tgoto tryconn6;\n\t\t}\n\t\tserver.sin_addr.s_addr = *(unsigned long *)hp->h_addr;\n\t}\n\n\tconn2 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (conn2 < 0) {\n\t\tperror(\"socket\");\n\t\tgoto tryconn6;\n\t}\n\n\tif (connect(conn2, (struct sockaddr *)&server, (sizeof(server))) < 0) {\n\t\tperror(\"connect\");\n\t\tgoto tryconn6;\n\t}\n\n\ttryconn6:\n#ifdef AF_INET6\n\tif (conn2 < 0 && !getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32];\n\n\t\tfprintf(stderr, \"connect[ipv6]: trying to connect via IPv6 to %s\\n\", connect_host);\n\t\tconn2 = -1;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", connect_port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\terr = getaddrinfo(connect_host, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint fd = -1;\n\t\t\t\tfd = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tperror(\"socket6\");\n\t\t\t\t} else {\n\t\t\t\t\tint dmsg = 0; \n\t\t\t\t\tint res = connect(fd, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\tperror(\"connect6\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\tfprintf(stderr, \"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(fd, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tconn2 = fd; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) perror(\"connect6\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t}\n#endif\n\tif (conn2 < 0) {\n\t\tfprintf(stderr, \"could not connect to %s\\n\", connect_host);\n\t\texit(1);\n\t}\n\tif (conn2 >= 0 && setsockopt(conn2, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t}\n\n\tuse_input_fds:\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tshow_cert(conn2);\n\t\tclose(conn2);\n\t\texit(0);\n\t}\n\n\tif (securevnc) {\n\t\tsecurevnc_setup(conn1, conn2);\n\t}\n\n\t/* fork into two processes; one for each direction: */\n\tparent = getpid();\n\t\n\tchild = fork();\n\t\n\tif (child == (pid_t) -1) {\n\t\t/* couldn't fork... */\n\t\tperror(\"fork\");\n\t\tclose(conn1);\n\t\tclose(conn2);\n\t\texit(1);\n\t}\n\n\t/* Do transfer/encode/decode loop: */\n\n\tif (child == 0) {\n\t\t/* encrypter: local-viewer -> remote-server */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn1, conn2);\n\t\t} else {\n\t\t\tenc_xfer(conn1, conn2, 1);\n\t\t}\n\t} else {\n\t\t/* decrypter: remote-server -> local-viewer */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn2, conn1);\n\t\t} else {\n\t\t\tenc_xfer(conn2, conn1, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sock",
            "SOL_IPV6",
            "IPV6_V6ONLY",
            "(char *)&zero",
            "sizeof(zero)"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"connect_tcp[ipv6]: connect\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\"",
            "sock",
            "ap->ai_family",
            "ap->ai_protocol",
            "s"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_getipaddr",
          "args": [
            "ap->ai_addr",
            "ap->ai_addrlen"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_getipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "525-536",
          "snippet": "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);",
            "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);\n\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"(Ignore the above error if this system is IPv4-only.)\\n\""
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"connect_tcp[ipv6]: socket\""
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ap->ai_family",
            "ap->ai_socktype",
            "ap->ai_protocol"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_V4MAPPED",
          "args": [
            "&(s6ptr->sin6_addr)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\"",
            "err",
            "gai_strerror(err)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "err"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "host2",
            "service",
            "&hints",
            "&ai"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\"",
            "err",
            "gai_strerror(err)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "err"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "host2",
            "service",
            "&hints",
            "&ai"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "host2",
            "']'"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host+1"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"::1\""
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "host",
            "\"127.0.0.1\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\"",
            "host"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_ip",
          "args": [
            "host"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "138-173",
          "snippet": "int ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nint ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "service",
            "\"%d\"",
            "port"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp: trying IPv6 %s %d\\n\"",
            "host",
            "port"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"connect_tcp: connection failed\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbConnectToTcpAddr",
          "args": [
            "host",
            "port"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp: re-trying %s %d\\n\"",
            "host",
            "port"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"connect_tcp: connection failed\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbConnectToTcpAddr",
          "args": [
            "host",
            "port"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"TESTING: IPV4_FAILS for connect_tcp.\\n\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_tcp: trying:   %s %d\\n\"",
            "host",
            "port"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"IPV4_FAILS\""
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
  },
  {
    "function_name": "accept_unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "698-714",
    "snippet": "int accept_unix(int s) {\n#if !defined(AF_UNIX) || !defined(LIBVNCSERVER_HAVE_SYS_SOCKET_H)\n\tif (s) {}\n\treturn -1;\n#else\n\tint fd;\n\tsocklen_t fromlen;\n\tstruct sockaddr_un fsaun;\n\n\tfd = accept(s, (struct sockaddr *)&fsaun, &fromlen);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"accept_unix: accept\");\n\t\treturn -1;\n\t}\n\treturn fd;\n#endif\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int accept_unix(int s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"accept_unix: accept\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "s",
            "(struct sockaddr *)&fsaun",
            "&fromlen"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint accept_unix(int s);\n\nint accept_unix(int s) {\n#if !defined(AF_UNIX) || !defined(LIBVNCSERVER_HAVE_SYS_SOCKET_H)\n\tif (s) {}\n\treturn -1;\n#else\n\tint fd;\n\tsocklen_t fromlen;\n\tstruct sockaddr_un fsaun;\n\n\tfd = accept(s, (struct sockaddr *)&fsaun, &fromlen);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"accept_unix: accept\");\n\t\treturn -1;\n\t}\n\treturn fd;\n#endif\n}"
  },
  {
    "function_name": "listen_unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "659-696",
    "snippet": "int listen_unix(char *file) {\n#if !defined(AF_UNIX) || !defined(LIBVNCSERVER_HAVE_SYS_SOCKET_H)\n\tif (sock) {}\n\treturn -1;\n#else\n\tint s, len;\n\tstruct sockaddr_un saun;\n\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (s < 0) {\n\t\trfbLogPerror(\"listen_unix: socket\");\n\t\treturn -1;\n\t}\n\tsaun.sun_family = AF_UNIX;\n\tif(strlen(file) + 1 > sizeof(saun.sun_path)) {\n\t        rfbLogPerror(\"listen_unix: socket name too long\");\n\t\treturn -1;\n\t}\n\tstrcpy(saun.sun_path, file);\n\tunlink(file);\n\n\tlen = sizeof(saun.sun_family) + strlen(saun.sun_path);\n\n\tif (bind(s, (struct sockaddr *)&saun, len) < 0) {\n\t\trfbLogPerror(\"listen_unix: bind\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\tif (listen(s, 32) < 0) {\n\t\trfbLogPerror(\"listen_unix: listen\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\trfbLog(\"listening on unix socket: %s fd=%d\\n\", file, s);\n\treturn s;\n#endif\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *raw2host(char *raw, int len);",
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);",
      "int listen_unix(char *file);",
      "int accept_unix(int s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"listening on unix socket: %s fd=%d\\n\"",
            "file",
            "s"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen_unix: listen\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "s",
            "32"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen_unix: bind\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "s",
            "(struct sockaddr *)&saun",
            "len"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "saun.sun_path"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "file"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "saun.sun_path",
            "file"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen_unix: socket name too long\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "file"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen_unix: socket\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *raw2host(char *raw, int len);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen_unix(char *file);\nint accept_unix(int s);\n\nint listen_unix(char *file) {\n#if !defined(AF_UNIX) || !defined(LIBVNCSERVER_HAVE_SYS_SOCKET_H)\n\tif (sock) {}\n\treturn -1;\n#else\n\tint s, len;\n\tstruct sockaddr_un saun;\n\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (s < 0) {\n\t\trfbLogPerror(\"listen_unix: socket\");\n\t\treturn -1;\n\t}\n\tsaun.sun_family = AF_UNIX;\n\tif(strlen(file) + 1 > sizeof(saun.sun_path)) {\n\t        rfbLogPerror(\"listen_unix: socket name too long\");\n\t\treturn -1;\n\t}\n\tstrcpy(saun.sun_path, file);\n\tunlink(file);\n\n\tlen = sizeof(saun.sun_family) + strlen(saun.sun_path);\n\n\tif (bind(s, (struct sockaddr *)&saun, len) < 0) {\n\t\trfbLogPerror(\"listen_unix: bind\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n\tif (listen(s, 32) < 0) {\n\t\trfbLogPerror(\"listen_unix: listen\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\trfbLog(\"listening on unix socket: %s fd=%d\\n\", file, s);\n\treturn s;\n#endif\n}"
  },
  {
    "function_name": "listen6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "538-653",
    "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int listen6(int port);",
      "int accept_unix(int s);",
      "int connect_tcp(char *host, int port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen6: listen\""
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "fd",
            "32"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen6: bind\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "fd",
            "(struct sockaddr *) &sin",
            "sizeof(sin)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "listen_str",
            "\"localhost\""
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "allow_list",
            "\"127.0.0.1\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Invalid or Unsupported -listen6 string: %s\\n\"",
            "listen_str6"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"listen6: using:    %s scope_id: %d\\n\"",
            "s",
            "sin.sin6_scope_id"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)&sin",
            "ap->ai_addr",
            "sizeof(sin)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"listen6: checking: %s family: %d\\n\"",
            "s",
            "ap->ai_family"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_getipaddr",
          "args": [
            "ap->ai_addr",
            "ap->ai_addrlen"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_getipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "525-536",
          "snippet": "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);",
            "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);\n\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "listen_str6",
            "service",
            "&hints",
            "&ai"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_ip",
          "args": [
            "listen_str6"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "138-173",
          "snippet": "int ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nint ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "service",
            "\"%d\"",
            "port"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "listen_str6",
            "\"::1\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "listen_str6",
            "\"localhost\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&sin",
            "0",
            "sizeof(sin)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen6: setsockopt IPV6_V6ONLY\""
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_IPV6",
            "IPV6_V6ONLY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen6: setsockopt SO_REUSEADDR\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"(Ignore the above error if this system is IPv4-only.)\\n\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"listen6: socket\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET6",
            "SOCK_STREAM",
            "0"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
  },
  {
    "function_name": "ipv6_getipaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "525-536",
    "snippet": "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);",
      "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "paddr",
            "addrlen",
            "name",
            "sizeof(name)",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);\n\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}"
  },
  {
    "function_name": "ipv6_getnameinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "512-523",
    "snippet": "char *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, 0) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);",
      "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "name"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "paddr",
            "addrlen",
            "name",
            "sizeof(name)",
            "NULL",
            "0",
            "0"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);\n\nchar *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, 0) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}"
  },
  {
    "function_name": "have_ssh_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "449-510",
    "snippet": "int have_ssh_env(void) {\n\tchar *str, *p = getenv(\"SSH_CONNECTION\");\n\tchar *rhost, *rport, *lhost, *lport;\n\t\n\tif (! p) {\n\t\tchar *q = getenv(\"SSH_CLIENT\");\n\t\tif (! q) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (strstr(q, \"127.0.0.1\") != NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (strstr(p, \"127.0.0.1\") != NULL) {\n\t\treturn 0;\n\t}\n\n\tstr = strdup(p);\n\t\n\tp = strtok(str, \" \");\n\trhost = p;\n\n\tp = strtok(NULL, \" \");\n\tif (! p) goto fail;\n\n\trport = p;\n\n\tp = strtok(NULL, \" \");\n\tif (! p) goto fail;\n\n\tlhost = p;\n\t\n\tp = strtok(NULL, \" \");\n\tif (! p) goto fail;\n\n\tlport = p;\n\nif (0) fprintf(stderr, \"%d/%d - '%s' '%s'\\n\", atoi(rport), atoi(lport), rhost, lhost);\n\n\tif (atoi(rport) <= 16 || atoi(rport) > 65535) {\n\t\tgoto fail;\n\t}\n\tif (atoi(lport) <= 16 || atoi(lport) > 65535) {\n\t\tgoto fail;\n\t}\n\n\tif (!strcmp(rhost, lhost)) {\n\t\tgoto fail;\n\t}\n\n\tfree(str);\n\n\treturn 1;\n\t\n\tfail:\n\n\tfree(str);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int have_ssh_env(void);",
      "int accept_unix(int s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rhost",
            "lhost"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "lport"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "lport"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "rport"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "rport"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d/%d - '%s' '%s'\\n\"",
            "atoi(rport)",
            "atoi(lport)",
            "rhost",
            "lhost"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "lport"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "rport"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\" \""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"127.0.0.1\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"127.0.0.1\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSH_CLIENT\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSH_CONNECTION\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint have_ssh_env(void);\nint accept_unix(int s);\n\nint have_ssh_env(void) {\n\tchar *str, *p = getenv(\"SSH_CONNECTION\");\n\tchar *rhost, *rport, *lhost, *lport;\n\t\n\tif (! p) {\n\t\tchar *q = getenv(\"SSH_CLIENT\");\n\t\tif (! q) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (strstr(q, \"127.0.0.1\") != NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (strstr(p, \"127.0.0.1\") != NULL) {\n\t\treturn 0;\n\t}\n\n\tstr = strdup(p);\n\t\n\tp = strtok(str, \" \");\n\trhost = p;\n\n\tp = strtok(NULL, \" \");\n\tif (! p) goto fail;\n\n\trport = p;\n\n\tp = strtok(NULL, \" \");\n\tif (! p) goto fail;\n\n\tlhost = p;\n\t\n\tp = strtok(NULL, \" \");\n\tif (! p) goto fail;\n\n\tlport = p;\n\nif (0) fprintf(stderr, \"%d/%d - '%s' '%s'\\n\", atoi(rport), atoi(lport), rhost, lhost);\n\n\tif (atoi(rport) <= 16 || atoi(rport) > 65535) {\n\t\tgoto fail;\n\t}\n\tif (atoi(lport) <= 16 || atoi(lport) > 65535) {\n\t\tgoto fail;\n\t}\n\n\tif (!strcmp(rhost, lhost)) {\n\t\tgoto fail;\n\t}\n\n\tfree(str);\n\n\treturn 1;\n\t\n\tfail:\n\n\tfree(str);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_free_port6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "431-447",
    "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);",
      "int find_free_port(int start, int end);",
      "int find_free_port6(int start, int end);",
      "int listen6(int port);",
      "int connect_tcp(char *host, int port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen6",
          "args": [
            "port"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "listen6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "538-653",
          "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "find_free_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "413-429",
    "snippet": "int find_free_port(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen_tcp(port, htonl(INADDR_ANY), 0);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);",
      "int find_free_port(int start, int end);",
      "int find_free_port6(int start, int end);",
      "int listen6(int port);",
      "int connect_tcp(char *host, int port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen_tcp",
          "args": [
            "port",
            "htonl(INADDR_ANY)",
            "0"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "listen_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "895-938",
          "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);",
            "int listen_tcp(int port, in_addr_t iface, int try6);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen_tcp(port, htonl(INADDR_ANY), 0);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ident_username",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "266-411",
    "snippet": "char *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *host2ip(char *host);",
      "char *raw2host(char *raw, int len);",
      "int ipv6_ip(char *host);",
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);",
      "char *ident_username(rfbClientPtr client);",
      "int accept_unix(int s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newhost"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%s@%s\"",
            "user",
            "newhost"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "newhost"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "user"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip2host",
          "args": [
            "client->host"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "ip2host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "112-136",
          "snippet": "char *ip2host(char *ip) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\tin_addr_t iaddr;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\tiaddr = inet_addr(ip);\n\tif (iaddr == htonl(INADDR_NONE)) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr((char *)&iaddr, sizeof(in_addr_t), AF_INET);\n\tif (!hp) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *ip2host(char *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ip2host(char *ip);\n\nchar *ip2host(char *ip) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\tin_addr_t iaddr;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\tiaddr = inet_addr(ip);\n\tif (iaddr == htonl(INADDR_NONE)) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr((char *)&iaddr, sizeof(in_addr_t), AF_INET);\n\tif (!hp) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "\"UNIX:\"",
            "user"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "\"unknown-user\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown-user\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "q"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\":\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\":\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "msg",
            "\"USERID\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock",
            "msg",
            "127"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250*1000"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "sock+1",
            "&rfds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "sock",
            "&rfds"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rfds"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock",
            "msg",
            "strlen(msg)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "msg",
            "\"%d, %d\\r\\n\"",
            "rport",
            "lport"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_local_port",
          "args": [
            "client->sock"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "230-232",
          "snippet": "int get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_remote_port",
          "args": [
            "client->sock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "226-228",
          "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ident_username: could not connect to ident: %s:%d\\n\"",
            "client->host",
            "113"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "client->host",
            "113"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "SIG_DFL"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "SIG_DFL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "SIG_DFL"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "SIG_DFL"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ident_username: set refused=1 (exit)\\n\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "rc"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "rc"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&rc2",
            "WNOHANG"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGTERM"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ident_username: set block=1 (hung)\\n\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&rc",
            "WNOHANG"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1500 * 1000"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&rc",
            "WNOHANG"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nchar *ident_username(rfbClientPtr client);\nint accept_unix(int s);\n\nchar *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}"
  },
  {
    "function_name": "get_local_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "262-264",
    "snippet": "char *get_local_host(int sock) {\n\treturn get_host(sock, 0);\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_host",
          "args": [
            "sock",
            "0"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "234-256",
          "snippet": "static char *get_host(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tchar *saddr_ip_str = NULL;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n#if LIBVNCSERVER_HAVE_NETINET_IN_H\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t}\n#endif\n\tif (! saddr_ip_str) {\n\t\tsaddr_ip_str = \"unknown\";\n\t}\n\treturn strdup(saddr_ip_str);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "static int get_port(int sock, int remote);",
            "static char *get_host(int sock, int remote);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nstatic int get_port(int sock, int remote);\nstatic char *get_host(int sock, int remote);\n\nstatic char *get_host(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tchar *saddr_ip_str = NULL;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n#if LIBVNCSERVER_HAVE_NETINET_IN_H\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t}\n#endif\n\tif (! saddr_ip_str) {\n\t\tsaddr_ip_str = \"unknown\";\n\t}\n\treturn strdup(saddr_ip_str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nchar *get_local_host(int sock) {\n\treturn get_host(sock, 0);\n}"
  },
  {
    "function_name": "get_remote_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "258-260",
    "snippet": "char *get_remote_host(int sock) {\n\treturn get_host(sock, 1);\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_host",
          "args": [
            "sock",
            "1"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "get_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "234-256",
          "snippet": "static char *get_host(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tchar *saddr_ip_str = NULL;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n#if LIBVNCSERVER_HAVE_NETINET_IN_H\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t}\n#endif\n\tif (! saddr_ip_str) {\n\t\tsaddr_ip_str = \"unknown\";\n\t}\n\treturn strdup(saddr_ip_str);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "static int get_port(int sock, int remote);",
            "static char *get_host(int sock, int remote);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nstatic int get_port(int sock, int remote);\nstatic char *get_host(int sock, int remote);\n\nstatic char *get_host(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tchar *saddr_ip_str = NULL;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n#if LIBVNCSERVER_HAVE_NETINET_IN_H\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t}\n#endif\n\tif (! saddr_ip_str) {\n\t\tsaddr_ip_str = \"unknown\";\n\t}\n\treturn strdup(saddr_ip_str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nchar *get_remote_host(int sock) {\n\treturn get_host(sock, 1);\n}"
  },
  {
    "function_name": "get_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "234-256",
    "snippet": "static char *get_host(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tchar *saddr_ip_str = NULL;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n#if LIBVNCSERVER_HAVE_NETINET_IN_H\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t}\n#endif\n\tif (! saddr_ip_str) {\n\t\tsaddr_ip_str = \"unknown\";\n\t}\n\treturn strdup(saddr_ip_str);\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);",
      "static int get_port(int sock, int remote);",
      "static char *get_host(int sock, int remote);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "saddr_ip_str"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "saddr.sin_addr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sock",
            "(struct sockaddr *)&saddr",
            "&saddr_len"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "saddr.sin_addr"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "sock",
            "(struct sockaddr *)&saddr",
            "&saddr_len"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&saddr",
            "0",
            "sizeof(saddr)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nstatic int get_port(int sock, int remote);\nstatic char *get_host(int sock, int remote);\n\nstatic char *get_host(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tchar *saddr_ip_str = NULL;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n#if LIBVNCSERVER_HAVE_NETINET_IN_H\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_ip_str = inet_ntoa(saddr.sin_addr);\n\t\t}\n\t}\n#endif\n\tif (! saddr_ip_str) {\n\t\tsaddr_ip_str = \"unknown\";\n\t}\n\treturn strdup(saddr_ip_str);\n}"
  },
  {
    "function_name": "get_local_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "230-232",
    "snippet": "int get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_port",
          "args": [
            "sock",
            "0"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "206-224",
          "snippet": "static int get_port(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tint saddr_port;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n\tsaddr_port = -1;\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t}\n\treturn saddr_port;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "static int get_port(int sock, int remote);",
            "static char *get_host(int sock, int remote);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nstatic int get_port(int sock, int remote);\nstatic char *get_host(int sock, int remote);\n\nstatic int get_port(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tint saddr_port;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n\tsaddr_port = -1;\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t}\n\treturn saddr_port;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}"
  },
  {
    "function_name": "get_remote_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "226-228",
    "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_port",
          "args": [
            "sock",
            "1"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "206-224",
          "snippet": "static int get_port(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tint saddr_port;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n\tsaddr_port = -1;\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t}\n\treturn saddr_port;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "static int get_port(int sock, int remote);",
            "static char *get_host(int sock, int remote);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nstatic int get_port(int sock, int remote);\nstatic char *get_host(int sock, int remote);\n\nstatic int get_port(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tint saddr_port;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n\tsaddr_port = -1;\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t}\n\treturn saddr_port;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
  },
  {
    "function_name": "get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "206-224",
    "snippet": "static int get_port(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tint saddr_port;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n\tsaddr_port = -1;\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t}\n\treturn saddr_port;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_remote_port(int sock);",
      "int get_local_port(int sock);",
      "char *get_remote_host(int sock);",
      "char *get_local_host(int sock);",
      "static int get_port(int sock, int remote);",
      "static char *get_host(int sock, int remote);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "saddr.sin_port"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sock",
            "(struct sockaddr *)&saddr",
            "&saddr_len"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "saddr.sin_port"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "sock",
            "(struct sockaddr *)&saddr",
            "&saddr_len"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&saddr",
            "0",
            "sizeof(saddr)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nstatic int get_port(int sock, int remote);\nstatic char *get_host(int sock, int remote);\n\nstatic int get_port(int sock, int remote) {\n\tstruct sockaddr_in saddr;\n\tunsigned int saddr_len;\n\tint saddr_port;\n\t\n\tsaddr_len = sizeof(saddr);\n\tmemset(&saddr, 0, sizeof(saddr));\n\tsaddr_port = -1;\n\tif (remote) {\n\t\tif (!getpeername(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t} else {\n\t\tif (!getsockname(sock, (struct sockaddr *)&saddr, &saddr_len)) {\n\t\t\tsaddr_port = ntohs(saddr.sin_port);\n\t\t}\n\t}\n\treturn saddr_port;\n}"
  },
  {
    "function_name": "dotted_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "175-204",
    "snippet": "int dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *host2ip(char *host);",
      "char *raw2host(char *raw, int len);",
      "int ipv6_ip(char *host);",
      "int dotted_ip(char *host, int partial);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) (*p)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) host[len-1]"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) host[0]"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint dotted_ip(char *host, int partial);\n\nint dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ipv6_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "138-173",
    "snippet": "int ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *host2ip(char *host);",
      "int ipv6_ip(char *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "a",
            "\":abcdef0123456789\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotted_ip",
          "args": [
            "host + strlen(\"::ffff:\")",
            "0"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "dotted_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "175-204",
          "snippet": "int dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "char *raw2host(char *raw, int len);",
            "int ipv6_ip(char *host);",
            "int dotted_ip(char *host, int partial);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint dotted_ip(char *host, int partial);\n\nint dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"::ffff:\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "host",
            "\"::FFFF:\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "host",
            "\"::ffff:\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nint ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "ip2host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "112-136",
    "snippet": "char *ip2host(char *ip) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\tin_addr_t iaddr;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\tiaddr = inet_addr(ip);\n\tif (iaddr == htonl(INADDR_NONE)) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr((char *)&iaddr, sizeof(in_addr_t), AF_INET);\n\tif (!hp) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *ip2host(char *ip);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "hp->h_name"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostbyaddr",
          "args": [
            "(char *)&iaddr",
            "sizeof(in_addr_t)",
            "AF_INET"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_NONE"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "ip"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ip2host(char *ip);\n\nchar *ip2host(char *ip) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\tin_addr_t iaddr;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\tiaddr = inet_addr(ip);\n\tif (iaddr == htonl(INADDR_NONE)) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr((char *)&iaddr, sizeof(in_addr_t), AF_INET);\n\tif (!hp) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}"
  },
  {
    "function_name": "raw2ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "108-110",
    "snippet": "char *raw2ip(char *raw) {\n\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *raw2ip(char *raw);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "inet_ntoa(*((struct in_addr *)raw))"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "*((struct in_addr *)raw)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *raw2ip(char *raw);\n\nchar *raw2ip(char *raw) {\n\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n}"
  },
  {
    "function_name": "raw2host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "88-106",
    "snippet": "char *raw2host(char *raw, int len) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr(raw, len, AF_INET);\n\tif (!hp) {\n\t\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *raw2host(char *raw, int len);",
      "char *raw2ip(char *raw);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "hp->h_name"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "inet_ntoa(*((struct in_addr *)raw))"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "*((struct in_addr *)raw)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostbyaddr",
          "args": [
            "raw",
            "len",
            "AF_INET"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *raw2host(char *raw, int len);\nchar *raw2ip(char *raw);\n\nchar *raw2host(char *raw, int len) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr(raw, len, AF_INET);\n\tif (!hp) {\n\t\treturn strdup(inet_ntoa(*((struct in_addr *)raw)));\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}"
  },
  {
    "function_name": "host2ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
    "lines": "68-86",
    "snippet": "char *host2ip(char *host) {\n\tstruct hostent *hp;\n\tstruct sockaddr_in addr;\n\tchar *str;\n\n\tif (! host_lookup) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyname(host);\n\tif (!hp) {\n\t\treturn NULL;\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr =  *(unsigned long *)hp->h_addr;\n\tstr = strdup(inet_ntoa(addr.sin_addr));\n\treturn str;\n}",
    "includes": [
      "#include <sys/un.h>",
      "#include \"sslhelper.h\"",
      "#include \"unixpw.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *host2ip(char *host);",
      "int ipv6_ip(char *host);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "inet_ntoa(addr.sin_addr)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "addr.sin_addr"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "host"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nchar *host2ip(char *host) {\n\tstruct hostent *hp;\n\tstruct sockaddr_in addr;\n\tchar *str;\n\n\tif (! host_lookup) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyname(host);\n\tif (!hp) {\n\t\treturn NULL;\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr =  *(unsigned long *)hp->h_addr;\n\tstr = strdup(inet_ntoa(addr.sin_addr));\n\treturn str;\n}"
  }
]