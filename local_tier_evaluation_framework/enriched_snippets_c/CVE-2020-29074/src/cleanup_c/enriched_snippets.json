[
  {
    "function_name": "known_sigpipe_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "767-783",
    "snippet": "int known_sigpipe_mode(char *s) {\n/*\n * skip, ignore, exit\n */\n\tif (strstr(s, \"ignore:\") == s) {\n\t\treturn 1;\n\t}\n\tif (strstr(s, \"exit:\") == s) {\n\t\treturn 1;\n\t}\n\tif (strcmp(s, \"skip\") && strcmp(s, \"ignore\") && \n\t    strcmp(s, \"exit\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_sigpipe_mode(char *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"exit\""
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"ignore\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"skip\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"exit:\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "s",
            "\"ignore:\""
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_sigpipe_mode(char *s);\n\nint known_sigpipe_mode(char *s) {\n/*\n * skip, ignore, exit\n */\n\tif (strstr(s, \"ignore:\") == s) {\n\t\treturn 1;\n\t}\n\tif (strstr(s, \"exit:\") == s) {\n\t\treturn 1;\n\t}\n\tif (strcmp(s, \"skip\") && strcmp(s, \"ignore\") && \n\t    strcmp(s, \"exit\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "close_exec_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "754-765",
    "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void close_exec_fds(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "flags"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFD"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "unset_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "742-752",
    "snippet": "void unset_signals(void) {\n\tsignal(SIGHUP,  SIG_DFL);\n\tsignal(SIGINT,  SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGABRT, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGBUS,  SIG_DFL);\n\tsignal(SIGSEGV, SIG_DFL);\n\tsignal(SIGFPE,  SIG_DFL);\n\tsignal(SIGPIPE, SIG_DFL);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void unset_signals(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_DFL"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGFPE",
            "SIG_DFL"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGSEGV",
            "SIG_DFL"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGBUS",
            "SIG_DFL"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "SIG_DFL"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGABRT",
            "SIG_DFL"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "SIG_DFL"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "SIG_DFL"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "SIG_DFL"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid unset_signals(void);\n\nvoid unset_signals(void) {\n\tsignal(SIGHUP,  SIG_DFL);\n\tsignal(SIGINT,  SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGABRT, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGBUS,  SIG_DFL);\n\tsignal(SIGSEGV, SIG_DFL);\n\tsignal(SIGFPE,  SIG_DFL);\n\tsignal(SIGPIPE, SIG_DFL);\n}"
  },
  {
    "function_name": "initialize_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "707-740",
    "snippet": "void initialize_signals(void) {\n\tsignal(SIGHUP,  interrupted);\n\tsignal(SIGINT,  interrupted);\n\tsignal(SIGQUIT, interrupted);\n\tsignal(SIGABRT, interrupted);\n\tsignal(SIGTERM, interrupted);\n\tsignal(SIGBUS,  interrupted);\n\tsignal(SIGSEGV, interrupted);\n\tsignal(SIGFPE,  interrupted);\n\n\tif (!sigpipe || *sigpipe == '\\0' || !strcmp(sigpipe, \"skip\")) {\n\t\t;\n\t} else if (strstr(sigpipe, \"ignore:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (strstr(sigpipe, \"exit:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (!strcmp(sigpipe, \"ignore\")) {\n#ifdef SIG_IGN\n\t\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\t} else if (!strcmp(sigpipe, \"exit\")) {\n\t\trfbLog(\"initialize_signals: will exit on SIGPIPE\\n\");\n\t\tsignal(SIGPIPE, interrupted);\n\t}\n\n#if NO_X11\n\treturn;\n#else\n\tX_LOCK;\n\tXerror_def = XSetErrorHandler(Xerror);\n\tXIOerr_def = XSetIOErrorHandler(XIOerr);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_signals(void);",
      "static XErrorHandler   Xerror_def;",
      "static XIOErrorHandler XIOerr_def;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetIOErrorHandler",
          "args": [
            "XIOerr"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "Xerror"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "interrupted"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_signals: will exit on SIGPIPE\\n\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sigpipe",
            "\"exit\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_IGN"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sigpipe",
            "\"ignore\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_sigs",
          "args": [
            "sigpipe"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_sigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "629-704",
          "snippet": "static void ignore_sigs(char *list) {\n\tchar *str, *p;\n\tint ignore = 1;\n\tif (list == NULL || *list == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(list);\n\tp = strtok(str, \":,\");\n\n#define SETSIG(x, y) \\\n\tif (strstr(p, x)) { \\\n\t\tif (ignore) { \\\n\t\t\tsignal(y, SIG_IGN); \\\n\t\t} else { \\\n\t\t\tsignal(y, interrupted); \\\n\t\t} \\\n\t}\n\n#ifdef SIG_IGN\n\twhile (p) {\n\t\tif (!strcmp(p, \"ignore\")) {\n\t\t\tignore = 1;\n\t\t} else if (!strcmp(p, \"exit\")) {\n\t\t\tignore = 0;\n\t\t}\n\t\t/* Take off every 'sig' ;-) */\n#ifdef SIGHUP\n\t\tSETSIG(\"HUP\", SIGHUP);\n#endif\n#ifdef SIGINT\n\t\tSETSIG(\"INT\", SIGINT);\n#endif\n#ifdef SIGQUIT\n\t\tSETSIG(\"QUIT\", SIGQUIT);\n#endif\n#ifdef SIGTRAP\n\t\tSETSIG(\"TRAP\", SIGTRAP);\n#endif\n#ifdef SIGABRT\n\t\tSETSIG(\"ABRT\", SIGABRT);\n#endif\n#ifdef SIGBUS\n\t\tSETSIG(\"BUS\", SIGBUS);\n#endif\n#ifdef SIGFPE\n\t\tSETSIG(\"FPE\", SIGFPE);\n#endif\n#ifdef SIGSEGV\n\t\tSETSIG(\"SEGV\", SIGSEGV);\n#endif\n#ifdef SIGPIPE\n\t\tSETSIG(\"PIPE\", SIGPIPE);\n#endif\n#ifdef SIGTERM\n\t\tSETSIG(\"TERM\", SIGTERM);\n#endif\n#ifdef SIGUSR1\n\t\tSETSIG(\"USR1\", SIGUSR1);\n#endif\n#ifdef SIGUSR2\n\t\tSETSIG(\"USR2\", SIGUSR2);\n#endif\n#ifdef SIGCONT\n\t\tSETSIG(\"CONT\", SIGCONT);\n#endif\n#ifdef SIGSTOP\n\t\tSETSIG(\"STOP\", SIGSTOP);\n#endif\n#ifdef SIGTSTP\n\t\tSETSIG(\"TSTP\", SIGTSTP);\n#endif\n\t\tp = strtok(NULL, \":,\");\n\t}\n#endif\t/* SIG_IGN */\n\tfree(str);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void interrupted (int sig);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void interrupted (int sig);\n\nstatic void ignore_sigs(char *list) {\n\tchar *str, *p;\n\tint ignore = 1;\n\tif (list == NULL || *list == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(list);\n\tp = strtok(str, \":,\");\n\n#define SETSIG(x, y) \\\n\tif (strstr(p, x)) { \\\n\t\tif (ignore) { \\\n\t\t\tsignal(y, SIG_IGN); \\\n\t\t} else { \\\n\t\t\tsignal(y, interrupted); \\\n\t\t} \\\n\t}\n\n#ifdef SIG_IGN\n\twhile (p) {\n\t\tif (!strcmp(p, \"ignore\")) {\n\t\t\tignore = 1;\n\t\t} else if (!strcmp(p, \"exit\")) {\n\t\t\tignore = 0;\n\t\t}\n\t\t/* Take off every 'sig' ;-) */\n#ifdef SIGHUP\n\t\tSETSIG(\"HUP\", SIGHUP);\n#endif\n#ifdef SIGINT\n\t\tSETSIG(\"INT\", SIGINT);\n#endif\n#ifdef SIGQUIT\n\t\tSETSIG(\"QUIT\", SIGQUIT);\n#endif\n#ifdef SIGTRAP\n\t\tSETSIG(\"TRAP\", SIGTRAP);\n#endif\n#ifdef SIGABRT\n\t\tSETSIG(\"ABRT\", SIGABRT);\n#endif\n#ifdef SIGBUS\n\t\tSETSIG(\"BUS\", SIGBUS);\n#endif\n#ifdef SIGFPE\n\t\tSETSIG(\"FPE\", SIGFPE);\n#endif\n#ifdef SIGSEGV\n\t\tSETSIG(\"SEGV\", SIGSEGV);\n#endif\n#ifdef SIGPIPE\n\t\tSETSIG(\"PIPE\", SIGPIPE);\n#endif\n#ifdef SIGTERM\n\t\tSETSIG(\"TERM\", SIGTERM);\n#endif\n#ifdef SIGUSR1\n\t\tSETSIG(\"USR1\", SIGUSR1);\n#endif\n#ifdef SIGUSR2\n\t\tSETSIG(\"USR2\", SIGUSR2);\n#endif\n#ifdef SIGCONT\n\t\tSETSIG(\"CONT\", SIGCONT);\n#endif\n#ifdef SIGSTOP\n\t\tSETSIG(\"STOP\", SIGSTOP);\n#endif\n#ifdef SIGTSTP\n\t\tSETSIG(\"TSTP\", SIGTSTP);\n#endif\n\t\tp = strtok(NULL, \":,\");\n\t}\n#endif\t/* SIG_IGN */\n\tfree(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "sigpipe",
            "\"exit:\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "sigpipe",
            "\"ignore:\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sigpipe",
            "\"skip\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGFPE",
            "interrupted"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGSEGV",
            "interrupted"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGBUS",
            "interrupted"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "interrupted"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGABRT",
            "interrupted"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "interrupted"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "interrupted"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "interrupted"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_signals(void);\nstatic XErrorHandler   Xerror_def;\nstatic XIOErrorHandler XIOerr_def;\n\nvoid initialize_signals(void) {\n\tsignal(SIGHUP,  interrupted);\n\tsignal(SIGINT,  interrupted);\n\tsignal(SIGQUIT, interrupted);\n\tsignal(SIGABRT, interrupted);\n\tsignal(SIGTERM, interrupted);\n\tsignal(SIGBUS,  interrupted);\n\tsignal(SIGSEGV, interrupted);\n\tsignal(SIGFPE,  interrupted);\n\n\tif (!sigpipe || *sigpipe == '\\0' || !strcmp(sigpipe, \"skip\")) {\n\t\t;\n\t} else if (strstr(sigpipe, \"ignore:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (strstr(sigpipe, \"exit:\") == sigpipe) {\n\t\tignore_sigs(sigpipe);\n\t} else if (!strcmp(sigpipe, \"ignore\")) {\n#ifdef SIG_IGN\n\t\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\t} else if (!strcmp(sigpipe, \"exit\")) {\n\t\trfbLog(\"initialize_signals: will exit on SIGPIPE\\n\");\n\t\tsignal(SIGPIPE, interrupted);\n\t}\n\n#if NO_X11\n\treturn;\n#else\n\tX_LOCK;\n\tXerror_def = XSetErrorHandler(Xerror);\n\tXIOerr_def = XSetIOErrorHandler(XIOerr);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "ignore_sigs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "629-704",
    "snippet": "static void ignore_sigs(char *list) {\n\tchar *str, *p;\n\tint ignore = 1;\n\tif (list == NULL || *list == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(list);\n\tp = strtok(str, \":,\");\n\n#define SETSIG(x, y) \\\n\tif (strstr(p, x)) { \\\n\t\tif (ignore) { \\\n\t\t\tsignal(y, SIG_IGN); \\\n\t\t} else { \\\n\t\t\tsignal(y, interrupted); \\\n\t\t} \\\n\t}\n\n#ifdef SIG_IGN\n\twhile (p) {\n\t\tif (!strcmp(p, \"ignore\")) {\n\t\t\tignore = 1;\n\t\t} else if (!strcmp(p, \"exit\")) {\n\t\t\tignore = 0;\n\t\t}\n\t\t/* Take off every 'sig' ;-) */\n#ifdef SIGHUP\n\t\tSETSIG(\"HUP\", SIGHUP);\n#endif\n#ifdef SIGINT\n\t\tSETSIG(\"INT\", SIGINT);\n#endif\n#ifdef SIGQUIT\n\t\tSETSIG(\"QUIT\", SIGQUIT);\n#endif\n#ifdef SIGTRAP\n\t\tSETSIG(\"TRAP\", SIGTRAP);\n#endif\n#ifdef SIGABRT\n\t\tSETSIG(\"ABRT\", SIGABRT);\n#endif\n#ifdef SIGBUS\n\t\tSETSIG(\"BUS\", SIGBUS);\n#endif\n#ifdef SIGFPE\n\t\tSETSIG(\"FPE\", SIGFPE);\n#endif\n#ifdef SIGSEGV\n\t\tSETSIG(\"SEGV\", SIGSEGV);\n#endif\n#ifdef SIGPIPE\n\t\tSETSIG(\"PIPE\", SIGPIPE);\n#endif\n#ifdef SIGTERM\n\t\tSETSIG(\"TERM\", SIGTERM);\n#endif\n#ifdef SIGUSR1\n\t\tSETSIG(\"USR1\", SIGUSR1);\n#endif\n#ifdef SIGUSR2\n\t\tSETSIG(\"USR2\", SIGUSR2);\n#endif\n#ifdef SIGCONT\n\t\tSETSIG(\"CONT\", SIGCONT);\n#endif\n#ifdef SIGSTOP\n\t\tSETSIG(\"STOP\", SIGSTOP);\n#endif\n#ifdef SIGTSTP\n\t\tSETSIG(\"TSTP\", SIGTSTP);\n#endif\n\t\tp = strtok(NULL, \":,\");\n\t}\n#endif\t/* SIG_IGN */\n\tfree(str);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void interrupted (int sig);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":,\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"TSTP\"",
            "SIGTSTP"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"STOP\"",
            "SIGSTOP"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"CONT\"",
            "SIGCONT"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"USR2\"",
            "SIGUSR2"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"USR1\"",
            "SIGUSR1"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"TERM\"",
            "SIGTERM"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"PIPE\"",
            "SIGPIPE"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"SEGV\"",
            "SIGSEGV"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"FPE\"",
            "SIGFPE"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"BUS\"",
            "SIGBUS"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"ABRT\"",
            "SIGABRT"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"TRAP\"",
            "SIGTRAP"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"QUIT\"",
            "SIGQUIT"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"INT\"",
            "SIGINT"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETSIG",
          "args": [
            "\"HUP\"",
            "SIGHUP"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"exit\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"ignore\""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\":,\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "list"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void interrupted (int sig);\n\nstatic void ignore_sigs(char *list) {\n\tchar *str, *p;\n\tint ignore = 1;\n\tif (list == NULL || *list == '\\0') {\n\t\treturn;\n\t}\n\tstr = strdup(list);\n\tp = strtok(str, \":,\");\n\n#define SETSIG(x, y) \\\n\tif (strstr(p, x)) { \\\n\t\tif (ignore) { \\\n\t\t\tsignal(y, SIG_IGN); \\\n\t\t} else { \\\n\t\t\tsignal(y, interrupted); \\\n\t\t} \\\n\t}\n\n#ifdef SIG_IGN\n\twhile (p) {\n\t\tif (!strcmp(p, \"ignore\")) {\n\t\t\tignore = 1;\n\t\t} else if (!strcmp(p, \"exit\")) {\n\t\t\tignore = 0;\n\t\t}\n\t\t/* Take off every 'sig' ;-) */\n#ifdef SIGHUP\n\t\tSETSIG(\"HUP\", SIGHUP);\n#endif\n#ifdef SIGINT\n\t\tSETSIG(\"INT\", SIGINT);\n#endif\n#ifdef SIGQUIT\n\t\tSETSIG(\"QUIT\", SIGQUIT);\n#endif\n#ifdef SIGTRAP\n\t\tSETSIG(\"TRAP\", SIGTRAP);\n#endif\n#ifdef SIGABRT\n\t\tSETSIG(\"ABRT\", SIGABRT);\n#endif\n#ifdef SIGBUS\n\t\tSETSIG(\"BUS\", SIGBUS);\n#endif\n#ifdef SIGFPE\n\t\tSETSIG(\"FPE\", SIGFPE);\n#endif\n#ifdef SIGSEGV\n\t\tSETSIG(\"SEGV\", SIGSEGV);\n#endif\n#ifdef SIGPIPE\n\t\tSETSIG(\"PIPE\", SIGPIPE);\n#endif\n#ifdef SIGTERM\n\t\tSETSIG(\"TERM\", SIGTERM);\n#endif\n#ifdef SIGUSR1\n\t\tSETSIG(\"USR1\", SIGUSR1);\n#endif\n#ifdef SIGUSR2\n\t\tSETSIG(\"USR2\", SIGUSR2);\n#endif\n#ifdef SIGCONT\n\t\tSETSIG(\"CONT\", SIGCONT);\n#endif\n#ifdef SIGSTOP\n\t\tSETSIG(\"STOP\", SIGSTOP);\n#endif\n#ifdef SIGTSTP\n\t\tSETSIG(\"TSTP\", SIGTSTP);\n#endif\n\t\tp = strtok(NULL, \":,\");\n\t}\n#endif\t/* SIG_IGN */\n\tfree(str);\n}"
  },
  {
    "function_name": "interrupted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "534-627",
    "snippet": "static void interrupted (int sig) {\n\texit_sig = sig;\n\tif (exit_flag) {\n\t\tfprintf(stderr, \"extra[%d] signal: %d\\n\", exit_flag, sig);\n\t\texit_flag++;\n\t\tif (use_threads)\n\t\t  usleep2(250 * 1000);\n\t\tif (exit_flag <= 2)\n\t\t  return;\n\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\n\t\t/* remove all created XInput2 devices */\n\t\tif(use_multipointer)\n\t\t    removeAllMDs(dpy);\n\n\t\texit(4);\n\t}\n\texit_flag++;\n\tif (sig == 0) {\n\t\tfprintf(stderr, \"caught X11 error:\\n\");\n\t\tif (crash_debug) { crash_shell(); }\n\t} else if (sig == -1) {\n\t\tfprintf(stderr, \"caught XIO error:\\n\");\n\t} else {\n\t\tfprintf(stderr, \"caught signal: %d\\n\", sig);\n\t}\n\tif (sig == SIGINT) {\n\t\tshut_down = 1;\n\t\treturn;\n\t}\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tX_UNLOCK;\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\t/* remove the shm areas with quick=1: */\n\tclean_shm(1);\n\n\tif (sig == -1) {\n\t\t/* not worth trying any more cleanup, X server probably gone */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(3);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tstop_stunnel();\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tif (sig) {\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(2);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int crash_debug = 0;",
      "void clean_shm(int quick);",
      "int trap_xerror(Display *d, XErrorEvent *error);",
      "int trap_xioerror(Display *d);",
      "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
      "char *xerror_string(XErrorEvent *error);",
      "static int exit_flag = 0;",
      "static int exit_sig = 0;",
      "static void clean_icon_mode(void);",
      "static int Xerror(Display *d, XErrorEvent *error);",
      "static int XIOerr(Display *d);",
      "static void crash_shell(void);",
      "static void interrupted (int sig);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "rm_flagfile"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_shell",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "crash_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "477-529",
          "snippet": "static void crash_shell(void) {\n\tchar qry[1000], cmd[1000], line[1000];\n\tchar *str, *p;\n\n\tcrash_shell_help();\n\tfprintf(stderr, \"\\ncrash> \");\n\twhile (fgets(line, sizeof line, stdin) != NULL) {\n\t\tstr = lblanks(line);\n\n\t\tp = str;\n\t\twhile(*p) {\n\t\t\tif (*p == '\\n') {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (*str == 'q' && *(str+1) == '\\0') {\n\t\t\tfprintf(stderr, \"quitting.\\n\");\n\t\t\treturn;\n\t\t} else if (*str == 'h' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == '?' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == 's' && *(str+1) == '\\0') {\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command1);\n\t\t\t/* crash */\n\t\t\tif (no_external_cmds || !cmd_ok(\"crash\")) {\n\t\t\t\tfprintf(stderr, \"\\nno_external_cmds=%d\\n\",\n\t\t\t\t    no_external_cmds);\n\t\t\t\tgoto crash_prompt;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command1);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command2);\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command2);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\t\t} else {\n\t\t\tsnprintf(qry, sizeof qry, \"qry=%s\", str);\n\t\t\tp = process_remote_cmd(qry, 1);\n\t\t\tfprintf(stderr, \"\\n\\nresult:\\n%s\\n\", p);\n\t\t\tfree(p);\n\t\t}\n\t\t\ncrash_prompt:\n\t\tfprintf(stderr, \"crash> \");\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int trap_xioerror(Display *d);",
            "int known_sigpipe_mode(char *s);",
            "static int XIOerr(Display *d);",
            "static void crash_shell_help(void);",
            "static void crash_shell(void);",
            "static char *crash_stack_command1 = NULL;",
            "static char *crash_stack_command2 = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xioerror(Display *d);\nint known_sigpipe_mode(char *s);\nstatic int XIOerr(Display *d);\nstatic void crash_shell_help(void);\nstatic void crash_shell(void);\nstatic char *crash_stack_command1 = NULL;\nstatic char *crash_stack_command2 = NULL;\n\nstatic void crash_shell(void) {\n\tchar qry[1000], cmd[1000], line[1000];\n\tchar *str, *p;\n\n\tcrash_shell_help();\n\tfprintf(stderr, \"\\ncrash> \");\n\twhile (fgets(line, sizeof line, stdin) != NULL) {\n\t\tstr = lblanks(line);\n\n\t\tp = str;\n\t\twhile(*p) {\n\t\t\tif (*p == '\\n') {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (*str == 'q' && *(str+1) == '\\0') {\n\t\t\tfprintf(stderr, \"quitting.\\n\");\n\t\t\treturn;\n\t\t} else if (*str == 'h' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == '?' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == 's' && *(str+1) == '\\0') {\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command1);\n\t\t\t/* crash */\n\t\t\tif (no_external_cmds || !cmd_ok(\"crash\")) {\n\t\t\t\tfprintf(stderr, \"\\nno_external_cmds=%d\\n\",\n\t\t\t\t    no_external_cmds);\n\t\t\t\tgoto crash_prompt;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command1);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command2);\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command2);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\t\t} else {\n\t\t\tsnprintf(qry, sizeof qry, \"qry=%s\", str);\n\t\t\tp = process_remote_cmd(qry, 1);\n\t\t\tfprintf(stderr, \"\\n\\nresult:\\n%s\\n\", p);\n\t\t\tfree(p);\n\t\t}\n\t\t\ncrash_prompt:\n\t\tfprintf(stderr, \"crash> \");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_stunnel",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "stop_stunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "378-391",
          "snippet": "void stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSLCMDS"
          ],
          "globals_used": [
            "void stop_stunnel(void);",
            "static pid_t stunnel_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nvoid stop_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nvoid stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kde_no_animate",
          "args": [
            "1"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "kde_no_animate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1055-1160",
          "snippet": "void kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nstatic void solid_macosx(int restore);\n\nvoid kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "solid_bg",
          "args": [
            "1"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "solid_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1330-1425",
          "snippet": "void solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);",
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);",
            "static char *last_color = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\nstatic char *last_color = NULL;\n\nvoid solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autorepeat",
          "args": [
            "1",
            "0"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "autorepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "386-442",
          "snippet": "void autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);",
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static int save_auto_repeat = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic int save_auto_repeat = -1;\n\nvoid autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_locks",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "clear_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "289-349",
          "snippet": "void clear_locks(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXModifierKeymap *map;\n\tint i, j, k = 0;\n\tunsigned int state = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n#if HAVE_XKEYBOARD\n\tif (xkb_present) {\n\t\tXkbStateRec kbstate;\n\t\tXkbGetState(dpy, XkbUseCoreKbd, &kbstate);\n\t\trfbLog(\"locked:  0x%x\\n\", kbstate.locked_mods);\n\t\trfbLog(\"latched: 0x%x\\n\", kbstate.latched_mods);\n\t\trfbLog(\"compat:  0x%x\\n\", kbstate.compat_state);\n\t\tstate = kbstate.locked_mods;\n\t\tif (! state) {\n\t\t\tstate = kbstate.compat_state;\n\t\t}\n\t} else \n#endif\n\t{\n\t\tstate = mask_state();\n\t\t/* this may contain non-locks too... */\n\t\trfbLog(\"state:   0x%x\\n\", state);\n\t}\n\tif (! state) {\n\t\treturn;\n\t}\n\tmap = XGetModifierMapping(dpy);\n\tif (! map) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tint did = 0;\n\t\tfor (j = 0; j < map->max_keypermod; j++) {\n\t\t\tif (! did && state & (0x1 << i)) {\n\t\t\t\tif (map->modifiermap[k]) {\n\t\t\t\t\tKeyCode key = map->modifiermap[k];\n\t\t\t\t\tKeySym ks = XKeycodeToKeysym_wr(dpy, key, 0);\n\t\t\t\t\tchar *nm = XKeysymToString(ks);\n\t\t\t\t\trfbLog(\"toggling: %03d / %03d -- %s\\n\", key, ks, nm ? nm : \"BadKey\");\n\t\t\t\t\tdid = 1;\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime); /* multipointer FIXME? */\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tXFreeModifiermap(map);\n\tXFlush_wr(dpy);\n\trfbLog(\"state:   0x%x\\n\", mask_state());\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clear_locks(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clear_locks(void);\n\nvoid clear_locks(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXModifierKeymap *map;\n\tint i, j, k = 0;\n\tunsigned int state = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n#if HAVE_XKEYBOARD\n\tif (xkb_present) {\n\t\tXkbStateRec kbstate;\n\t\tXkbGetState(dpy, XkbUseCoreKbd, &kbstate);\n\t\trfbLog(\"locked:  0x%x\\n\", kbstate.locked_mods);\n\t\trfbLog(\"latched: 0x%x\\n\", kbstate.latched_mods);\n\t\trfbLog(\"compat:  0x%x\\n\", kbstate.compat_state);\n\t\tstate = kbstate.locked_mods;\n\t\tif (! state) {\n\t\t\tstate = kbstate.compat_state;\n\t\t}\n\t} else \n#endif\n\t{\n\t\tstate = mask_state();\n\t\t/* this may contain non-locks too... */\n\t\trfbLog(\"state:   0x%x\\n\", state);\n\t}\n\tif (! state) {\n\t\treturn;\n\t}\n\tmap = XGetModifierMapping(dpy);\n\tif (! map) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tint did = 0;\n\t\tfor (j = 0; j < map->max_keypermod; j++) {\n\t\t\tif (! did && state & (0x1 << i)) {\n\t\t\t\tif (map->modifiermap[k]) {\n\t\t\t\t\tKeyCode key = map->modifiermap[k];\n\t\t\t\t\tKeySym ks = XKeycodeToKeysym_wr(dpy, key, 0);\n\t\t\t\t\tchar *nm = XKeysymToString(ks);\n\t\t\t\t\trfbLog(\"toggling: %03d / %03d -- %s\\n\", key, ks, nm ? nm : \"BadKey\");\n\t\t\t\t\tdid = 1;\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime); /* multipointer FIXME? */\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tXFreeModifiermap(map);\n\tXFlush_wr(dpy);\n\trfbLog(\"state:   0x%x\\n\", mask_state());\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_keys",
          "args": [],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "clear_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "271-286",
          "snippet": "void clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_keys(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_keys(void);\n\nvoid clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_modifiers",
          "args": [
            "0"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "clear_modifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "125-197",
          "snippet": "void clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_modifiers(int init);",
            "int add_keysym(KeySym keysym);",
            "char *short_kmbcf(char *str);",
            "static void add_dead_keysyms(char *str);",
            "static char modifiers[0x100];",
            "static KeyCode keycodes[0x100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_modifiers(int init);\nint add_keysym(KeySym keysym);\nchar *short_kmbcf(char *str);\nstatic void add_dead_keysyms(char *str);\nstatic char modifiers[0x100];\nstatic KeyCode keycodes[0x100];\n\nvoid clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "removeAllMDs",
          "args": [
            "dpy"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "removeAllMDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
          "lines": "158-169",
          "snippet": "void removeAllMDs(Display *dpy)\n{\n    /* remove all created XInput2 devices */\n    rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n    rfbClientPtr cl;\n    while((cl = rfbClientIteratorNext(iter))) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"cleanup: removed XInput2 MD for client %s.\\n\", cl->host);\n    }\n    rfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include <cairo.h>",
            "#include <X11/Xcursor/Xcursor.h>",
            "#include \"xi2_devices.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"cursor.h\"",
            "#include \"x11vnc.h\"",
            "#include <X11/keysym.h>",
            "#include <X11/Xproto.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nvoid removeAllMDs(Display *dpy)\n{\n    /* remove all created XInput2 devices */\n    rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n    rfbClientPtr cl;\n    while((cl = rfbClientIteratorNext(iter))) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"cleanup: removed XInput2 MD for client %s.\\n\", cl->host);\n    }\n    rfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_added_keycodes",
          "args": [
            "0"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "delete_added_keycodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "626-634",
          "snippet": "void delete_added_keycodes(int bequiet) {\n\tint kc;\n\tfor (kc = 0; kc < 0x100; kc++) {\n\t\tif (added_keysyms[kc] != NoSymbol) {\n\t\t\tdelete_keycode(kc, bequiet);\n\t\t\tadded_keysyms[kc] = NoSymbol;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static KeySym added_keysyms[0x100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic KeySym added_keysyms[0x100];\n\nvoid delete_added_keycodes(int bequiet) {\n\tint kc;\n\tfor (kc = 0; kc < 0x100; kc++) {\n\t\tif (added_keysyms[kc] != NoSymbol) {\n\t\t\tdelete_keycode(kc, bequiet);\n\t\t\tadded_keysyms[kc] = NoSymbol;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "rm_flagfile"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_shm",
          "args": [
            "1"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "clean_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "93-132",
          "snippet": "void clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_shm(int quick);",
            "int trap_xioerror(Display *d);",
            "static int XIOerr(Display *d);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_shm(int quick);\nint trap_xioerror(Display *d);\nstatic int XIOerr(Display *d);\n\nvoid clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_icon_mode",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "clean_icon_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "134-145",
          "snippet": "static void clean_icon_mode(void) {\n\tif (icon_mode && icon_mode_fh) {\n\t\tfprintf(icon_mode_fh, \"quit\\n\");\n\t\tfflush(icon_mode_fh);\n\t\tfclose(icon_mode_fh);\n\t\ticon_mode_fh = NULL;\n\t\tif (icon_mode_file) {\n\t\t\tunlink(icon_mode_file);\n\t\t\ticon_mode_file = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void clean_icon_mode(void);\n\nstatic void clean_icon_mode(void) {\n\tif (icon_mode && icon_mode_fh) {\n\t\tfprintf(icon_mode_fh, \"quit\\n\");\n\t\tfflush(icon_mode_fh);\n\t\tfclose(icon_mode_fh);\n\t\ticon_mode_fh = NULL;\n\t\tif (icon_mode_file) {\n\t\t\tunlink(icon_mode_file);\n\t\t\ticon_mode_file = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"caught signal: %d\\n\"",
            "sig"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"caught XIO error:\\n\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"caught X11 error:\\n\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "rm_flagfile"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep2",
          "args": [
            "250 * 1000"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"extra[%d] signal: %d\\n\"",
            "exit_flag",
            "sig"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint crash_debug = 0;\nvoid clean_shm(int quick);\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_xioerror(Display *d);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int exit_flag = 0;\nstatic int exit_sig = 0;\nstatic void clean_icon_mode(void);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic int XIOerr(Display *d);\nstatic void crash_shell(void);\nstatic void interrupted (int sig);\n\nstatic void interrupted (int sig) {\n\texit_sig = sig;\n\tif (exit_flag) {\n\t\tfprintf(stderr, \"extra[%d] signal: %d\\n\", exit_flag, sig);\n\t\texit_flag++;\n\t\tif (use_threads)\n\t\t  usleep2(250 * 1000);\n\t\tif (exit_flag <= 2)\n\t\t  return;\n\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\n\t\t/* remove all created XInput2 devices */\n\t\tif(use_multipointer)\n\t\t    removeAllMDs(dpy);\n\n\t\texit(4);\n\t}\n\texit_flag++;\n\tif (sig == 0) {\n\t\tfprintf(stderr, \"caught X11 error:\\n\");\n\t\tif (crash_debug) { crash_shell(); }\n\t} else if (sig == -1) {\n\t\tfprintf(stderr, \"caught XIO error:\\n\");\n\t} else {\n\t\tfprintf(stderr, \"caught signal: %d\\n\", sig);\n\t}\n\tif (sig == SIGINT) {\n\t\tshut_down = 1;\n\t\treturn;\n\t}\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tX_UNLOCK;\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\t/* remove the shm areas with quick=1: */\n\tclean_shm(1);\n\n\tif (sig == -1) {\n\t\t/* not worth trying any more cleanup, X server probably gone */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(3);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tstop_stunnel();\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tif (sig) {\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(2);\n\t}\n}"
  },
  {
    "function_name": "crash_shell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "477-529",
    "snippet": "static void crash_shell(void) {\n\tchar qry[1000], cmd[1000], line[1000];\n\tchar *str, *p;\n\n\tcrash_shell_help();\n\tfprintf(stderr, \"\\ncrash> \");\n\twhile (fgets(line, sizeof line, stdin) != NULL) {\n\t\tstr = lblanks(line);\n\n\t\tp = str;\n\t\twhile(*p) {\n\t\t\tif (*p == '\\n') {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (*str == 'q' && *(str+1) == '\\0') {\n\t\t\tfprintf(stderr, \"quitting.\\n\");\n\t\t\treturn;\n\t\t} else if (*str == 'h' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == '?' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == 's' && *(str+1) == '\\0') {\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command1);\n\t\t\t/* crash */\n\t\t\tif (no_external_cmds || !cmd_ok(\"crash\")) {\n\t\t\t\tfprintf(stderr, \"\\nno_external_cmds=%d\\n\",\n\t\t\t\t    no_external_cmds);\n\t\t\t\tgoto crash_prompt;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command1);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command2);\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command2);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\t\t} else {\n\t\t\tsnprintf(qry, sizeof qry, \"qry=%s\", str);\n\t\t\tp = process_remote_cmd(qry, 1);\n\t\t\tfprintf(stderr, \"\\n\\nresult:\\n%s\\n\", p);\n\t\t\tfree(p);\n\t\t}\n\t\t\ncrash_prompt:\n\t\tfprintf(stderr, \"crash> \");\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trap_xioerror(Display *d);",
      "int known_sigpipe_mode(char *s);",
      "static int XIOerr(Display *d);",
      "static void crash_shell_help(void);",
      "static void crash_shell(void);",
      "static char *crash_stack_command1 = NULL;",
      "static char *crash_stack_command2 = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"crash> \""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\\nresult:\\n%s\\n\"",
            "p"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_remote_cmd",
          "args": [
            "qry",
            "1"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "process_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "843-6324",
          "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}",
            "#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}"
          ],
          "globals_used": [
            "int send_remote_cmd(char *cmd, int query, int wait);",
            "void check_black_fb(void);",
            "int check_httpdir(void);",
            "void http_connections(int on);",
            "int remote_control_access_ok(void);",
            "char *process_remote_cmd(char *cmd, int stringonly);",
            "static void if_8bpp_do_new_fb(void);",
            "int rc_npieces = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\nint send_remote_cmd(char *cmd, int query, int wait);\nvoid check_black_fb(void);\nint check_httpdir(void);\nvoid http_connections(int on);\nint remote_control_access_ok(void);\nchar *process_remote_cmd(char *cmd, int stringonly);\nstatic void if_8bpp_do_new_fb(void);\nint rc_npieces = 0;\n\nchar *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "qry",
            "sizeof qry",
            "\"qry=%s\"",
            "str"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000*1000"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nrunning:\\n\\t%s\\n\\n\"",
            "crash_stack_command2"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"sh -c '(%s) &'\"",
            "crash_stack_command2"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000*1000"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nrunning:\\n\\t%s\\n\\n\"",
            "crash_stack_command1"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nno_external_cmds=%d\\n\"",
            "no_external_cmds"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"crash\""
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"sh -c '(%s) &'\"",
            "crash_stack_command1"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_shell_help",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "crash_shell_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "457-475",
          "snippet": "static void crash_shell_help(void) {\n\tint pid = program_pid;\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"   *** Welcome to the x11vnc crash shell! ***\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"PROGRAM: %s  PID: %d\\n\", program_name, pid);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"POSSIBLE DEBUGGER COMMAND:\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  %s\\n\", crash_debug_command);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Press \\\"q\\\" to quit.\\n\");\n\tfprintf(stderr, \"Press \\\"h\\\" or \\\"?\\\" for this help.\\n\");\n\tfprintf(stderr, \"Press \\\"s\\\" to try to run some commands to\"\n\t    \" show a stack trace (gdb/pstack).\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Anything else is passed to -Q query function.\\n\");\n\tfprintf(stderr, \"\\n\");\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int trap_xioerror(Display *d);",
            "int known_sigpipe_mode(char *s);",
            "static int XIOerr(Display *d);",
            "static void crash_shell_help(void);",
            "static char *crash_debug_command = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xioerror(Display *d);\nint known_sigpipe_mode(char *s);\nstatic int XIOerr(Display *d);\nstatic void crash_shell_help(void);\nstatic char *crash_debug_command = NULL;\n\nstatic void crash_shell_help(void) {\n\tint pid = program_pid;\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"   *** Welcome to the x11vnc crash shell! ***\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"PROGRAM: %s  PID: %d\\n\", program_name, pid);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"POSSIBLE DEBUGGER COMMAND:\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  %s\\n\", crash_debug_command);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Press \\\"q\\\" to quit.\\n\");\n\tfprintf(stderr, \"Press \\\"h\\\" or \\\"?\\\" for this help.\\n\");\n\tfprintf(stderr, \"Press \\\"s\\\" to try to run some commands to\"\n\t    \" show a stack trace (gdb/pstack).\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Anything else is passed to -Q query function.\\n\");\n\tfprintf(stderr, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"quitting.\\n\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "line"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof line",
            "stdin"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\ncrash> \""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xioerror(Display *d);\nint known_sigpipe_mode(char *s);\nstatic int XIOerr(Display *d);\nstatic void crash_shell_help(void);\nstatic void crash_shell(void);\nstatic char *crash_stack_command1 = NULL;\nstatic char *crash_stack_command2 = NULL;\n\nstatic void crash_shell(void) {\n\tchar qry[1000], cmd[1000], line[1000];\n\tchar *str, *p;\n\n\tcrash_shell_help();\n\tfprintf(stderr, \"\\ncrash> \");\n\twhile (fgets(line, sizeof line, stdin) != NULL) {\n\t\tstr = lblanks(line);\n\n\t\tp = str;\n\t\twhile(*p) {\n\t\t\tif (*p == '\\n') {\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tif (*str == 'q' && *(str+1) == '\\0') {\n\t\t\tfprintf(stderr, \"quitting.\\n\");\n\t\t\treturn;\n\t\t} else if (*str == 'h' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == '?' && *(str+1) == '\\0') {\n\t\t\tcrash_shell_help();\n\t\t} else if (*str == 's' && *(str+1) == '\\0') {\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command1);\n\t\t\t/* crash */\n\t\t\tif (no_external_cmds || !cmd_ok(\"crash\")) {\n\t\t\t\tfprintf(stderr, \"\\nno_external_cmds=%d\\n\",\n\t\t\t\t    no_external_cmds);\n\t\t\t\tgoto crash_prompt;\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command1);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\n\t\t\tsprintf(cmd, \"sh -c '(%s) &'\", crash_stack_command2);\n\t\t\tfprintf(stderr, \"\\nrunning:\\n\\t%s\\n\\n\",\n\t\t\t    crash_stack_command2);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000*1000);\n\t\t} else {\n\t\t\tsnprintf(qry, sizeof qry, \"qry=%s\", str);\n\t\t\tp = process_remote_cmd(qry, 1);\n\t\t\tfprintf(stderr, \"\\n\\nresult:\\n%s\\n\", p);\n\t\t\tfree(p);\n\t\t}\n\t\t\ncrash_prompt:\n\t\tfprintf(stderr, \"crash> \");\n\t}\n}"
  },
  {
    "function_name": "crash_shell_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "457-475",
    "snippet": "static void crash_shell_help(void) {\n\tint pid = program_pid;\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"   *** Welcome to the x11vnc crash shell! ***\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"PROGRAM: %s  PID: %d\\n\", program_name, pid);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"POSSIBLE DEBUGGER COMMAND:\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  %s\\n\", crash_debug_command);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Press \\\"q\\\" to quit.\\n\");\n\tfprintf(stderr, \"Press \\\"h\\\" or \\\"?\\\" for this help.\\n\");\n\tfprintf(stderr, \"Press \\\"s\\\" to try to run some commands to\"\n\t    \" show a stack trace (gdb/pstack).\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Anything else is passed to -Q query function.\\n\");\n\tfprintf(stderr, \"\\n\");\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trap_xioerror(Display *d);",
      "int known_sigpipe_mode(char *s);",
      "static int XIOerr(Display *d);",
      "static void crash_shell_help(void);",
      "static char *crash_debug_command = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Anything else is passed to -Q query function.\\n\""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Press \\\"s\\\" to try to run some commands to\"\n\t    \" show a stack trace (gdb/pstack).\\n\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Press \\\"h\\\" or \\\"?\\\" for this help.\\n\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Press \\\"q\\\" to quit.\\n\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  %s\\n\"",
            "crash_debug_command"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"POSSIBLE DEBUGGER COMMAND:\\n\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"PROGRAM: %s  PID: %d\\n\"",
            "program_name",
            "pid"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   *** Welcome to the x11vnc crash shell! ***\\n\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xioerror(Display *d);\nint known_sigpipe_mode(char *s);\nstatic int XIOerr(Display *d);\nstatic void crash_shell_help(void);\nstatic char *crash_debug_command = NULL;\n\nstatic void crash_shell_help(void) {\n\tint pid = program_pid;\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"   *** Welcome to the x11vnc crash shell! ***\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"PROGRAM: %s  PID: %d\\n\", program_name, pid);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"POSSIBLE DEBUGGER COMMAND:\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"  %s\\n\", crash_debug_command);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Press \\\"q\\\" to quit.\\n\");\n\tfprintf(stderr, \"Press \\\"h\\\" or \\\"?\\\" for this help.\\n\");\n\tfprintf(stderr, \"Press \\\"s\\\" to try to run some commands to\"\n\t    \" show a stack trace (gdb/pstack).\\n\");\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"Anything else is passed to -Q query function.\\n\");\n\tfprintf(stderr, \"\\n\");\n}"
  },
  {
    "function_name": "initialize_crash_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "441-455",
    "snippet": "void initialize_crash_handler(void) {\n\tint pid = program_pid;\n\tsize_t buffer_size = 1000;\n\tcrash_stack_command1 = (char *) malloc(buffer_size);\n\tcrash_stack_command2 = (char *) malloc(buffer_size);\n\tcrash_debug_command =  (char *) malloc(buffer_size);\n\n\tsnprintf(crash_stack_command1, buffer_size, \"echo where > /tmp/gdb.%d;\"\n\t    \" env PATH=$PATH:/usr/local/bin:/usr/sfw/bin:/usr/bin\"\n\t    \" gdb -x /tmp/gdb.%d -batch -n %s %d;\"\n\t    \" rm -f /tmp/gdb.%d\", pid, pid, program_name, pid, pid);\n\tsnprintf(crash_stack_command2, buffer_size, \"pstack %d\", program_pid);\n\t\n\tsnprintf(crash_debug_command, buffer_size, \"gdb %s %d\", program_name, pid);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trap_xioerror(Display *d);",
      "void initialize_crash_handler(void);",
      "int known_sigpipe_mode(char *s);",
      "static int XIOerr(Display *d);",
      "static char *crash_stack_command1 = NULL;",
      "static char *crash_stack_command2 = NULL;",
      "static char *crash_debug_command = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "crash_debug_command",
            "buffer_size",
            "\"gdb %s %d\"",
            "program_name",
            "pid"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "crash_stack_command2",
            "buffer_size",
            "\"pstack %d\"",
            "program_pid"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "crash_stack_command1",
            "buffer_size",
            "\"echo where > /tmp/gdb.%d;\"\n\t    \" env PATH=$PATH:/usr/local/bin:/usr/sfw/bin:/usr/bin\"\n\t    \" gdb -x /tmp/gdb.%d -batch -n %s %d;\"\n\t    \" rm -f /tmp/gdb.%d\"",
            "pid",
            "pid",
            "program_name",
            "pid",
            "pid"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "buffer_size"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "buffer_size"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "buffer_size"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xioerror(Display *d);\nvoid initialize_crash_handler(void);\nint known_sigpipe_mode(char *s);\nstatic int XIOerr(Display *d);\nstatic char *crash_stack_command1 = NULL;\nstatic char *crash_stack_command2 = NULL;\nstatic char *crash_debug_command = NULL;\n\nvoid initialize_crash_handler(void) {\n\tint pid = program_pid;\n\tsize_t buffer_size = 1000;\n\tcrash_stack_command1 = (char *) malloc(buffer_size);\n\tcrash_stack_command2 = (char *) malloc(buffer_size);\n\tcrash_debug_command =  (char *) malloc(buffer_size);\n\n\tsnprintf(crash_stack_command1, buffer_size, \"echo where > /tmp/gdb.%d;\"\n\t    \" env PATH=$PATH:/usr/local/bin:/usr/sfw/bin:/usr/bin\"\n\t    \" gdb -x /tmp/gdb.%d -batch -n %s %d;\"\n\t    \" rm -f /tmp/gdb.%d\", pid, pid, program_name, pid, pid);\n\tsnprintf(crash_stack_command2, buffer_size, \"pstack %d\", program_pid);\n\t\n\tsnprintf(crash_debug_command, buffer_size, \"gdb %s %d\", program_name, pid);\n}"
  },
  {
    "function_name": "xerror_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "425-435",
    "snippet": "char *xerror_string(XErrorEvent *error) {\n\tint index = -1;\n\tif (error) {\n\t\tindex = (int) error->error_code;\n\t}\n\tif (0 <= index && index <= xerrors_max) {\n\t\treturn xerrors[index];\n\t} else {\n\t\treturn xerrors[xerrors_max+1];\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trap_xerror(Display *d, XErrorEvent *error);",
      "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
      "char *xerror_string(XErrorEvent *error);",
      "static int Xerror(Display *d, XErrorEvent *error);",
      "static char *xerrors[] = {\n\t\"Success\",\n\t\"BadRequest\",\n\t\"BadValue\",\n\t\"BadWindow\",\n\t\"BadPixmap\",\n\t\"BadAtom\",\n\t\"BadCursor\",\n\t\"BadFont\",\n\t\"BadMatch\",\n\t\"BadDrawable\",\n\t\"BadAccess\",\n\t\"BadAlloc\",\n\t\"BadColor\",\n\t\"BadGC\",\n\t\"BadIDChoice\",\n\t\"BadName\",\n\t\"BadLength\",\n\t\"BadImplementation\",\n\t\"unknown\"\n};",
      "static int xerrors_max = BadImplementation;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic char *xerrors[] = {\n\t\"Success\",\n\t\"BadRequest\",\n\t\"BadValue\",\n\t\"BadWindow\",\n\t\"BadPixmap\",\n\t\"BadAtom\",\n\t\"BadCursor\",\n\t\"BadFont\",\n\t\"BadMatch\",\n\t\"BadDrawable\",\n\t\"BadAccess\",\n\t\"BadAlloc\",\n\t\"BadColor\",\n\t\"BadGC\",\n\t\"BadIDChoice\",\n\t\"BadName\",\n\t\"BadLength\",\n\t\"BadImplementation\",\n\t\"unknown\"\n};\nstatic int xerrors_max = BadImplementation;\n\nchar *xerror_string(XErrorEvent *error) {\n\tint index = -1;\n\tif (error) {\n\t\tindex = (int) error->error_code;\n\t}\n\tif (0 <= index && index <= xerrors_max) {\n\t\treturn xerrors[index];\n\t} else {\n\t\treturn xerrors[xerrors_max+1];\n\t}\n}"
  },
  {
    "function_name": "XIOerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "337-400",
    "snippet": "static int XIOerr(Display *d) {\n\tstatic int reopen = 0, rmax = 1;\n\tX_UNLOCK;\n\n\tif (getenv(\"X11VNC_REOPEN_DISPLAY\")) {\n\t\trmax = atoi(getenv(\"X11VNC_REOPEN_DISPLAY\"));\n\t}\n\n#if !NO_X11\n\tif (reopen < rmax && getenv(\"X11VNC_REOPEN_DISPLAY\")) {\n\t\tint db = getenv(\"X11VNC_REOPEN_DEBUG\") ? 1 : 0;\n\t\tint sleepmax = 10, i;\n\t\tDisplay *save_dpy = dpy;\n\t\tchar *dstr = strdup(DisplayString(save_dpy));\n\t\treopen++;\t\n\t\tif (getenv(\"X11VNC_REOPEN_SLEEP_MAX\")) {\n\t\t\tsleepmax = atoi(getenv(\"X11VNC_REOPEN_SLEEP_MAX\"));\n\t\t}\n\t\trfbLog(\"*** XIO error: Trying to reopen[%d/%d] display '%s'\\n\", reopen, rmax, dstr);\n\t\trfbLog(\"*** XIO error: Note the reopened state may be unstable.\\n\");\n\t\tfor (i=0; i < sleepmax; i++) {\n\t\t\tusleep (1000 * 1000);\n\t\t\tdpy = XOpenDisplay_wr(dstr);\n\t\t\trfbLog(\"dpy[%d/%d]: %p\\n\", i+1, sleepmax, dpy);\n\t\t\tif (dpy) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlast_open_xdisplay = time(NULL);\n\t\tif (dpy) {\n\t\t\trfbLog(\"*** XIO error: Reopened display '%s' successfully.\\n\", dstr);\n\t\t\tif (db) rfbLog(\"*** XIO error: '%s' 0x%x\\n\", dstr, dpy);\n\t\t\tscr = DefaultScreen(dpy);\n\t\t\trootwin = RootWindow(dpy, scr);\n\t\t\tif (db) rfbLog(\"*** XIO error: disable_grabserver\\n\");\n\t\t\tdisable_grabserver(dpy, 0);\n\t\t\tif (db) rfbLog(\"*** XIO error: xrecord\\n\");\n\t\t\tzerodisp_xrecord();\n\t\t\tinitialize_xrecord();\n\t\t\tif (db) rfbLog(\"*** XIO error: xdamage\\n\");\n\t\t\tcreate_xdamage_if_needed(1);\n\t\t\tif (db) rfbLog(\"*** XIO error: do_new_fb\\n\");\n\t\t\tif (using_shm) {\n\t\t\t\tif (db) rfbLog(\"*** XIO error: clean_shm\\n\");\n\t\t\t\tclean_shm(1);\n\t\t\t}\n\t\t\tdo_new_fb(1);\n\t\t\tif (db) rfbLog(\"*** XIO error: check_xevents\\n\");\n\t\t\tcheck_xevents(1);\n\n\t\t\t/* sadly, we can never return... */\n\t\t\tif (db) rfbLog(\"*** XIO error: watch_loop\\n\");\n\t\t\twatch_loop();\n\t\t\tclean_up_exit(1);\t\n\t\t}\n\t}\n#endif\n\n\tinterrupted(-1);\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn (*XIOerr_def)(d);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trap_xerror(Display *d, XErrorEvent *error);",
      "int trap_xioerror(Display *d);",
      "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
      "char *xerror_string(XErrorEvent *error);",
      "int known_sigpipe_mode(char *s);",
      "static int Xerror(Display *d, XErrorEvent *error);",
      "static int XIOerr(Display *d);",
      "static XIOErrorHandler XIOerr_def;",
      "void watch_loop(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "d"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interrupted",
          "args": [
            "-1"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "interrupted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "534-627",
          "snippet": "static void interrupted (int sig) {\n\texit_sig = sig;\n\tif (exit_flag) {\n\t\tfprintf(stderr, \"extra[%d] signal: %d\\n\", exit_flag, sig);\n\t\texit_flag++;\n\t\tif (use_threads)\n\t\t  usleep2(250 * 1000);\n\t\tif (exit_flag <= 2)\n\t\t  return;\n\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\n\t\t/* remove all created XInput2 devices */\n\t\tif(use_multipointer)\n\t\t    removeAllMDs(dpy);\n\n\t\texit(4);\n\t}\n\texit_flag++;\n\tif (sig == 0) {\n\t\tfprintf(stderr, \"caught X11 error:\\n\");\n\t\tif (crash_debug) { crash_shell(); }\n\t} else if (sig == -1) {\n\t\tfprintf(stderr, \"caught XIO error:\\n\");\n\t} else {\n\t\tfprintf(stderr, \"caught signal: %d\\n\", sig);\n\t}\n\tif (sig == SIGINT) {\n\t\tshut_down = 1;\n\t\treturn;\n\t}\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tX_UNLOCK;\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\t/* remove the shm areas with quick=1: */\n\tclean_shm(1);\n\n\tif (sig == -1) {\n\t\t/* not worth trying any more cleanup, X server probably gone */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(3);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tstop_stunnel();\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tif (sig) {\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(2);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int crash_debug = 0;",
            "void clean_shm(int quick);",
            "int trap_xerror(Display *d, XErrorEvent *error);",
            "int trap_xioerror(Display *d);",
            "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
            "char *xerror_string(XErrorEvent *error);",
            "static int exit_flag = 0;",
            "static int exit_sig = 0;",
            "static void clean_icon_mode(void);",
            "static int Xerror(Display *d, XErrorEvent *error);",
            "static int XIOerr(Display *d);",
            "static void crash_shell(void);",
            "static void interrupted (int sig);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint crash_debug = 0;\nvoid clean_shm(int quick);\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_xioerror(Display *d);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int exit_flag = 0;\nstatic int exit_sig = 0;\nstatic void clean_icon_mode(void);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic int XIOerr(Display *d);\nstatic void crash_shell(void);\nstatic void interrupted (int sig);\n\nstatic void interrupted (int sig) {\n\texit_sig = sig;\n\tif (exit_flag) {\n\t\tfprintf(stderr, \"extra[%d] signal: %d\\n\", exit_flag, sig);\n\t\texit_flag++;\n\t\tif (use_threads)\n\t\t  usleep2(250 * 1000);\n\t\tif (exit_flag <= 2)\n\t\t  return;\n\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\n\t\t/* remove all created XInput2 devices */\n\t\tif(use_multipointer)\n\t\t    removeAllMDs(dpy);\n\n\t\texit(4);\n\t}\n\texit_flag++;\n\tif (sig == 0) {\n\t\tfprintf(stderr, \"caught X11 error:\\n\");\n\t\tif (crash_debug) { crash_shell(); }\n\t} else if (sig == -1) {\n\t\tfprintf(stderr, \"caught XIO error:\\n\");\n\t} else {\n\t\tfprintf(stderr, \"caught signal: %d\\n\", sig);\n\t}\n\tif (sig == SIGINT) {\n\t\tshut_down = 1;\n\t\treturn;\n\t}\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tX_UNLOCK;\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\t/* remove the shm areas with quick=1: */\n\tclean_shm(1);\n\n\tif (sig == -1) {\n\t\t/* not worth trying any more cleanup, X server probably gone */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(3);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tstop_stunnel();\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tif (sig) {\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "watch_loop",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "watch_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "4395-4775",
          "snippet": "void watch_loop(void) {\n\tint cnt = 0, tile_diffs = 0, skip_pe = 0, wait;\n\tdouble tm, dtr, dt = 0.0;\n\ttime_t start = time(NULL);\n\n\tif (use_threads && !started_rfbRunEventLoop) {\n\t\tstarted_rfbRunEventLoop = 1;\n\t\trfbRunEventLoop(screen, -1, TRUE);\n\t}\n\n\twhile (1) {\n\t\tchar msg[] = \"new client: %s taking unixpw client off hold.\\n\";\n\t\tint skip_scan_for_updates = 0;\n\n\t\tgot_user_input = 0;\n\t\tgot_pointer_input = 0;\n\t\tgot_local_pointer_input = 0;\n\t\tgot_pointer_calls = 0;\n\t\tgot_keyboard_input = 0;\n\t\tgot_keyboard_calls = 0;\n\t\turgent_update = 0;\n\n\t\tx11vnc_current = dnow();\n\n\t\tif (! use_threads) {\n\t\t\tdtime0(&tm);\n\t\t\tif (! skip_pe) {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(1);\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 1;\n\n\t\t\t\t/*\n\t\t\t\t * do a few more since a key press may\n\t\t\t\t * have induced a small change we want to\n\t\t\t\t * see quickly (just 1 rfbPE will likely\n\t\t\t\t * only process the subsequent \"up\" event)\n\t\t\t\t */\n\t\t\t\tif (tm < last_keyboard_time + 0.20) {\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t} else {\n\t\t\t\t\tif (extra_fbur > 0) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i=0; i < extra_fbur; i++) {\n\t\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tif (x11vnc_current < last_new_client + 0.5) {\n\t\t\t\t\turgent_update = 1;\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 0;\n\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\t/* rfbPE loop until logged in. */\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(0);\n\t\t\t\t\tfb_update_sent(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdtr = dtime(&tm);\n\n\t\t\tif (! cursor_shape_updates) {\n\t\t\t\t/* undo any cursor shape requests */\n\t\t\t\tdisable_cursor_shape_updates(screen);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint ret = check_user_input(dt, dtr, tile_diffs, &cnt);\n\t\t\t\t/* true: loop back for more input */\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\tskip_pe = 1;\n\t\t\t\t}\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (debug_scroll) fprintf(stderr, \"watch_loop: LOOP-BACK: %d\\n\", ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* watch for viewonly input piling up: */\n\t\t\tif ((got_pointer_calls > got_pointer_input) ||\n\t\t\t    (got_keyboard_calls > got_keyboard_input)) {\n\t\t\t\teat_viewonly_input(10, 3);\n\t\t\t}\n\t\t} else {\n\t\t\t/* -threads here. */\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_xrecord) {\n\t\t\t\tcheck_xrecord();\n\t\t\t}\n\t\t\tif (wireframe && button_mask) {\n\t\t\t\tcheck_wireframe();\n\t\t\t}\n\t\t}\n\t\tskip_pe = 0;\n\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\n\t\tif (unixpw_in_progress) {\n\t\t\tcheck_new_clients();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (! urgent_update) {\n\t\t\tif (do_copy_screen) {\n\t\t\t\tdo_copy_screen = 0;\n\t\t\t\tcopy_screen();\n\t\t\t}\n\n\t\t\tcheck_new_clients();\n\t\t\tcheck_ncache(0, 0);\n\t\t\tcheck_xevents(0);\n\t\t\tcheck_autorepeat();\n\t\t\tcheck_pm();\n\t\t\tcheck_filexfer();\n\t\t\tcheck_keycode_state();\n\t\t\tcheck_connect_inputs();\n\t\t\tcheck_gui_inputs();\n\t\t\tcheck_stunnel();\n\t\t\tcheck_openssl();\n\t\t\tcheck_https();\n\t\t\trecord_last_fb_update();\n\t\t\tcheck_padded_fb();\n\t\t\tcheck_fixscreen();\n\t\t\tcheck_xdamage_state();\n\t\t\tcheck_xrecord_reset(0);\n\t\t\tcheck_add_keysyms();\n\t\t\tcheck_new_passwds(0);\n#ifdef ENABLE_GRABLOCAL\n\t\t\tif (grab_local) {\n\t\t\t\tcheck_local_grab();\n\t\t\t}\n#endif\n\t\t\tif (started_as_root) {\n\t\t\t\tcheck_switched_user();\n\t\t\t}\n\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tstart = time(NULL);\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t}\n\n\t\tif (rawfb_vnc_reflect) {\n\t\t\tstatic time_t lastone = 0;\n\t\t\tif (time(NULL) > lastone + 10) {\n\t\t\t\tlastone = time(NULL);\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\t\t}\n\n\t\tif (first_conn_timeout) {\n\t\t\tint t = first_conn_timeout;\n\t\t\tif (!clients_served) {\n\t\t\t\tif (time(NULL) - start > first_conn_timeout) {\n\t\t\t\t\trfbLog(\"No client after %d secs.\\n\", t);\n\t\t\t\t\tshut_down = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!client_normal_count) {\n\t\t\t\t\tif (time(NULL) - start > t + 3) {\n\t\t\t\t\t\trfbLog(\"No valid client after %d secs.\\n\", t + 3);\n\t\t\t\t\t\tshut_down = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\t/* waiting for a client */\n\t\t\tusleep(200 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (first_conn_timeout && all_clients_initialized()) {\n\t\t\tfirst_conn_timeout = 0;\n\t\t}\n\n\t\tif (nofb) {\n\t\t\t/* no framebuffer polling needed */\n\t\t\tif (cursor_pos_updates) {\n\t\t\t\tcheck_x11_pointer();\n\t\t\t}\n#ifdef MACOSX\n\t\t\telse check_x11_pointer();\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (x11vnc_current < last_new_client + 0.5 && !all_clients_initialized()) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\t/* XXX not working */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tcheck_xevents(0);\n\t\t\tif (subwin_obscured) {\n\t\t\t\tskip_scan_for_updates = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_scan_for_updates || nofb) {\n\t\t\t;\n\t\t} else if (button_mask && (!show_dragging || pointer_mode == 0)) {\n\t\t\t/*\n\t\t\t * if any button is pressed in this mode do\n\t\t\t * not update rfb screen, but do flush the\n\t\t\t * X11 display.\n\t\t\t */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tdt = 0.0;\n\t\t} else { /* scan for updates case */\n\t\t\tstatic double last_dt = 0.0;\n\t\t\tdouble xdamage_thrash = 0.4; \n\t\t\tstatic int tilecut = -1;\n\n\t\t\t/* for timing the scan to try to detect thrashing */\n\n\t\t\tif (use_xdamage && last_dt > xdamage_thrash)  {\n\t\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t\t}\n\n\t\t\tif (unixpw_in_progress) continue;\n\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\n\t\t\tdtime0(&tm);\n\n#if !NO_X11\n\t\t\tif (xrandr_present && !xrandr && xrandr_maybe) {\n\t\t\t\tint delay = 180;\n\t\t\t\t/*  there may be xrandr right after xsession start */\n\t\t\t\tif (tm < x11vnc_start + delay || tm < last_client + delay) {\n\t\t\t\t\tint tw = 20;\n\t\t\t\t\tif (auth_file != NULL) {\n\t\t\t\t\t\ttw = 120;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tif (tm < x11vnc_start + tw || tm < last_client + tw) {\n\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t\t}\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tcheck_xrandr_event(\"before-scan\");\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n#endif\n\t\t\t/* Now, for scanning and drawing soft cursors (i.e. writing to the framebuffer),\n\t\t\t   make sure we're not sending any updates to clients (i.e. reading the framebuffer).\n\t\t\t   Otherwise we get flicker! */\n\n\t\t\t/* Update offset in case local framebuffer is double buffered */\n\t\t\tif (rawfb_double_buffer) {\n\t\t\t\traw_fb_offset = rawfb_get_offset(&raw_fb_fd);\n\t\t\t}\n\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    LOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\n\t\t\tif (use_snapfb) {\n\t\t\t\tint t, tries = 3;\n\t\t\t\tcopy_snap();\n\t\t\t\tfor (t=0; t < tries; t++) {\n\t\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tif (! nap_ok) {\n\t\t\t\tlast_dt = dt;\n\t\t\t}\n\n\t\t\tif (tilecut < 0) {\n\t\t\t\tif (getenv(\"TILECUT\")) {\n\t\t\t\t\ttilecut = atoi(getenv(\"TILECUT\"));\n\t\t\t\t}\n\t\t\t\tif (tilecut < 0) tilecut = 4;\n\t\t\t}\n\n\t\t\tif ((debug_tiles || debug_scroll > 1 || debug_wireframe > 1)\n\t\t\t    && (tile_diffs > tilecut || debug_tiles > 1)) {\n\t\t\t\tdouble rate = (tile_x * tile_y * bpp/8 * tile_diffs) / dt;\n\t\t\t\tfprintf(stderr, \"============================= TILES: %d  dt: %.4f\"\n\t\t\t\t    \"  t: %.4f  %.2f MB/s nap_ok: %d\\n\", tile_diffs, dt,\n\t\t\t\t    tm - x11vnc_start, rate/1000000.0, nap_ok);\n\t\t\t}\n\n\t\t\t/* important to have this here since it draws cursors into framebuffer */\n\t\t\tcheck_cursor_changes();\n\n\t\t\t/* \n\t\t\t   Release the send ban again.\n\t\t\t*/\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    UNLOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\t\t\t\n\t\t} /* END scan for updates case */\n\n\t\t/* sleep a bit to lessen load */\n\t\twait = choose_delay(dt);\n\n\t\tif (urgent_update) {\n\t\t\t;\n\t\t} else if (wait > 2*waitms) {\n\t\t\t/* bog case, break it up */\n\t\t\tnap_sleep(wait, 10);\n\t\t} else {\n\t\t\tdouble t1, t2;\n\t\t\tint idt;\n\t\t\tif (extra_fbur > 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i <= extra_fbur; i++) {\n\t\t\t\t\tint r = rfbPE(0);\n\t\t\t\t\tif (!r) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* sometimes the sleep is too short, so measure it: */\n\t\t\tt1 = dnow();\n\t\t\tusleep(wait * 1000);\n\t\t\tt2 = dnow();\n\n\t\t\tidt = (int) (1000. * (t2 - t1));\n\t\t\tif (idt > 0 && idt < wait) {\n\t\t\t\t/* try to sleep the remainder */\n\t\t\t\tusleep((wait - idt) * 1000);\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_padded_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void vnc_reflect_process_client(void);",
            "static void nofb_hook(rfbClientPtr cl);",
            "static void install_fake_fb(int w, int h, int bpp);",
            "static void check_filexfer(void);",
            "static void record_last_fb_update(void);",
            "static void check_cursor_changes(void);",
            "static int choose_delay(double dt);",
            "int rawfb_vnc_reflect = 0;",
            "int rawfb_double_buffer = 0;",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid check_padded_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid vnc_reflect_process_client(void);\nstatic void nofb_hook(rfbClientPtr cl);\nstatic void install_fake_fb(int w, int h, int bpp);\nstatic void check_filexfer(void);\nstatic void record_last_fb_update(void);\nstatic void check_cursor_changes(void);\nstatic int choose_delay(double dt);\nint rawfb_vnc_reflect = 0;\nint rawfb_double_buffer = 0;\nstatic rfbClient* client = NULL;\n\nvoid watch_loop(void) {\n\tint cnt = 0, tile_diffs = 0, skip_pe = 0, wait;\n\tdouble tm, dtr, dt = 0.0;\n\ttime_t start = time(NULL);\n\n\tif (use_threads && !started_rfbRunEventLoop) {\n\t\tstarted_rfbRunEventLoop = 1;\n\t\trfbRunEventLoop(screen, -1, TRUE);\n\t}\n\n\twhile (1) {\n\t\tchar msg[] = \"new client: %s taking unixpw client off hold.\\n\";\n\t\tint skip_scan_for_updates = 0;\n\n\t\tgot_user_input = 0;\n\t\tgot_pointer_input = 0;\n\t\tgot_local_pointer_input = 0;\n\t\tgot_pointer_calls = 0;\n\t\tgot_keyboard_input = 0;\n\t\tgot_keyboard_calls = 0;\n\t\turgent_update = 0;\n\n\t\tx11vnc_current = dnow();\n\n\t\tif (! use_threads) {\n\t\t\tdtime0(&tm);\n\t\t\tif (! skip_pe) {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(1);\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 1;\n\n\t\t\t\t/*\n\t\t\t\t * do a few more since a key press may\n\t\t\t\t * have induced a small change we want to\n\t\t\t\t * see quickly (just 1 rfbPE will likely\n\t\t\t\t * only process the subsequent \"up\" event)\n\t\t\t\t */\n\t\t\t\tif (tm < last_keyboard_time + 0.20) {\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t\trfbPE(0);\n\t\t\t\t} else {\n\t\t\t\t\tif (extra_fbur > 0) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i=0; i < extra_fbur; i++) {\n\t\t\t\t\t\t\trfbPE(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tif (x11vnc_current < last_new_client + 0.5) {\n\t\t\t\t\turgent_update = 1;\n\t\t\t\t}\n\n\t\t\t\tunixpw_in_rfbPE = 0;\n\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\t/* rfbPE loop until logged in. */\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tmeasure_send_rates(0);\n\t\t\t\t\tfb_update_sent(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (unixpw_in_progress) {\n\t\t\t\t\tskip_pe = 0;\n\t\t\t\t\tcheck_new_clients();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdtr = dtime(&tm);\n\n\t\t\tif (! cursor_shape_updates) {\n\t\t\t\t/* undo any cursor shape requests */\n\t\t\t\tdisable_cursor_shape_updates(screen);\n\t\t\t}\n\t\t\tif (screen && screen->clientHead) {\n\t\t\t\tint ret = check_user_input(dt, dtr, tile_diffs, &cnt);\n\t\t\t\t/* true: loop back for more input */\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\tskip_pe = 1;\n\t\t\t\t}\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (debug_scroll) fprintf(stderr, \"watch_loop: LOOP-BACK: %d\\n\", ret);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* watch for viewonly input piling up: */\n\t\t\tif ((got_pointer_calls > got_pointer_input) ||\n\t\t\t    (got_keyboard_calls > got_keyboard_input)) {\n\t\t\t\teat_viewonly_input(10, 3);\n\t\t\t}\n\t\t} else {\n\t\t\t/* -threads here. */\n\t\t\tif (unixpw_in_progress) {\n\t\t\t\trfbClientPtr cl = unixpw_client;\n\t\t\t\tif (cl && cl->onHold) {\n\t\t\t\t\trfbLog(msg, cl->host);\n\t\t\t\t\tunixpw_client->onHold = FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (use_xrecord) {\n\t\t\t\tcheck_xrecord();\n\t\t\t}\n\t\t\tif (wireframe && button_mask) {\n\t\t\t\tcheck_wireframe();\n\t\t\t}\n\t\t}\n\t\tskip_pe = 0;\n\n\t\tif (shut_down) {\n\t\t\tclean_up_exit(0);\n\t\t}\n\n\t\tif (unixpw_in_progress) {\n\t\t\tcheck_new_clients();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (! urgent_update) {\n\t\t\tif (do_copy_screen) {\n\t\t\t\tdo_copy_screen = 0;\n\t\t\t\tcopy_screen();\n\t\t\t}\n\n\t\t\tcheck_new_clients();\n\t\t\tcheck_ncache(0, 0);\n\t\t\tcheck_xevents(0);\n\t\t\tcheck_autorepeat();\n\t\t\tcheck_pm();\n\t\t\tcheck_filexfer();\n\t\t\tcheck_keycode_state();\n\t\t\tcheck_connect_inputs();\n\t\t\tcheck_gui_inputs();\n\t\t\tcheck_stunnel();\n\t\t\tcheck_openssl();\n\t\t\tcheck_https();\n\t\t\trecord_last_fb_update();\n\t\t\tcheck_padded_fb();\n\t\t\tcheck_fixscreen();\n\t\t\tcheck_xdamage_state();\n\t\t\tcheck_xrecord_reset(0);\n\t\t\tcheck_add_keysyms();\n\t\t\tcheck_new_passwds(0);\n#ifdef ENABLE_GRABLOCAL\n\t\t\tif (grab_local) {\n\t\t\t\tcheck_local_grab();\n\t\t\t}\n#endif\n\t\t\tif (started_as_root) {\n\t\t\t\tcheck_switched_user();\n\t\t\t}\n\n\t\t\tif (first_conn_timeout < 0) {\n\t\t\t\tstart = time(NULL);\n\t\t\t\tfirst_conn_timeout = -first_conn_timeout;\n\t\t\t}\n\t\t}\n\n\t\tif (rawfb_vnc_reflect) {\n\t\t\tstatic time_t lastone = 0;\n\t\t\tif (time(NULL) > lastone + 10) {\n\t\t\t\tlastone = time(NULL);\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\t\t}\n\n\t\tif (first_conn_timeout) {\n\t\t\tint t = first_conn_timeout;\n\t\t\tif (!clients_served) {\n\t\t\t\tif (time(NULL) - start > first_conn_timeout) {\n\t\t\t\t\trfbLog(\"No client after %d secs.\\n\", t);\n\t\t\t\t\tshut_down = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!client_normal_count) {\n\t\t\t\t\tif (time(NULL) - start > t + 3) {\n\t\t\t\t\t\trfbLog(\"No valid client after %d secs.\\n\", t + 3);\n\t\t\t\t\t\tshut_down = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (! screen || ! screen->clientHead) {\n\t\t\t/* waiting for a client */\n\t\t\tusleep(200 * 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (first_conn_timeout && all_clients_initialized()) {\n\t\t\tfirst_conn_timeout = 0;\n\t\t}\n\n\t\tif (nofb) {\n\t\t\t/* no framebuffer polling needed */\n\t\t\tif (cursor_pos_updates) {\n\t\t\t\tcheck_x11_pointer();\n\t\t\t}\n#ifdef MACOSX\n\t\t\telse check_x11_pointer();\n#endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (x11vnc_current < last_new_client + 0.5 && !all_clients_initialized()) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\t/* XXX not working */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tcheck_xevents(0);\n\t\t\tif (subwin_obscured) {\n\t\t\t\tskip_scan_for_updates = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_scan_for_updates || nofb) {\n\t\t\t;\n\t\t} else if (button_mask && (!show_dragging || pointer_mode == 0)) {\n\t\t\t/*\n\t\t\t * if any button is pressed in this mode do\n\t\t\t * not update rfb screen, but do flush the\n\t\t\t * X11 display.\n\t\t\t */\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t\tdt = 0.0;\n\t\t} else { /* scan for updates case */\n\t\t\tstatic double last_dt = 0.0;\n\t\t\tdouble xdamage_thrash = 0.4; \n\t\t\tstatic int tilecut = -1;\n\n\t\t\t/* for timing the scan to try to detect thrashing */\n\n\t\t\tif (use_xdamage && last_dt > xdamage_thrash)  {\n\t\t\t\tclear_xdamage_mark_region(NULL, 0);\n\t\t\t}\n\n\t\t\tif (unixpw_in_progress) continue;\n\n\t\t\tif (rawfb_vnc_reflect) {\n\t\t\t\tvnc_reflect_process_client();\n\t\t\t}\n\n\t\t\tdtime0(&tm);\n\n#if !NO_X11\n\t\t\tif (xrandr_present && !xrandr && xrandr_maybe) {\n\t\t\t\tint delay = 180;\n\t\t\t\t/*  there may be xrandr right after xsession start */\n\t\t\t\tif (tm < x11vnc_start + delay || tm < last_client + delay) {\n\t\t\t\t\tint tw = 20;\n\t\t\t\t\tif (auth_file != NULL) {\n\t\t\t\t\t\ttw = 120;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tif (tm < x11vnc_start + tw || tm < last_client + tw) {\n\t\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t\t}\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tcheck_xrandr_event(\"before-scan\");\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n#endif\n\t\t\t/* Now, for scanning and drawing soft cursors (i.e. writing to the framebuffer),\n\t\t\t   make sure we're not sending any updates to clients (i.e. reading the framebuffer).\n\t\t\t   Otherwise we get flicker! */\n\n\t\t\t/* Update offset in case local framebuffer is double buffered */\n\t\t\tif (rawfb_double_buffer) {\n\t\t\t\traw_fb_offset = rawfb_get_offset(&raw_fb_fd);\n\t\t\t}\n\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    LOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\n\t\t\tif (use_snapfb) {\n\t\t\t\tint t, tries = 3;\n\t\t\t\tcopy_snap();\n\t\t\t\tfor (t=0; t < tries; t++) {\n\t\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttile_diffs = scan_for_updates(0);\n\t\t\t}\n\t\t\tdt = dtime(&tm);\n\t\t\tif (! nap_ok) {\n\t\t\t\tlast_dt = dt;\n\t\t\t}\n\n\t\t\tif (tilecut < 0) {\n\t\t\t\tif (getenv(\"TILECUT\")) {\n\t\t\t\t\ttilecut = atoi(getenv(\"TILECUT\"));\n\t\t\t\t}\n\t\t\t\tif (tilecut < 0) tilecut = 4;\n\t\t\t}\n\n\t\t\tif ((debug_tiles || debug_scroll > 1 || debug_wireframe > 1)\n\t\t\t    && (tile_diffs > tilecut || debug_tiles > 1)) {\n\t\t\t\tdouble rate = (tile_x * tile_y * bpp/8 * tile_diffs) / dt;\n\t\t\t\tfprintf(stderr, \"============================= TILES: %d  dt: %.4f\"\n\t\t\t\t    \"  t: %.4f  %.2f MB/s nap_ok: %d\\n\", tile_diffs, dt,\n\t\t\t\t    tm - x11vnc_start, rate/1000000.0, nap_ok);\n\t\t\t}\n\n\t\t\t/* important to have this here since it draws cursors into framebuffer */\n\t\t\tcheck_cursor_changes();\n\n\t\t\t/* \n\t\t\t   Release the send ban again.\n\t\t\t*/\n\t\t\tif(use_threads){\n\t\t\t  rfbClientPtr cl;\n\t\t\t  rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n\t\t\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n\t\t\t    UNLOCK(cl->sendMutex);\n\t\t\t  }\n\t\t\t  rfbReleaseClientIterator(iter);\n\t\t\t}\n\t\t\t\n\t\t} /* END scan for updates case */\n\n\t\t/* sleep a bit to lessen load */\n\t\twait = choose_delay(dt);\n\n\t\tif (urgent_update) {\n\t\t\t;\n\t\t} else if (wait > 2*waitms) {\n\t\t\t/* bog case, break it up */\n\t\t\tnap_sleep(wait, 10);\n\t\t} else {\n\t\t\tdouble t1, t2;\n\t\t\tint idt;\n\t\t\tif (extra_fbur > 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i <= extra_fbur; i++) {\n\t\t\t\t\tint r = rfbPE(0);\n\t\t\t\t\tif (!r) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* sometimes the sleep is too short, so measure it: */\n\t\t\tt1 = dnow();\n\t\t\tusleep(wait * 1000);\n\t\t\tt2 = dnow();\n\n\t\t\tidt = (int) (1000. * (t2 - t1));\n\t\t\tif (idt > 0 && idt < wait) {\n\t\t\t\t/* try to sleep the remainder */\n\t\t\t\tusleep((wait - idt) * 1000);\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: watch_loop\\n\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_xevents",
          "args": [
            "1"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "check_xevents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1203-1675",
          "snippet": "void check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DEBUG_XEVENTS 1"
          ],
          "globals_used": [
            "int sync_tod_delay = 20;",
            "void sync_tod_with_servertime(void);",
            "void set_prop_atom(Atom atom);",
            "void check_xevents(int reset);",
            "void set_server_input(rfbClientPtr cl, int s);",
            "void set_text_chat(rfbClientPtr cl, int l, char *t);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
            "static void initialize_xevents(int reset);",
            "static void print_xevent_bases(void);",
            "static void bust_grab(int reset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DEBUG_XEVENTS 1\n\nint sync_tod_delay = 20;\nvoid sync_tod_with_servertime(void);\nvoid set_prop_atom(Atom atom);\nvoid check_xevents(int reset);\nvoid set_server_input(rfbClientPtr cl, int s);\nvoid set_text_chat(rfbClientPtr cl, int l, char *t);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void print_xevent_bases(void);\nstatic void bust_grab(int reset);\n\nvoid check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: check_xevents\\n\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_shm",
          "args": [
            "1"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "clean_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "93-132",
          "snippet": "void clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_shm(int quick);",
            "int trap_xioerror(Display *d);",
            "static int XIOerr(Display *d);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_shm(int quick);\nint trap_xioerror(Display *d);\nstatic int XIOerr(Display *d);\n\nvoid clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: clean_shm\\n\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: do_new_fb\\n\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_xdamage_if_needed",
          "args": [
            "1"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "create_xdamage_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "770-785",
          "snippet": "void create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void create_xdamage_if_needed(int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid create_xdamage_if_needed(int force);\n\nvoid create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: xdamage\\n\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_xrecord",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xrecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "187-283",
          "snippet": "void initialize_xrecord(void) {\n\tuse_xrecord = 0;\n\tif (! xrecord_present) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n\tif (noxrecord) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_RECORD\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = XRecordAllocRange();\n\trr_CW = XRecordAllocRange();\n\trr_GS = XRecordAllocRange();\n\tif (!rr_CA || !rr_CW || !rr_GS) {\n\t\treturn;\n\t}\n\t/* protocol request ranges: */\n\trr_CA->core_requests.first = X_CopyArea;\n\trr_CA->core_requests.last  = X_CopyArea;\n\t\n\trr_CW->core_requests.first = X_ConfigureWindow;\n\trr_CW->core_requests.last  = X_ConfigureWindow;\n\n\trr_GS->core_requests.first = X_GrabServer;\n\trr_GS->core_requests.last  = X_UngrabServer;\n\n\tX_LOCK;\n\t/* open a 2nd control connection to DISPLAY: */\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\trdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_ctrl) {\n\t\tfprintf(stderr, \"rdpy_ctrl open failed: %s / %s / %s / %s\\n\", getenv(\"DISPLAY\"), DisplayString(dpy), getenv(\"XAUTHORITY\"), getenv(\"XAUTHORIT_\"));\n\t}\n\tXSync(dpy, True);\n\tXSync(rdpy_ctrl, True);\n\t/* open datalink connection to DISPLAY: */\n\trdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_data) {\n\t\tfprintf(stderr, \"rdpy_data open failed\\n\");\n\t}\n\tif (!rdpy_ctrl || ! rdpy_data) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tdisable_grabserver(rdpy_ctrl, 0);\n\tdisable_grabserver(rdpy_data, 0);\n\n\tuse_xrecord = 1;\n\n\t/*\n\t * now set up the GrabServer watcher.  We get GrabServer\n\t * deadlock in XRecordCreateContext() even with XTestGrabServer\n\t * in place, why?  Not sure, so we manually watch for grabs...\n\t */\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\n\tgdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_ctrl) {\n\t\tfprintf(stderr, \"gdpy_ctrl open failed\\n\");\n\t}\n\tXSync(dpy, True);\n\tXSync(gdpy_ctrl, True);\n\tgdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_data) {\n\t\tfprintf(stderr, \"gdpy_data open failed\\n\");\n\t}\n\tif (gdpy_ctrl && gdpy_data) {\n\t\tdisable_grabserver(gdpy_ctrl, 0);\n\t\tdisable_grabserver(gdpy_data, 0);\n\t\txrecord_grabserver(1);\n\t}\n\tX_UNLOCK;\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "int xserver_grabbed = 0;",
            "void initialize_xrecord(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nint xserver_grabbed = 0;\nvoid initialize_xrecord(void);\n\nvoid initialize_xrecord(void) {\n\tuse_xrecord = 0;\n\tif (! xrecord_present) {\n\t\treturn;\n\t}\n\tif (nofb) {\n\t\treturn;\n\t}\n\tif (noxrecord) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_RECORD\n\n\tif (rr_CA) XFree_wr(rr_CA);\n\tif (rr_CW) XFree_wr(rr_CW);\n\tif (rr_GS) XFree_wr(rr_GS);\n\n\trr_CA = XRecordAllocRange();\n\trr_CW = XRecordAllocRange();\n\trr_GS = XRecordAllocRange();\n\tif (!rr_CA || !rr_CW || !rr_GS) {\n\t\treturn;\n\t}\n\t/* protocol request ranges: */\n\trr_CA->core_requests.first = X_CopyArea;\n\trr_CA->core_requests.last  = X_CopyArea;\n\t\n\trr_CW->core_requests.first = X_ConfigureWindow;\n\trr_CW->core_requests.last  = X_ConfigureWindow;\n\n\trr_GS->core_requests.first = X_GrabServer;\n\trr_GS->core_requests.last  = X_UngrabServer;\n\n\tX_LOCK;\n\t/* open a 2nd control connection to DISPLAY: */\n\tif (rdpy_data) {\n\t\tXCloseDisplay_wr(rdpy_data);\n\t\trdpy_data = NULL;\n\t}\n\tif (rdpy_ctrl) {\n\t\tXCloseDisplay_wr(rdpy_ctrl);\n\t\trdpy_ctrl = NULL;\n\t}\n\trdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_ctrl) {\n\t\tfprintf(stderr, \"rdpy_ctrl open failed: %s / %s / %s / %s\\n\", getenv(\"DISPLAY\"), DisplayString(dpy), getenv(\"XAUTHORITY\"), getenv(\"XAUTHORIT_\"));\n\t}\n\tXSync(dpy, True);\n\tXSync(rdpy_ctrl, True);\n\t/* open datalink connection to DISPLAY: */\n\trdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!rdpy_data) {\n\t\tfprintf(stderr, \"rdpy_data open failed\\n\");\n\t}\n\tif (!rdpy_ctrl || ! rdpy_data) {\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\tdisable_grabserver(rdpy_ctrl, 0);\n\tdisable_grabserver(rdpy_data, 0);\n\n\tuse_xrecord = 1;\n\n\t/*\n\t * now set up the GrabServer watcher.  We get GrabServer\n\t * deadlock in XRecordCreateContext() even with XTestGrabServer\n\t * in place, why?  Not sure, so we manually watch for grabs...\n\t */\n\tif (gdpy_data) {\n\t\tXCloseDisplay_wr(gdpy_data);\n\t\tgdpy_data = NULL;\n\t}\n\tif (gdpy_ctrl) {\n\t\tXCloseDisplay_wr(gdpy_ctrl);\n\t\tgdpy_ctrl = NULL;\n\t}\n\txserver_grabbed = 0;\n\n\tgdpy_ctrl = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_ctrl) {\n\t\tfprintf(stderr, \"gdpy_ctrl open failed\\n\");\n\t}\n\tXSync(dpy, True);\n\tXSync(gdpy_ctrl, True);\n\tgdpy_data = XOpenDisplay_wr(DisplayString(dpy));\n\tif (!gdpy_data) {\n\t\tfprintf(stderr, \"gdpy_data open failed\\n\");\n\t}\n\tif (gdpy_ctrl && gdpy_data) {\n\t\tdisable_grabserver(gdpy_ctrl, 0);\n\t\tdisable_grabserver(gdpy_data, 0);\n\t\txrecord_grabserver(1);\n\t}\n\tX_UNLOCK;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "zerodisp_xrecord",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "zerodisp_xrecord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrecord.c",
          "lines": "180-185",
          "snippet": "void zerodisp_xrecord(void) {\n\trdpy_data = NULL;\n\trdpy_ctrl = NULL;\n\tgdpy_data = NULL;\n\tgdpy_ctrl = NULL;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"scrollevent_t.h\"",
            "#include \"winattr_t.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *rdpy_data = NULL;",
            "Display *rdpy_ctrl = NULL;",
            "Display *gdpy_ctrl = NULL;",
            "Display *gdpy_data = NULL;",
            "void zerodisp_xrecord(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"scrollevent_t.h\"\n#include \"winattr_t.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nDisplay *rdpy_data = NULL;\nDisplay *rdpy_ctrl = NULL;\nDisplay *gdpy_ctrl = NULL;\nDisplay *gdpy_data = NULL;\nvoid zerodisp_xrecord(void);\n\nvoid zerodisp_xrecord(void) {\n\trdpy_data = NULL;\n\trdpy_ctrl = NULL;\n\tgdpy_data = NULL;\n\tgdpy_ctrl = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: xrecord\\n\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_grabserver",
          "args": [
            "dpy",
            "0"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "disable_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1313-1372",
          "snippet": "void disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void disable_grabserver(Display *in_dpy, int change);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid disable_grabserver(Display *in_dpy, int change);\n\nvoid disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: disable_grabserver\\n\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RootWindow",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreen",
          "args": [
            "dpy"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: '%s' 0x%x\\n\"",
            "dstr",
            "dpy"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: Reopened display '%s' successfully.\\n\"",
            "dstr"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"dpy[%d/%d]: %p\\n\"",
            "i+1",
            "sleepmax",
            "dpy"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "dstr"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000 * 1000"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: Note the reopened state may be unstable.\\n\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"*** XIO error: Trying to reopen[%d/%d] display '%s'\\n\"",
            "reopen",
            "rmax",
            "dstr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_REOPEN_SLEEP_MAX\")"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REOPEN_SLEEP_MAX\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REOPEN_SLEEP_MAX\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "DisplayString(save_dpy)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "save_dpy"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REOPEN_DEBUG\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REOPEN_DISPLAY\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_REOPEN_DISPLAY\")"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REOPEN_DISPLAY\""
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REOPEN_DISPLAY\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_xioerror(Display *d);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nint known_sigpipe_mode(char *s);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic int XIOerr(Display *d);\nstatic XIOErrorHandler XIOerr_def;\nvoid watch_loop(void);\n\nstatic int XIOerr(Display *d) {\n\tstatic int reopen = 0, rmax = 1;\n\tX_UNLOCK;\n\n\tif (getenv(\"X11VNC_REOPEN_DISPLAY\")) {\n\t\trmax = atoi(getenv(\"X11VNC_REOPEN_DISPLAY\"));\n\t}\n\n#if !NO_X11\n\tif (reopen < rmax && getenv(\"X11VNC_REOPEN_DISPLAY\")) {\n\t\tint db = getenv(\"X11VNC_REOPEN_DEBUG\") ? 1 : 0;\n\t\tint sleepmax = 10, i;\n\t\tDisplay *save_dpy = dpy;\n\t\tchar *dstr = strdup(DisplayString(save_dpy));\n\t\treopen++;\t\n\t\tif (getenv(\"X11VNC_REOPEN_SLEEP_MAX\")) {\n\t\t\tsleepmax = atoi(getenv(\"X11VNC_REOPEN_SLEEP_MAX\"));\n\t\t}\n\t\trfbLog(\"*** XIO error: Trying to reopen[%d/%d] display '%s'\\n\", reopen, rmax, dstr);\n\t\trfbLog(\"*** XIO error: Note the reopened state may be unstable.\\n\");\n\t\tfor (i=0; i < sleepmax; i++) {\n\t\t\tusleep (1000 * 1000);\n\t\t\tdpy = XOpenDisplay_wr(dstr);\n\t\t\trfbLog(\"dpy[%d/%d]: %p\\n\", i+1, sleepmax, dpy);\n\t\t\tif (dpy) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlast_open_xdisplay = time(NULL);\n\t\tif (dpy) {\n\t\t\trfbLog(\"*** XIO error: Reopened display '%s' successfully.\\n\", dstr);\n\t\t\tif (db) rfbLog(\"*** XIO error: '%s' 0x%x\\n\", dstr, dpy);\n\t\t\tscr = DefaultScreen(dpy);\n\t\t\trootwin = RootWindow(dpy, scr);\n\t\t\tif (db) rfbLog(\"*** XIO error: disable_grabserver\\n\");\n\t\t\tdisable_grabserver(dpy, 0);\n\t\t\tif (db) rfbLog(\"*** XIO error: xrecord\\n\");\n\t\t\tzerodisp_xrecord();\n\t\t\tinitialize_xrecord();\n\t\t\tif (db) rfbLog(\"*** XIO error: xdamage\\n\");\n\t\t\tcreate_xdamage_if_needed(1);\n\t\t\tif (db) rfbLog(\"*** XIO error: do_new_fb\\n\");\n\t\t\tif (using_shm) {\n\t\t\t\tif (db) rfbLog(\"*** XIO error: clean_shm\\n\");\n\t\t\t\tclean_shm(1);\n\t\t\t}\n\t\t\tdo_new_fb(1);\n\t\t\tif (db) rfbLog(\"*** XIO error: check_xevents\\n\");\n\t\t\tcheck_xevents(1);\n\n\t\t\t/* sadly, we can never return... */\n\t\t\tif (db) rfbLog(\"*** XIO error: watch_loop\\n\");\n\t\t\twatch_loop();\n\t\t\tclean_up_exit(1);\t\n\t\t}\n\t}\n#endif\n\n\tinterrupted(-1);\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn (*XIOerr_def)(d);\n}"
  },
  {
    "function_name": "Xerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "306-333",
    "snippet": "static int Xerror(Display *d, XErrorEvent *error) {\n\tX_UNLOCK;\n\n\tif (getenv(\"X11VNC_PRINT_XERROR\")) {\n\t\tfprintf(stderr, \"Xerror: major_opcode: %d minor_opcode: %d error_code: %d\\n\",\n\t\t    error->request_code, error->minor_code, error->error_code);\n\t}\n\n\tif (xshm_opcode > 0 && error->request_code == xshm_opcode) {\n\t\tif (error->minor_code == X_ShmAttach) {\n\t\t\tchar *dstr = DisplayString(dpy);\n\t\t\tfprintf(stderr, \"\\nX11 MIT Shared Memory Attach failed:\\n\");\n\t\t\tfprintf(stderr, \"  Is your DISPLAY=%s on a remote machine?\\n\", dstr);\n\t\t\tif (strstr(dstr, \"localhost:\")) {\n\t\t\t\tfprintf(stderr, \"  Note:   DISPLAY=localhost:N suggests a SSH X11 redir to a remote machine.\\n\");\n\t\t\t} else if (dstr[0] != ':') {\n\t\t\t\tfprintf(stderr, \"  Note:   DISPLAY=hostname:N suggests a remote display.\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"  Suggestion, use: x11vnc -display :0 ... for local display :0\\n\\n\");\n\t\t}\n\t}\n\n\tinterrupted(0);\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn (*Xerror_def)(d, error);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define X_ShmAttach 1"
    ],
    "globals_used": [
      "int trap_xerror(Display *d, XErrorEvent *error);",
      "int trap_xioerror(Display *d);",
      "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
      "char *xerror_string(XErrorEvent *error);",
      "int known_sigpipe_mode(char *s);",
      "static int Xerror(Display *d, XErrorEvent *error);",
      "static int XIOerr(Display *d);",
      "static XErrorHandler   Xerror_def;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "d",
            "error"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interrupted",
          "args": [
            "0"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "interrupted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "534-627",
          "snippet": "static void interrupted (int sig) {\n\texit_sig = sig;\n\tif (exit_flag) {\n\t\tfprintf(stderr, \"extra[%d] signal: %d\\n\", exit_flag, sig);\n\t\texit_flag++;\n\t\tif (use_threads)\n\t\t  usleep2(250 * 1000);\n\t\tif (exit_flag <= 2)\n\t\t  return;\n\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\n\t\t/* remove all created XInput2 devices */\n\t\tif(use_multipointer)\n\t\t    removeAllMDs(dpy);\n\n\t\texit(4);\n\t}\n\texit_flag++;\n\tif (sig == 0) {\n\t\tfprintf(stderr, \"caught X11 error:\\n\");\n\t\tif (crash_debug) { crash_shell(); }\n\t} else if (sig == -1) {\n\t\tfprintf(stderr, \"caught XIO error:\\n\");\n\t} else {\n\t\tfprintf(stderr, \"caught signal: %d\\n\", sig);\n\t}\n\tif (sig == SIGINT) {\n\t\tshut_down = 1;\n\t\treturn;\n\t}\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tX_UNLOCK;\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\t/* remove the shm areas with quick=1: */\n\tclean_shm(1);\n\n\tif (sig == -1) {\n\t\t/* not worth trying any more cleanup, X server probably gone */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(3);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tstop_stunnel();\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tif (sig) {\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(2);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int crash_debug = 0;",
            "void clean_shm(int quick);",
            "int trap_xerror(Display *d, XErrorEvent *error);",
            "int trap_xioerror(Display *d);",
            "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
            "char *xerror_string(XErrorEvent *error);",
            "static int exit_flag = 0;",
            "static int exit_sig = 0;",
            "static void clean_icon_mode(void);",
            "static int Xerror(Display *d, XErrorEvent *error);",
            "static int XIOerr(Display *d);",
            "static void crash_shell(void);",
            "static void interrupted (int sig);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint crash_debug = 0;\nvoid clean_shm(int quick);\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_xioerror(Display *d);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int exit_flag = 0;\nstatic int exit_sig = 0;\nstatic void clean_icon_mode(void);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic int XIOerr(Display *d);\nstatic void crash_shell(void);\nstatic void interrupted (int sig);\n\nstatic void interrupted (int sig) {\n\texit_sig = sig;\n\tif (exit_flag) {\n\t\tfprintf(stderr, \"extra[%d] signal: %d\\n\", exit_flag, sig);\n\t\texit_flag++;\n\t\tif (use_threads)\n\t\t  usleep2(250 * 1000);\n\t\tif (exit_flag <= 2)\n\t\t  return;\n\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\n\t\t/* remove all created XInput2 devices */\n\t\tif(use_multipointer)\n\t\t    removeAllMDs(dpy);\n\n\t\texit(4);\n\t}\n\texit_flag++;\n\tif (sig == 0) {\n\t\tfprintf(stderr, \"caught X11 error:\\n\");\n\t\tif (crash_debug) { crash_shell(); }\n\t} else if (sig == -1) {\n\t\tfprintf(stderr, \"caught XIO error:\\n\");\n\t} else {\n\t\tfprintf(stderr, \"caught signal: %d\\n\", sig);\n\t}\n\tif (sig == SIGINT) {\n\t\tshut_down = 1;\n\t\treturn;\n\t}\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tX_UNLOCK;\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\t/* remove the shm areas with quick=1: */\n\tclean_shm(1);\n\n\tif (sig == -1) {\n\t\t/* not worth trying any more cleanup, X server probably gone */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(3);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tstop_stunnel();\n\n\tif (crash_debug) {\n\t\tcrash_shell();\n\t}\n\n\tif (sig) {\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  Suggestion, use: x11vnc -display :0 ... for local display :0\\n\\n\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  Note:   DISPLAY=hostname:N suggests a remote display.\\n\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  Note:   DISPLAY=localhost:N suggests a SSH X11 redir to a remote machine.\\n\""
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dstr",
            "\"localhost:\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  Is your DISPLAY=%s on a remote machine?\\n\"",
            "dstr"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nX11 MIT Shared Memory Attach failed:\\n\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Xerror: major_opcode: %d minor_opcode: %d error_code: %d\\n\"",
            "error->request_code",
            "error->minor_code",
            "error->error_code"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_PRINT_XERROR\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define X_ShmAttach 1\n\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_xioerror(Display *d);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nint known_sigpipe_mode(char *s);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic int XIOerr(Display *d);\nstatic XErrorHandler   Xerror_def;\n\nstatic int Xerror(Display *d, XErrorEvent *error) {\n\tX_UNLOCK;\n\n\tif (getenv(\"X11VNC_PRINT_XERROR\")) {\n\t\tfprintf(stderr, \"Xerror: major_opcode: %d minor_opcode: %d error_code: %d\\n\",\n\t\t    error->request_code, error->minor_code, error->error_code);\n\t}\n\n\tif (xshm_opcode > 0 && error->request_code == xshm_opcode) {\n\t\tif (error->minor_code == X_ShmAttach) {\n\t\t\tchar *dstr = DisplayString(dpy);\n\t\t\tfprintf(stderr, \"\\nX11 MIT Shared Memory Attach failed:\\n\");\n\t\t\tfprintf(stderr, \"  Is your DISPLAY=%s on a remote machine?\\n\", dstr);\n\t\t\tif (strstr(dstr, \"localhost:\")) {\n\t\t\t\tfprintf(stderr, \"  Note:   DISPLAY=localhost:N suggests a SSH X11 redir to a remote machine.\\n\");\n\t\t\t} else if (dstr[0] != ':') {\n\t\t\t\tfprintf(stderr, \"  Note:   DISPLAY=hostname:N suggests a remote display.\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"  Suggestion, use: x11vnc -display :0 ... for local display :0\\n\\n\");\n\t\t}\n\t}\n\n\tinterrupted(0);\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn (*Xerror_def)(d, error);\n}"
  },
  {
    "function_name": "trap_getimage_xerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "290-297",
    "snippet": "int trap_getimage_xerror(Display *d, XErrorEvent *error) {\n\ttrapped_getimage_xerror = 1;\n\ttrapped_xerror_event = error;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trapped_getimage_xerror = 0;",
      "XErrorEvent *trapped_xerror_event;",
      "int trap_xerror(Display *d, XErrorEvent *error);",
      "int trap_xioerror(Display *d);",
      "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
      "char *xerror_string(XErrorEvent *error);",
      "static int Xerror(Display *d, XErrorEvent *error);",
      "static int XIOerr(Display *d);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trapped_getimage_xerror = 0;\nXErrorEvent *trapped_xerror_event;\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_xioerror(Display *d);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic int XIOerr(Display *d);\n\nint trap_getimage_xerror(Display *d, XErrorEvent *error) {\n\ttrapped_getimage_xerror = 1;\n\ttrapped_xerror_event = error;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trap_xioerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "282-288",
    "snippet": "int trap_xioerror(Display *d) {\n\ttrapped_xioerror = 1;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trapped_xioerror = 0;",
      "int trap_xioerror(Display *d);",
      "static int XIOerr(Display *d);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trapped_xioerror = 0;\nint trap_xioerror(Display *d);\nstatic int XIOerr(Display *d);\n\nint trap_xioerror(Display *d) {\n\ttrapped_xioerror = 1;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trap_xerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "273-280",
    "snippet": "int trap_xerror(Display *d, XErrorEvent *error) {\n\ttrapped_xerror = 1;\n\ttrapped_xerror_event = error;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int trapped_xerror = 0;",
      "XErrorEvent *trapped_xerror_event;",
      "int trap_xerror(Display *d, XErrorEvent *error);",
      "int trap_xioerror(Display *d);",
      "int trap_getimage_xerror(Display *d, XErrorEvent *error);",
      "char *xerror_string(XErrorEvent *error);",
      "static int Xerror(Display *d, XErrorEvent *error);",
      "static int XIOerr(Display *d);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint trapped_xerror = 0;\nXErrorEvent *trapped_xerror_event;\nint trap_xerror(Display *d, XErrorEvent *error);\nint trap_xioerror(Display *d);\nint trap_getimage_xerror(Display *d, XErrorEvent *error);\nchar *xerror_string(XErrorEvent *error);\nstatic int Xerror(Display *d, XErrorEvent *error);\nstatic int XIOerr(Display *d);\n\nint trap_xerror(Display *d, XErrorEvent *error) {\n\ttrapped_xerror = 1;\n\ttrapped_xerror_event = error;\n\n\tif (d) {} /* unused vars warning: */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clean_up_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "151-266",
    "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void clean_up_exit(int ret);",
      "int known_sigpipe_mode(char *s);",
      "static int exit_flag = 0;",
      "static void clean_icon_mode(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avahi_cleanup",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "avahi_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/avahi.c",
          "lines": "407-431",
          "snippet": "void avahi_cleanup(void) {\nif (db) fprintf(stderr, \"in  avahi_cleanup\\n\");\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_cleanup client null\\n\");\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"    avahi_cleanup poll_lock\\n\");\n\tavahi_threaded_poll_lock(_poll);\nif (db) fprintf(stderr, \"    avahi_cleanup poll_stop\\n\");\n\n\tsignal(SIGALRM, avahi_timeout);\n\talarm(3);\n\tavahi_threaded_poll_stop(_poll);\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\nif (db) fprintf(stderr, \"    avahi_cleanup client_free\\n\");\n\tavahi_client_free(_client);\n\t_client = NULL;\n\nif (db) fprintf(stderr, \"    avahi_cleanup poll_free\\n\");\n\tavahi_threaded_poll_free(_poll);\n\t_poll = NULL;\nif (db) fprintf(stderr, \"out avahi_cleanup\\n\");\n}",
          "includes": [
            "#include <avahi-common/error.h>",
            "#include <avahi-common/malloc.h>",
            "#include <avahi-client/publish.h>",
            "#include <avahi-client/client.h>",
            "#include <avahi-common/alternative.h>",
            "#include <avahi-common/thread-watch.h>",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void avahi_cleanup(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <avahi-common/error.h>\n#include <avahi-common/malloc.h>\n#include <avahi-client/publish.h>\n#include <avahi-client/client.h>\n#include <avahi-common/alternative.h>\n#include <avahi-common/thread-watch.h>\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"x11vnc.h\"\n\nvoid avahi_cleanup(void);\n\nvoid avahi_cleanup(void) {\nif (db) fprintf(stderr, \"in  avahi_cleanup\\n\");\n\tif (!_client) {\nif (db) fprintf(stderr, \"    avahi_cleanup client null\\n\");\n\t\treturn;\n\t}\nif (db) fprintf(stderr, \"    avahi_cleanup poll_lock\\n\");\n\tavahi_threaded_poll_lock(_poll);\nif (db) fprintf(stderr, \"    avahi_cleanup poll_stop\\n\");\n\n\tsignal(SIGALRM, avahi_timeout);\n\talarm(3);\n\tavahi_threaded_poll_stop(_poll);\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\nif (db) fprintf(stderr, \"    avahi_cleanup client_free\\n\");\n\tavahi_client_free(_client);\n\t_client = NULL;\n\nif (db) fprintf(stderr, \"    avahi_cleanup poll_free\\n\");\n\tavahi_threaded_poll_free(_poll);\n\t_poll = NULL;\nif (db) fprintf(stderr, \"out avahi_cleanup\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "rm_flagfile"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCloseDisplay_wr",
          "args": [
            "dpy"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "XCloseDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1504-1512",
          "snippet": "int XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nint XCloseDisplay_wr(Display *display) {\n\tint db = 0;\n\tif (db) fprintf(stderr, \"XCloseDisplay_wr: %p\\n\", (void *)display);\n#if NO_X11\n\treturn 0;\n#else\n\treturn XCloseDisplay(display);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XEFreeTC",
          "args": [
            "trap_ctx"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDamageDestroy",
          "args": [
            "dpy",
            "xdamage"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTestDiscard_wr",
          "args": [
            "dpy"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "XTestDiscard_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1236-1246",
          "snippet": "void XTestDiscard_wr(Display *dpy) {\n\tif (! xtest_present) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_XTEST\n\tXTestDiscard(dpy);\n#else\n\tif (!dpy) {}\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xtest_present = 0;",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint xtest_present = 0;\nvoid XTestDiscard_wr(Display *dpy);\n\nvoid XTestDiscard_wr(Display *dpy) {\n\tif (! xtest_present) {\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n#if HAVE_XTEST\n\tXTestDiscard(dpy);\n#else\n\tif (!dpy) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kde_no_animate",
          "args": [
            "1"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "kde_no_animate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1055-1160",
          "snippet": "void kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nstatic void solid_macosx(int restore);\n\nvoid kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "solid_bg",
          "args": [
            "1"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "solid_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1330-1425",
          "snippet": "void solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);",
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);",
            "static char *last_color = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\nstatic char *last_color = NULL;\n\nvoid solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autorepeat",
          "args": [
            "1",
            "0"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "autorepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "386-442",
          "snippet": "void autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);",
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static int save_auto_repeat = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic int save_auto_repeat = -1;\n\nvoid autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_locks",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "clear_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "289-349",
          "snippet": "void clear_locks(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXModifierKeymap *map;\n\tint i, j, k = 0;\n\tunsigned int state = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n#if HAVE_XKEYBOARD\n\tif (xkb_present) {\n\t\tXkbStateRec kbstate;\n\t\tXkbGetState(dpy, XkbUseCoreKbd, &kbstate);\n\t\trfbLog(\"locked:  0x%x\\n\", kbstate.locked_mods);\n\t\trfbLog(\"latched: 0x%x\\n\", kbstate.latched_mods);\n\t\trfbLog(\"compat:  0x%x\\n\", kbstate.compat_state);\n\t\tstate = kbstate.locked_mods;\n\t\tif (! state) {\n\t\t\tstate = kbstate.compat_state;\n\t\t}\n\t} else \n#endif\n\t{\n\t\tstate = mask_state();\n\t\t/* this may contain non-locks too... */\n\t\trfbLog(\"state:   0x%x\\n\", state);\n\t}\n\tif (! state) {\n\t\treturn;\n\t}\n\tmap = XGetModifierMapping(dpy);\n\tif (! map) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tint did = 0;\n\t\tfor (j = 0; j < map->max_keypermod; j++) {\n\t\t\tif (! did && state & (0x1 << i)) {\n\t\t\t\tif (map->modifiermap[k]) {\n\t\t\t\t\tKeyCode key = map->modifiermap[k];\n\t\t\t\t\tKeySym ks = XKeycodeToKeysym_wr(dpy, key, 0);\n\t\t\t\t\tchar *nm = XKeysymToString(ks);\n\t\t\t\t\trfbLog(\"toggling: %03d / %03d -- %s\\n\", key, ks, nm ? nm : \"BadKey\");\n\t\t\t\t\tdid = 1;\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime); /* multipointer FIXME? */\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tXFreeModifiermap(map);\n\tXFlush_wr(dpy);\n\trfbLog(\"state:   0x%x\\n\", mask_state());\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clear_locks(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clear_locks(void);\n\nvoid clear_locks(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXModifierKeymap *map;\n\tint i, j, k = 0;\n\tunsigned int state = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n#if HAVE_XKEYBOARD\n\tif (xkb_present) {\n\t\tXkbStateRec kbstate;\n\t\tXkbGetState(dpy, XkbUseCoreKbd, &kbstate);\n\t\trfbLog(\"locked:  0x%x\\n\", kbstate.locked_mods);\n\t\trfbLog(\"latched: 0x%x\\n\", kbstate.latched_mods);\n\t\trfbLog(\"compat:  0x%x\\n\", kbstate.compat_state);\n\t\tstate = kbstate.locked_mods;\n\t\tif (! state) {\n\t\t\tstate = kbstate.compat_state;\n\t\t}\n\t} else \n#endif\n\t{\n\t\tstate = mask_state();\n\t\t/* this may contain non-locks too... */\n\t\trfbLog(\"state:   0x%x\\n\", state);\n\t}\n\tif (! state) {\n\t\treturn;\n\t}\n\tmap = XGetModifierMapping(dpy);\n\tif (! map) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tint did = 0;\n\t\tfor (j = 0; j < map->max_keypermod; j++) {\n\t\t\tif (! did && state & (0x1 << i)) {\n\t\t\t\tif (map->modifiermap[k]) {\n\t\t\t\t\tKeyCode key = map->modifiermap[k];\n\t\t\t\t\tKeySym ks = XKeycodeToKeysym_wr(dpy, key, 0);\n\t\t\t\t\tchar *nm = XKeysymToString(ks);\n\t\t\t\t\trfbLog(\"toggling: %03d / %03d -- %s\\n\", key, ks, nm ? nm : \"BadKey\");\n\t\t\t\t\tdid = 1;\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime); /* multipointer FIXME? */\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t\t\t\t\tXFlush_wr(dpy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tXFreeModifiermap(map);\n\tXFlush_wr(dpy);\n\trfbLog(\"state:   0x%x\\n\", mask_state());\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_keys",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "clear_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "271-286",
          "snippet": "void clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_keys(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_keys(void);\n\nvoid clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_modifiers",
          "args": [
            "0"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "clear_modifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "125-197",
          "snippet": "void clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_modifiers(int init);",
            "int add_keysym(KeySym keysym);",
            "char *short_kmbcf(char *str);",
            "static void add_dead_keysyms(char *str);",
            "static char modifiers[0x100];",
            "static KeyCode keycodes[0x100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_modifiers(int init);\nint add_keysym(KeySym keysym);\nchar *short_kmbcf(char *str);\nstatic void add_dead_keysyms(char *str);\nstatic char modifiers[0x100];\nstatic KeyCode keycodes[0x100];\n\nvoid clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "removeAllMDs",
          "args": [
            "dpy"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "removeAllMDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
          "lines": "158-169",
          "snippet": "void removeAllMDs(Display *dpy)\n{\n    /* remove all created XInput2 devices */\n    rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n    rfbClientPtr cl;\n    while((cl = rfbClientIteratorNext(iter))) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"cleanup: removed XInput2 MD for client %s.\\n\", cl->host);\n    }\n    rfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include <cairo.h>",
            "#include <X11/Xcursor/Xcursor.h>",
            "#include \"xi2_devices.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"cursor.h\"",
            "#include \"x11vnc.h\"",
            "#include <X11/keysym.h>",
            "#include <X11/Xproto.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nvoid removeAllMDs(Display *dpy)\n{\n    /* remove all created XInput2 devices */\n    rfbClientIteratorPtr iter = rfbGetClientIterator(screen);\n    rfbClientPtr cl;\n    while((cl = rfbClientIteratorNext(iter))) {\n\tClientData *cd = (ClientData *) cl->clientData;\n\tif(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"cleanup: removed XInput2 MD for client %s.\\n\", cl->host);\n    }\n    rfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_added_keycodes",
          "args": [
            "0"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "delete_added_keycodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "626-634",
          "snippet": "void delete_added_keycodes(int bequiet) {\n\tint kc;\n\tfor (kc = 0; kc < 0x100; kc++) {\n\t\tif (added_keysyms[kc] != NoSymbol) {\n\t\t\tdelete_keycode(kc, bequiet);\n\t\t\tadded_keysyms[kc] = NoSymbol;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static KeySym added_keysyms[0x100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic KeySym added_keysyms[0x100];\n\nvoid delete_added_keycodes(int bequiet) {\n\tint kc;\n\tfor (kc = 0; kc < 0x100; kc++) {\n\t\tif (added_keysyms[kc] != NoSymbol) {\n\t\t\tdelete_keycode(kc, bequiet);\n\t\t\tadded_keysyms[kc] = NoSymbol;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "rm_flagfile"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "unix_sock"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "unix_sock_fd"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"deleting unix sock: %s\\n\"",
            "unix_sock"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_uinput",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_uinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "215-236",
          "snippet": "void shutdown_uinput(void) {\n#ifdef UINPUT_OK\n\tif (fd >= 0) {\n\t\tif (db) {\n\t\t\trfbLog(\"shutdown_uinput called on fd=%d\\n\", fd);\n\t\t}\n\t\tioctl(fd, UI_DEV_DESTROY);\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\t/* close direct injection files too: */\n\tif (direct_rel_fd >= 0) close(direct_rel_fd);\n\tif (direct_abs_fd >= 0) close(direct_abs_fd);\n\tif (direct_btn_fd >= 0) close(direct_btn_fd);\n\tif (direct_key_fd >= 0) close(direct_key_fd);\n\tdirect_rel_fd = -1;\n\tdirect_abs_fd = -1;\n\tdirect_btn_fd = -1;\n\tdirect_key_fd = -1;\n#endif\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "void shutdown_uinput(void);",
            "static int fd = -1;",
            "static int direct_rel_fd = -1;",
            "static int direct_abs_fd = -1;",
            "static int direct_btn_fd = -1;",
            "static int direct_key_fd = -1;",
            "static int db = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nvoid shutdown_uinput(void);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int direct_abs_fd = -1;\nstatic int direct_btn_fd = -1;\nstatic int direct_key_fd = -1;\nstatic int db = 0;\n\nvoid shutdown_uinput(void) {\n#ifdef UINPUT_OK\n\tif (fd >= 0) {\n\t\tif (db) {\n\t\t\trfbLog(\"shutdown_uinput called on fd=%d\\n\", fd);\n\t\t}\n\t\tioctl(fd, UI_DEV_DESTROY);\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\t/* close direct injection files too: */\n\tif (direct_rel_fd >= 0) close(direct_rel_fd);\n\tif (direct_abs_fd >= 0) close(direct_abs_fd);\n\tif (direct_btn_fd >= 0) close(direct_btn_fd);\n\tif (direct_key_fd >= 0) close(direct_key_fd);\n\tdirect_rel_fd = -1;\n\tdirect_abs_fd = -1;\n\tdirect_btn_fd = -1;\n\tdirect_key_fd = -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "pipeinput_fh"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_fini",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "218-226",
          "snippet": "void macosxCG_fini(void) {\n\tmacosxCGP_dim_shutdown();\n\tif (macosx_noscreensaver) {\n\t\tmacosxCGP_screensaver_timer_off();\n\t}\n\tmacosxCG_refresh_callback_off();\n\tmacosx_opengl_fini();\n\tdisplayID = 0;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_fini(void) {\n\tmacosxCGP_dim_shutdown();\n\tif (macosx_noscreensaver) {\n\t\tmacosxCGP_screensaver_timer_off();\n\t}\n\tmacosxCG_refresh_callback_off();\n\tmacosx_opengl_fini();\n\tdisplayID = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "client_connect_file"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "client_connect_file",
            "\"/tmp/x11vnc-macosx-remote\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "ssh_pid",
            "SIGTERM"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "ssl_helper_pid",
          "args": [
            "0",
            "0"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2999-3117",
          "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_stunnel",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "stop_stunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "378-391",
          "snippet": "void stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSLCMDS"
          ],
          "globals_used": [
            "void stop_stunnel(void);",
            "static pid_t stunnel_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSLCMDS\n\nvoid stop_stunnel(void);\nstatic pid_t stunnel_pid = 0;\n\nvoid stop_stunnel(void) {\n\tint status;\n\tif (! stunnel_pid) {\n\t\treturn;\n\t}\n#ifdef SSLCMDS\n\tkill(stunnel_pid, SIGTERM);\n\tusleep (150 * 1000);\n\tkill(stunnel_pid, SIGKILL);\n\tusleep (50 * 1000);\n\twaitpid(stunnel_pid, &status, WNOHANG); \n#endif\n\tstunnel_pid = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_shm",
          "args": [
            "0"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "clean_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "93-132",
          "snippet": "void clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_shm(int quick);",
            "int trap_xioerror(Display *d);",
            "static int XIOerr(Display *d);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_shm(int quick);\nint trap_xioerror(Display *d);\nstatic int XIOerr(Display *d);\n\nvoid clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_icon_mode",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "clean_icon_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "134-145",
          "snippet": "static void clean_icon_mode(void) {\n\tif (icon_mode && icon_mode_fh) {\n\t\tfprintf(icon_mode_fh, \"quit\\n\");\n\t\tfflush(icon_mode_fh);\n\t\tfclose(icon_mode_fh);\n\t\ticon_mode_fh = NULL;\n\t\tif (icon_mode_file) {\n\t\t\tunlink(icon_mode_file);\n\t\t\ticon_mode_file = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void clean_icon_mode(void);\n\nstatic void clean_icon_mode(void) {\n\tif (icon_mode && icon_mode_fh) {\n\t\tfprintf(icon_mode_fh, \"quit\\n\");\n\t\tfflush(icon_mode_fh);\n\t\tfclose(icon_mode_fh);\n\t\ticon_mode_fh = NULL;\n\t\tif (icon_mode_file) {\n\t\t\tunlink(icon_mode_file);\n\t\t\ticon_mode_file = NULL;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
  },
  {
    "function_name": "clean_icon_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "134-145",
    "snippet": "static void clean_icon_mode(void) {\n\tif (icon_mode && icon_mode_fh) {\n\t\tfprintf(icon_mode_fh, \"quit\\n\");\n\t\tfflush(icon_mode_fh);\n\t\tfclose(icon_mode_fh);\n\t\ticon_mode_fh = NULL;\n\t\tif (icon_mode_file) {\n\t\t\tunlink(icon_mode_file);\n\t\t\ticon_mode_file = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void clean_icon_mode(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "icon_mode_file"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "icon_mode_fh"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "icon_mode_fh"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "icon_mode_fh",
            "\"quit\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void clean_icon_mode(void);\n\nstatic void clean_icon_mode(void) {\n\tif (icon_mode && icon_mode_fh) {\n\t\tfprintf(icon_mode_fh, \"quit\\n\");\n\t\tfflush(icon_mode_fh);\n\t\tfclose(icon_mode_fh);\n\t\ticon_mode_fh = NULL;\n\t\tif (icon_mode_file) {\n\t\t\tunlink(icon_mode_file);\n\t\t\ticon_mode_file = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "clean_shm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
    "lines": "93-132",
    "snippet": "void clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"uinput.h\"",
      "#include \"xevents.h\"",
      "#include \"xrecord.h\"",
      "#include \"screen.h\"",
      "#include \"avahi.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"connections.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"unixpw.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"scan.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"xdamage.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void clean_shm(int quick);",
      "int trap_xioerror(Display *d);",
      "static int XIOerr(Display *d);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"deleted %d tile_row polling images.\\n\"",
            "cnt"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shm_clean",
          "args": [
            "&tile_row_shm[i]",
            "tile_row[i]"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "shm_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "392-421",
          "snippet": "void shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"shm_clean: called:  %p\\n\", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \"shm_clean: XShmDetach_wr\\n\");\n\t\tXShmDetach_wr(dpy, shm);\n\t}\n#endif\n\tif (xim != NULL) {\n\t\tif (! raw_fb_back_to_X) {\t/* raw_fb hack */\n\t\t\tif (xim->bitmap_unit != -1) {\n\t\t\t\tif (db) fprintf(stderr, \"shm_clean: XDestroyImage  %p\\n\", (void *)xim);\n\t\t\t\tXDestroyImage(xim);\n\t\t\t} else {\n\t\t\t\tif (xim->data) {\n\t\t\t\t\tif (db) fprintf(stderr, \"shm_clean: free xim->data  %p %p\\n\", (void *)xim, (void *)(xim->data));\n\t\t\t\t\tfree(xim->data);\n\t\t\t\t\txim->data = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txim = NULL;\n\t}\n\tX_UNLOCK;\n\n\tshm_delete(shm);\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "void shm_clean(XShmSegmentInfo *shm, XImage *xim);",
            "static char *flip_ximage_byte_order(XImage *xim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nstatic char *flip_ximage_byte_order(XImage *xim);\n\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim) {\n\tint db = 0;\n\n\tif (db) fprintf(stderr, \"shm_clean: called:  %p\\n\", (void *)xim);\n\tX_LOCK;\n#if HAVE_XSHM\n\tif (shm != NULL && shm->shmid != -1 && dpy) {\n\t\tif (db) fprintf(stderr, \"shm_clean: XShmDetach_wr\\n\");\n\t\tXShmDetach_wr(dpy, shm);\n\t}\n#endif\n\tif (xim != NULL) {\n\t\tif (! raw_fb_back_to_X) {\t/* raw_fb hack */\n\t\t\tif (xim->bitmap_unit != -1) {\n\t\t\t\tif (db) fprintf(stderr, \"shm_clean: XDestroyImage  %p\\n\", (void *)xim);\n\t\t\t\tXDestroyImage(xim);\n\t\t\t} else {\n\t\t\t\tif (xim->data) {\n\t\t\t\t\tif (db) fprintf(stderr, \"shm_clean: free xim->data  %p %p\\n\", (void *)xim, (void *)(xim->data));\n\t\t\t\t\tfree(xim->data);\n\t\t\t\t\txim->data = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txim = NULL;\n\t}\n\tX_UNLOCK;\n\n\tshm_delete(shm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shm_delete",
          "args": [
            "&tile_row_shm[i]"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "shm_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "374-390",
          "snippet": "void shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\n\nvoid shm_delete(XShmSegmentInfo *shm) {\n#if HAVE_XSHM\n\tif (getenv(\"X11VNC_SHM_DEBUG\")) fprintf(stderr, \"shm_delete:    %p\\n\", (void *) shm);\n\tif (shm != NULL && shm->shmaddr != (char *) -1) {\n\t\tshmdt(shm->shmaddr);\n\t}\n\tif (shm != NULL && shm->shmid != -1) {\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t}\n\tif (shm != NULL) {\n\t\tshm->shmaddr = (char *) -1;\n\t\tshm->shmid = -1;\n\t}\n#else\n\tif (!shm) {}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_shm(int quick);\nint trap_xioerror(Display *d);\nstatic int XIOerr(Display *d);\n\nvoid clean_shm(int quick) {\n\tint i, cnt = 0;\n\n\t/*\n\t * to avoid deadlock, etc, under quick=1 we just delete the shm\n\t * areas and leave the X stuff hanging.\n\t */\n\tif (quick) {\n\t\tshm_delete(&scanline_shm);\n\t\tshm_delete(&fullscreen_shm);\n\t\tshm_delete(&snaprect_shm);\n\t} else {\n\t\tshm_clean(&scanline_shm, scanline);\n\t\tshm_clean(&fullscreen_shm, fullscreen);\n\t\tshm_clean(&snaprect_shm, snaprect);\n\t}\n\n\t/* \n\t * Here we have to clean up quite a few shm areas for all\n\t * the possible tile row runs (40 for 1280), not as robust\n\t * as one might like... sometimes need to run ipcrm(1). \n\t */\n\tfor(i=1; i<=ntiles_x; i++) {\n\t\tif (i > tile_shm_count) {\n\t\t\tbreak;\n\t\t}\n\t\tif (quick) {\n\t\t\tshm_delete(&tile_row_shm[i]);\n\t\t} else {\n\t\t\tshm_clean(&tile_row_shm[i], tile_row[i]);\n\t\t}\n\t\tcnt++;\n\t\tif (single_copytile_count && i >= single_copytile_count) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!quiet && cnt > 0) {\n\t\trfbLog(\"deleted %d tile_row polling images.\\n\", cnt);\n\t}\n}"
  }
]