[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "2108-2147",
    "snippet": "extern int main (int argc, char *argv[]) {\n\tchar *kf, *q;\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_LOOP\")) {\n\t\tif (!getenv(\"ULTRAVNC_DSM_HELPER_LOOP_SET\")) {\n\t\t\tdoloop(argc, argv);\n\t\t}\n\t}\n\n\tif (argc == 3) {\n\t\tif (!strcmp(argv[1], \"showcert\")) {\n\t\t\tenc_do(argv[1], NULL, NULL, argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (argc == 4) {\n\t\tif (!strcmp(argv[1], \"none\") || !strcmp(argv[1], \"relay\")) {\n\t\t\tenc_do(argv[1], NULL, argv[2], argv[3]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (argc < 5) {\n\t\tfprintf(stdout, \"%s\\n\", usage);\n\t\texit(1);\n\t}\n\n\t/* guard against pw= on cmdline (e.g. linux) */\n\tkf = strdup(argv[2]);\n\tq = strstr(argv[2], \"pw=\");\n\tif (q) {\n\t\twhile (*q != '\\0') {\n\t\t\t*q = '\\0';\t/* now ps(1) won't show it */\n\t\t\tq++;\n\t\t}\n\t}\n\n\tenc_do(argv[1], kf, argv[3], argv[4]);\n\n\treturn 0;\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enc_do",
          "args": [
            "argv[1]",
            "kf",
            "argv[3]",
            "argv[4]"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "enc_do",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "347-611",
          "snippet": "extern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\n\tstruct stat sb;\n\tchar *q, *p, *connect_host;\n\tchar tmp[16];\n\tint fd, len = 0, listen_port = 0, connect_port, mbits;\n\n\tq = ciph;\n\n\t/* check for noultra mode: */\n\tif (strstr(q, \"noultra:\") == q) {\n\t\tnoultra = 1;\n\t\tq += strlen(\"noultra:\");\n\t}\n\n\t/* check for reverse mode: */\n\tif (strstr(q, \"rev:\") == q) {\n\t\treverse = 1;\n\t\tq += strlen(\"rev:\");\n\t}\n\n\t/* work out which cipher and set Cipher to the selected one. */\n\tif (!strcasecmp(q, \"msrc4\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t} else if (!strcasecmp(q, \"msrc4_sc\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\t\tmsrc4_sc = 1;\t\t\t/* no salt/iv workaround */\n\n\t} else if (strstr(q, \"arc4\") == q) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t} else if (strstr(q, \"aesv2\") == q || strstr(q, \"aes-ofb\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t} else if (strstr(q, \"aes-cfb\") == q) {\n\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t} else if (strstr(q, \"aes256\") == q) {\n\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t} else if (strstr(q, \"blowfish\") == q) {\n\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t} else if (strstr(q, \"3des\") == q) {\n\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t} else if (strstr(q, \"securevnc\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\tsecurevnc = 1;\n\n\t} else if (strstr(q, \"none\") == q || strstr(q, \"relay\") == q) {\n\t\tcipher = \"none\";\n\n\t} else if (strstr(q, \"showcert\") == q) {\n\t\tcipher = \"showcert\";\n\n\t} else if (strstr(q, \".\") == q) {\n\t\t/* otherwise, try to guess cipher from key filename: */\n\t\tif (strstr(keyfile, \"arc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t\t} else if (strstr(keyfile, \"rc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t\t} else if (strstr(keyfile, \"aesv2.key\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t\t} else if (strstr(keyfile, \"aes-cfb.key\")) {\n\t\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t\t} else if (strstr(keyfile, \"aes256.key\")) {\n\t\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t\t} else if (strstr(keyfile, \"blowfish.key\")) {\n\t\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t\t} else if (strstr(keyfile, \"3des.key\")) {\n\t\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t\t} else if (strstr(keyfile, \"securevnc.\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\t\tsecurevnc = 1;\n\n\t\t} else {\n\t\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\texit(1);\n\t}\n\n\t/* set the default message digest (md5) */\n\tif (!securevnc) {\n\t\tDigest = EVP_md5();\n\t} else {\n\t\tDigest = EVP_sha1();\n\t}\n\n\t/*\n\t * Look for user specified salt and IV sizes at the end\n\t * ( ciph@salt,iv and ciph@[md+]salt,iv ):\n\t */\n\tp = strchr(q, '@');\n\tif (p) {\n\t\tint s, v;\n\t\tp++;\n\t\tif (strstr(p, \"md5+\") == p) {\n\t\t\tDigest = EVP_md5();        p += strlen(\"md5+\");\n#if OPENSSL_VERSION_NUMBER < 0x10100000L && !defined OPENSSL_NO_SHA0\n\t\t} else if (strstr(p, \"sha+\") == p) {\n\t\t\tDigest = EVP_sha();        p += strlen(\"sha+\");\n#endif\n\t\t} else if (strstr(p, \"sha1+\") == p) {\n\t\t\tDigest = EVP_sha1();       p += strlen(\"sha1+\");\n\t\t} else if (strstr(p, \"ripe+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripe+\");\n\t\t} else if (strstr(p, \"ripemd160+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripemd160+\");\n\t\t}\n\t\tif (sscanf(p, \"%d,%d\", &s, &v) == 2) {\n\t\t\t/* cipher@n,m */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (0 <= v && v <= EVP_MAX_IV_LENGTH) {\n\t\t\t\tivec_size = v;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid IV size: %d\\n\",\n\t\t\t\t    prog, v);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (sscanf(p, \"%d\", &s) == 1) {\n\t\t\t/* cipher@n */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (salt_size == -1) {\n\t\t\t/* let salt = -1 mean skip both MD5 and salt */\n\t\t\tnomd = 1;\n\t\t\tsalt_size = 0;\n\t\t}\n\t}\n\n\t/* port to listen on (0 => stdio, negative => localhost) */\n\tif (lport != NULL) {\n\t\tlisten_port = atoi(lport);\n\t}\n\n\t/* extract remote hostname and port */\n\tq = strrchr(rhp, ':');\n\tif (q) {\n\t\tconnect_port = atoi(q+1);\n\t\t*q = '\\0';\n\t} else {\n\t\t/* otherwise guess VNC display 0 ... */\n\t\tconnect_port = 5900;\n\t}\n\tconnect_host = strdup(rhp);\n\n\t/* check for and read in the key file */\n\tmemset(keydata, 0, sizeof(keydata));\n\n\tif (!strcmp(cipher, \"none\")) {\n\t\tgoto readed_in;\n\t}\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto readed_in;\n\t}\n\n\tif (securevnc) {\n\t\t/* note the keyfile for rsa verification later */\n\t\tif (keyfile != NULL && strcasecmp(keyfile, \"none\")) {\n\t\t\tsecurevnc_file = keyfile;\n\t\t}\n\t\tgoto readed_in;\n\t}\n\n\tif (stat(keyfile, &sb) != 0) {\n\t\tif (strstr(keyfile, \"pw=\") == keyfile) {\n\t\t\t/* user specified key/password on cmdline */\n\t\t\tint i;\n\t\t\tlen = 0;\n\t\t\tpw_in = 1;\n\t\t\tfor (i=0; i < (int) strlen(keyfile); i++) {\n\t\t\t\t/* load the string to keydata: */\n\t\t\t\tint n = i + strlen(\"pw=\");\n\t\t\t\tkeydata[i] = keyfile[n];\n\t\t\t\tif (keyfile[n] == '\\0') break;\n\t\t\t\tlen++;\n\t\t\t\tif (i > 100) break;\n\t\t\t}\n\t\t\tgoto readed_in;\n\t\t}\n\t\t/* otherwise invalid file */\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tif (sb.st_size > 1024) {\n\t\tfprintf(stderr, \"%s: key file too big.\\n\", prog);\n\t\texit(1);\n\t}\n\tfd = open(keyfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\texit(1);\n\t}\n\n\t/* read it all in */\n\tlen = (int) read(fd, keydata, (size_t) sb.st_size);\n\tif (len != sb.st_size) {\n\t\tperror(\"read\");\n\t\tfprintf(stderr, \"%s, could not read key file.\\n\", prog);\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\treaded_in:\n\n\n\t/* check for ultravnc msrc4 format 'rc4.key' */\n\tmbits = 0;\n\tif (strstr(keydata, \"128 bit\") == keydata) {\n\t\tmbits = 128;\n\t} else if (strstr(keydata, \" 56 bit\") == keydata) {\n\t\tmbits = 56;\n\t} else if (strstr(keydata, \" 40 bit\") == keydata) {\n\t\tmbits = 40;\n\t}\n\tif (mbits > 0) {\n\t\t/* 4 is for int key length, 12 is for BLOBHEADER. */\n\t\tint i, offset = strlen(\"xxx bit\") + 4 + 12;\n\n\t\t/* the key is stored in reverse order! */\n\t\tlen = mbits/8;\n\t\tfor (i=0; i < len; i++) {\n\t\t\ttmp[i] = keydata[offset + len - i - 1];\n\t\t}\n\n\t\t/* clear keydata and then copy the reversed bytes there: */\n\t\tmemset(keydata, 0, sizeof(keydata));\n\t\tmemcpy(keydata, tmp, len);\n\t}\n\n\tkeydata_len = len;\n\n\t/* initialize random */\n\tRAND_poll();\n\n\t/*\n\t * Setup connections, then transfer data when they are all\n\t * hooked up.\n\t */\n\tenc_connections(listen_port, connect_host, connect_port);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SALT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SALT 16\n\nextern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\n\tstruct stat sb;\n\tchar *q, *p, *connect_host;\n\tchar tmp[16];\n\tint fd, len = 0, listen_port = 0, connect_port, mbits;\n\n\tq = ciph;\n\n\t/* check for noultra mode: */\n\tif (strstr(q, \"noultra:\") == q) {\n\t\tnoultra = 1;\n\t\tq += strlen(\"noultra:\");\n\t}\n\n\t/* check for reverse mode: */\n\tif (strstr(q, \"rev:\") == q) {\n\t\treverse = 1;\n\t\tq += strlen(\"rev:\");\n\t}\n\n\t/* work out which cipher and set Cipher to the selected one. */\n\tif (!strcasecmp(q, \"msrc4\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t} else if (!strcasecmp(q, \"msrc4_sc\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\t\tmsrc4_sc = 1;\t\t\t/* no salt/iv workaround */\n\n\t} else if (strstr(q, \"arc4\") == q) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t} else if (strstr(q, \"aesv2\") == q || strstr(q, \"aes-ofb\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t} else if (strstr(q, \"aes-cfb\") == q) {\n\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t} else if (strstr(q, \"aes256\") == q) {\n\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t} else if (strstr(q, \"blowfish\") == q) {\n\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t} else if (strstr(q, \"3des\") == q) {\n\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t} else if (strstr(q, \"securevnc\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\tsecurevnc = 1;\n\n\t} else if (strstr(q, \"none\") == q || strstr(q, \"relay\") == q) {\n\t\tcipher = \"none\";\n\n\t} else if (strstr(q, \"showcert\") == q) {\n\t\tcipher = \"showcert\";\n\n\t} else if (strstr(q, \".\") == q) {\n\t\t/* otherwise, try to guess cipher from key filename: */\n\t\tif (strstr(keyfile, \"arc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t\t} else if (strstr(keyfile, \"rc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t\t} else if (strstr(keyfile, \"aesv2.key\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t\t} else if (strstr(keyfile, \"aes-cfb.key\")) {\n\t\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t\t} else if (strstr(keyfile, \"aes256.key\")) {\n\t\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t\t} else if (strstr(keyfile, \"blowfish.key\")) {\n\t\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t\t} else if (strstr(keyfile, \"3des.key\")) {\n\t\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t\t} else if (strstr(keyfile, \"securevnc.\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\t\tsecurevnc = 1;\n\n\t\t} else {\n\t\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\texit(1);\n\t}\n\n\t/* set the default message digest (md5) */\n\tif (!securevnc) {\n\t\tDigest = EVP_md5();\n\t} else {\n\t\tDigest = EVP_sha1();\n\t}\n\n\t/*\n\t * Look for user specified salt and IV sizes at the end\n\t * ( ciph@salt,iv and ciph@[md+]salt,iv ):\n\t */\n\tp = strchr(q, '@');\n\tif (p) {\n\t\tint s, v;\n\t\tp++;\n\t\tif (strstr(p, \"md5+\") == p) {\n\t\t\tDigest = EVP_md5();        p += strlen(\"md5+\");\n#if OPENSSL_VERSION_NUMBER < 0x10100000L && !defined OPENSSL_NO_SHA0\n\t\t} else if (strstr(p, \"sha+\") == p) {\n\t\t\tDigest = EVP_sha();        p += strlen(\"sha+\");\n#endif\n\t\t} else if (strstr(p, \"sha1+\") == p) {\n\t\t\tDigest = EVP_sha1();       p += strlen(\"sha1+\");\n\t\t} else if (strstr(p, \"ripe+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripe+\");\n\t\t} else if (strstr(p, \"ripemd160+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripemd160+\");\n\t\t}\n\t\tif (sscanf(p, \"%d,%d\", &s, &v) == 2) {\n\t\t\t/* cipher@n,m */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (0 <= v && v <= EVP_MAX_IV_LENGTH) {\n\t\t\t\tivec_size = v;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid IV size: %d\\n\",\n\t\t\t\t    prog, v);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (sscanf(p, \"%d\", &s) == 1) {\n\t\t\t/* cipher@n */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (salt_size == -1) {\n\t\t\t/* let salt = -1 mean skip both MD5 and salt */\n\t\t\tnomd = 1;\n\t\t\tsalt_size = 0;\n\t\t}\n\t}\n\n\t/* port to listen on (0 => stdio, negative => localhost) */\n\tif (lport != NULL) {\n\t\tlisten_port = atoi(lport);\n\t}\n\n\t/* extract remote hostname and port */\n\tq = strrchr(rhp, ':');\n\tif (q) {\n\t\tconnect_port = atoi(q+1);\n\t\t*q = '\\0';\n\t} else {\n\t\t/* otherwise guess VNC display 0 ... */\n\t\tconnect_port = 5900;\n\t}\n\tconnect_host = strdup(rhp);\n\n\t/* check for and read in the key file */\n\tmemset(keydata, 0, sizeof(keydata));\n\n\tif (!strcmp(cipher, \"none\")) {\n\t\tgoto readed_in;\n\t}\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto readed_in;\n\t}\n\n\tif (securevnc) {\n\t\t/* note the keyfile for rsa verification later */\n\t\tif (keyfile != NULL && strcasecmp(keyfile, \"none\")) {\n\t\t\tsecurevnc_file = keyfile;\n\t\t}\n\t\tgoto readed_in;\n\t}\n\n\tif (stat(keyfile, &sb) != 0) {\n\t\tif (strstr(keyfile, \"pw=\") == keyfile) {\n\t\t\t/* user specified key/password on cmdline */\n\t\t\tint i;\n\t\t\tlen = 0;\n\t\t\tpw_in = 1;\n\t\t\tfor (i=0; i < (int) strlen(keyfile); i++) {\n\t\t\t\t/* load the string to keydata: */\n\t\t\t\tint n = i + strlen(\"pw=\");\n\t\t\t\tkeydata[i] = keyfile[n];\n\t\t\t\tif (keyfile[n] == '\\0') break;\n\t\t\t\tlen++;\n\t\t\t\tif (i > 100) break;\n\t\t\t}\n\t\t\tgoto readed_in;\n\t\t}\n\t\t/* otherwise invalid file */\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tif (sb.st_size > 1024) {\n\t\tfprintf(stderr, \"%s: key file too big.\\n\", prog);\n\t\texit(1);\n\t}\n\tfd = open(keyfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\texit(1);\n\t}\n\n\t/* read it all in */\n\tlen = (int) read(fd, keydata, (size_t) sb.st_size);\n\tif (len != sb.st_size) {\n\t\tperror(\"read\");\n\t\tfprintf(stderr, \"%s, could not read key file.\\n\", prog);\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\treaded_in:\n\n\n\t/* check for ultravnc msrc4 format 'rc4.key' */\n\tmbits = 0;\n\tif (strstr(keydata, \"128 bit\") == keydata) {\n\t\tmbits = 128;\n\t} else if (strstr(keydata, \" 56 bit\") == keydata) {\n\t\tmbits = 56;\n\t} else if (strstr(keydata, \" 40 bit\") == keydata) {\n\t\tmbits = 40;\n\t}\n\tif (mbits > 0) {\n\t\t/* 4 is for int key length, 12 is for BLOBHEADER. */\n\t\tint i, offset = strlen(\"xxx bit\") + 4 + 12;\n\n\t\t/* the key is stored in reverse order! */\n\t\tlen = mbits/8;\n\t\tfor (i=0; i < len; i++) {\n\t\t\ttmp[i] = keydata[offset + len - i - 1];\n\t\t}\n\n\t\t/* clear keydata and then copy the reversed bytes there: */\n\t\tmemset(keydata, 0, sizeof(keydata));\n\t\tmemcpy(keydata, tmp, len);\n\t}\n\n\tkeydata_len = len;\n\n\t/* initialize random */\n\tRAND_poll();\n\n\t/*\n\t * Setup connections, then transfer data when they are all\n\t * hooked up.\n\t */\n\tenc_connections(listen_port, connect_host, connect_port);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "argv[2]",
            "\"pw=\""
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[2]"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\\n\"",
            "usage"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"relay\""
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"none\""
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"showcert\""
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "doloop",
          "args": [
            "argc",
            "argv"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "doloop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "2078-2106",
          "snippet": "static void doloop (int argc, char *argv[]) {\n\tint ms = atoi(getenv(\"ULTRAVNC_DSM_HELPER_LOOP\"));\n\tif (ms > 0) {\n\t\tchar *cmd;\n\t\tint i, len = 0;\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tlen += strlen(argv[i]) + 2;\n\t\t}\n\t\tcmd = (char *)malloc(len);\n\t\tcmd[0] = '\\0';\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tstrcat(cmd, argv[i]);\n\t\t\tif (i < argc - 1) {\n\t\t\t\tstrcat(cmd, \" \");\n\t\t\t}\n\t\t}\n\n\t\tsetenv(\"ULTRAVNC_DSM_HELPER_LOOP_SET\", \"1\", 1);\n\t\tif (ms == 1) {\n\t\t\tms = 500;\n\t\t}\n\t\ti = 0;\n\t\twhile (1) {\n\t\t\tfprintf(stderr, \"loop running[%d]: %s\\n\", ++i, cmd);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000 * ms);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void doloop (int argc, char *argv[]) {\n\tint ms = atoi(getenv(\"ULTRAVNC_DSM_HELPER_LOOP\"));\n\tif (ms > 0) {\n\t\tchar *cmd;\n\t\tint i, len = 0;\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tlen += strlen(argv[i]) + 2;\n\t\t}\n\t\tcmd = (char *)malloc(len);\n\t\tcmd[0] = '\\0';\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tstrcat(cmd, argv[i]);\n\t\t\tif (i < argc - 1) {\n\t\t\t\tstrcat(cmd, \" \");\n\t\t\t}\n\t\t}\n\n\t\tsetenv(\"ULTRAVNC_DSM_HELPER_LOOP_SET\", \"1\", 1);\n\t\tif (ms == 1) {\n\t\t\tms = 500;\n\t\t}\n\t\ti = 0;\n\t\twhile (1) {\n\t\t\tfprintf(stderr, \"loop running[%d]: %s\\n\", ++i, cmd);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000 * ms);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_LOOP_SET\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_LOOP\""
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nextern int main (int argc, char *argv[]) {\n\tchar *kf, *q;\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_LOOP\")) {\n\t\tif (!getenv(\"ULTRAVNC_DSM_HELPER_LOOP_SET\")) {\n\t\t\tdoloop(argc, argv);\n\t\t}\n\t}\n\n\tif (argc == 3) {\n\t\tif (!strcmp(argv[1], \"showcert\")) {\n\t\t\tenc_do(argv[1], NULL, NULL, argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (argc == 4) {\n\t\tif (!strcmp(argv[1], \"none\") || !strcmp(argv[1], \"relay\")) {\n\t\t\tenc_do(argv[1], NULL, argv[2], argv[3]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (argc < 5) {\n\t\tfprintf(stdout, \"%s\\n\", usage);\n\t\texit(1);\n\t}\n\n\t/* guard against pw= on cmdline (e.g. linux) */\n\tkf = strdup(argv[2]);\n\tq = strstr(argv[2], \"pw=\");\n\tif (q) {\n\t\twhile (*q != '\\0') {\n\t\t\t*q = '\\0';\t/* now ps(1) won't show it */\n\t\t\tq++;\n\t\t}\n\t}\n\n\tenc_do(argv[1], kf, argv[3], argv[4]);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "doloop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "2078-2106",
    "snippet": "static void doloop (int argc, char *argv[]) {\n\tint ms = atoi(getenv(\"ULTRAVNC_DSM_HELPER_LOOP\"));\n\tif (ms > 0) {\n\t\tchar *cmd;\n\t\tint i, len = 0;\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tlen += strlen(argv[i]) + 2;\n\t\t}\n\t\tcmd = (char *)malloc(len);\n\t\tcmd[0] = '\\0';\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tstrcat(cmd, argv[i]);\n\t\t\tif (i < argc - 1) {\n\t\t\t\tstrcat(cmd, \" \");\n\t\t\t}\n\t\t}\n\n\t\tsetenv(\"ULTRAVNC_DSM_HELPER_LOOP_SET\", \"1\", 1);\n\t\tif (ms == 1) {\n\t\t\tms = 500;\n\t\t}\n\t\ti = 0;\n\t\twhile (1) {\n\t\t\tfprintf(stderr, \"loop running[%d]: %s\\n\", ++i, cmd);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000 * ms);\n\t\t}\n\t}\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000 * ms"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"loop running[%d]: %s\\n\"",
            "++i",
            "cmd"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_LOOP_SET\"",
            "\"1\"",
            "1"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\" \""
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "argv[i]"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"ULTRAVNC_DSM_HELPER_LOOP\")"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_LOOP\""
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void doloop (int argc, char *argv[]) {\n\tint ms = atoi(getenv(\"ULTRAVNC_DSM_HELPER_LOOP\"));\n\tif (ms > 0) {\n\t\tchar *cmd;\n\t\tint i, len = 0;\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tlen += strlen(argv[i]) + 2;\n\t\t}\n\t\tcmd = (char *)malloc(len);\n\t\tcmd[0] = '\\0';\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tstrcat(cmd, argv[i]);\n\t\t\tif (i < argc - 1) {\n\t\t\t\tstrcat(cmd, \" \");\n\t\t\t}\n\t\t}\n\n\t\tsetenv(\"ULTRAVNC_DSM_HELPER_LOOP_SET\", \"1\", 1);\n\t\tif (ms == 1) {\n\t\t\tms = 500;\n\t\t}\n\t\ti = 0;\n\t\twhile (1) {\n\t\t\tfprintf(stderr, \"loop running[%d]: %s\\n\", ++i, cmd);\n\t\t\tsystem(cmd);\n\t\t\tusleep(1000 * ms);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "enc_connections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1721-2075",
    "snippet": "static void enc_connections(int listen_port, char *connect_host, int connect_port) {\n\tint listen_fd = -1, listen_fd6 = -1, conn1 = -1, conn2 = -1, ret, one = 1;\n\tsocklen_t clen;\n\tstruct hostent *hp;\n\tstruct sockaddr_in client, server;\n\tfd_set fds;\n\tint maxfd = -1;\n\n\t/* zero means use stdio (preferably from socketpair()) */\n\tif (listen_port == 0) {\n\t\tconn1 = fileno(stdin);\n\t\tgoto use_stdio;\n\t}\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto use_stdio;\n\t}\n\n\t/* fd=n,m means use the supplied already established sockets */\n\tif (sscanf(connect_host, \"fd=%d,%d\", &conn1, &conn2) == 2) {\n\t\tgoto use_input_fds;\n\t}\n\n\t/* create the listening socket: */\n\tmemset(&client, 0, sizeof(client));\n\tclient.sin_family = AF_INET;\n\tif (listen_port < 0) {\n\t\t/* negative port means use loopback */\n\t\tclient.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tclient.sin_port = htons(-listen_port);\n\t} else {\n\t\tclient.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tclient.sin_port = htons(listen_port);\n\t}\n\n\tlisten_fd = socket(AF_INET, SOCK_STREAM, 0); \n\tif (listen_fd < 0) {\n\t\tperror(\"socket\");\n\t\tgoto try6;\n\t}\n\n\tret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR,\n\t    (char *)&one, sizeof(one));\n\tif (ret < 0) {\n\t\tperror(\"setsockopt\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = bind(listen_fd, (struct sockaddr *) &client, sizeof(client));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = listen(listen_fd, 2);\n\tif (ret < 0) {\n\t\tperror(\"listen\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\ttry6:\n#ifdef AF_INET6\n\tif (!getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tstruct sockaddr_in6 sin;\n\t\tint one = 1, sock = -1;\n\n\t\tsock = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket6\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 SO_REUSEADDR\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 IPV6_V6ONLY\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n#endif\n\n\t\tmemset((char *)&sin, 0, sizeof(sin));\n\t\tsin.sin6_family = AF_INET6;\n\n\t\tif (listen_port < 0) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t\tsin.sin6_port = htons(-listen_port);\n\t\t} else {\n\t\t\tsin.sin6_addr = in6addr_any;\n\t\t\tsin.sin6_port = htons(listen_port);\n\t\t}\n\n\t\tif (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\t\tperror(\"bind6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (listen(sock, 2) < 0) {\n\t\t\tperror(\"listen6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfail:\n\t\tlisten_fd6 = sock;\n\t}\n#endif\n\n\tif (listen_fd < 0 && listen_fd6 < 0) {\n\t\tfprintf(stderr, \"%s: could not listen on port: %d\\n\",\n\t\t    prog, listen_port);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"%s: waiting for connection on port: %d\\n\",\n\t    prog, listen_port);\n\n\t/* wait for a connection: */\n\tFD_ZERO(&fds);\n\tif (listen_fd >= 0) {\n\t\tFD_SET(listen_fd, &fds);\n\t\tif (listen_fd > maxfd) {\n\t\t\tmaxfd = listen_fd;\n\t\t}\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tFD_SET(listen_fd6, &fds);\n\t\tif (listen_fd6 > maxfd) {\n\t\t\tmaxfd = listen_fd6;\n\t\t}\n\t}\n\tif (select(maxfd+1, &fds, NULL, NULL, NULL) <= 0) {\n\t\tperror(\"select\");\n\t\texit(1);\n\t}\n\n\tif (FD_ISSET(listen_fd, &fds)) {\n\t\tclen = sizeof(client);\n\t\tconn1 = accept(listen_fd, (struct sockaddr *) &client, &clen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t} else if (FD_ISSET(listen_fd6, &fds)) {\n#ifdef AF_INET6\n\t\tstruct sockaddr_in6 addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\n\t\tconn1 = accept(listen_fd6, (struct sockaddr *) &addr, &addrlen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept6\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tfprintf(stderr, \"No IPv6 / AF_INET6 support.\\n\");\n\t\texit(1);\n#endif\n\t}\n\n\tif (setsockopt(conn1, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t\texit(1);\n\t}\n\n\t/* done with the listening socket(s): */\n\tif (listen_fd >= 0) {\n\t\tclose(listen_fd);\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tclose(listen_fd6);\n\t}\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_BG\")) {\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\tfprintf(stderr, \"%s: putting child %d in background.\\n\",\n\t\t\t    prog, p);\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"%s: could not fork\\n\", prog);\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\tfprintf(stderr, \"%s: setsid failed\\n\", prog);\n\t\t\tperror(\"setsid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t}\n\n\tuse_stdio:\n\n\tfprintf(stderr, \"%s: got connection: %d\\n\", prog, conn1);\n\n\t/* now connect to remote server: */\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family = AF_INET;\n\tserver.sin_port = htons(connect_port);\n\n\tif ((server.sin_addr.s_addr = inet_addr(connect_host)) == htonl(INADDR_NONE)) {\n\t\tif (!(hp = gethostbyname(connect_host))) {\n\t\t\tperror(\"gethostbyname\");\n\t\t\tgoto tryconn6;\n\t\t}\n\t\tserver.sin_addr.s_addr = *(unsigned long *)hp->h_addr;\n\t}\n\n\tconn2 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (conn2 < 0) {\n\t\tperror(\"socket\");\n\t\tgoto tryconn6;\n\t}\n\n\tif (connect(conn2, (struct sockaddr *)&server, (sizeof(server))) < 0) {\n\t\tperror(\"connect\");\n\t\tgoto tryconn6;\n\t}\n\n\ttryconn6:\n#ifdef AF_INET6\n\tif (conn2 < 0 && !getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32];\n\n\t\tfprintf(stderr, \"connect[ipv6]: trying to connect via IPv6 to %s\\n\", connect_host);\n\t\tconn2 = -1;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", connect_port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\terr = getaddrinfo(connect_host, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint fd = -1;\n\t\t\t\tfd = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tperror(\"socket6\");\n\t\t\t\t} else {\n\t\t\t\t\tint dmsg = 0; \n\t\t\t\t\tint res = connect(fd, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\tperror(\"connect6\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\tfprintf(stderr, \"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(fd, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tconn2 = fd; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) perror(\"connect6\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t}\n#endif\n\tif (conn2 < 0) {\n\t\tfprintf(stderr, \"could not connect to %s\\n\", connect_host);\n\t\texit(1);\n\t}\n\tif (conn2 >= 0 && setsockopt(conn2, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t}\n\n\tuse_input_fds:\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tshow_cert(conn2);\n\t\tclose(conn2);\n\t\texit(0);\n\t}\n\n\tif (securevnc) {\n\t\tsecurevnc_setup(conn1, conn2);\n\t}\n\n\t/* fork into two processes; one for each direction: */\n\tparent = getpid();\n\t\n\tchild = fork();\n\t\n\tif (child == (pid_t) -1) {\n\t\t/* couldn't fork... */\n\t\tperror(\"fork\");\n\t\tclose(conn1);\n\t\tclose(conn2);\n\t\texit(1);\n\t}\n\n\t/* Do transfer/encode/decode loop: */\n\n\tif (child == 0) {\n\t\t/* encrypter: local-viewer -> remote-server */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn1, conn2);\n\t\t} else {\n\t\t\tenc_xfer(conn1, conn2, 1);\n\t\t}\n\t} else {\n\t\t/* decrypter: remote-server -> local-viewer */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn2, conn1);\n\t\t} else {\n\t\t\tenc_xfer(conn2, conn1, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SOL_IPV6 IPPROTO_IPV6",
      "#define INADDR_NONE ((in_addr_t) 0xffffffff)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enc_xfer",
          "args": [
            "conn2",
            "conn1",
            "0"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "enc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "694-1065",
          "snippet": "static void enc_xfer(int sock_fr, int sock_to, int encrypt) {\n\t/*\n\t * We keep both E and D aspects in case we revert back to a\n\t * single process calling select(2) on all fds...\n\t */\n\tunsigned char E_keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char D_keystr[EVP_MAX_KEY_LENGTH];\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX *E_ctx, *D_ctx;\n#else\n\tEVP_CIPHER_CTX E_ctx, D_ctx;\n#endif\n\tEVP_CIPHER_CTX *ctx = NULL;\n\n\tunsigned char buf[BSIZE], out[BSIZE];\n\tunsigned char *psrc = NULL, *keystr;\n\tunsigned char salt[SALT+1];\n\tunsigned char ivec_real[EVP_MAX_IV_LENGTH];\n\tunsigned char *ivec = ivec_real;\n\n\tint i, cnt, len, m, n = 0, vb = 0, first = 1;\n\tint whoops = 1; /* for the msrc4 problem */\n\tchar *encstr, *encsym;\n\t\n\t/* zero the buffers */\n\tmemset(buf,  0, BSIZE);\n\tmemset(out,  0, BSIZE);\n\tmemset(salt, 0, sizeof(salt));\n\tmemset(ivec_real, 0, sizeof(ivec_real));\n\tmemset(E_keystr, 0, sizeof(E_keystr));\n\tmemset(D_keystr, 0, sizeof(D_keystr));\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\tsalt_size = MSRC4_SALT; /* 11 vs. 16 */\n\t}\n\n\tif (msrc4_sc) {\n\t\twhoops = 1;\t/* force workaround in SC mode */\n\t}\n\n\tif (getenv(\"ENCRYPT_VERBOSE\")) {\n\t\tvb = 1;\t/* let user turn on some debugging via env. var. */\n\t}\n\n\t/*\n\t * reverse mode, e.g. we help a vnc server instead of a viewer.\n\t */\n\tif (reverse) {\n\t\tencrypt = (!encrypt);\n\t}\n\tencstr = encrypt ? \"encrypt\" : \"decrypt\";  /* string for messages */\n\tencsym = encrypt ? \"+\" : \"-\";\n\n\t/* use the encryption/decryption context variables below */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tE_ctx = EVP_CIPHER_CTX_new();\n\tD_ctx = EVP_CIPHER_CTX_new();\n\tctx = encrypt ? E_ctx : D_ctx;\n#else\n\tctx = encrypt ? &E_ctx : &D_ctx;\n#endif\n\tif (encrypt) {\n\t\tkeystr = E_keystr;\n\t} else {\n\t\tkeystr = D_keystr;\n\t}\n\n\tif (securevnc) {\n\t\tfirst = 0;\t/* no need for salt+iv on first time */\n\t\tsalt_size = 0;\t/* we want no salt */\n\t\tn = 0;\t\t/* nothing read */\n\t\tivec_size = 0;\t/* we want no IV. */\n\t\tivec = NULL;\n\t} else if (encrypt) {\n\t\t/* encrypter initializes the salt and initialization vector */\n\n\t\t/*\n\t\t * Our salt is 16 bytes but I believe only the first 8\n\t\t * bytes are used by EVP_BytesToKey(3).  Since we send it\n\t\t * to the other \"plugin\" we need to keep it 16.  Also,\n\t\t * the IV size can depend on the cipher type.  Again, 16.\n\t\t */\n\t\tRAND_bytes(salt, salt_size);\n\t\tRAND_bytes(ivec, ivec_size);\n\n\t\t/* place them in the send buffer: */\n\t\tmemcpy(buf, salt, salt_size);\n\t\tmemcpy(buf+salt_size, ivec, ivec_size);\n\n\t\tn = salt_size + ivec_size;\n\n\t\tENC_PT_DBG(buf, n);\n\n\t} else {\n\t\t/* decrypter needs to read salt + iv from the wire: */\n\n\t\t/* sleep 100 ms (TODO: select on fd) */\n\t\tstruct timeval tv;\n\t\ttv.tv_sec  = 0;\n\t\ttv.tv_usec = 100 * 1000;\n\t\tselect(1, NULL, NULL, NULL, &tv);\n\n\t\tif (salt_size+ivec_size == 0) {\n\t\t\tn = 0;\t/* no salt or iv, skip reading. */\n\t\t} else {\n\t\t\tn = read(sock_fr, buf, salt_size+ivec_size+96);\n\t\t}\n\t\tif (n == 0 && salt_size+ivec_size > 0) {\n\t\t\tfprintf(stderr, \"%s: decrypt finished.\\n\", prog);\n\t\t\tgoto finished;\n\t\t}\n\t\tif (n < salt_size+ivec_size) {\n\t\t    if (msrc4_sc && n == 12) {\n\t\t\tfprintf(stderr, \"%s: only %d bytes read. Assuming \"\n\t\t\t    \"UVNC Single Click server.\\n\", prog, n);\n\t\t    } else {\n\t\t\tif (n < 0) perror(\"read\");\n\t\t\tfprintf(stderr, \"%s: could not read enough for salt \"\n\t\t\t    \"and ivec: n=%d\\n\", prog, n);\n\t\t\tgoto finished;\n\t\t    }\n\t\t}\n\n\t\tDEC_CT_DBG(buf, n);\n\n\t\tif (msrc4_sc && n == 12) {\n\t\t\t; /* send it as is */\n\t\t} else {\n\t\t\t/* extract them to their buffers: */\n\t\t\tmemcpy(salt, buf, salt_size);\n\t\t\tmemcpy(ivec, buf+salt_size, ivec_size);\n\n\t\t\t/* the rest is some encrypted data: */\n\t\t\tn = n - salt_size - ivec_size;\n\t\t\tpsrc = buf + salt_size + ivec_size;\n\t\t\n\t\t\tif (n > 0) {\n\t\t\t\t/*\n\t\t\t\t * copy it down to the start of buf for\n\t\t\t\t * sending below:\n\t\t\t\t */\n\t\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\t\tbuf[i] = psrc[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* debug output */\n\tPRINT_KEYDATA;\n\tPRINT_IVEC;\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\t/* special cases for MSRC4: */\n\n\t\tif (whoops) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: MSRC4 mode and IGNORING random salt\\n\", prog, encstr);\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: and initialization vector!!\\n\", prog, encstr);\n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tif (pw_in) {\n\t\t\t    /* for pw=xxxx a md5 hash is used */\n\t\t\t    EVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t        keydata_len, 1, keystr, NULL);\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL, keystr, NULL,\n\t\t\t        encrypt);\n\t\t\t} else {\n\t\t\t    /* otherwise keydata as is */\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL,\n\t\t\t        (unsigned char *) keydata, NULL, encrypt);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX might not be correct, just exit. */\n\t\t\tfprintf(stderr, \"%s: %s - Not sure about msrc4 && !whoops case, exiting.\\n\", prog, encstr);\n\t\t\texit(1);\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec); \n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec,\n\t\t\t    encrypt);\n\t\t}\n\n\t} else {\n\t\tunsigned char *in_salt = NULL;\n\n\t\t/* check salt and IV source and size. */\n\t\tif (securevnc) {\n\t\t\tin_salt = NULL;\n\t\t} else if (salt_size <= 0) {\n\t\t\t/* let salt_size = 0 mean keep it out of the MD5 */\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no salt\\n\",\n\t\t\t    prog, encstr);\n\t\t\tin_salt = NULL;\n\t\t} else {\n\t\t\tin_salt = salt;\n\t\t}\n\n\t\tif (ivec_size < EVP_CIPHER_iv_length(Cipher) && !securevnc) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: short IV %d < %d\\n\",\n\t\t\t    prog, encstr, ivec_size, EVP_CIPHER_iv_length(Cipher));\n\t\t}\n\n\t\t/* make the hashed value and place in keystr */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin had count=0, and overwrote ivec\n\t\t * by not passing NULL iv.\n\t\t */\n\n\t\tif (nomd) {\n\t\t\t/* special mode: no salt or md5, use keydata directly */\n\n\t\t\tint sz = keydata_len < EVP_MAX_KEY_LENGTH ?\n\t\t\t    keydata_len : EVP_MAX_KEY_LENGTH; \n\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no-md5 specified: ignoring salt & hash\\n\", prog, encstr);\n\t\t\tmemcpy(keystr, keydata, sz);\n\n\t\t} else if (noultra && ivec_size > 0) {\n\t\t\t/* \"normal\" mode, don't overwrite ivec. */\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, NULL);\n\n\t\t} else {\n\t\t\t/* \n\t\t\t * Ultra DSM compatibility mode.  Note that this\n\t\t\t * clobbers the ivec we set up above!  Under\n\t\t\t * noultra we overwrite ivec only if ivec_size=0.\n\t\t\t *\n\t\t\t * SecureVNC also goes through here. in_salt and ivec are NULL.\n\t\t\t * And ivec is NULL below in the EVP_CipherInit_ex() call.\n\t\t\t */\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec);\n\t\t}\n\n\n\t\t/* initialize the context */\n\t\tEVP_CIPHER_CTX_init(ctx);\n\n\n\t\t/* set the cipher & initialize */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin implementation had encrypt=1\n\t\t * for both (i.e. perfectly symmetric)\n\t\t */\n\n\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec, encrypt);\n\t}\n\n\tif (securevnc && securevnc_arc4) {\n\t\t/* need to discard initial 3072 bytes */\n\t\tunsigned char buf1[SECUREVNC_RC4_DROP_BYTES];\n\t\tunsigned char buf2[SECUREVNC_RC4_DROP_BYTES];\n\t\tint cnt = 0;\n\t\tEVP_CipherUpdate(ctx, buf1, &cnt, buf2, SECUREVNC_RC4_DROP_BYTES);\n\t}\n\n\t/* debug output */\n\tPRINT_KEYSTR_AND_FRIENDS;\n\n\t/* now loop forever processing the data stream */\n\n\twhile (1) {\n\t\terrno = 0;\n\t\tif (first && n > 0) {\n\t\t\tif (encrypt && msrc4_sc) {\n\t\t\t\t/* skip sending salt+iv */\n\t\t\t\tfirst = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* use that first block of data placed in buf */\n\t\t\t}\n\t\t} else if (first && n == 0 && salt_size + ivec_size == 0) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* general case of loop, read some in: */\n\t\t\tn = read(sock_fr, buf, BSIZE);\n\t\t}\n\n\t\t/* debug output: */\n\t\tif (vb) fprintf(stderr, \"%s%d/%d \", encsym, n, errno);\n\t\tPRINT_LOOP_DBG1;\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tPRINT_LOOP_DBG2;\n\t\t\tfprintf(stderr, \"%s: %s - input stream finished: n=%d, err=%d\", prog, encstr, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\t\t\t/* we read in some data, now transform it: */\n\n\t\t\tif (first && encrypt) {\n\t\t\t\t/* first time, copy the salt and ivec to out[] for sending */\n\t\t\t\tmemcpy(out, buf, n);\n\t\t\t\tcnt = n;\n\n\t\t\t} else if (!EVP_CipherUpdate(ctx, out, &cnt, buf, n)) {\n\t\t\t\t/* otherwise, we transform the data */\n\t\t\t\tfprintf(stderr, \"%s: enc_xfer EVP_CipherUpdate failed.\\n\", prog);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* debug output: */\n\t\t\tif (vb) fprintf(stderr, \"%sc%d/%d \", encsym, cnt, n);\n\t\t\tPRINT_LOOP_DBG3;\n\n\t\t\t/* write transformed data to the other end: */\n\t\t\tlen = cnt;\n\t\t\tpsrc = out;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\t/* debug output: */\n\t\t\t\tif (vb) fprintf(stderr, \"m%s%d/%d \", encsym, m, errno);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\tfinished:\n\n\tfprintf(stderr, \"\\n%s: %s - close sock_to\\n\", prog, encstr);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: %s - close sock_fr\\n\", prog, encstr);\n\tclose(sock_fr);\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(E_ctx);\n\tEVP_CIPHER_CTX_free(D_ctx);\n#endif\n\n\t/* kill our partner after 2 secs. */\n\tsleep(2);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) parent);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SECUREVNC_RC4_DROP_BYTES 3072",
            "#define BSIZE 8192",
            "#define MSRC4_SALT 11",
            "#define SALT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RC4_DROP_BYTES 3072\n#define BSIZE 8192\n#define MSRC4_SALT 11\n#define SALT 16\n\nstatic void enc_xfer(int sock_fr, int sock_to, int encrypt) {\n\t/*\n\t * We keep both E and D aspects in case we revert back to a\n\t * single process calling select(2) on all fds...\n\t */\n\tunsigned char E_keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char D_keystr[EVP_MAX_KEY_LENGTH];\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX *E_ctx, *D_ctx;\n#else\n\tEVP_CIPHER_CTX E_ctx, D_ctx;\n#endif\n\tEVP_CIPHER_CTX *ctx = NULL;\n\n\tunsigned char buf[BSIZE], out[BSIZE];\n\tunsigned char *psrc = NULL, *keystr;\n\tunsigned char salt[SALT+1];\n\tunsigned char ivec_real[EVP_MAX_IV_LENGTH];\n\tunsigned char *ivec = ivec_real;\n\n\tint i, cnt, len, m, n = 0, vb = 0, first = 1;\n\tint whoops = 1; /* for the msrc4 problem */\n\tchar *encstr, *encsym;\n\t\n\t/* zero the buffers */\n\tmemset(buf,  0, BSIZE);\n\tmemset(out,  0, BSIZE);\n\tmemset(salt, 0, sizeof(salt));\n\tmemset(ivec_real, 0, sizeof(ivec_real));\n\tmemset(E_keystr, 0, sizeof(E_keystr));\n\tmemset(D_keystr, 0, sizeof(D_keystr));\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\tsalt_size = MSRC4_SALT; /* 11 vs. 16 */\n\t}\n\n\tif (msrc4_sc) {\n\t\twhoops = 1;\t/* force workaround in SC mode */\n\t}\n\n\tif (getenv(\"ENCRYPT_VERBOSE\")) {\n\t\tvb = 1;\t/* let user turn on some debugging via env. var. */\n\t}\n\n\t/*\n\t * reverse mode, e.g. we help a vnc server instead of a viewer.\n\t */\n\tif (reverse) {\n\t\tencrypt = (!encrypt);\n\t}\n\tencstr = encrypt ? \"encrypt\" : \"decrypt\";  /* string for messages */\n\tencsym = encrypt ? \"+\" : \"-\";\n\n\t/* use the encryption/decryption context variables below */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tE_ctx = EVP_CIPHER_CTX_new();\n\tD_ctx = EVP_CIPHER_CTX_new();\n\tctx = encrypt ? E_ctx : D_ctx;\n#else\n\tctx = encrypt ? &E_ctx : &D_ctx;\n#endif\n\tif (encrypt) {\n\t\tkeystr = E_keystr;\n\t} else {\n\t\tkeystr = D_keystr;\n\t}\n\n\tif (securevnc) {\n\t\tfirst = 0;\t/* no need for salt+iv on first time */\n\t\tsalt_size = 0;\t/* we want no salt */\n\t\tn = 0;\t\t/* nothing read */\n\t\tivec_size = 0;\t/* we want no IV. */\n\t\tivec = NULL;\n\t} else if (encrypt) {\n\t\t/* encrypter initializes the salt and initialization vector */\n\n\t\t/*\n\t\t * Our salt is 16 bytes but I believe only the first 8\n\t\t * bytes are used by EVP_BytesToKey(3).  Since we send it\n\t\t * to the other \"plugin\" we need to keep it 16.  Also,\n\t\t * the IV size can depend on the cipher type.  Again, 16.\n\t\t */\n\t\tRAND_bytes(salt, salt_size);\n\t\tRAND_bytes(ivec, ivec_size);\n\n\t\t/* place them in the send buffer: */\n\t\tmemcpy(buf, salt, salt_size);\n\t\tmemcpy(buf+salt_size, ivec, ivec_size);\n\n\t\tn = salt_size + ivec_size;\n\n\t\tENC_PT_DBG(buf, n);\n\n\t} else {\n\t\t/* decrypter needs to read salt + iv from the wire: */\n\n\t\t/* sleep 100 ms (TODO: select on fd) */\n\t\tstruct timeval tv;\n\t\ttv.tv_sec  = 0;\n\t\ttv.tv_usec = 100 * 1000;\n\t\tselect(1, NULL, NULL, NULL, &tv);\n\n\t\tif (salt_size+ivec_size == 0) {\n\t\t\tn = 0;\t/* no salt or iv, skip reading. */\n\t\t} else {\n\t\t\tn = read(sock_fr, buf, salt_size+ivec_size+96);\n\t\t}\n\t\tif (n == 0 && salt_size+ivec_size > 0) {\n\t\t\tfprintf(stderr, \"%s: decrypt finished.\\n\", prog);\n\t\t\tgoto finished;\n\t\t}\n\t\tif (n < salt_size+ivec_size) {\n\t\t    if (msrc4_sc && n == 12) {\n\t\t\tfprintf(stderr, \"%s: only %d bytes read. Assuming \"\n\t\t\t    \"UVNC Single Click server.\\n\", prog, n);\n\t\t    } else {\n\t\t\tif (n < 0) perror(\"read\");\n\t\t\tfprintf(stderr, \"%s: could not read enough for salt \"\n\t\t\t    \"and ivec: n=%d\\n\", prog, n);\n\t\t\tgoto finished;\n\t\t    }\n\t\t}\n\n\t\tDEC_CT_DBG(buf, n);\n\n\t\tif (msrc4_sc && n == 12) {\n\t\t\t; /* send it as is */\n\t\t} else {\n\t\t\t/* extract them to their buffers: */\n\t\t\tmemcpy(salt, buf, salt_size);\n\t\t\tmemcpy(ivec, buf+salt_size, ivec_size);\n\n\t\t\t/* the rest is some encrypted data: */\n\t\t\tn = n - salt_size - ivec_size;\n\t\t\tpsrc = buf + salt_size + ivec_size;\n\t\t\n\t\t\tif (n > 0) {\n\t\t\t\t/*\n\t\t\t\t * copy it down to the start of buf for\n\t\t\t\t * sending below:\n\t\t\t\t */\n\t\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\t\tbuf[i] = psrc[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* debug output */\n\tPRINT_KEYDATA;\n\tPRINT_IVEC;\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\t/* special cases for MSRC4: */\n\n\t\tif (whoops) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: MSRC4 mode and IGNORING random salt\\n\", prog, encstr);\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: and initialization vector!!\\n\", prog, encstr);\n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tif (pw_in) {\n\t\t\t    /* for pw=xxxx a md5 hash is used */\n\t\t\t    EVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t        keydata_len, 1, keystr, NULL);\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL, keystr, NULL,\n\t\t\t        encrypt);\n\t\t\t} else {\n\t\t\t    /* otherwise keydata as is */\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL,\n\t\t\t        (unsigned char *) keydata, NULL, encrypt);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX might not be correct, just exit. */\n\t\t\tfprintf(stderr, \"%s: %s - Not sure about msrc4 && !whoops case, exiting.\\n\", prog, encstr);\n\t\t\texit(1);\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec); \n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec,\n\t\t\t    encrypt);\n\t\t}\n\n\t} else {\n\t\tunsigned char *in_salt = NULL;\n\n\t\t/* check salt and IV source and size. */\n\t\tif (securevnc) {\n\t\t\tin_salt = NULL;\n\t\t} else if (salt_size <= 0) {\n\t\t\t/* let salt_size = 0 mean keep it out of the MD5 */\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no salt\\n\",\n\t\t\t    prog, encstr);\n\t\t\tin_salt = NULL;\n\t\t} else {\n\t\t\tin_salt = salt;\n\t\t}\n\n\t\tif (ivec_size < EVP_CIPHER_iv_length(Cipher) && !securevnc) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: short IV %d < %d\\n\",\n\t\t\t    prog, encstr, ivec_size, EVP_CIPHER_iv_length(Cipher));\n\t\t}\n\n\t\t/* make the hashed value and place in keystr */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin had count=0, and overwrote ivec\n\t\t * by not passing NULL iv.\n\t\t */\n\n\t\tif (nomd) {\n\t\t\t/* special mode: no salt or md5, use keydata directly */\n\n\t\t\tint sz = keydata_len < EVP_MAX_KEY_LENGTH ?\n\t\t\t    keydata_len : EVP_MAX_KEY_LENGTH; \n\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no-md5 specified: ignoring salt & hash\\n\", prog, encstr);\n\t\t\tmemcpy(keystr, keydata, sz);\n\n\t\t} else if (noultra && ivec_size > 0) {\n\t\t\t/* \"normal\" mode, don't overwrite ivec. */\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, NULL);\n\n\t\t} else {\n\t\t\t/* \n\t\t\t * Ultra DSM compatibility mode.  Note that this\n\t\t\t * clobbers the ivec we set up above!  Under\n\t\t\t * noultra we overwrite ivec only if ivec_size=0.\n\t\t\t *\n\t\t\t * SecureVNC also goes through here. in_salt and ivec are NULL.\n\t\t\t * And ivec is NULL below in the EVP_CipherInit_ex() call.\n\t\t\t */\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec);\n\t\t}\n\n\n\t\t/* initialize the context */\n\t\tEVP_CIPHER_CTX_init(ctx);\n\n\n\t\t/* set the cipher & initialize */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin implementation had encrypt=1\n\t\t * for both (i.e. perfectly symmetric)\n\t\t */\n\n\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec, encrypt);\n\t}\n\n\tif (securevnc && securevnc_arc4) {\n\t\t/* need to discard initial 3072 bytes */\n\t\tunsigned char buf1[SECUREVNC_RC4_DROP_BYTES];\n\t\tunsigned char buf2[SECUREVNC_RC4_DROP_BYTES];\n\t\tint cnt = 0;\n\t\tEVP_CipherUpdate(ctx, buf1, &cnt, buf2, SECUREVNC_RC4_DROP_BYTES);\n\t}\n\n\t/* debug output */\n\tPRINT_KEYSTR_AND_FRIENDS;\n\n\t/* now loop forever processing the data stream */\n\n\twhile (1) {\n\t\terrno = 0;\n\t\tif (first && n > 0) {\n\t\t\tif (encrypt && msrc4_sc) {\n\t\t\t\t/* skip sending salt+iv */\n\t\t\t\tfirst = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* use that first block of data placed in buf */\n\t\t\t}\n\t\t} else if (first && n == 0 && salt_size + ivec_size == 0) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* general case of loop, read some in: */\n\t\t\tn = read(sock_fr, buf, BSIZE);\n\t\t}\n\n\t\t/* debug output: */\n\t\tif (vb) fprintf(stderr, \"%s%d/%d \", encsym, n, errno);\n\t\tPRINT_LOOP_DBG1;\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tPRINT_LOOP_DBG2;\n\t\t\tfprintf(stderr, \"%s: %s - input stream finished: n=%d, err=%d\", prog, encstr, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\t\t\t/* we read in some data, now transform it: */\n\n\t\t\tif (first && encrypt) {\n\t\t\t\t/* first time, copy the salt and ivec to out[] for sending */\n\t\t\t\tmemcpy(out, buf, n);\n\t\t\t\tcnt = n;\n\n\t\t\t} else if (!EVP_CipherUpdate(ctx, out, &cnt, buf, n)) {\n\t\t\t\t/* otherwise, we transform the data */\n\t\t\t\tfprintf(stderr, \"%s: enc_xfer EVP_CipherUpdate failed.\\n\", prog);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* debug output: */\n\t\t\tif (vb) fprintf(stderr, \"%sc%d/%d \", encsym, cnt, n);\n\t\t\tPRINT_LOOP_DBG3;\n\n\t\t\t/* write transformed data to the other end: */\n\t\t\tlen = cnt;\n\t\t\tpsrc = out;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\t/* debug output: */\n\t\t\t\tif (vb) fprintf(stderr, \"m%s%d/%d \", encsym, m, errno);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\tfinished:\n\n\tfprintf(stderr, \"\\n%s: %s - close sock_to\\n\", prog, encstr);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: %s - close sock_fr\\n\", prog, encstr);\n\tclose(sock_fr);\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(E_ctx);\n\tEVP_CIPHER_CTX_free(D_ctx);\n#endif\n\n\t/* kill our partner after 2 secs. */\n\tsleep(2);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) parent);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "enc_raw_xfer",
          "args": [
            "conn2",
            "conn1"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "enc_raw_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "614-687",
          "snippet": "static void enc_raw_xfer(int sock_fr, int sock_to) {\n\n\tunsigned char buf[BSIZE];\n\tunsigned char *psrc = NULL;\n\tint len, m, n = 0;\n\t\n\t/* zero the buffers */\n\tmemset(buf, 0, BSIZE);\n\n\t/* now loop forever processing the data stream */\n\twhile (1) {\n\t\terrno = 0;\n\n\t\t/* general case of loop, read some in: */\n\t\tn = read(sock_fr, buf, BSIZE);\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tfprintf(stderr, \"%s: input stream finished: n=%d, err=%d\", prog, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\n\t\t\t/* write data to the other end: */\n\t\t\tlen = n;\n\t\t\tpsrc = buf;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\n\tfprintf(stderr, \"\\n%s: close sock_to\\n\", prog);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: close sock_fr\\n\", prog);\n\tclose(sock_fr);\n\n\t/* kill our partner after 1 secs. */\n\tsleep(1);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) parent);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define BSIZE 8192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define BSIZE 8192\n\nstatic void enc_raw_xfer(int sock_fr, int sock_to) {\n\n\tunsigned char buf[BSIZE];\n\tunsigned char *psrc = NULL;\n\tint len, m, n = 0;\n\t\n\t/* zero the buffers */\n\tmemset(buf, 0, BSIZE);\n\n\t/* now loop forever processing the data stream */\n\twhile (1) {\n\t\terrno = 0;\n\n\t\t/* general case of loop, read some in: */\n\t\tn = read(sock_fr, buf, BSIZE);\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tfprintf(stderr, \"%s: input stream finished: n=%d, err=%d\", prog, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\n\t\t\t/* write data to the other end: */\n\t\t\tlen = n;\n\t\t\tpsrc = buf;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\n\tfprintf(stderr, \"\\n%s: close sock_to\\n\", prog);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: close sock_fr\\n\", prog);\n\tclose(sock_fr);\n\n\t/* kill our partner after 1 secs. */\n\tsleep(1);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) parent);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"relay\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"none\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"relay\""
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"none\""
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "conn2"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securevnc_setup",
          "args": [
            "conn1",
            "conn2"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "securevnc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1252-1570",
          "snippet": "static void securevnc_setup(int conn1, int conn2) {\n\tRSA *rsa = NULL;\n\tEVP_CIPHER_CTX *init_ctx;\n\tunsigned char keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char *rsabuf, *rsasav;\n\tunsigned char *encrypted_keybuf;\n\tunsigned char *initkey;\t\n\tunsigned int server_flags = 0;\n\tunsigned char one = 1, zero = 0, sig = 16;\n\tunsigned char b1, b2, b3, b4;\n\tunsigned char buf[BSIZE], to_viewer[BSIZE];\n\tint to_viewer_len = 0;\n\tint n = 0, len, rc;\n\tint server = reverse ? conn1 : conn2;\n\tint viewer = reverse ? conn2 : conn1;\n\tchar *client_auth = NULL;\n\tint client_auth_req = 0;\n\tint keystore_verified = 0;\n\n\tERR_load_crypto_strings();\n\n\t/* alloc and read from server the 270 comprising the rsa public key: */\n\trsabuf = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\trsasav = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\tlen = 0;\n\twhile (len < SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tn = read(server, rsabuf + len, SECUREVNC_RSA_PUBKEY_SIZE - len);\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\tfprintf(stderr, \"securevnc_setup: fail read rsabuf: n=%d len=%d\\n\", n, len);\n\t\t\texit(1);\n\t\t}\n\t\tlen += n;\n\t}\n\tif (len != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tfprintf(stderr, \"securevnc_setup: fail final read rsabuf: n=%d len=%d\\n\", n, len);\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: rsa data read len: %d\\n\", len);\n\tmemcpy(rsasav, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\n\tfprintf(stderr, \"securevnc_setup: RSA key has MD5 sum: %s\\n\", rsa_md5_sum(rsabuf)); \n\tfprintf(stderr, \"securevnc_setup:\\n\"); \n\tfprintf(stderr, \"securevnc_setup: One way to print out the SecureVNC Server key MD5 sum is:\\n\\n\"); \n\tfprintf(stderr, \"openssl rsa -inform DER -outform DER -pubout -in ./Server_SecureVNC.pkey | dd bs=1 skip=24 | md5sum\\n\\n\");\n\tif (securevnc_file == NULL) {\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: ULTRAVNC SERVER RSA KEY NOT VERIFIED.   **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: A MAN-IN-THE-MIDDLE ATTACK IS POSSIBLE. **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t} else {\n\t\tchar *q = strrchr(securevnc_file, 'C');\n\t\tint skip = 0;\n\t\tif (q) {\n\t\t\tif (!strcmp(q, \"ClientAuth.pkey\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tskip = 1;\n\t\t\t} else if (!strcmp(q, \"ClientAuth.pkey.rsa\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tq = strrchr(client_auth, '.');\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t}\n\t\tif (!skip) {\n\t\t\trc = securevnc_check_server_rsa(securevnc_file, rsabuf);\n\t\t}\n\t\tif (skip) {\n\t\t\t;\n\t\t} else if (rc == 0) {\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY_ERROR: SERVER RSA KEY DID NOT MATCH:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\texit(1);\n\t\t} else if (rc == -1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: User cancelled the save and hence the connection.\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\texit(1);\n\t\t} else if (rc == 1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY SUCCESS: server rsa key matches the contents of:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 1;\n\t\t} else if (rc == 2) {\n\t\t\tfprintf(stderr, \"securevnc_setup: Server rsa key stored in:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 2;\n\t\t}\n\t}\n\n\t/*\n\t * read in the server flags. Note that SecureVNCPlugin sends these\n\t * in little endian and not network order!!\n\t */\n\tread(server, (char *) &b1, 1);\n\tread(server, (char *) &b2, 1);\n\tread(server, (char *) &b3, 1);\n\tread(server, (char *) &b4, 1);\n\t\n\tserver_flags = 0;\n\tserver_flags |= ((unsigned int) b4) << 24;\n\tserver_flags |= ((unsigned int) b3) << 16;\n\tserver_flags |= ((unsigned int) b2) << 8;\n\tserver_flags |= ((unsigned int) b1) << 0;\n\tfprintf(stderr, \"securevnc_setup: server_flags: 0x%08x\\n\", server_flags);\n\n\t/* check for arc4 usage: */\n\tif (server_flags & 0x1) {\n\t\tfprintf(stderr, \"securevnc_setup: server uses AES cipher.\\n\");\n\t} else {\n\t\tfprintf(stderr, \"securevnc_setup: server uses ARC4 cipher.\\n\");\n\t\tsecurevnc_arc4 = 1;\n\t\tCipher = EVP_rc4();\n\t}\n\n\t/* check for client auth signature requirement: */\n\tif (server_flags & (sig << 24)) {\n\t\tfprintf(stderr, \"securevnc_setup: server requires Client Auth signature.\\n\");\n\t\tclient_auth_req = 1;\n\t\tif (!client_auth) {\n\t\t\tfprintf(stderr, \"securevnc_setup: However, NO *ClientAuth.pkey keyfile was supplied on our\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: command line.  Exiting.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t/*\n\t * The first packet 'RFB 003.006' is obscured with key\n\t * that is a sha1 hash of public key.  So make this tmp key now:\n \t *\n\t */\n\tinitkey = (unsigned char *) calloc(SECUREVNC_KEY_SIZE, 1);\n\tEVP_BytesToKey(EVP_rc4(), EVP_sha1(), NULL, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE, 1, initkey, NULL);\n\n\t/* expand the transported rsabuf into an rsa object */\n\trsa = d2i_RSAPublicKey(NULL, (const unsigned char **) &rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tif (rsa == NULL) {\n\t\tsslexit(\"securevnc_setup: failed to create rsa\");\n\t}\n\n\t/*\n\t * Back to the work involving the tmp obscuring key:\n\t */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tinit_ctx = EVP_CIPHER_CTX_new();\n#else\n\n\tEVP_CIPHER_CTX init_ctx_obj;\n\tinit_ctx = &init_ctx_obj;\n#endif\n\tEVP_CIPHER_CTX_init(init_ctx);\n\trc = EVP_CipherInit_ex(init_ctx, EVP_rc4(), NULL, initkey, NULL, 1);\n\tif (rc == 0) {\n\t\tsslexit(\"securevnc_setup: EVP_CipherInit_ex(init_ctx) failed\");\n\t}\n\n\t/* for the first obscured packet, read what we can... */\n\tn = read(server, (char *) buf, BSIZE);\n\tfprintf(stderr, \"securevnc_setup: data read: %d\\n\", n);\n\tif (n < 0) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: initial data[%d]: \", n);\n\t\n\t/* decode with the tmp key */\n\tif (n > 0) {\n\t\tmemset(to_viewer, 0, sizeof(to_viewer));\n\t\tif (EVP_CipherUpdate(init_ctx, to_viewer, &len, buf, n) == 0) {\n\t\t\tsslexit(\"securevnc_setup: EVP_CipherUpdate(init_ctx) failed\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\t\texit(1);\n\t\t}\n\t\tto_viewer_len = len;\n\t}\n\tEVP_CIPHER_CTX_cleanup(init_ctx);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\tfree(initkey);\n\n\t/* print what we would send to the viewer (sent below): */\n\twrite(2, to_viewer, 12);\t/* and first 12 bytes 'RFB ...' as message */\n\n\t/* now create the random session key: */\n\tencrypted_keybuf = (unsigned char*) calloc(RSA_size(rsa), 1);\n\n\tfprintf(stderr, \"securevnc_setup: creating random session key: %d/%d\\n\",\n\t    SECUREVNC_KEY_SIZE, SECUREVNC_RAND_KEY_SOURCE);\n\tkeydata_len = SECUREVNC_RAND_KEY_SOURCE;\n\n\trc = RAND_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\tif (rc <= 0) {\n\t\tfprintf(stderr, \"securevnc_setup: RAND_bytes() failed: %s\\n\", ERR_error_string(ERR_get_error(), NULL));\n\t\trc = RAND_pseudo_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\t\tfprintf(stderr, \"securevnc_setup: RAND_pseudo_bytes() rc=%d\\n\", rc);\n\t\tif (getenv(\"RANDSTR\")) {\n\t\t\tchar *s = getenv(\"RANDSTR\"); \n\t\t\tfprintf(stderr, \"securevnc_setup: seeding with RANDSTR len=%d\\n\", strlen(s));\n\t\t\tRAND_add(s, strlen(s), strlen(s));\n\t\t}\n\t}\n\n\t/* N.B. this will be repeated in enc_xfer() setup. */\n\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata, keydata_len, 1, keystr, NULL);\n\n\t/* encrypt the session key with the server's public rsa key: */\n\tn = RSA_public_encrypt(SECUREVNC_KEY_SIZE, keystr, encrypted_keybuf, rsa, RSA_PKCS1_PADDING);\n\tif (n == -1) {\n\t\tsslexit(\"securevnc_setup: RSA_public_encrypt() failed\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: encrypted session key size: %d. sending to server.\\n\", n);\n\n\t/* send it to the server: */\n\twrite(server, encrypted_keybuf, n);\n\tfree(encrypted_keybuf);\n\n\t/*\n\t * Reply back with flags indicating cipher (same as one sent to\n\t * us) and we do not want client-side auth.\n\t *\n\t * We send it out on the wire in little endian order:\n\t */\n\tif (securevnc_arc4) {\n\t\twrite(server, (char *)&zero, 1);\n\t} else {\n\t\twrite(server, (char *)&one, 1);\n\t}\n\twrite(server, (char *)&zero, 1);\n\twrite(server, (char *)&zero, 1);\n\tif (client_auth_req) {\n\t\twrite(server, (char *)&sig, 1);\n\t} else {\n\t\twrite(server, (char *)&zero, 1);\n\t}\n\n\tif (client_auth_req && client_auth) {\n\t\tRSA *client_rsa = load_client_auth(client_auth);\n\t\tEVP_MD_CTX *dctx;\n\t\tunsigned char digest[EVP_MAX_MD_SIZE], *signature;\n\t\tunsigned int ndig = 0, nsig = 0;\n\n\t\tif (0) {\n\t\t\t/* for testing only, use the wrong RSA key: */\n\t\t\tclient_rsa = RSA_generate_key(2048, 0x10001, NULL, NULL);\n\t\t}\n\t\t\n\t\tif (client_rsa == NULL) {\n\t\t\tfprintf(stderr, \"securevnc_setup: problem reading rsa key from '%s'\\n\", client_auth);\n\t\t\texit(1);\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tdctx = EVP_MD_CTX_new();\n#else\n\t\tdctx = EVP_MD_CTX_create();\n#endif\n\t\tEVP_DigestInit(dctx, EVP_sha1());\n\t\tEVP_DigestUpdate(dctx, keystr, SECUREVNC_KEY_SIZE);\n\t\t/*\n\t\t * Without something like the following MITM is still possible.\n\t\t * This is because the MITM knows keystr and can use it with\n\t\t * the server connection as well, and then he just forwards our\n\t\t * signed digest.  The additional information below would be the\n\t\t * MITM's rsa public key, and so the real VNC server will notice\n\t\t * the difference.  And MITM can't sign keystr+server_rsa.pub since\n\t\t * he doesn't have Viewer_ClientAuth.pkey.\n\t\t */\n\t\tif (0) {\n\t\t\tEVP_DigestUpdate(dctx, rsasav, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: Warning: even *WITH* Client Authentication in SecureVNC,\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: an attacker may be able to trick you into connecting to his\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: fake VNC server and supplying VNC or Windows passwords, etc.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: THE FIRST VERSION OF THE SECUREVNC PROTOCOL IS\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: BEING USED.  *EVEN* WITH CLIENT AUTHENTICATION IT\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: IS SUSCEPTIBLE TO A MAN-IN-THE-MIDDLE ATTACK.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t}\n\t\tEVP_DigestFinal(dctx, (unsigned char *)digest, &ndig);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tEVP_MD_CTX_free(dctx);\n#else\n\t\tEVP_MD_CTX_destroy(dctx);\n#endif\n\n\t\tsignature = (unsigned char *) calloc(RSA_size(client_rsa), 1);\n\t\tRSA_sign(NID_sha1, digest, ndig, signature, &nsig, client_rsa);\n\n\t\tfprintf(stderr, \"securevnc_setup: sending ClientAuth.pkey signed data: %d\\n\", nsig);\n\t\twrite(server, signature, nsig);\n\t\tfree(signature);\n\n\t\tRSA_free(client_rsa);\n\t}\n\n\tfprintf(stderr, \"securevnc_setup: done.\\n\");\n\n\t/* now send the 'RFB ...' to the viewer */\n\tif (to_viewer_len > 0) {\n\t\twrite(viewer, to_viewer, to_viewer_len);\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SECUREVNC_RAND_KEY_SOURCE 1024",
            "#define SECUREVNC_KEY_SIZE 16",
            "#define SECUREVNC_RSA_PUBKEY_SIZE 270",
            "#define BSIZE 8192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RAND_KEY_SOURCE 1024\n#define SECUREVNC_KEY_SIZE 16\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n#define BSIZE 8192\n\nstatic void securevnc_setup(int conn1, int conn2) {\n\tRSA *rsa = NULL;\n\tEVP_CIPHER_CTX *init_ctx;\n\tunsigned char keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char *rsabuf, *rsasav;\n\tunsigned char *encrypted_keybuf;\n\tunsigned char *initkey;\t\n\tunsigned int server_flags = 0;\n\tunsigned char one = 1, zero = 0, sig = 16;\n\tunsigned char b1, b2, b3, b4;\n\tunsigned char buf[BSIZE], to_viewer[BSIZE];\n\tint to_viewer_len = 0;\n\tint n = 0, len, rc;\n\tint server = reverse ? conn1 : conn2;\n\tint viewer = reverse ? conn2 : conn1;\n\tchar *client_auth = NULL;\n\tint client_auth_req = 0;\n\tint keystore_verified = 0;\n\n\tERR_load_crypto_strings();\n\n\t/* alloc and read from server the 270 comprising the rsa public key: */\n\trsabuf = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\trsasav = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\tlen = 0;\n\twhile (len < SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tn = read(server, rsabuf + len, SECUREVNC_RSA_PUBKEY_SIZE - len);\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\tfprintf(stderr, \"securevnc_setup: fail read rsabuf: n=%d len=%d\\n\", n, len);\n\t\t\texit(1);\n\t\t}\n\t\tlen += n;\n\t}\n\tif (len != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tfprintf(stderr, \"securevnc_setup: fail final read rsabuf: n=%d len=%d\\n\", n, len);\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: rsa data read len: %d\\n\", len);\n\tmemcpy(rsasav, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\n\tfprintf(stderr, \"securevnc_setup: RSA key has MD5 sum: %s\\n\", rsa_md5_sum(rsabuf)); \n\tfprintf(stderr, \"securevnc_setup:\\n\"); \n\tfprintf(stderr, \"securevnc_setup: One way to print out the SecureVNC Server key MD5 sum is:\\n\\n\"); \n\tfprintf(stderr, \"openssl rsa -inform DER -outform DER -pubout -in ./Server_SecureVNC.pkey | dd bs=1 skip=24 | md5sum\\n\\n\");\n\tif (securevnc_file == NULL) {\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: ULTRAVNC SERVER RSA KEY NOT VERIFIED.   **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: A MAN-IN-THE-MIDDLE ATTACK IS POSSIBLE. **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t} else {\n\t\tchar *q = strrchr(securevnc_file, 'C');\n\t\tint skip = 0;\n\t\tif (q) {\n\t\t\tif (!strcmp(q, \"ClientAuth.pkey\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tskip = 1;\n\t\t\t} else if (!strcmp(q, \"ClientAuth.pkey.rsa\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tq = strrchr(client_auth, '.');\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t}\n\t\tif (!skip) {\n\t\t\trc = securevnc_check_server_rsa(securevnc_file, rsabuf);\n\t\t}\n\t\tif (skip) {\n\t\t\t;\n\t\t} else if (rc == 0) {\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY_ERROR: SERVER RSA KEY DID NOT MATCH:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\texit(1);\n\t\t} else if (rc == -1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: User cancelled the save and hence the connection.\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\texit(1);\n\t\t} else if (rc == 1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY SUCCESS: server rsa key matches the contents of:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 1;\n\t\t} else if (rc == 2) {\n\t\t\tfprintf(stderr, \"securevnc_setup: Server rsa key stored in:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 2;\n\t\t}\n\t}\n\n\t/*\n\t * read in the server flags. Note that SecureVNCPlugin sends these\n\t * in little endian and not network order!!\n\t */\n\tread(server, (char *) &b1, 1);\n\tread(server, (char *) &b2, 1);\n\tread(server, (char *) &b3, 1);\n\tread(server, (char *) &b4, 1);\n\t\n\tserver_flags = 0;\n\tserver_flags |= ((unsigned int) b4) << 24;\n\tserver_flags |= ((unsigned int) b3) << 16;\n\tserver_flags |= ((unsigned int) b2) << 8;\n\tserver_flags |= ((unsigned int) b1) << 0;\n\tfprintf(stderr, \"securevnc_setup: server_flags: 0x%08x\\n\", server_flags);\n\n\t/* check for arc4 usage: */\n\tif (server_flags & 0x1) {\n\t\tfprintf(stderr, \"securevnc_setup: server uses AES cipher.\\n\");\n\t} else {\n\t\tfprintf(stderr, \"securevnc_setup: server uses ARC4 cipher.\\n\");\n\t\tsecurevnc_arc4 = 1;\n\t\tCipher = EVP_rc4();\n\t}\n\n\t/* check for client auth signature requirement: */\n\tif (server_flags & (sig << 24)) {\n\t\tfprintf(stderr, \"securevnc_setup: server requires Client Auth signature.\\n\");\n\t\tclient_auth_req = 1;\n\t\tif (!client_auth) {\n\t\t\tfprintf(stderr, \"securevnc_setup: However, NO *ClientAuth.pkey keyfile was supplied on our\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: command line.  Exiting.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t/*\n\t * The first packet 'RFB 003.006' is obscured with key\n\t * that is a sha1 hash of public key.  So make this tmp key now:\n \t *\n\t */\n\tinitkey = (unsigned char *) calloc(SECUREVNC_KEY_SIZE, 1);\n\tEVP_BytesToKey(EVP_rc4(), EVP_sha1(), NULL, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE, 1, initkey, NULL);\n\n\t/* expand the transported rsabuf into an rsa object */\n\trsa = d2i_RSAPublicKey(NULL, (const unsigned char **) &rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tif (rsa == NULL) {\n\t\tsslexit(\"securevnc_setup: failed to create rsa\");\n\t}\n\n\t/*\n\t * Back to the work involving the tmp obscuring key:\n\t */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tinit_ctx = EVP_CIPHER_CTX_new();\n#else\n\n\tEVP_CIPHER_CTX init_ctx_obj;\n\tinit_ctx = &init_ctx_obj;\n#endif\n\tEVP_CIPHER_CTX_init(init_ctx);\n\trc = EVP_CipherInit_ex(init_ctx, EVP_rc4(), NULL, initkey, NULL, 1);\n\tif (rc == 0) {\n\t\tsslexit(\"securevnc_setup: EVP_CipherInit_ex(init_ctx) failed\");\n\t}\n\n\t/* for the first obscured packet, read what we can... */\n\tn = read(server, (char *) buf, BSIZE);\n\tfprintf(stderr, \"securevnc_setup: data read: %d\\n\", n);\n\tif (n < 0) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: initial data[%d]: \", n);\n\t\n\t/* decode with the tmp key */\n\tif (n > 0) {\n\t\tmemset(to_viewer, 0, sizeof(to_viewer));\n\t\tif (EVP_CipherUpdate(init_ctx, to_viewer, &len, buf, n) == 0) {\n\t\t\tsslexit(\"securevnc_setup: EVP_CipherUpdate(init_ctx) failed\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\t\texit(1);\n\t\t}\n\t\tto_viewer_len = len;\n\t}\n\tEVP_CIPHER_CTX_cleanup(init_ctx);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\tfree(initkey);\n\n\t/* print what we would send to the viewer (sent below): */\n\twrite(2, to_viewer, 12);\t/* and first 12 bytes 'RFB ...' as message */\n\n\t/* now create the random session key: */\n\tencrypted_keybuf = (unsigned char*) calloc(RSA_size(rsa), 1);\n\n\tfprintf(stderr, \"securevnc_setup: creating random session key: %d/%d\\n\",\n\t    SECUREVNC_KEY_SIZE, SECUREVNC_RAND_KEY_SOURCE);\n\tkeydata_len = SECUREVNC_RAND_KEY_SOURCE;\n\n\trc = RAND_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\tif (rc <= 0) {\n\t\tfprintf(stderr, \"securevnc_setup: RAND_bytes() failed: %s\\n\", ERR_error_string(ERR_get_error(), NULL));\n\t\trc = RAND_pseudo_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\t\tfprintf(stderr, \"securevnc_setup: RAND_pseudo_bytes() rc=%d\\n\", rc);\n\t\tif (getenv(\"RANDSTR\")) {\n\t\t\tchar *s = getenv(\"RANDSTR\"); \n\t\t\tfprintf(stderr, \"securevnc_setup: seeding with RANDSTR len=%d\\n\", strlen(s));\n\t\t\tRAND_add(s, strlen(s), strlen(s));\n\t\t}\n\t}\n\n\t/* N.B. this will be repeated in enc_xfer() setup. */\n\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata, keydata_len, 1, keystr, NULL);\n\n\t/* encrypt the session key with the server's public rsa key: */\n\tn = RSA_public_encrypt(SECUREVNC_KEY_SIZE, keystr, encrypted_keybuf, rsa, RSA_PKCS1_PADDING);\n\tif (n == -1) {\n\t\tsslexit(\"securevnc_setup: RSA_public_encrypt() failed\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: encrypted session key size: %d. sending to server.\\n\", n);\n\n\t/* send it to the server: */\n\twrite(server, encrypted_keybuf, n);\n\tfree(encrypted_keybuf);\n\n\t/*\n\t * Reply back with flags indicating cipher (same as one sent to\n\t * us) and we do not want client-side auth.\n\t *\n\t * We send it out on the wire in little endian order:\n\t */\n\tif (securevnc_arc4) {\n\t\twrite(server, (char *)&zero, 1);\n\t} else {\n\t\twrite(server, (char *)&one, 1);\n\t}\n\twrite(server, (char *)&zero, 1);\n\twrite(server, (char *)&zero, 1);\n\tif (client_auth_req) {\n\t\twrite(server, (char *)&sig, 1);\n\t} else {\n\t\twrite(server, (char *)&zero, 1);\n\t}\n\n\tif (client_auth_req && client_auth) {\n\t\tRSA *client_rsa = load_client_auth(client_auth);\n\t\tEVP_MD_CTX *dctx;\n\t\tunsigned char digest[EVP_MAX_MD_SIZE], *signature;\n\t\tunsigned int ndig = 0, nsig = 0;\n\n\t\tif (0) {\n\t\t\t/* for testing only, use the wrong RSA key: */\n\t\t\tclient_rsa = RSA_generate_key(2048, 0x10001, NULL, NULL);\n\t\t}\n\t\t\n\t\tif (client_rsa == NULL) {\n\t\t\tfprintf(stderr, \"securevnc_setup: problem reading rsa key from '%s'\\n\", client_auth);\n\t\t\texit(1);\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tdctx = EVP_MD_CTX_new();\n#else\n\t\tdctx = EVP_MD_CTX_create();\n#endif\n\t\tEVP_DigestInit(dctx, EVP_sha1());\n\t\tEVP_DigestUpdate(dctx, keystr, SECUREVNC_KEY_SIZE);\n\t\t/*\n\t\t * Without something like the following MITM is still possible.\n\t\t * This is because the MITM knows keystr and can use it with\n\t\t * the server connection as well, and then he just forwards our\n\t\t * signed digest.  The additional information below would be the\n\t\t * MITM's rsa public key, and so the real VNC server will notice\n\t\t * the difference.  And MITM can't sign keystr+server_rsa.pub since\n\t\t * he doesn't have Viewer_ClientAuth.pkey.\n\t\t */\n\t\tif (0) {\n\t\t\tEVP_DigestUpdate(dctx, rsasav, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: Warning: even *WITH* Client Authentication in SecureVNC,\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: an attacker may be able to trick you into connecting to his\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: fake VNC server and supplying VNC or Windows passwords, etc.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: THE FIRST VERSION OF THE SECUREVNC PROTOCOL IS\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: BEING USED.  *EVEN* WITH CLIENT AUTHENTICATION IT\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: IS SUSCEPTIBLE TO A MAN-IN-THE-MIDDLE ATTACK.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t}\n\t\tEVP_DigestFinal(dctx, (unsigned char *)digest, &ndig);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tEVP_MD_CTX_free(dctx);\n#else\n\t\tEVP_MD_CTX_destroy(dctx);\n#endif\n\n\t\tsignature = (unsigned char *) calloc(RSA_size(client_rsa), 1);\n\t\tRSA_sign(NID_sha1, digest, ndig, signature, &nsig, client_rsa);\n\n\t\tfprintf(stderr, \"securevnc_setup: sending ClientAuth.pkey signed data: %d\\n\", nsig);\n\t\twrite(server, signature, nsig);\n\t\tfree(signature);\n\n\t\tRSA_free(client_rsa);\n\t}\n\n\tfprintf(stderr, \"securevnc_setup: done.\\n\");\n\n\t/* now send the 'RFB ...' to the viewer */\n\tif (to_viewer_len > 0) {\n\t\twrite(viewer, to_viewer, to_viewer_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_cert",
          "args": [
            "conn2"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "show_cert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1585-1708",
          "snippet": "static void show_cert(int sock) {\n#ifndef ENC_DISABLE_SHOW_CERT\n\tSSL_CTX *ctx;\n\tSSL *ssl = NULL;\n\tSTACK_OF(X509) *sk = NULL;\n\tX509 *peer = NULL;\n\tSSL_CIPHER *c;\n\tBIO *bio;\n\tunsigned char *sid =  (unsigned char *) \"ultravnc_dsm_helper SID\";\n\tlong mode;\n\tint i;\n\n\tfprintf(stdout, \"CONNECTED(%08X)\\n\",sock);\n\n\tSSL_library_init();\n\tSSL_load_error_strings();\n\n\tif (!RAND_status()) {\n\t\tRAND_poll();\n\t}\n\t/* this is not for a secured connection. */\n\tfor (i=0; i < 100; i++) {\n\t\tif (!RAND_status()) {\n\t\t\tchar tmp[32];\n\t\t\tsprintf(tmp, \"%d\", getpid() * (17 + i));\n\t\t\tRAND_add(tmp, strlen(tmp), 5);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx = SSL_CTX_new( SSLv23_client_method() );\n\tif (ctx == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_CTX_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_SHOWCERT_ADH\")) {\n\t\tSSL_CTX_set_cipher_list(ctx, \"ADH:@STRENGTH\");\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\tssl = SSL_new(ctx);\n\n\tif (ssl == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (! SSL_set_fd(ssl, sock)) {\n\t\tfprintf(stdout, \"show_cert: SSL_set_fd failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_connect_state(ssl);\n\n\tif (SSL_connect(ssl) <= 0) {\n\t\tunsigned long err = ERR_get_error();\n\t\tfprintf(stdout, \"show_cert: SSL_connect failed.\\n\");\n\t\tif (err) {\n\t\t\tchar str[256];\n\t\t\tERR_error_string(err, str);\n\t\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t\t}\n\t}\n\n\tSSL_get_verify_result(ssl);\n\n\tsk = SSL_get_peer_cert_chain(ssl);\n\tif (sk != NULL) {\n\t\tfprintf(stdout, \"---\\nCertificate chain\\n\");\n\t\tfor (i=0; i < sk_X509_num(sk); i++) {\n\t\t\tchar buf[2048];\n\t\t\tX509_NAME_oneline(X509_get_subject_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"%2d s:%s\\n\", i, buf);\n\t\t\tX509_NAME_oneline(X509_get_issuer_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"   i:%s\\n\", buf);\n\t\t}\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_cert_chain failed.\\n\");\n\t}\n\tfprintf(stdout, \"---\\n\");\n\tpeer = SSL_get_peer_certificate(ssl);\n\tbio = BIO_new_fp(stdout, BIO_NOCLOSE);\n\tif (peer != NULL) {\n\t\tchar buf[2048];\n\t\tBIO_printf(bio,\"Server certificate\\n\");\n\t\tPEM_write_bio_X509(bio, peer);\n\n\t\tX509_NAME_oneline(X509_get_subject_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"subject=%s\\n\",buf);\n\t\tX509_NAME_oneline(X509_get_issuer_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"issuer=%s\\n\",buf);\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_certificate failed.\\n\");\n\t}\n\n\tc = SSL_get_current_cipher(ssl);\n\tBIO_printf(bio,\"---\\nNew, %s, Cipher is %s\\n\", SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));\n\n\tif (peer != NULL) {\n\t\tEVP_PKEY *pktmp;\n\t\tpktmp = X509_get_pubkey(peer);\n\t\tBIO_printf(bio,\"Server public key is %d bit\\n\", EVP_PKEY_bits(pktmp));\n\t\tEVP_PKEY_free(pktmp);\n\t}\n\tBIO_printf(bio,\"---\\nDONE\\n---\\n\");\n\t\n\tfflush(stdout);\n\n#endif\n\tclose(sock);\n\texit(0);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void show_cert(int sock) {\n#ifndef ENC_DISABLE_SHOW_CERT\n\tSSL_CTX *ctx;\n\tSSL *ssl = NULL;\n\tSTACK_OF(X509) *sk = NULL;\n\tX509 *peer = NULL;\n\tSSL_CIPHER *c;\n\tBIO *bio;\n\tunsigned char *sid =  (unsigned char *) \"ultravnc_dsm_helper SID\";\n\tlong mode;\n\tint i;\n\n\tfprintf(stdout, \"CONNECTED(%08X)\\n\",sock);\n\n\tSSL_library_init();\n\tSSL_load_error_strings();\n\n\tif (!RAND_status()) {\n\t\tRAND_poll();\n\t}\n\t/* this is not for a secured connection. */\n\tfor (i=0; i < 100; i++) {\n\t\tif (!RAND_status()) {\n\t\t\tchar tmp[32];\n\t\t\tsprintf(tmp, \"%d\", getpid() * (17 + i));\n\t\t\tRAND_add(tmp, strlen(tmp), 5);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx = SSL_CTX_new( SSLv23_client_method() );\n\tif (ctx == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_CTX_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_SHOWCERT_ADH\")) {\n\t\tSSL_CTX_set_cipher_list(ctx, \"ADH:@STRENGTH\");\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\tssl = SSL_new(ctx);\n\n\tif (ssl == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (! SSL_set_fd(ssl, sock)) {\n\t\tfprintf(stdout, \"show_cert: SSL_set_fd failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_connect_state(ssl);\n\n\tif (SSL_connect(ssl) <= 0) {\n\t\tunsigned long err = ERR_get_error();\n\t\tfprintf(stdout, \"show_cert: SSL_connect failed.\\n\");\n\t\tif (err) {\n\t\t\tchar str[256];\n\t\t\tERR_error_string(err, str);\n\t\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t\t}\n\t}\n\n\tSSL_get_verify_result(ssl);\n\n\tsk = SSL_get_peer_cert_chain(ssl);\n\tif (sk != NULL) {\n\t\tfprintf(stdout, \"---\\nCertificate chain\\n\");\n\t\tfor (i=0; i < sk_X509_num(sk); i++) {\n\t\t\tchar buf[2048];\n\t\t\tX509_NAME_oneline(X509_get_subject_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"%2d s:%s\\n\", i, buf);\n\t\t\tX509_NAME_oneline(X509_get_issuer_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"   i:%s\\n\", buf);\n\t\t}\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_cert_chain failed.\\n\");\n\t}\n\tfprintf(stdout, \"---\\n\");\n\tpeer = SSL_get_peer_certificate(ssl);\n\tbio = BIO_new_fp(stdout, BIO_NOCLOSE);\n\tif (peer != NULL) {\n\t\tchar buf[2048];\n\t\tBIO_printf(bio,\"Server certificate\\n\");\n\t\tPEM_write_bio_X509(bio, peer);\n\n\t\tX509_NAME_oneline(X509_get_subject_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"subject=%s\\n\",buf);\n\t\tX509_NAME_oneline(X509_get_issuer_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"issuer=%s\\n\",buf);\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_certificate failed.\\n\");\n\t}\n\n\tc = SSL_get_current_cipher(ssl);\n\tBIO_printf(bio,\"---\\nNew, %s, Cipher is %s\\n\", SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));\n\n\tif (peer != NULL) {\n\t\tEVP_PKEY *pktmp;\n\t\tpktmp = X509_get_pubkey(peer);\n\t\tBIO_printf(bio,\"Server public key is %d bit\\n\", EVP_PKEY_bits(pktmp));\n\t\tEVP_PKEY_free(pktmp);\n\t}\n\tBIO_printf(bio,\"---\\nDONE\\n---\\n\");\n\t\n\tfflush(stdout);\n\n#endif\n\tclose(sock);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"showcert\""
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt TCP_NODELAY\""
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "conn2",
            "IPPROTO_TCP",
            "TCP_NODELAY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not connect to %s\\n\"",
            "connect_host"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"connect6\""
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "fd",
            "ap->ai_addr",
            "ap->ai_addrlen"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "enc_connections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1721-2075",
          "snippet": "static void enc_connections(int listen_port, char *connect_host, int connect_port) {\n\tint listen_fd = -1, listen_fd6 = -1, conn1 = -1, conn2 = -1, ret, one = 1;\n\tsocklen_t clen;\n\tstruct hostent *hp;\n\tstruct sockaddr_in client, server;\n\tfd_set fds;\n\tint maxfd = -1;\n\n\t/* zero means use stdio (preferably from socketpair()) */\n\tif (listen_port == 0) {\n\t\tconn1 = fileno(stdin);\n\t\tgoto use_stdio;\n\t}\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto use_stdio;\n\t}\n\n\t/* fd=n,m means use the supplied already established sockets */\n\tif (sscanf(connect_host, \"fd=%d,%d\", &conn1, &conn2) == 2) {\n\t\tgoto use_input_fds;\n\t}\n\n\t/* create the listening socket: */\n\tmemset(&client, 0, sizeof(client));\n\tclient.sin_family = AF_INET;\n\tif (listen_port < 0) {\n\t\t/* negative port means use loopback */\n\t\tclient.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tclient.sin_port = htons(-listen_port);\n\t} else {\n\t\tclient.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tclient.sin_port = htons(listen_port);\n\t}\n\n\tlisten_fd = socket(AF_INET, SOCK_STREAM, 0); \n\tif (listen_fd < 0) {\n\t\tperror(\"socket\");\n\t\tgoto try6;\n\t}\n\n\tret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR,\n\t    (char *)&one, sizeof(one));\n\tif (ret < 0) {\n\t\tperror(\"setsockopt\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = bind(listen_fd, (struct sockaddr *) &client, sizeof(client));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = listen(listen_fd, 2);\n\tif (ret < 0) {\n\t\tperror(\"listen\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\ttry6:\n#ifdef AF_INET6\n\tif (!getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tstruct sockaddr_in6 sin;\n\t\tint one = 1, sock = -1;\n\n\t\tsock = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket6\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 SO_REUSEADDR\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 IPV6_V6ONLY\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n#endif\n\n\t\tmemset((char *)&sin, 0, sizeof(sin));\n\t\tsin.sin6_family = AF_INET6;\n\n\t\tif (listen_port < 0) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t\tsin.sin6_port = htons(-listen_port);\n\t\t} else {\n\t\t\tsin.sin6_addr = in6addr_any;\n\t\t\tsin.sin6_port = htons(listen_port);\n\t\t}\n\n\t\tif (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\t\tperror(\"bind6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (listen(sock, 2) < 0) {\n\t\t\tperror(\"listen6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfail:\n\t\tlisten_fd6 = sock;\n\t}\n#endif\n\n\tif (listen_fd < 0 && listen_fd6 < 0) {\n\t\tfprintf(stderr, \"%s: could not listen on port: %d\\n\",\n\t\t    prog, listen_port);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"%s: waiting for connection on port: %d\\n\",\n\t    prog, listen_port);\n\n\t/* wait for a connection: */\n\tFD_ZERO(&fds);\n\tif (listen_fd >= 0) {\n\t\tFD_SET(listen_fd, &fds);\n\t\tif (listen_fd > maxfd) {\n\t\t\tmaxfd = listen_fd;\n\t\t}\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tFD_SET(listen_fd6, &fds);\n\t\tif (listen_fd6 > maxfd) {\n\t\t\tmaxfd = listen_fd6;\n\t\t}\n\t}\n\tif (select(maxfd+1, &fds, NULL, NULL, NULL) <= 0) {\n\t\tperror(\"select\");\n\t\texit(1);\n\t}\n\n\tif (FD_ISSET(listen_fd, &fds)) {\n\t\tclen = sizeof(client);\n\t\tconn1 = accept(listen_fd, (struct sockaddr *) &client, &clen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t} else if (FD_ISSET(listen_fd6, &fds)) {\n#ifdef AF_INET6\n\t\tstruct sockaddr_in6 addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\n\t\tconn1 = accept(listen_fd6, (struct sockaddr *) &addr, &addrlen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept6\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tfprintf(stderr, \"No IPv6 / AF_INET6 support.\\n\");\n\t\texit(1);\n#endif\n\t}\n\n\tif (setsockopt(conn1, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t\texit(1);\n\t}\n\n\t/* done with the listening socket(s): */\n\tif (listen_fd >= 0) {\n\t\tclose(listen_fd);\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tclose(listen_fd6);\n\t}\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_BG\")) {\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\tfprintf(stderr, \"%s: putting child %d in background.\\n\",\n\t\t\t    prog, p);\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"%s: could not fork\\n\", prog);\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\tfprintf(stderr, \"%s: setsid failed\\n\", prog);\n\t\t\tperror(\"setsid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t}\n\n\tuse_stdio:\n\n\tfprintf(stderr, \"%s: got connection: %d\\n\", prog, conn1);\n\n\t/* now connect to remote server: */\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family = AF_INET;\n\tserver.sin_port = htons(connect_port);\n\n\tif ((server.sin_addr.s_addr = inet_addr(connect_host)) == htonl(INADDR_NONE)) {\n\t\tif (!(hp = gethostbyname(connect_host))) {\n\t\t\tperror(\"gethostbyname\");\n\t\t\tgoto tryconn6;\n\t\t}\n\t\tserver.sin_addr.s_addr = *(unsigned long *)hp->h_addr;\n\t}\n\n\tconn2 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (conn2 < 0) {\n\t\tperror(\"socket\");\n\t\tgoto tryconn6;\n\t}\n\n\tif (connect(conn2, (struct sockaddr *)&server, (sizeof(server))) < 0) {\n\t\tperror(\"connect\");\n\t\tgoto tryconn6;\n\t}\n\n\ttryconn6:\n#ifdef AF_INET6\n\tif (conn2 < 0 && !getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32];\n\n\t\tfprintf(stderr, \"connect[ipv6]: trying to connect via IPv6 to %s\\n\", connect_host);\n\t\tconn2 = -1;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", connect_port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\terr = getaddrinfo(connect_host, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint fd = -1;\n\t\t\t\tfd = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tperror(\"socket6\");\n\t\t\t\t} else {\n\t\t\t\t\tint dmsg = 0; \n\t\t\t\t\tint res = connect(fd, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\tperror(\"connect6\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\tfprintf(stderr, \"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(fd, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tconn2 = fd; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) perror(\"connect6\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t}\n#endif\n\tif (conn2 < 0) {\n\t\tfprintf(stderr, \"could not connect to %s\\n\", connect_host);\n\t\texit(1);\n\t}\n\tif (conn2 >= 0 && setsockopt(conn2, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t}\n\n\tuse_input_fds:\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tshow_cert(conn2);\n\t\tclose(conn2);\n\t\texit(0);\n\t}\n\n\tif (securevnc) {\n\t\tsecurevnc_setup(conn1, conn2);\n\t}\n\n\t/* fork into two processes; one for each direction: */\n\tparent = getpid();\n\t\n\tchild = fork();\n\t\n\tif (child == (pid_t) -1) {\n\t\t/* couldn't fork... */\n\t\tperror(\"fork\");\n\t\tclose(conn1);\n\t\tclose(conn2);\n\t\texit(1);\n\t}\n\n\t/* Do transfer/encode/decode loop: */\n\n\tif (child == 0) {\n\t\t/* encrypter: local-viewer -> remote-server */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn1, conn2);\n\t\t} else {\n\t\t\tenc_xfer(conn1, conn2, 1);\n\t\t}\n\t} else {\n\t\t/* decrypter: remote-server -> local-viewer */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn2, conn1);\n\t\t} else {\n\t\t\tenc_xfer(conn2, conn1, 0);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\""
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_IPV6",
            "IPV6_V6ONLY",
            "(char *)&zero",
            "sizeof(zero)"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"connect6\""
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"socket6\""
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "ap->ai_family",
            "ap->ai_socktype",
            "ap->ai_protocol"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"getaddrinfo[%d]: %s\\n\"",
            "err",
            "gai_strerror(err)"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "err"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "connect_host",
            "service",
            "&hints",
            "&ai"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "service",
            "\"%d\"",
            "connect_port"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"connect[ipv6]: trying to connect via IPv6 to %s\\n\"",
            "connect_host"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_NOIPV6\""
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"connect\""
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"socket\""
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"gethostbyname\""
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "connect_host"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_NONE"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "connect_host"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "connect_port"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&server",
            "0",
            "sizeof(server)"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: got connection: %d\\n\"",
            "prog",
            "conn1"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "2"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "1"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "n",
            "0"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDONLY"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsid\""
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: setsid failed\\n\"",
            "prog"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: could not fork\\n\"",
            "prog"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: putting child %d in background.\\n\"",
            "prog",
            "p"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_BG\""
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt TCP_NODELAY\""
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "conn1",
            "IPPROTO_TCP",
            "TCP_NODELAY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No IPv6 / AF_INET6 support.\\n\""
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"accept6\""
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "listen_fd6",
            "(struct sockaddr *) &addr",
            "&addrlen"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "listen_fd6",
            "&fds"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"accept\""
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "listen_fd",
            "(struct sockaddr *) &client",
            "&clen"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "listen_fd",
            "&fds"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"select\""
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "maxfd+1",
            "&fds",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "listen_fd6",
            "&fds"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "listen_fd",
            "&fds"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: waiting for connection on port: %d\\n\"",
            "prog",
            "listen_port"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: could not listen on port: %d\\n\"",
            "prog",
            "listen_port"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"listen6\""
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sock",
            "2"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"bind6\""
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "(struct sockaddr *) &sin",
            "sizeof(sin)"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "listen_port"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "-listen_port"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&sin",
            "0",
            "sizeof(sin)"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt6 IPV6_V6ONLY\""
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sock",
            "SOL_IPV6",
            "IPV6_V6ONLY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt6 SO_REUSEADDR\""
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sock",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"socket6\""
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET6",
            "SOCK_STREAM",
            "0"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_NOIPV6\""
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"listen\""
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "listen_fd",
            "2"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"bind\""
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "listen_fd",
            "(struct sockaddr *) &client",
            "sizeof(client)"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt\""
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "listen_fd",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"socket\""
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "listen_port"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "-listen_port"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&client",
            "0",
            "sizeof(client)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "connect_host",
            "\"fd=%d,%d\"",
            "&conn1",
            "&conn2"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"showcert\""
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SOL_IPV6 IPPROTO_IPV6\n#define INADDR_NONE ((in_addr_t) 0xffffffff)\n\nstatic void enc_connections(int listen_port, char *connect_host, int connect_port) {\n\tint listen_fd = -1, listen_fd6 = -1, conn1 = -1, conn2 = -1, ret, one = 1;\n\tsocklen_t clen;\n\tstruct hostent *hp;\n\tstruct sockaddr_in client, server;\n\tfd_set fds;\n\tint maxfd = -1;\n\n\t/* zero means use stdio (preferably from socketpair()) */\n\tif (listen_port == 0) {\n\t\tconn1 = fileno(stdin);\n\t\tgoto use_stdio;\n\t}\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto use_stdio;\n\t}\n\n\t/* fd=n,m means use the supplied already established sockets */\n\tif (sscanf(connect_host, \"fd=%d,%d\", &conn1, &conn2) == 2) {\n\t\tgoto use_input_fds;\n\t}\n\n\t/* create the listening socket: */\n\tmemset(&client, 0, sizeof(client));\n\tclient.sin_family = AF_INET;\n\tif (listen_port < 0) {\n\t\t/* negative port means use loopback */\n\t\tclient.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tclient.sin_port = htons(-listen_port);\n\t} else {\n\t\tclient.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tclient.sin_port = htons(listen_port);\n\t}\n\n\tlisten_fd = socket(AF_INET, SOCK_STREAM, 0); \n\tif (listen_fd < 0) {\n\t\tperror(\"socket\");\n\t\tgoto try6;\n\t}\n\n\tret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR,\n\t    (char *)&one, sizeof(one));\n\tif (ret < 0) {\n\t\tperror(\"setsockopt\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = bind(listen_fd, (struct sockaddr *) &client, sizeof(client));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = listen(listen_fd, 2);\n\tif (ret < 0) {\n\t\tperror(\"listen\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\ttry6:\n#ifdef AF_INET6\n\tif (!getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tstruct sockaddr_in6 sin;\n\t\tint one = 1, sock = -1;\n\n\t\tsock = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket6\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 SO_REUSEADDR\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 IPV6_V6ONLY\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n#endif\n\n\t\tmemset((char *)&sin, 0, sizeof(sin));\n\t\tsin.sin6_family = AF_INET6;\n\n\t\tif (listen_port < 0) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t\tsin.sin6_port = htons(-listen_port);\n\t\t} else {\n\t\t\tsin.sin6_addr = in6addr_any;\n\t\t\tsin.sin6_port = htons(listen_port);\n\t\t}\n\n\t\tif (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\t\tperror(\"bind6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (listen(sock, 2) < 0) {\n\t\t\tperror(\"listen6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfail:\n\t\tlisten_fd6 = sock;\n\t}\n#endif\n\n\tif (listen_fd < 0 && listen_fd6 < 0) {\n\t\tfprintf(stderr, \"%s: could not listen on port: %d\\n\",\n\t\t    prog, listen_port);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"%s: waiting for connection on port: %d\\n\",\n\t    prog, listen_port);\n\n\t/* wait for a connection: */\n\tFD_ZERO(&fds);\n\tif (listen_fd >= 0) {\n\t\tFD_SET(listen_fd, &fds);\n\t\tif (listen_fd > maxfd) {\n\t\t\tmaxfd = listen_fd;\n\t\t}\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tFD_SET(listen_fd6, &fds);\n\t\tif (listen_fd6 > maxfd) {\n\t\t\tmaxfd = listen_fd6;\n\t\t}\n\t}\n\tif (select(maxfd+1, &fds, NULL, NULL, NULL) <= 0) {\n\t\tperror(\"select\");\n\t\texit(1);\n\t}\n\n\tif (FD_ISSET(listen_fd, &fds)) {\n\t\tclen = sizeof(client);\n\t\tconn1 = accept(listen_fd, (struct sockaddr *) &client, &clen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t} else if (FD_ISSET(listen_fd6, &fds)) {\n#ifdef AF_INET6\n\t\tstruct sockaddr_in6 addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\n\t\tconn1 = accept(listen_fd6, (struct sockaddr *) &addr, &addrlen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept6\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tfprintf(stderr, \"No IPv6 / AF_INET6 support.\\n\");\n\t\texit(1);\n#endif\n\t}\n\n\tif (setsockopt(conn1, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t\texit(1);\n\t}\n\n\t/* done with the listening socket(s): */\n\tif (listen_fd >= 0) {\n\t\tclose(listen_fd);\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tclose(listen_fd6);\n\t}\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_BG\")) {\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\tfprintf(stderr, \"%s: putting child %d in background.\\n\",\n\t\t\t    prog, p);\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"%s: could not fork\\n\", prog);\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\tfprintf(stderr, \"%s: setsid failed\\n\", prog);\n\t\t\tperror(\"setsid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t}\n\n\tuse_stdio:\n\n\tfprintf(stderr, \"%s: got connection: %d\\n\", prog, conn1);\n\n\t/* now connect to remote server: */\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family = AF_INET;\n\tserver.sin_port = htons(connect_port);\n\n\tif ((server.sin_addr.s_addr = inet_addr(connect_host)) == htonl(INADDR_NONE)) {\n\t\tif (!(hp = gethostbyname(connect_host))) {\n\t\t\tperror(\"gethostbyname\");\n\t\t\tgoto tryconn6;\n\t\t}\n\t\tserver.sin_addr.s_addr = *(unsigned long *)hp->h_addr;\n\t}\n\n\tconn2 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (conn2 < 0) {\n\t\tperror(\"socket\");\n\t\tgoto tryconn6;\n\t}\n\n\tif (connect(conn2, (struct sockaddr *)&server, (sizeof(server))) < 0) {\n\t\tperror(\"connect\");\n\t\tgoto tryconn6;\n\t}\n\n\ttryconn6:\n#ifdef AF_INET6\n\tif (conn2 < 0 && !getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32];\n\n\t\tfprintf(stderr, \"connect[ipv6]: trying to connect via IPv6 to %s\\n\", connect_host);\n\t\tconn2 = -1;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", connect_port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\terr = getaddrinfo(connect_host, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint fd = -1;\n\t\t\t\tfd = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tperror(\"socket6\");\n\t\t\t\t} else {\n\t\t\t\t\tint dmsg = 0; \n\t\t\t\t\tint res = connect(fd, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\tperror(\"connect6\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\tfprintf(stderr, \"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(fd, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tconn2 = fd; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) perror(\"connect6\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t}\n#endif\n\tif (conn2 < 0) {\n\t\tfprintf(stderr, \"could not connect to %s\\n\", connect_host);\n\t\texit(1);\n\t}\n\tif (conn2 >= 0 && setsockopt(conn2, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t}\n\n\tuse_input_fds:\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tshow_cert(conn2);\n\t\tclose(conn2);\n\t\texit(0);\n\t}\n\n\tif (securevnc) {\n\t\tsecurevnc_setup(conn1, conn2);\n\t}\n\n\t/* fork into two processes; one for each direction: */\n\tparent = getpid();\n\t\n\tchild = fork();\n\t\n\tif (child == (pid_t) -1) {\n\t\t/* couldn't fork... */\n\t\tperror(\"fork\");\n\t\tclose(conn1);\n\t\tclose(conn2);\n\t\texit(1);\n\t}\n\n\t/* Do transfer/encode/decode loop: */\n\n\tif (child == 0) {\n\t\t/* encrypter: local-viewer -> remote-server */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn1, conn2);\n\t\t} else {\n\t\t\tenc_xfer(conn1, conn2, 1);\n\t\t}\n\t} else {\n\t\t/* decrypter: remote-server -> local-viewer */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn2, conn1);\n\t\t} else {\n\t\t\tenc_xfer(conn2, conn1, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "show_cert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1585-1708",
    "snippet": "static void show_cert(int sock) {\n#ifndef ENC_DISABLE_SHOW_CERT\n\tSSL_CTX *ctx;\n\tSSL *ssl = NULL;\n\tSTACK_OF(X509) *sk = NULL;\n\tX509 *peer = NULL;\n\tSSL_CIPHER *c;\n\tBIO *bio;\n\tunsigned char *sid =  (unsigned char *) \"ultravnc_dsm_helper SID\";\n\tlong mode;\n\tint i;\n\n\tfprintf(stdout, \"CONNECTED(%08X)\\n\",sock);\n\n\tSSL_library_init();\n\tSSL_load_error_strings();\n\n\tif (!RAND_status()) {\n\t\tRAND_poll();\n\t}\n\t/* this is not for a secured connection. */\n\tfor (i=0; i < 100; i++) {\n\t\tif (!RAND_status()) {\n\t\t\tchar tmp[32];\n\t\t\tsprintf(tmp, \"%d\", getpid() * (17 + i));\n\t\t\tRAND_add(tmp, strlen(tmp), 5);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx = SSL_CTX_new( SSLv23_client_method() );\n\tif (ctx == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_CTX_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_SHOWCERT_ADH\")) {\n\t\tSSL_CTX_set_cipher_list(ctx, \"ADH:@STRENGTH\");\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\tssl = SSL_new(ctx);\n\n\tif (ssl == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (! SSL_set_fd(ssl, sock)) {\n\t\tfprintf(stdout, \"show_cert: SSL_set_fd failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_connect_state(ssl);\n\n\tif (SSL_connect(ssl) <= 0) {\n\t\tunsigned long err = ERR_get_error();\n\t\tfprintf(stdout, \"show_cert: SSL_connect failed.\\n\");\n\t\tif (err) {\n\t\t\tchar str[256];\n\t\t\tERR_error_string(err, str);\n\t\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t\t}\n\t}\n\n\tSSL_get_verify_result(ssl);\n\n\tsk = SSL_get_peer_cert_chain(ssl);\n\tif (sk != NULL) {\n\t\tfprintf(stdout, \"---\\nCertificate chain\\n\");\n\t\tfor (i=0; i < sk_X509_num(sk); i++) {\n\t\t\tchar buf[2048];\n\t\t\tX509_NAME_oneline(X509_get_subject_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"%2d s:%s\\n\", i, buf);\n\t\t\tX509_NAME_oneline(X509_get_issuer_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"   i:%s\\n\", buf);\n\t\t}\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_cert_chain failed.\\n\");\n\t}\n\tfprintf(stdout, \"---\\n\");\n\tpeer = SSL_get_peer_certificate(ssl);\n\tbio = BIO_new_fp(stdout, BIO_NOCLOSE);\n\tif (peer != NULL) {\n\t\tchar buf[2048];\n\t\tBIO_printf(bio,\"Server certificate\\n\");\n\t\tPEM_write_bio_X509(bio, peer);\n\n\t\tX509_NAME_oneline(X509_get_subject_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"subject=%s\\n\",buf);\n\t\tX509_NAME_oneline(X509_get_issuer_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"issuer=%s\\n\",buf);\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_certificate failed.\\n\");\n\t}\n\n\tc = SSL_get_current_cipher(ssl);\n\tBIO_printf(bio,\"---\\nNew, %s, Cipher is %s\\n\", SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));\n\n\tif (peer != NULL) {\n\t\tEVP_PKEY *pktmp;\n\t\tpktmp = X509_get_pubkey(peer);\n\t\tBIO_printf(bio,\"Server public key is %d bit\\n\", EVP_PKEY_bits(pktmp));\n\t\tEVP_PKEY_free(pktmp);\n\t}\n\tBIO_printf(bio,\"---\\nDONE\\n---\\n\");\n\t\n\tfflush(stdout);\n\n#endif\n\tclose(sock);\n\texit(0);\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\"---\\nDONE\\n---\\n\""
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "pktmp"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\"Server public key is %d bit\\n\"",
            "EVP_PKEY_bits(pktmp)"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_bits",
          "args": [
            "pktmp"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_pubkey",
          "args": [
            "peer"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\"---\\nNew, %s, Cipher is %s\\n\"",
            "SSL_CIPHER_get_version(c)",
            "SSL_CIPHER_get_name(c)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CIPHER_get_name",
          "args": [
            "c"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CIPHER_get_version",
          "args": [
            "c"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_current_cipher",
          "args": [
            "ssl"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"show_cert: SSL_get_peer_certificate failed.\\n\""
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\"issuer=%s\\n\"",
            "buf"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_NAME_oneline",
          "args": [
            "X509_get_issuer_name(peer)",
            "buf",
            "sizeof buf"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_issuer_name",
          "args": [
            "peer"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\"subject=%s\\n\"",
            "buf"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_NAME_oneline",
          "args": [
            "X509_get_subject_name(peer)",
            "buf",
            "sizeof buf"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_subject_name",
          "args": [
            "peer"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_X509",
          "args": [
            "bio",
            "peer"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\"Server certificate\\n\""
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new_fp",
          "args": [
            "stdout",
            "BIO_NOCLOSE"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_peer_certificate",
          "args": [
            "ssl"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"---\\n\""
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"show_cert: SSL_get_peer_cert_chain failed.\\n\""
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"   i:%s\\n\"",
            "buf"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_NAME_oneline",
          "args": [
            "X509_get_issuer_name(sk_X509_value(sk,i))",
            "buf",
            "sizeof buf"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_issuer_name",
          "args": [
            "sk_X509_value(sk,i)"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_X509_value",
          "args": [
            "sk",
            "i"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%2d s:%s\\n\"",
            "i",
            "buf"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_NAME_oneline",
          "args": [
            "X509_get_subject_name(sk_X509_value(sk,i))",
            "buf",
            "sizeof buf"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_subject_name",
          "args": [
            "sk_X509_value(sk,i)"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_X509_value",
          "args": [
            "sk",
            "i"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_X509_num",
          "args": [
            "sk"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"---\\nCertificate chain\\n\""
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_peer_cert_chain",
          "args": [
            "ssl"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_verify_result",
          "args": [
            "ssl"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"ssl error: %s\\n\"",
            "str"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_error_string",
          "args": [
            "err",
            "str"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"show_cert: SSL_connect failed.\\n\""
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_connect",
          "args": [
            "ssl"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_connect_state",
          "args": [
            "ssl"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enc_sslerrexit",
          "args": [],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "enc_sslerrexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1573-1582",
          "snippet": "static void enc_sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t}\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void enc_sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t}\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"show_cert: SSL_set_fd failed.\\n\""
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_fd",
          "args": [
            "ssl",
            "sock"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_session_id_context",
          "args": [
            "ssl",
            "sid",
            "strlen((char *)sid)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(char *)sid"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"show_cert: SSL_new failed.\\n\""
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_new",
          "args": [
            "ctx"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_verify",
          "args": [
            "ctx",
            "SSL_VERIFY_NONE",
            "NULL"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_cipher_list",
          "args": [
            "ctx",
            "\"ADH:@STRENGTH\""
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ULTRAVNC_DSM_HELPER_SHOWCERT_ADH\""
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_mode",
          "args": [
            "ctx",
            "mode"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"show_cert: SSL_CTX_new failed.\\n\""
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_new",
          "args": [
            "SSLv23_client_method()"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSLv23_client_method",
          "args": [],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_add",
          "args": [
            "tmp",
            "strlen(tmp)",
            "5"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%d\"",
            "getpid() * (17 + i)"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_status",
          "args": [],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_poll",
          "args": [],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_status",
          "args": [],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_load_error_strings",
          "args": [],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_library_init",
          "args": [],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"CONNECTED(%08X)\\n\"",
            "sock"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_OF",
          "args": [
            "X509"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void show_cert(int sock) {\n#ifndef ENC_DISABLE_SHOW_CERT\n\tSSL_CTX *ctx;\n\tSSL *ssl = NULL;\n\tSTACK_OF(X509) *sk = NULL;\n\tX509 *peer = NULL;\n\tSSL_CIPHER *c;\n\tBIO *bio;\n\tunsigned char *sid =  (unsigned char *) \"ultravnc_dsm_helper SID\";\n\tlong mode;\n\tint i;\n\n\tfprintf(stdout, \"CONNECTED(%08X)\\n\",sock);\n\n\tSSL_library_init();\n\tSSL_load_error_strings();\n\n\tif (!RAND_status()) {\n\t\tRAND_poll();\n\t}\n\t/* this is not for a secured connection. */\n\tfor (i=0; i < 100; i++) {\n\t\tif (!RAND_status()) {\n\t\t\tchar tmp[32];\n\t\t\tsprintf(tmp, \"%d\", getpid() * (17 + i));\n\t\t\tRAND_add(tmp, strlen(tmp), 5);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx = SSL_CTX_new( SSLv23_client_method() );\n\tif (ctx == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_CTX_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_SHOWCERT_ADH\")) {\n\t\tSSL_CTX_set_cipher_list(ctx, \"ADH:@STRENGTH\");\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\tssl = SSL_new(ctx);\n\n\tif (ssl == NULL) {\n\t\tfprintf(stdout, \"show_cert: SSL_new failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (! SSL_set_fd(ssl, sock)) {\n\t\tfprintf(stdout, \"show_cert: SSL_set_fd failed.\\n\");\n\t\tclose(sock);\n\t\tenc_sslerrexit();\n\t}\n\n\tSSL_set_connect_state(ssl);\n\n\tif (SSL_connect(ssl) <= 0) {\n\t\tunsigned long err = ERR_get_error();\n\t\tfprintf(stdout, \"show_cert: SSL_connect failed.\\n\");\n\t\tif (err) {\n\t\t\tchar str[256];\n\t\t\tERR_error_string(err, str);\n\t\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t\t}\n\t}\n\n\tSSL_get_verify_result(ssl);\n\n\tsk = SSL_get_peer_cert_chain(ssl);\n\tif (sk != NULL) {\n\t\tfprintf(stdout, \"---\\nCertificate chain\\n\");\n\t\tfor (i=0; i < sk_X509_num(sk); i++) {\n\t\t\tchar buf[2048];\n\t\t\tX509_NAME_oneline(X509_get_subject_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"%2d s:%s\\n\", i, buf);\n\t\t\tX509_NAME_oneline(X509_get_issuer_name(sk_X509_value(sk,i)), buf, sizeof buf);\n\t\t\tfprintf(stdout, \"   i:%s\\n\", buf);\n\t\t}\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_cert_chain failed.\\n\");\n\t}\n\tfprintf(stdout, \"---\\n\");\n\tpeer = SSL_get_peer_certificate(ssl);\n\tbio = BIO_new_fp(stdout, BIO_NOCLOSE);\n\tif (peer != NULL) {\n\t\tchar buf[2048];\n\t\tBIO_printf(bio,\"Server certificate\\n\");\n\t\tPEM_write_bio_X509(bio, peer);\n\n\t\tX509_NAME_oneline(X509_get_subject_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"subject=%s\\n\",buf);\n\t\tX509_NAME_oneline(X509_get_issuer_name(peer), buf, sizeof buf);\n\t\tBIO_printf(bio,\"issuer=%s\\n\",buf);\n\t} else {\n\t\tfprintf(stdout, \"show_cert: SSL_get_peer_certificate failed.\\n\");\n\t}\n\n\tc = SSL_get_current_cipher(ssl);\n\tBIO_printf(bio,\"---\\nNew, %s, Cipher is %s\\n\", SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));\n\n\tif (peer != NULL) {\n\t\tEVP_PKEY *pktmp;\n\t\tpktmp = X509_get_pubkey(peer);\n\t\tBIO_printf(bio,\"Server public key is %d bit\\n\", EVP_PKEY_bits(pktmp));\n\t\tEVP_PKEY_free(pktmp);\n\t}\n\tBIO_printf(bio,\"---\\nDONE\\n---\\n\");\n\t\n\tfflush(stdout);\n\n#endif\n\tclose(sock);\n\texit(0);\n}"
  },
  {
    "function_name": "enc_sslerrexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1573-1582",
    "snippet": "static void enc_sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t}\n\texit(1);\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"ssl error: %s\\n\"",
            "str"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_error_string",
          "args": [
            "err",
            "str"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void enc_sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stdout, \"ssl error: %s\\n\", str);\n\t}\n\texit(1);\n}"
  },
  {
    "function_name": "securevnc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1252-1570",
    "snippet": "static void securevnc_setup(int conn1, int conn2) {\n\tRSA *rsa = NULL;\n\tEVP_CIPHER_CTX *init_ctx;\n\tunsigned char keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char *rsabuf, *rsasav;\n\tunsigned char *encrypted_keybuf;\n\tunsigned char *initkey;\t\n\tunsigned int server_flags = 0;\n\tunsigned char one = 1, zero = 0, sig = 16;\n\tunsigned char b1, b2, b3, b4;\n\tunsigned char buf[BSIZE], to_viewer[BSIZE];\n\tint to_viewer_len = 0;\n\tint n = 0, len, rc;\n\tint server = reverse ? conn1 : conn2;\n\tint viewer = reverse ? conn2 : conn1;\n\tchar *client_auth = NULL;\n\tint client_auth_req = 0;\n\tint keystore_verified = 0;\n\n\tERR_load_crypto_strings();\n\n\t/* alloc and read from server the 270 comprising the rsa public key: */\n\trsabuf = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\trsasav = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\tlen = 0;\n\twhile (len < SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tn = read(server, rsabuf + len, SECUREVNC_RSA_PUBKEY_SIZE - len);\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\tfprintf(stderr, \"securevnc_setup: fail read rsabuf: n=%d len=%d\\n\", n, len);\n\t\t\texit(1);\n\t\t}\n\t\tlen += n;\n\t}\n\tif (len != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tfprintf(stderr, \"securevnc_setup: fail final read rsabuf: n=%d len=%d\\n\", n, len);\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: rsa data read len: %d\\n\", len);\n\tmemcpy(rsasav, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\n\tfprintf(stderr, \"securevnc_setup: RSA key has MD5 sum: %s\\n\", rsa_md5_sum(rsabuf)); \n\tfprintf(stderr, \"securevnc_setup:\\n\"); \n\tfprintf(stderr, \"securevnc_setup: One way to print out the SecureVNC Server key MD5 sum is:\\n\\n\"); \n\tfprintf(stderr, \"openssl rsa -inform DER -outform DER -pubout -in ./Server_SecureVNC.pkey | dd bs=1 skip=24 | md5sum\\n\\n\");\n\tif (securevnc_file == NULL) {\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: ULTRAVNC SERVER RSA KEY NOT VERIFIED.   **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: A MAN-IN-THE-MIDDLE ATTACK IS POSSIBLE. **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t} else {\n\t\tchar *q = strrchr(securevnc_file, 'C');\n\t\tint skip = 0;\n\t\tif (q) {\n\t\t\tif (!strcmp(q, \"ClientAuth.pkey\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tskip = 1;\n\t\t\t} else if (!strcmp(q, \"ClientAuth.pkey.rsa\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tq = strrchr(client_auth, '.');\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t}\n\t\tif (!skip) {\n\t\t\trc = securevnc_check_server_rsa(securevnc_file, rsabuf);\n\t\t}\n\t\tif (skip) {\n\t\t\t;\n\t\t} else if (rc == 0) {\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY_ERROR: SERVER RSA KEY DID NOT MATCH:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\texit(1);\n\t\t} else if (rc == -1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: User cancelled the save and hence the connection.\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\texit(1);\n\t\t} else if (rc == 1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY SUCCESS: server rsa key matches the contents of:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 1;\n\t\t} else if (rc == 2) {\n\t\t\tfprintf(stderr, \"securevnc_setup: Server rsa key stored in:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 2;\n\t\t}\n\t}\n\n\t/*\n\t * read in the server flags. Note that SecureVNCPlugin sends these\n\t * in little endian and not network order!!\n\t */\n\tread(server, (char *) &b1, 1);\n\tread(server, (char *) &b2, 1);\n\tread(server, (char *) &b3, 1);\n\tread(server, (char *) &b4, 1);\n\t\n\tserver_flags = 0;\n\tserver_flags |= ((unsigned int) b4) << 24;\n\tserver_flags |= ((unsigned int) b3) << 16;\n\tserver_flags |= ((unsigned int) b2) << 8;\n\tserver_flags |= ((unsigned int) b1) << 0;\n\tfprintf(stderr, \"securevnc_setup: server_flags: 0x%08x\\n\", server_flags);\n\n\t/* check for arc4 usage: */\n\tif (server_flags & 0x1) {\n\t\tfprintf(stderr, \"securevnc_setup: server uses AES cipher.\\n\");\n\t} else {\n\t\tfprintf(stderr, \"securevnc_setup: server uses ARC4 cipher.\\n\");\n\t\tsecurevnc_arc4 = 1;\n\t\tCipher = EVP_rc4();\n\t}\n\n\t/* check for client auth signature requirement: */\n\tif (server_flags & (sig << 24)) {\n\t\tfprintf(stderr, \"securevnc_setup: server requires Client Auth signature.\\n\");\n\t\tclient_auth_req = 1;\n\t\tif (!client_auth) {\n\t\t\tfprintf(stderr, \"securevnc_setup: However, NO *ClientAuth.pkey keyfile was supplied on our\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: command line.  Exiting.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t/*\n\t * The first packet 'RFB 003.006' is obscured with key\n\t * that is a sha1 hash of public key.  So make this tmp key now:\n \t *\n\t */\n\tinitkey = (unsigned char *) calloc(SECUREVNC_KEY_SIZE, 1);\n\tEVP_BytesToKey(EVP_rc4(), EVP_sha1(), NULL, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE, 1, initkey, NULL);\n\n\t/* expand the transported rsabuf into an rsa object */\n\trsa = d2i_RSAPublicKey(NULL, (const unsigned char **) &rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tif (rsa == NULL) {\n\t\tsslexit(\"securevnc_setup: failed to create rsa\");\n\t}\n\n\t/*\n\t * Back to the work involving the tmp obscuring key:\n\t */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tinit_ctx = EVP_CIPHER_CTX_new();\n#else\n\n\tEVP_CIPHER_CTX init_ctx_obj;\n\tinit_ctx = &init_ctx_obj;\n#endif\n\tEVP_CIPHER_CTX_init(init_ctx);\n\trc = EVP_CipherInit_ex(init_ctx, EVP_rc4(), NULL, initkey, NULL, 1);\n\tif (rc == 0) {\n\t\tsslexit(\"securevnc_setup: EVP_CipherInit_ex(init_ctx) failed\");\n\t}\n\n\t/* for the first obscured packet, read what we can... */\n\tn = read(server, (char *) buf, BSIZE);\n\tfprintf(stderr, \"securevnc_setup: data read: %d\\n\", n);\n\tif (n < 0) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: initial data[%d]: \", n);\n\t\n\t/* decode with the tmp key */\n\tif (n > 0) {\n\t\tmemset(to_viewer, 0, sizeof(to_viewer));\n\t\tif (EVP_CipherUpdate(init_ctx, to_viewer, &len, buf, n) == 0) {\n\t\t\tsslexit(\"securevnc_setup: EVP_CipherUpdate(init_ctx) failed\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\t\texit(1);\n\t\t}\n\t\tto_viewer_len = len;\n\t}\n\tEVP_CIPHER_CTX_cleanup(init_ctx);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\tfree(initkey);\n\n\t/* print what we would send to the viewer (sent below): */\n\twrite(2, to_viewer, 12);\t/* and first 12 bytes 'RFB ...' as message */\n\n\t/* now create the random session key: */\n\tencrypted_keybuf = (unsigned char*) calloc(RSA_size(rsa), 1);\n\n\tfprintf(stderr, \"securevnc_setup: creating random session key: %d/%d\\n\",\n\t    SECUREVNC_KEY_SIZE, SECUREVNC_RAND_KEY_SOURCE);\n\tkeydata_len = SECUREVNC_RAND_KEY_SOURCE;\n\n\trc = RAND_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\tif (rc <= 0) {\n\t\tfprintf(stderr, \"securevnc_setup: RAND_bytes() failed: %s\\n\", ERR_error_string(ERR_get_error(), NULL));\n\t\trc = RAND_pseudo_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\t\tfprintf(stderr, \"securevnc_setup: RAND_pseudo_bytes() rc=%d\\n\", rc);\n\t\tif (getenv(\"RANDSTR\")) {\n\t\t\tchar *s = getenv(\"RANDSTR\"); \n\t\t\tfprintf(stderr, \"securevnc_setup: seeding with RANDSTR len=%d\\n\", strlen(s));\n\t\t\tRAND_add(s, strlen(s), strlen(s));\n\t\t}\n\t}\n\n\t/* N.B. this will be repeated in enc_xfer() setup. */\n\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata, keydata_len, 1, keystr, NULL);\n\n\t/* encrypt the session key with the server's public rsa key: */\n\tn = RSA_public_encrypt(SECUREVNC_KEY_SIZE, keystr, encrypted_keybuf, rsa, RSA_PKCS1_PADDING);\n\tif (n == -1) {\n\t\tsslexit(\"securevnc_setup: RSA_public_encrypt() failed\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: encrypted session key size: %d. sending to server.\\n\", n);\n\n\t/* send it to the server: */\n\twrite(server, encrypted_keybuf, n);\n\tfree(encrypted_keybuf);\n\n\t/*\n\t * Reply back with flags indicating cipher (same as one sent to\n\t * us) and we do not want client-side auth.\n\t *\n\t * We send it out on the wire in little endian order:\n\t */\n\tif (securevnc_arc4) {\n\t\twrite(server, (char *)&zero, 1);\n\t} else {\n\t\twrite(server, (char *)&one, 1);\n\t}\n\twrite(server, (char *)&zero, 1);\n\twrite(server, (char *)&zero, 1);\n\tif (client_auth_req) {\n\t\twrite(server, (char *)&sig, 1);\n\t} else {\n\t\twrite(server, (char *)&zero, 1);\n\t}\n\n\tif (client_auth_req && client_auth) {\n\t\tRSA *client_rsa = load_client_auth(client_auth);\n\t\tEVP_MD_CTX *dctx;\n\t\tunsigned char digest[EVP_MAX_MD_SIZE], *signature;\n\t\tunsigned int ndig = 0, nsig = 0;\n\n\t\tif (0) {\n\t\t\t/* for testing only, use the wrong RSA key: */\n\t\t\tclient_rsa = RSA_generate_key(2048, 0x10001, NULL, NULL);\n\t\t}\n\t\t\n\t\tif (client_rsa == NULL) {\n\t\t\tfprintf(stderr, \"securevnc_setup: problem reading rsa key from '%s'\\n\", client_auth);\n\t\t\texit(1);\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tdctx = EVP_MD_CTX_new();\n#else\n\t\tdctx = EVP_MD_CTX_create();\n#endif\n\t\tEVP_DigestInit(dctx, EVP_sha1());\n\t\tEVP_DigestUpdate(dctx, keystr, SECUREVNC_KEY_SIZE);\n\t\t/*\n\t\t * Without something like the following MITM is still possible.\n\t\t * This is because the MITM knows keystr and can use it with\n\t\t * the server connection as well, and then he just forwards our\n\t\t * signed digest.  The additional information below would be the\n\t\t * MITM's rsa public key, and so the real VNC server will notice\n\t\t * the difference.  And MITM can't sign keystr+server_rsa.pub since\n\t\t * he doesn't have Viewer_ClientAuth.pkey.\n\t\t */\n\t\tif (0) {\n\t\t\tEVP_DigestUpdate(dctx, rsasav, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: Warning: even *WITH* Client Authentication in SecureVNC,\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: an attacker may be able to trick you into connecting to his\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: fake VNC server and supplying VNC or Windows passwords, etc.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: THE FIRST VERSION OF THE SECUREVNC PROTOCOL IS\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: BEING USED.  *EVEN* WITH CLIENT AUTHENTICATION IT\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: IS SUSCEPTIBLE TO A MAN-IN-THE-MIDDLE ATTACK.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t}\n\t\tEVP_DigestFinal(dctx, (unsigned char *)digest, &ndig);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tEVP_MD_CTX_free(dctx);\n#else\n\t\tEVP_MD_CTX_destroy(dctx);\n#endif\n\n\t\tsignature = (unsigned char *) calloc(RSA_size(client_rsa), 1);\n\t\tRSA_sign(NID_sha1, digest, ndig, signature, &nsig, client_rsa);\n\n\t\tfprintf(stderr, \"securevnc_setup: sending ClientAuth.pkey signed data: %d\\n\", nsig);\n\t\twrite(server, signature, nsig);\n\t\tfree(signature);\n\n\t\tRSA_free(client_rsa);\n\t}\n\n\tfprintf(stderr, \"securevnc_setup: done.\\n\");\n\n\t/* now send the 'RFB ...' to the viewer */\n\tif (to_viewer_len > 0) {\n\t\twrite(viewer, to_viewer, to_viewer_len);\n\t}\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SECUREVNC_RAND_KEY_SOURCE 1024",
      "#define SECUREVNC_KEY_SIZE 16",
      "#define SECUREVNC_RSA_PUBKEY_SIZE 270",
      "#define BSIZE 8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "viewer",
            "to_viewer",
            "to_viewer_len"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: done.\\n\""
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_free",
          "args": [
            "client_rsa"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "signature"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: sending ClientAuth.pkey signed data: %d\\n\"",
            "nsig"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_sign",
          "args": [
            "NID_sha1",
            "digest",
            "ndig",
            "signature",
            "&nsig",
            "client_rsa"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "RSA_size(client_rsa)",
            "1"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_size",
          "args": [
            "client_rsa"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_destroy",
          "args": [
            "dctx"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_free",
          "args": [
            "dctx"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DigestFinal",
          "args": [
            "dctx",
            "(unsigned char *)digest",
            "&ndig"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: be used to verify the server in subsequent connections.\\n\""
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\""
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\""
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: WARNING: IS SUSCEPTIBLE TO A MAN-IN-THE-MIDDLE ATTACK.\\n\""
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: WARNING: BEING USED.  *EVEN* WITH CLIENT AUTHENTICATION IT\\n\""
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: WARNING: THE FIRST VERSION OF THE SECUREVNC PROTOCOL IS\\n\""
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: be used to verify the server in subsequent connections.\\n\""
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\""
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\""
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: fake VNC server and supplying VNC or Windows passwords, etc.\\n\""
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: an attacker may be able to trick you into connecting to his\\n\""
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: Warning: even *WITH* Client Authentication in SecureVNC,\\n\""
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DigestUpdate",
          "args": [
            "dctx",
            "rsasav",
            "SECUREVNC_RSA_PUBKEY_SIZE"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DigestUpdate",
          "args": [
            "dctx",
            "keystr",
            "SECUREVNC_KEY_SIZE"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DigestInit",
          "args": [
            "dctx",
            "EVP_sha1()"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha1",
          "args": [],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_create",
          "args": [],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_new",
          "args": [],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: problem reading rsa key from '%s'\\n\"",
            "client_auth"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_generate_key",
          "args": [
            "2048",
            "0x10001",
            "NULL",
            "NULL"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_client_auth",
          "args": [
            "client_auth"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "load_client_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1204-1245",
          "snippet": "static RSA *load_client_auth(char *file) {\n\tstruct stat sb;\n\tint fd, n;\n\tchar *contents;\n\tRSA *rsa;\n\n\tif (!file) {\n\t\treturn NULL;\n\t}\n\tif (stat(file, &sb) != 0) {\n\t\treturn NULL;\n\t}\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"load_client_auth: could not open: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tcontents = (char *) malloc(sb.st_size);\n\tn = (int) read(fd, contents, sb.st_size);\n\tclose(fd);\n\n\tif (n != sb.st_size)  {\n\t\tfprintf(stderr, \"load_client_auth: could not read all of: '%s'\\n\", file);\n\t\tfree(contents);\n\t\treturn NULL;\n\t}\n\n\trsa = d2i_RSAPrivateKey(NULL, (const unsigned char **) ((void *) &contents), sb.st_size);\n\tif (!rsa) {\n\t\tfprintf(stderr, \"load_client_auth: d2i_RSAPrivateKey failed for: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tif (RSA_check_key(rsa) != 1) {\n\t\tfprintf(stderr, \"load_client_auth: rsa key invalid: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\treturn rsa;\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic RSA *load_client_auth(char *file) {\n\tstruct stat sb;\n\tint fd, n;\n\tchar *contents;\n\tRSA *rsa;\n\n\tif (!file) {\n\t\treturn NULL;\n\t}\n\tif (stat(file, &sb) != 0) {\n\t\treturn NULL;\n\t}\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"load_client_auth: could not open: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tcontents = (char *) malloc(sb.st_size);\n\tn = (int) read(fd, contents, sb.st_size);\n\tclose(fd);\n\n\tif (n != sb.st_size)  {\n\t\tfprintf(stderr, \"load_client_auth: could not read all of: '%s'\\n\", file);\n\t\tfree(contents);\n\t\treturn NULL;\n\t}\n\n\trsa = d2i_RSAPrivateKey(NULL, (const unsigned char **) ((void *) &contents), sb.st_size);\n\tif (!rsa) {\n\t\tfprintf(stderr, \"load_client_auth: d2i_RSAPrivateKey failed for: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tif (RSA_check_key(rsa) != 1) {\n\t\tfprintf(stderr, \"load_client_auth: rsa key invalid: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\treturn rsa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: encrypted session key size: %d. sending to server.\\n\"",
            "n"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_public_encrypt",
          "args": [
            "SECUREVNC_KEY_SIZE",
            "keystr",
            "encrypted_keybuf",
            "rsa",
            "RSA_PKCS1_PADDING"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "Cipher",
            "Digest",
            "NULL",
            "(unsigned char *) keydata",
            "keydata_len",
            "1",
            "keystr",
            "NULL"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_add",
          "args": [
            "s",
            "strlen(s)",
            "strlen(s)"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: seeding with RANDSTR len=%d\\n\"",
            "strlen(s)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RANDSTR\""
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RANDSTR\""
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: RAND_pseudo_bytes() rc=%d\\n\"",
            "rc"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_pseudo_bytes",
          "args": [
            "(unsigned char *)keydata",
            "SECUREVNC_RAND_KEY_SOURCE"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: RAND_bytes() failed: %s\\n\"",
            "ERR_error_string(ERR_get_error(), NULL)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_error_string",
          "args": [
            "ERR_get_error()",
            "NULL"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "(unsigned char *)keydata",
            "SECUREVNC_RAND_KEY_SOURCE"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: creating random session key: %d/%d\\n\"",
            "SECUREVNC_KEY_SIZE",
            "SECUREVNC_RAND_KEY_SOURCE"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "RSA_size(rsa)",
            "1"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_size",
          "args": [
            "rsa"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_free",
          "args": [
            "init_ctx"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_cleanup",
          "args": [
            "init_ctx"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_free",
          "args": [
            "init_ctx"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CipherUpdate",
          "args": [
            "init_ctx",
            "to_viewer",
            "&len",
            "buf",
            "n"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "to_viewer",
            "0",
            "sizeof(to_viewer)"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: initial data[%d]: \"",
            "n"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_free",
          "args": [
            "init_ctx"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: data read: %d\\n\"",
            "n"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "server",
            "(char *) buf",
            "BSIZE"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CipherInit_ex",
          "args": [
            "init_ctx",
            "EVP_rc4()",
            "NULL",
            "initkey",
            "NULL",
            "1"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_init",
          "args": [
            "init_ctx"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_new",
          "args": [],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d2i_RSAPublicKey",
          "args": [
            "NULL",
            "(const unsigned char **) &rsabuf",
            "SECUREVNC_RSA_PUBKEY_SIZE"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "EVP_rc4()",
            "EVP_sha1()",
            "NULL",
            "rsabuf",
            "SECUREVNC_RSA_PUBKEY_SIZE",
            "1",
            "initkey",
            "NULL"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha1",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "SECUREVNC_KEY_SIZE",
            "1"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: command line.  Exiting.\\n\""
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: However, NO *ClientAuth.pkey keyfile was supplied on our\\n\""
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: server requires Client Auth signature.\\n\""
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: server uses ARC4 cipher.\\n\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: server uses AES cipher.\\n\""
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: server_flags: 0x%08x\\n\"",
            "server_flags"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:     %s\\n\"",
            "securevnc_file"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: Server rsa key stored in:\\n\""
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:     %s\\n\"",
            "securevnc_file"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: VERIFY SUCCESS: server rsa key matches the contents of:\\n\""
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:     %s\\n\"",
            "securevnc_file"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: User cancelled the save and hence the connection.\\n\""
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:     %s\\n\"",
            "securevnc_file"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: VERIFY_ERROR: SERVER RSA KEY DID NOT MATCH:\\n\""
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securevnc_check_server_rsa",
          "args": [
            "securevnc_file",
            "rsabuf"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "securevnc_check_server_rsa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1148-1202",
          "snippet": "static int securevnc_check_server_rsa(char *file, unsigned char *rsabuf) {\n\tstruct stat sb;\n\tunsigned char filebuf[SECUREVNC_RSA_PUBKEY_SIZE];\n\tchar *md5str = rsa_md5_sum(rsabuf);\n\n\tif (!file) {\n\t\treturn 0;\n\t}\n\n\tmemset(filebuf, 0, sizeof(filebuf));\n\tif (stat(file, &sb) == 0) {\n\t\tint n, fd, i, ok = 1;\n\n\t\tif (sb.st_size != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: file is wrong size: %d != %d '%s'\\n\",\n\t\t\t    (int) sb.st_size, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfd = open(file, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open: '%s'\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = (int) read(fd, filebuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tclose(fd);\n\t\tif (n != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not read all of file: %d != %d '%s'\\n\",\n\t\t\t    n, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i=0; i < SECUREVNC_RSA_PUBKEY_SIZE; i++) {\n\t\t\tif (filebuf[i] != rsabuf[i]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tchar *str1 = rsa_md5_sum(rsabuf);\n\t\t\tchar *str2 = rsa_md5_sum(filebuf);\n\t\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore contents differ for '%s'\\n\", file);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of server key: %s\\n\", str1);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of keystore:   %s\\n\", str2);\n\t\t}\n\t\treturn ok;\n\t} else {\n\n\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore file does not exist: '%s'\\n\", file);\n\t\tfprintf(stderr, \"checkserver_rsa: asking user if we should store rsa key in it.\\n\\n\");\n\t\tfprintf(stderr, \"checkserver_rsa: RSA key has MD5 sum: %s\\n\\n\", md5str); \n\n\t\treturn securevnc_server_rsa_save_dialog(file, md5str, rsabuf);\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SECUREVNC_RSA_PUBKEY_SIZE 270"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n\nstatic int securevnc_check_server_rsa(char *file, unsigned char *rsabuf) {\n\tstruct stat sb;\n\tunsigned char filebuf[SECUREVNC_RSA_PUBKEY_SIZE];\n\tchar *md5str = rsa_md5_sum(rsabuf);\n\n\tif (!file) {\n\t\treturn 0;\n\t}\n\n\tmemset(filebuf, 0, sizeof(filebuf));\n\tif (stat(file, &sb) == 0) {\n\t\tint n, fd, i, ok = 1;\n\n\t\tif (sb.st_size != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: file is wrong size: %d != %d '%s'\\n\",\n\t\t\t    (int) sb.st_size, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfd = open(file, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open: '%s'\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = (int) read(fd, filebuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tclose(fd);\n\t\tif (n != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not read all of file: %d != %d '%s'\\n\",\n\t\t\t    n, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i=0; i < SECUREVNC_RSA_PUBKEY_SIZE; i++) {\n\t\t\tif (filebuf[i] != rsabuf[i]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tchar *str1 = rsa_md5_sum(rsabuf);\n\t\t\tchar *str2 = rsa_md5_sum(filebuf);\n\t\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore contents differ for '%s'\\n\", file);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of server key: %s\\n\", str1);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of keystore:   %s\\n\", str2);\n\t\t}\n\t\treturn ok;\n\t} else {\n\n\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore file does not exist: '%s'\\n\", file);\n\t\tfprintf(stderr, \"checkserver_rsa: asking user if we should store rsa key in it.\\n\\n\");\n\t\tfprintf(stderr, \"checkserver_rsa: RSA key has MD5 sum: %s\\n\\n\", md5str); \n\n\t\treturn securevnc_server_rsa_save_dialog(file, md5str, rsabuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "client_auth",
            "'.'"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "securevnc_file"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q",
            "\"ClientAuth.pkey.rsa\""
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "securevnc_file"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "q",
            "\"ClientAuth.pkey\""
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "securevnc_file",
            "'C'"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: ** WARNING: A MAN-IN-THE-MIDDLE ATTACK IS POSSIBLE. **\\n\""
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: ** WARNING: ULTRAVNC SERVER RSA KEY NOT VERIFIED.   **\\n\""
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"openssl rsa -inform DER -outform DER -pubout -in ./Server_SecureVNC.pkey | dd bs=1 skip=24 | md5sum\\n\\n\""
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: One way to print out the SecureVNC Server key MD5 sum is:\\n\\n\""
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup:\\n\""
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: RSA key has MD5 sum: %s\\n\"",
            "rsa_md5_sum(rsabuf)"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_md5_sum",
          "args": [
            "rsabuf"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_md5_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1119-1146",
          "snippet": "static char *rsa_md5_sum(unsigned char* rsabuf) {\n\tEVP_MD_CTX *md;\n\tchar digest[EVP_MAX_MD_SIZE], tmp[16];\n\tchar md5str[EVP_MAX_MD_SIZE * 8];\n\tunsigned int i, size = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmd = EVP_MD_CTX_new();\n#else\n\tmd = EVP_MD_CTX_create();\n#endif\n\tEVP_DigestInit(md, EVP_md5());\n\tEVP_DigestUpdate(md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tEVP_DigestFinal(md, (unsigned char *)digest, &size);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_MD_CTX_free(md);\n#else\n\tEVP_MD_CTX_destroy(md);\n#endif\n\n\tmemset(md5str, 0, sizeof(md5str));\n\tfor (i=0; i < size; i++) {\n\t\tunsigned char uc = (unsigned char) digest[i];\n\t\tsprintf(tmp, \"%02x\", (int) uc);\n\t\tstrcat(md5str, tmp);\n\t}\n\treturn strdup(md5str);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SECUREVNC_RSA_PUBKEY_SIZE 270"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n\nstatic char *rsa_md5_sum(unsigned char* rsabuf) {\n\tEVP_MD_CTX *md;\n\tchar digest[EVP_MAX_MD_SIZE], tmp[16];\n\tchar md5str[EVP_MAX_MD_SIZE * 8];\n\tunsigned int i, size = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmd = EVP_MD_CTX_new();\n#else\n\tmd = EVP_MD_CTX_create();\n#endif\n\tEVP_DigestInit(md, EVP_md5());\n\tEVP_DigestUpdate(md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tEVP_DigestFinal(md, (unsigned char *)digest, &size);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_MD_CTX_free(md);\n#else\n\tEVP_MD_CTX_destroy(md);\n#endif\n\n\tmemset(md5str, 0, sizeof(md5str));\n\tfor (i=0; i < size; i++) {\n\t\tunsigned char uc = (unsigned char) digest[i];\n\t\tsprintf(tmp, \"%02x\", (int) uc);\n\t\tstrcat(md5str, tmp);\n\t}\n\treturn strdup(md5str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rsasav",
            "rsabuf",
            "SECUREVNC_RSA_PUBKEY_SIZE"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: rsa data read len: %d\\n\"",
            "len"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: fail final read rsabuf: n=%d len=%d\\n\"",
            "n",
            "len"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"securevnc_setup: fail read rsabuf: n=%d len=%d\\n\"",
            "n",
            "len"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "SECUREVNC_RSA_PUBKEY_SIZE",
            "1"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "SECUREVNC_RSA_PUBKEY_SIZE",
            "1"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_load_crypto_strings",
          "args": [],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RAND_KEY_SOURCE 1024\n#define SECUREVNC_KEY_SIZE 16\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n#define BSIZE 8192\n\nstatic void securevnc_setup(int conn1, int conn2) {\n\tRSA *rsa = NULL;\n\tEVP_CIPHER_CTX *init_ctx;\n\tunsigned char keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char *rsabuf, *rsasav;\n\tunsigned char *encrypted_keybuf;\n\tunsigned char *initkey;\t\n\tunsigned int server_flags = 0;\n\tunsigned char one = 1, zero = 0, sig = 16;\n\tunsigned char b1, b2, b3, b4;\n\tunsigned char buf[BSIZE], to_viewer[BSIZE];\n\tint to_viewer_len = 0;\n\tint n = 0, len, rc;\n\tint server = reverse ? conn1 : conn2;\n\tint viewer = reverse ? conn2 : conn1;\n\tchar *client_auth = NULL;\n\tint client_auth_req = 0;\n\tint keystore_verified = 0;\n\n\tERR_load_crypto_strings();\n\n\t/* alloc and read from server the 270 comprising the rsa public key: */\n\trsabuf = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\trsasav = (unsigned char *) calloc(SECUREVNC_RSA_PUBKEY_SIZE, 1);\n\tlen = 0;\n\twhile (len < SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tn = read(server, rsabuf + len, SECUREVNC_RSA_PUBKEY_SIZE - len);\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\tfprintf(stderr, \"securevnc_setup: fail read rsabuf: n=%d len=%d\\n\", n, len);\n\t\t\texit(1);\n\t\t}\n\t\tlen += n;\n\t}\n\tif (len != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\tfprintf(stderr, \"securevnc_setup: fail final read rsabuf: n=%d len=%d\\n\", n, len);\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: rsa data read len: %d\\n\", len);\n\tmemcpy(rsasav, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\n\tfprintf(stderr, \"securevnc_setup: RSA key has MD5 sum: %s\\n\", rsa_md5_sum(rsabuf)); \n\tfprintf(stderr, \"securevnc_setup:\\n\"); \n\tfprintf(stderr, \"securevnc_setup: One way to print out the SecureVNC Server key MD5 sum is:\\n\\n\"); \n\tfprintf(stderr, \"openssl rsa -inform DER -outform DER -pubout -in ./Server_SecureVNC.pkey | dd bs=1 skip=24 | md5sum\\n\\n\");\n\tif (securevnc_file == NULL) {\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: ULTRAVNC SERVER RSA KEY NOT VERIFIED.   **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup: ** WARNING: A MAN-IN-THE-MIDDLE ATTACK IS POSSIBLE. **\\n\");\n\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t} else {\n\t\tchar *q = strrchr(securevnc_file, 'C');\n\t\tint skip = 0;\n\t\tif (q) {\n\t\t\tif (!strcmp(q, \"ClientAuth.pkey\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tskip = 1;\n\t\t\t} else if (!strcmp(q, \"ClientAuth.pkey.rsa\")) {\n\t\t\t\tclient_auth = strdup(securevnc_file);\n\t\t\t\tq = strrchr(client_auth, '.');\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t}\n\t\tif (!skip) {\n\t\t\trc = securevnc_check_server_rsa(securevnc_file, rsabuf);\n\t\t}\n\t\tif (skip) {\n\t\t\t;\n\t\t} else if (rc == 0) {\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY_ERROR: SERVER RSA KEY DID NOT MATCH:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\texit(1);\n\t\t} else if (rc == -1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: User cancelled the save and hence the connection.\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\texit(1);\n\t\t} else if (rc == 1) {\n\t\t\tfprintf(stderr, \"securevnc_setup: VERIFY SUCCESS: server rsa key matches the contents of:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 1;\n\t\t} else if (rc == 2) {\n\t\t\tfprintf(stderr, \"securevnc_setup: Server rsa key stored in:\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup:     %s\\n\", securevnc_file);\n\t\t\tkeystore_verified = 2;\n\t\t}\n\t}\n\n\t/*\n\t * read in the server flags. Note that SecureVNCPlugin sends these\n\t * in little endian and not network order!!\n\t */\n\tread(server, (char *) &b1, 1);\n\tread(server, (char *) &b2, 1);\n\tread(server, (char *) &b3, 1);\n\tread(server, (char *) &b4, 1);\n\t\n\tserver_flags = 0;\n\tserver_flags |= ((unsigned int) b4) << 24;\n\tserver_flags |= ((unsigned int) b3) << 16;\n\tserver_flags |= ((unsigned int) b2) << 8;\n\tserver_flags |= ((unsigned int) b1) << 0;\n\tfprintf(stderr, \"securevnc_setup: server_flags: 0x%08x\\n\", server_flags);\n\n\t/* check for arc4 usage: */\n\tif (server_flags & 0x1) {\n\t\tfprintf(stderr, \"securevnc_setup: server uses AES cipher.\\n\");\n\t} else {\n\t\tfprintf(stderr, \"securevnc_setup: server uses ARC4 cipher.\\n\");\n\t\tsecurevnc_arc4 = 1;\n\t\tCipher = EVP_rc4();\n\t}\n\n\t/* check for client auth signature requirement: */\n\tif (server_flags & (sig << 24)) {\n\t\tfprintf(stderr, \"securevnc_setup: server requires Client Auth signature.\\n\");\n\t\tclient_auth_req = 1;\n\t\tif (!client_auth) {\n\t\t\tfprintf(stderr, \"securevnc_setup: However, NO *ClientAuth.pkey keyfile was supplied on our\\n\");\n\t\t\tfprintf(stderr, \"securevnc_setup: command line.  Exiting.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t/*\n\t * The first packet 'RFB 003.006' is obscured with key\n\t * that is a sha1 hash of public key.  So make this tmp key now:\n \t *\n\t */\n\tinitkey = (unsigned char *) calloc(SECUREVNC_KEY_SIZE, 1);\n\tEVP_BytesToKey(EVP_rc4(), EVP_sha1(), NULL, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE, 1, initkey, NULL);\n\n\t/* expand the transported rsabuf into an rsa object */\n\trsa = d2i_RSAPublicKey(NULL, (const unsigned char **) &rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tif (rsa == NULL) {\n\t\tsslexit(\"securevnc_setup: failed to create rsa\");\n\t}\n\n\t/*\n\t * Back to the work involving the tmp obscuring key:\n\t */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tinit_ctx = EVP_CIPHER_CTX_new();\n#else\n\n\tEVP_CIPHER_CTX init_ctx_obj;\n\tinit_ctx = &init_ctx_obj;\n#endif\n\tEVP_CIPHER_CTX_init(init_ctx);\n\trc = EVP_CipherInit_ex(init_ctx, EVP_rc4(), NULL, initkey, NULL, 1);\n\tif (rc == 0) {\n\t\tsslexit(\"securevnc_setup: EVP_CipherInit_ex(init_ctx) failed\");\n\t}\n\n\t/* for the first obscured packet, read what we can... */\n\tn = read(server, (char *) buf, BSIZE);\n\tfprintf(stderr, \"securevnc_setup: data read: %d\\n\", n);\n\tif (n < 0) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: initial data[%d]: \", n);\n\t\n\t/* decode with the tmp key */\n\tif (n > 0) {\n\t\tmemset(to_viewer, 0, sizeof(to_viewer));\n\t\tif (EVP_CipherUpdate(init_ctx, to_viewer, &len, buf, n) == 0) {\n\t\t\tsslexit(\"securevnc_setup: EVP_CipherUpdate(init_ctx) failed\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\t\t\texit(1);\n\t\t}\n\t\tto_viewer_len = len;\n\t}\n\tEVP_CIPHER_CTX_cleanup(init_ctx);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(init_ctx);\n#endif\n\tfree(initkey);\n\n\t/* print what we would send to the viewer (sent below): */\n\twrite(2, to_viewer, 12);\t/* and first 12 bytes 'RFB ...' as message */\n\n\t/* now create the random session key: */\n\tencrypted_keybuf = (unsigned char*) calloc(RSA_size(rsa), 1);\n\n\tfprintf(stderr, \"securevnc_setup: creating random session key: %d/%d\\n\",\n\t    SECUREVNC_KEY_SIZE, SECUREVNC_RAND_KEY_SOURCE);\n\tkeydata_len = SECUREVNC_RAND_KEY_SOURCE;\n\n\trc = RAND_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\tif (rc <= 0) {\n\t\tfprintf(stderr, \"securevnc_setup: RAND_bytes() failed: %s\\n\", ERR_error_string(ERR_get_error(), NULL));\n\t\trc = RAND_pseudo_bytes((unsigned char *)keydata, SECUREVNC_RAND_KEY_SOURCE);\n\t\tfprintf(stderr, \"securevnc_setup: RAND_pseudo_bytes() rc=%d\\n\", rc);\n\t\tif (getenv(\"RANDSTR\")) {\n\t\t\tchar *s = getenv(\"RANDSTR\"); \n\t\t\tfprintf(stderr, \"securevnc_setup: seeding with RANDSTR len=%d\\n\", strlen(s));\n\t\t\tRAND_add(s, strlen(s), strlen(s));\n\t\t}\n\t}\n\n\t/* N.B. this will be repeated in enc_xfer() setup. */\n\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata, keydata_len, 1, keystr, NULL);\n\n\t/* encrypt the session key with the server's public rsa key: */\n\tn = RSA_public_encrypt(SECUREVNC_KEY_SIZE, keystr, encrypted_keybuf, rsa, RSA_PKCS1_PADDING);\n\tif (n == -1) {\n\t\tsslexit(\"securevnc_setup: RSA_public_encrypt() failed\");\n\t\texit(1);\n\t}\n\tfprintf(stderr, \"securevnc_setup: encrypted session key size: %d. sending to server.\\n\", n);\n\n\t/* send it to the server: */\n\twrite(server, encrypted_keybuf, n);\n\tfree(encrypted_keybuf);\n\n\t/*\n\t * Reply back with flags indicating cipher (same as one sent to\n\t * us) and we do not want client-side auth.\n\t *\n\t * We send it out on the wire in little endian order:\n\t */\n\tif (securevnc_arc4) {\n\t\twrite(server, (char *)&zero, 1);\n\t} else {\n\t\twrite(server, (char *)&one, 1);\n\t}\n\twrite(server, (char *)&zero, 1);\n\twrite(server, (char *)&zero, 1);\n\tif (client_auth_req) {\n\t\twrite(server, (char *)&sig, 1);\n\t} else {\n\t\twrite(server, (char *)&zero, 1);\n\t}\n\n\tif (client_auth_req && client_auth) {\n\t\tRSA *client_rsa = load_client_auth(client_auth);\n\t\tEVP_MD_CTX *dctx;\n\t\tunsigned char digest[EVP_MAX_MD_SIZE], *signature;\n\t\tunsigned int ndig = 0, nsig = 0;\n\n\t\tif (0) {\n\t\t\t/* for testing only, use the wrong RSA key: */\n\t\t\tclient_rsa = RSA_generate_key(2048, 0x10001, NULL, NULL);\n\t\t}\n\t\t\n\t\tif (client_rsa == NULL) {\n\t\t\tfprintf(stderr, \"securevnc_setup: problem reading rsa key from '%s'\\n\", client_auth);\n\t\t\texit(1);\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tdctx = EVP_MD_CTX_new();\n#else\n\t\tdctx = EVP_MD_CTX_create();\n#endif\n\t\tEVP_DigestInit(dctx, EVP_sha1());\n\t\tEVP_DigestUpdate(dctx, keystr, SECUREVNC_KEY_SIZE);\n\t\t/*\n\t\t * Without something like the following MITM is still possible.\n\t\t * This is because the MITM knows keystr and can use it with\n\t\t * the server connection as well, and then he just forwards our\n\t\t * signed digest.  The additional information below would be the\n\t\t * MITM's rsa public key, and so the real VNC server will notice\n\t\t * the difference.  And MITM can't sign keystr+server_rsa.pub since\n\t\t * he doesn't have Viewer_ClientAuth.pkey.\n\t\t */\n\t\tif (0) {\n\t\t\tEVP_DigestUpdate(dctx, rsasav, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: Warning: even *WITH* Client Authentication in SecureVNC,\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: an attacker may be able to trick you into connecting to his\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: fake VNC server and supplying VNC or Windows passwords, etc.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (!keystore_verified) {\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: THE FIRST VERSION OF THE SECUREVNC PROTOCOL IS\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: BEING USED.  *EVEN* WITH CLIENT AUTHENTICATION IT\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: WARNING: IS SUSCEPTIBLE TO A MAN-IN-THE-MIDDLE ATTACK.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: To increase security manually verify the Server RSA key's MD5\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: checksum and then have SSVNC save the key in its keystore to\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup: be used to verify the server in subsequent connections.\\n\");\n\t\t\t\tfprintf(stderr, \"securevnc_setup:\\n\");\n\t\t\t}\n\t\t}\n\t\tEVP_DigestFinal(dctx, (unsigned char *)digest, &ndig);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tEVP_MD_CTX_free(dctx);\n#else\n\t\tEVP_MD_CTX_destroy(dctx);\n#endif\n\n\t\tsignature = (unsigned char *) calloc(RSA_size(client_rsa), 1);\n\t\tRSA_sign(NID_sha1, digest, ndig, signature, &nsig, client_rsa);\n\n\t\tfprintf(stderr, \"securevnc_setup: sending ClientAuth.pkey signed data: %d\\n\", nsig);\n\t\twrite(server, signature, nsig);\n\t\tfree(signature);\n\n\t\tRSA_free(client_rsa);\n\t}\n\n\tfprintf(stderr, \"securevnc_setup: done.\\n\");\n\n\t/* now send the 'RFB ...' to the viewer */\n\tif (to_viewer_len > 0) {\n\t\twrite(viewer, to_viewer, to_viewer_len);\n\t}\n}"
  },
  {
    "function_name": "sslexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1247-1250",
    "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s\\n\"",
            "msg",
            "ERR_error_string(ERR_get_error(), NULL)"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_error_string",
          "args": [
            "ERR_get_error()",
            "NULL"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
  },
  {
    "function_name": "load_client_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1204-1245",
    "snippet": "static RSA *load_client_auth(char *file) {\n\tstruct stat sb;\n\tint fd, n;\n\tchar *contents;\n\tRSA *rsa;\n\n\tif (!file) {\n\t\treturn NULL;\n\t}\n\tif (stat(file, &sb) != 0) {\n\t\treturn NULL;\n\t}\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"load_client_auth: could not open: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tcontents = (char *) malloc(sb.st_size);\n\tn = (int) read(fd, contents, sb.st_size);\n\tclose(fd);\n\n\tif (n != sb.st_size)  {\n\t\tfprintf(stderr, \"load_client_auth: could not read all of: '%s'\\n\", file);\n\t\tfree(contents);\n\t\treturn NULL;\n\t}\n\n\trsa = d2i_RSAPrivateKey(NULL, (const unsigned char **) ((void *) &contents), sb.st_size);\n\tif (!rsa) {\n\t\tfprintf(stderr, \"load_client_auth: d2i_RSAPrivateKey failed for: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tif (RSA_check_key(rsa) != 1) {\n\t\tfprintf(stderr, \"load_client_auth: rsa key invalid: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\treturn rsa;\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"load_client_auth: rsa key invalid: '%s'\\n\"",
            "file"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_check_key",
          "args": [
            "rsa"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"load_client_auth: d2i_RSAPrivateKey failed for: '%s'\\n\"",
            "file"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d2i_RSAPrivateKey",
          "args": [
            "NULL",
            "(const unsigned char **) ((void *) &contents)",
            "sb.st_size"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "contents"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"load_client_auth: could not read all of: '%s'\\n\"",
            "file"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "contents",
            "sb.st_size"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sb.st_size"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"load_client_auth: could not open: '%s'\\n\"",
            "file"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file",
            "O_RDONLY"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file",
            "&sb"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic RSA *load_client_auth(char *file) {\n\tstruct stat sb;\n\tint fd, n;\n\tchar *contents;\n\tRSA *rsa;\n\n\tif (!file) {\n\t\treturn NULL;\n\t}\n\tif (stat(file, &sb) != 0) {\n\t\treturn NULL;\n\t}\n\n\tfd = open(file, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"load_client_auth: could not open: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tcontents = (char *) malloc(sb.st_size);\n\tn = (int) read(fd, contents, sb.st_size);\n\tclose(fd);\n\n\tif (n != sb.st_size)  {\n\t\tfprintf(stderr, \"load_client_auth: could not read all of: '%s'\\n\", file);\n\t\tfree(contents);\n\t\treturn NULL;\n\t}\n\n\trsa = d2i_RSAPrivateKey(NULL, (const unsigned char **) ((void *) &contents), sb.st_size);\n\tif (!rsa) {\n\t\tfprintf(stderr, \"load_client_auth: d2i_RSAPrivateKey failed for: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\tif (RSA_check_key(rsa) != 1) {\n\t\tfprintf(stderr, \"load_client_auth: rsa key invalid: '%s'\\n\", file);\n\t\treturn NULL;\n\t}\n\n\treturn rsa;\n}"
  },
  {
    "function_name": "securevnc_check_server_rsa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1148-1202",
    "snippet": "static int securevnc_check_server_rsa(char *file, unsigned char *rsabuf) {\n\tstruct stat sb;\n\tunsigned char filebuf[SECUREVNC_RSA_PUBKEY_SIZE];\n\tchar *md5str = rsa_md5_sum(rsabuf);\n\n\tif (!file) {\n\t\treturn 0;\n\t}\n\n\tmemset(filebuf, 0, sizeof(filebuf));\n\tif (stat(file, &sb) == 0) {\n\t\tint n, fd, i, ok = 1;\n\n\t\tif (sb.st_size != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: file is wrong size: %d != %d '%s'\\n\",\n\t\t\t    (int) sb.st_size, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfd = open(file, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open: '%s'\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = (int) read(fd, filebuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tclose(fd);\n\t\tif (n != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not read all of file: %d != %d '%s'\\n\",\n\t\t\t    n, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i=0; i < SECUREVNC_RSA_PUBKEY_SIZE; i++) {\n\t\t\tif (filebuf[i] != rsabuf[i]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tchar *str1 = rsa_md5_sum(rsabuf);\n\t\t\tchar *str2 = rsa_md5_sum(filebuf);\n\t\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore contents differ for '%s'\\n\", file);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of server key: %s\\n\", str1);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of keystore:   %s\\n\", str2);\n\t\t}\n\t\treturn ok;\n\t} else {\n\n\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore file does not exist: '%s'\\n\", file);\n\t\tfprintf(stderr, \"checkserver_rsa: asking user if we should store rsa key in it.\\n\\n\");\n\t\tfprintf(stderr, \"checkserver_rsa: RSA key has MD5 sum: %s\\n\\n\", md5str); \n\n\t\treturn securevnc_server_rsa_save_dialog(file, md5str, rsabuf);\n\t}\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SECUREVNC_RSA_PUBKEY_SIZE 270"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "securevnc_server_rsa_save_dialog",
          "args": [
            "file",
            "md5str",
            "rsabuf"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "securevnc_server_rsa_save_dialog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1067-1117",
          "snippet": "static int securevnc_server_rsa_save_dialog(char *file, char *md5str, unsigned char* rsabuf) {\n\t/* since we are likely running in the background, use this kludge by running tk */\n\tFILE *p;\n\tchar str[2], *q = file, *cmd = getenv(\"WISH\") ? getenv(\"WISH\") : \"wish\";\n\tint rc;\n\n\tmemset(str, 0, sizeof(str));\n\n\tp = popen(cmd, \"w\");\n\tif (p == NULL) {\n\t\tfprintf(stderr, \"checkserver_rsa: could not run: %s\\n\", cmd); \n\t\treturn 0;\n\t}\n\n\t/* start piping tk/tcl code to it: */\n\tfprintf(p, \"wm withdraw .\\n\");\n\tfprintf(p, \"set x [expr [winfo screenwidth  .]/2]\\n\");\n\tfprintf(p, \"set y [expr [winfo screenheight .]/2]\\n\");\n\tfprintf(p, \"wm geometry . +$x+$y; update\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.font {helvetica -14 bold}}\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.wrapLength 6i}\\n\");\n\tfprintf(p, \"set ans [tk_messageBox -title \\\"Save and Trust UltraVNC RSA Key?\\\" -icon question \");\n\tfprintf(p, \"-type yesno -message \\\"Save and Trust UltraVNC SecureVNCPlugin RSA Key\\\\n\\\\n\");\n\tfprintf(p, \"With MD5 sum: %s\\\\n\\\\n\", md5str);\n\tfprintf(p, \"In file: \");\n\twhile (*q != '\\0') {\n\t\t/* sanitize user supplied string: */\n\t\tstr[0] = *q;\n\t\tif (strpbrk(str, \"[](){}`'\\\"$&*|<>\") == NULL) {\n\t\t\tfprintf(p, \"%s\", str);\n\t\t}\n\t\tq++;\n\t}\n\tfprintf(p, \" ?\\\"]\\n\");\n\tfprintf(p, \"if { $ans == \\\"yes\\\" } {destroy .; exit 0} else {destroy .; exit 1}\\n\");\n\trc = pclose(p);\n\tif (rc == 0) {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  saving it.\\n\", rc);\n\t\tp = fopen(file, \"w\");\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open %s\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\t\twrite(fileno(p), rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tfclose(p);\n\t\treturn 2;\n\t} else {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  NOT saving it.\\n\", rc);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SECUREVNC_RSA_PUBKEY_SIZE 270"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n\nstatic int securevnc_server_rsa_save_dialog(char *file, char *md5str, unsigned char* rsabuf) {\n\t/* since we are likely running in the background, use this kludge by running tk */\n\tFILE *p;\n\tchar str[2], *q = file, *cmd = getenv(\"WISH\") ? getenv(\"WISH\") : \"wish\";\n\tint rc;\n\n\tmemset(str, 0, sizeof(str));\n\n\tp = popen(cmd, \"w\");\n\tif (p == NULL) {\n\t\tfprintf(stderr, \"checkserver_rsa: could not run: %s\\n\", cmd); \n\t\treturn 0;\n\t}\n\n\t/* start piping tk/tcl code to it: */\n\tfprintf(p, \"wm withdraw .\\n\");\n\tfprintf(p, \"set x [expr [winfo screenwidth  .]/2]\\n\");\n\tfprintf(p, \"set y [expr [winfo screenheight .]/2]\\n\");\n\tfprintf(p, \"wm geometry . +$x+$y; update\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.font {helvetica -14 bold}}\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.wrapLength 6i}\\n\");\n\tfprintf(p, \"set ans [tk_messageBox -title \\\"Save and Trust UltraVNC RSA Key?\\\" -icon question \");\n\tfprintf(p, \"-type yesno -message \\\"Save and Trust UltraVNC SecureVNCPlugin RSA Key\\\\n\\\\n\");\n\tfprintf(p, \"With MD5 sum: %s\\\\n\\\\n\", md5str);\n\tfprintf(p, \"In file: \");\n\twhile (*q != '\\0') {\n\t\t/* sanitize user supplied string: */\n\t\tstr[0] = *q;\n\t\tif (strpbrk(str, \"[](){}`'\\\"$&*|<>\") == NULL) {\n\t\t\tfprintf(p, \"%s\", str);\n\t\t}\n\t\tq++;\n\t}\n\tfprintf(p, \" ?\\\"]\\n\");\n\tfprintf(p, \"if { $ans == \\\"yes\\\" } {destroy .; exit 0} else {destroy .; exit 1}\\n\");\n\trc = pclose(p);\n\tif (rc == 0) {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  saving it.\\n\", rc);\n\t\tp = fopen(file, \"w\");\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open %s\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\t\twrite(fileno(p), rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tfclose(p);\n\t\treturn 2;\n\t} else {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  NOT saving it.\\n\", rc);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: RSA key has MD5 sum: %s\\n\\n\"",
            "md5str"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: asking user if we should store rsa key in it.\\n\\n\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: rsa keystore file does not exist: '%s'\\n\"",
            "file"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: MD5 sum of keystore:   %s\\n\"",
            "str2"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: MD5 sum of server key: %s\\n\"",
            "str1"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: rsa keystore contents differ for '%s'\\n\"",
            "file"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsa_md5_sum",
          "args": [
            "filebuf"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "rsa_md5_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1119-1146",
          "snippet": "static char *rsa_md5_sum(unsigned char* rsabuf) {\n\tEVP_MD_CTX *md;\n\tchar digest[EVP_MAX_MD_SIZE], tmp[16];\n\tchar md5str[EVP_MAX_MD_SIZE * 8];\n\tunsigned int i, size = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmd = EVP_MD_CTX_new();\n#else\n\tmd = EVP_MD_CTX_create();\n#endif\n\tEVP_DigestInit(md, EVP_md5());\n\tEVP_DigestUpdate(md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tEVP_DigestFinal(md, (unsigned char *)digest, &size);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_MD_CTX_free(md);\n#else\n\tEVP_MD_CTX_destroy(md);\n#endif\n\n\tmemset(md5str, 0, sizeof(md5str));\n\tfor (i=0; i < size; i++) {\n\t\tunsigned char uc = (unsigned char) digest[i];\n\t\tsprintf(tmp, \"%02x\", (int) uc);\n\t\tstrcat(md5str, tmp);\n\t}\n\treturn strdup(md5str);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SECUREVNC_RSA_PUBKEY_SIZE 270"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n\nstatic char *rsa_md5_sum(unsigned char* rsabuf) {\n\tEVP_MD_CTX *md;\n\tchar digest[EVP_MAX_MD_SIZE], tmp[16];\n\tchar md5str[EVP_MAX_MD_SIZE * 8];\n\tunsigned int i, size = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmd = EVP_MD_CTX_new();\n#else\n\tmd = EVP_MD_CTX_create();\n#endif\n\tEVP_DigestInit(md, EVP_md5());\n\tEVP_DigestUpdate(md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tEVP_DigestFinal(md, (unsigned char *)digest, &size);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_MD_CTX_free(md);\n#else\n\tEVP_MD_CTX_destroy(md);\n#endif\n\n\tmemset(md5str, 0, sizeof(md5str));\n\tfor (i=0; i < size; i++) {\n\t\tunsigned char uc = (unsigned char) digest[i];\n\t\tsprintf(tmp, \"%02x\", (int) uc);\n\t\tstrcat(md5str, tmp);\n\t}\n\treturn strdup(md5str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: could not read all of file: %d != %d '%s'\\n\"",
            "n",
            "SECUREVNC_RSA_PUBKEY_SIZE",
            "file"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "filebuf",
            "SECUREVNC_RSA_PUBKEY_SIZE"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: could not open: '%s'\\n\"",
            "file"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file",
            "O_RDONLY"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: file is wrong size: %d != %d '%s'\\n\"",
            "(int) sb.st_size",
            "SECUREVNC_RSA_PUBKEY_SIZE",
            "file"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file",
            "&sb"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "filebuf",
            "0",
            "sizeof(filebuf)"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n\nstatic int securevnc_check_server_rsa(char *file, unsigned char *rsabuf) {\n\tstruct stat sb;\n\tunsigned char filebuf[SECUREVNC_RSA_PUBKEY_SIZE];\n\tchar *md5str = rsa_md5_sum(rsabuf);\n\n\tif (!file) {\n\t\treturn 0;\n\t}\n\n\tmemset(filebuf, 0, sizeof(filebuf));\n\tif (stat(file, &sb) == 0) {\n\t\tint n, fd, i, ok = 1;\n\n\t\tif (sb.st_size != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: file is wrong size: %d != %d '%s'\\n\",\n\t\t\t    (int) sb.st_size, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfd = open(file, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open: '%s'\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tn = (int) read(fd, filebuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tclose(fd);\n\t\tif (n != SECUREVNC_RSA_PUBKEY_SIZE) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not read all of file: %d != %d '%s'\\n\",\n\t\t\t    n, SECUREVNC_RSA_PUBKEY_SIZE, file);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i=0; i < SECUREVNC_RSA_PUBKEY_SIZE; i++) {\n\t\t\tif (filebuf[i] != rsabuf[i]) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tchar *str1 = rsa_md5_sum(rsabuf);\n\t\t\tchar *str2 = rsa_md5_sum(filebuf);\n\t\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore contents differ for '%s'\\n\", file);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of server key: %s\\n\", str1);\n\t\t\tfprintf(stderr, \"checkserver_rsa: MD5 sum of keystore:   %s\\n\", str2);\n\t\t}\n\t\treturn ok;\n\t} else {\n\n\t\tfprintf(stderr, \"checkserver_rsa: rsa keystore file does not exist: '%s'\\n\", file);\n\t\tfprintf(stderr, \"checkserver_rsa: asking user if we should store rsa key in it.\\n\\n\");\n\t\tfprintf(stderr, \"checkserver_rsa: RSA key has MD5 sum: %s\\n\\n\", md5str); \n\n\t\treturn securevnc_server_rsa_save_dialog(file, md5str, rsabuf);\n\t}\n}"
  },
  {
    "function_name": "rsa_md5_sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1119-1146",
    "snippet": "static char *rsa_md5_sum(unsigned char* rsabuf) {\n\tEVP_MD_CTX *md;\n\tchar digest[EVP_MAX_MD_SIZE], tmp[16];\n\tchar md5str[EVP_MAX_MD_SIZE * 8];\n\tunsigned int i, size = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmd = EVP_MD_CTX_new();\n#else\n\tmd = EVP_MD_CTX_create();\n#endif\n\tEVP_DigestInit(md, EVP_md5());\n\tEVP_DigestUpdate(md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tEVP_DigestFinal(md, (unsigned char *)digest, &size);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_MD_CTX_free(md);\n#else\n\tEVP_MD_CTX_destroy(md);\n#endif\n\n\tmemset(md5str, 0, sizeof(md5str));\n\tfor (i=0; i < size; i++) {\n\t\tunsigned char uc = (unsigned char) digest[i];\n\t\tsprintf(tmp, \"%02x\", (int) uc);\n\t\tstrcat(md5str, tmp);\n\t}\n\treturn strdup(md5str);\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SECUREVNC_RSA_PUBKEY_SIZE 270"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "md5str"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "md5str",
            "tmp"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%02x\"",
            "(int) uc"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "md5str",
            "0",
            "sizeof(md5str)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_destroy",
          "args": [
            "md"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_free",
          "args": [
            "md"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DigestFinal",
          "args": [
            "md",
            "(unsigned char *)digest",
            "&size"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DigestUpdate",
          "args": [
            "md",
            "rsabuf",
            "SECUREVNC_RSA_PUBKEY_SIZE"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DigestInit",
          "args": [
            "md",
            "EVP_md5()"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_md5",
          "args": [],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_create",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_MD_CTX_new",
          "args": [],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n\nstatic char *rsa_md5_sum(unsigned char* rsabuf) {\n\tEVP_MD_CTX *md;\n\tchar digest[EVP_MAX_MD_SIZE], tmp[16];\n\tchar md5str[EVP_MAX_MD_SIZE * 8];\n\tunsigned int i, size = 0;\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmd = EVP_MD_CTX_new();\n#else\n\tmd = EVP_MD_CTX_create();\n#endif\n\tEVP_DigestInit(md, EVP_md5());\n\tEVP_DigestUpdate(md, rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\tEVP_DigestFinal(md, (unsigned char *)digest, &size);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_MD_CTX_free(md);\n#else\n\tEVP_MD_CTX_destroy(md);\n#endif\n\n\tmemset(md5str, 0, sizeof(md5str));\n\tfor (i=0; i < size; i++) {\n\t\tunsigned char uc = (unsigned char) digest[i];\n\t\tsprintf(tmp, \"%02x\", (int) uc);\n\t\tstrcat(md5str, tmp);\n\t}\n\treturn strdup(md5str);\n}"
  },
  {
    "function_name": "securevnc_server_rsa_save_dialog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "1067-1117",
    "snippet": "static int securevnc_server_rsa_save_dialog(char *file, char *md5str, unsigned char* rsabuf) {\n\t/* since we are likely running in the background, use this kludge by running tk */\n\tFILE *p;\n\tchar str[2], *q = file, *cmd = getenv(\"WISH\") ? getenv(\"WISH\") : \"wish\";\n\tint rc;\n\n\tmemset(str, 0, sizeof(str));\n\n\tp = popen(cmd, \"w\");\n\tif (p == NULL) {\n\t\tfprintf(stderr, \"checkserver_rsa: could not run: %s\\n\", cmd); \n\t\treturn 0;\n\t}\n\n\t/* start piping tk/tcl code to it: */\n\tfprintf(p, \"wm withdraw .\\n\");\n\tfprintf(p, \"set x [expr [winfo screenwidth  .]/2]\\n\");\n\tfprintf(p, \"set y [expr [winfo screenheight .]/2]\\n\");\n\tfprintf(p, \"wm geometry . +$x+$y; update\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.font {helvetica -14 bold}}\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.wrapLength 6i}\\n\");\n\tfprintf(p, \"set ans [tk_messageBox -title \\\"Save and Trust UltraVNC RSA Key?\\\" -icon question \");\n\tfprintf(p, \"-type yesno -message \\\"Save and Trust UltraVNC SecureVNCPlugin RSA Key\\\\n\\\\n\");\n\tfprintf(p, \"With MD5 sum: %s\\\\n\\\\n\", md5str);\n\tfprintf(p, \"In file: \");\n\twhile (*q != '\\0') {\n\t\t/* sanitize user supplied string: */\n\t\tstr[0] = *q;\n\t\tif (strpbrk(str, \"[](){}`'\\\"$&*|<>\") == NULL) {\n\t\t\tfprintf(p, \"%s\", str);\n\t\t}\n\t\tq++;\n\t}\n\tfprintf(p, \" ?\\\"]\\n\");\n\tfprintf(p, \"if { $ans == \\\"yes\\\" } {destroy .; exit 0} else {destroy .; exit 1}\\n\");\n\trc = pclose(p);\n\tif (rc == 0) {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  saving it.\\n\", rc);\n\t\tp = fopen(file, \"w\");\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open %s\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\t\twrite(fileno(p), rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tfclose(p);\n\t\treturn 2;\n\t} else {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  NOT saving it.\\n\", rc);\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SECUREVNC_RSA_PUBKEY_SIZE 270"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: query returned: %d.  NOT saving it.\\n\"",
            "rc"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "p"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fileno(p)",
            "rsabuf",
            "SECUREVNC_RSA_PUBKEY_SIZE"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "p"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: could not open %s\\n\"",
            "file"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"w\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: query returned: %d.  saving it.\\n\"",
            "rc"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"if { $ans == \\\"yes\\\" } {destroy .; exit 0} else {destroy .; exit 1}\\n\""
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\" ?\\\"]\\n\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"%s\"",
            "str"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "str",
            "\"[](){}`'\\\"$&*|<>\""
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"In file: \""
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"With MD5 sum: %s\\\\n\\\\n\"",
            "md5str"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"-type yesno -message \\\"Save and Trust UltraVNC SecureVNCPlugin RSA Key\\\\n\\\\n\""
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"set ans [tk_messageBox -title \\\"Save and Trust UltraVNC RSA Key?\\\" -icon question \""
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"catch {option add *Dialog.msg.wrapLength 6i}\\n\""
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"catch {option add *Dialog.msg.font {helvetica -14 bold}}\\n\""
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"wm geometry . +$x+$y; update\\n\""
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"set y [expr [winfo screenheight .]/2]\\n\""
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"set x [expr [winfo screenwidth  .]/2]\\n\""
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "p",
            "\"wm withdraw .\\n\""
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"checkserver_rsa: could not run: %s\\n\"",
            "cmd"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"w\""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "str",
            "0",
            "sizeof(str)"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"WISH\""
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"WISH\""
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RSA_PUBKEY_SIZE 270\n\nstatic int securevnc_server_rsa_save_dialog(char *file, char *md5str, unsigned char* rsabuf) {\n\t/* since we are likely running in the background, use this kludge by running tk */\n\tFILE *p;\n\tchar str[2], *q = file, *cmd = getenv(\"WISH\") ? getenv(\"WISH\") : \"wish\";\n\tint rc;\n\n\tmemset(str, 0, sizeof(str));\n\n\tp = popen(cmd, \"w\");\n\tif (p == NULL) {\n\t\tfprintf(stderr, \"checkserver_rsa: could not run: %s\\n\", cmd); \n\t\treturn 0;\n\t}\n\n\t/* start piping tk/tcl code to it: */\n\tfprintf(p, \"wm withdraw .\\n\");\n\tfprintf(p, \"set x [expr [winfo screenwidth  .]/2]\\n\");\n\tfprintf(p, \"set y [expr [winfo screenheight .]/2]\\n\");\n\tfprintf(p, \"wm geometry . +$x+$y; update\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.font {helvetica -14 bold}}\\n\");\n\tfprintf(p, \"catch {option add *Dialog.msg.wrapLength 6i}\\n\");\n\tfprintf(p, \"set ans [tk_messageBox -title \\\"Save and Trust UltraVNC RSA Key?\\\" -icon question \");\n\tfprintf(p, \"-type yesno -message \\\"Save and Trust UltraVNC SecureVNCPlugin RSA Key\\\\n\\\\n\");\n\tfprintf(p, \"With MD5 sum: %s\\\\n\\\\n\", md5str);\n\tfprintf(p, \"In file: \");\n\twhile (*q != '\\0') {\n\t\t/* sanitize user supplied string: */\n\t\tstr[0] = *q;\n\t\tif (strpbrk(str, \"[](){}`'\\\"$&*|<>\") == NULL) {\n\t\t\tfprintf(p, \"%s\", str);\n\t\t}\n\t\tq++;\n\t}\n\tfprintf(p, \" ?\\\"]\\n\");\n\tfprintf(p, \"if { $ans == \\\"yes\\\" } {destroy .; exit 0} else {destroy .; exit 1}\\n\");\n\trc = pclose(p);\n\tif (rc == 0) {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  saving it.\\n\", rc);\n\t\tp = fopen(file, \"w\");\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"checkserver_rsa: could not open %s\\n\", file);\n\t\t\treturn 0;\n\t\t}\n\t\twrite(fileno(p), rsabuf, SECUREVNC_RSA_PUBKEY_SIZE);\n\t\tfclose(p);\n\t\treturn 2;\n\t} else {\n\t\tfprintf(stderr, \"checkserver_rsa: query returned: %d.  NOT saving it.\\n\", rc);\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "enc_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "694-1065",
    "snippet": "static void enc_xfer(int sock_fr, int sock_to, int encrypt) {\n\t/*\n\t * We keep both E and D aspects in case we revert back to a\n\t * single process calling select(2) on all fds...\n\t */\n\tunsigned char E_keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char D_keystr[EVP_MAX_KEY_LENGTH];\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX *E_ctx, *D_ctx;\n#else\n\tEVP_CIPHER_CTX E_ctx, D_ctx;\n#endif\n\tEVP_CIPHER_CTX *ctx = NULL;\n\n\tunsigned char buf[BSIZE], out[BSIZE];\n\tunsigned char *psrc = NULL, *keystr;\n\tunsigned char salt[SALT+1];\n\tunsigned char ivec_real[EVP_MAX_IV_LENGTH];\n\tunsigned char *ivec = ivec_real;\n\n\tint i, cnt, len, m, n = 0, vb = 0, first = 1;\n\tint whoops = 1; /* for the msrc4 problem */\n\tchar *encstr, *encsym;\n\t\n\t/* zero the buffers */\n\tmemset(buf,  0, BSIZE);\n\tmemset(out,  0, BSIZE);\n\tmemset(salt, 0, sizeof(salt));\n\tmemset(ivec_real, 0, sizeof(ivec_real));\n\tmemset(E_keystr, 0, sizeof(E_keystr));\n\tmemset(D_keystr, 0, sizeof(D_keystr));\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\tsalt_size = MSRC4_SALT; /* 11 vs. 16 */\n\t}\n\n\tif (msrc4_sc) {\n\t\twhoops = 1;\t/* force workaround in SC mode */\n\t}\n\n\tif (getenv(\"ENCRYPT_VERBOSE\")) {\n\t\tvb = 1;\t/* let user turn on some debugging via env. var. */\n\t}\n\n\t/*\n\t * reverse mode, e.g. we help a vnc server instead of a viewer.\n\t */\n\tif (reverse) {\n\t\tencrypt = (!encrypt);\n\t}\n\tencstr = encrypt ? \"encrypt\" : \"decrypt\";  /* string for messages */\n\tencsym = encrypt ? \"+\" : \"-\";\n\n\t/* use the encryption/decryption context variables below */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tE_ctx = EVP_CIPHER_CTX_new();\n\tD_ctx = EVP_CIPHER_CTX_new();\n\tctx = encrypt ? E_ctx : D_ctx;\n#else\n\tctx = encrypt ? &E_ctx : &D_ctx;\n#endif\n\tif (encrypt) {\n\t\tkeystr = E_keystr;\n\t} else {\n\t\tkeystr = D_keystr;\n\t}\n\n\tif (securevnc) {\n\t\tfirst = 0;\t/* no need for salt+iv on first time */\n\t\tsalt_size = 0;\t/* we want no salt */\n\t\tn = 0;\t\t/* nothing read */\n\t\tivec_size = 0;\t/* we want no IV. */\n\t\tivec = NULL;\n\t} else if (encrypt) {\n\t\t/* encrypter initializes the salt and initialization vector */\n\n\t\t/*\n\t\t * Our salt is 16 bytes but I believe only the first 8\n\t\t * bytes are used by EVP_BytesToKey(3).  Since we send it\n\t\t * to the other \"plugin\" we need to keep it 16.  Also,\n\t\t * the IV size can depend on the cipher type.  Again, 16.\n\t\t */\n\t\tRAND_bytes(salt, salt_size);\n\t\tRAND_bytes(ivec, ivec_size);\n\n\t\t/* place them in the send buffer: */\n\t\tmemcpy(buf, salt, salt_size);\n\t\tmemcpy(buf+salt_size, ivec, ivec_size);\n\n\t\tn = salt_size + ivec_size;\n\n\t\tENC_PT_DBG(buf, n);\n\n\t} else {\n\t\t/* decrypter needs to read salt + iv from the wire: */\n\n\t\t/* sleep 100 ms (TODO: select on fd) */\n\t\tstruct timeval tv;\n\t\ttv.tv_sec  = 0;\n\t\ttv.tv_usec = 100 * 1000;\n\t\tselect(1, NULL, NULL, NULL, &tv);\n\n\t\tif (salt_size+ivec_size == 0) {\n\t\t\tn = 0;\t/* no salt or iv, skip reading. */\n\t\t} else {\n\t\t\tn = read(sock_fr, buf, salt_size+ivec_size+96);\n\t\t}\n\t\tif (n == 0 && salt_size+ivec_size > 0) {\n\t\t\tfprintf(stderr, \"%s: decrypt finished.\\n\", prog);\n\t\t\tgoto finished;\n\t\t}\n\t\tif (n < salt_size+ivec_size) {\n\t\t    if (msrc4_sc && n == 12) {\n\t\t\tfprintf(stderr, \"%s: only %d bytes read. Assuming \"\n\t\t\t    \"UVNC Single Click server.\\n\", prog, n);\n\t\t    } else {\n\t\t\tif (n < 0) perror(\"read\");\n\t\t\tfprintf(stderr, \"%s: could not read enough for salt \"\n\t\t\t    \"and ivec: n=%d\\n\", prog, n);\n\t\t\tgoto finished;\n\t\t    }\n\t\t}\n\n\t\tDEC_CT_DBG(buf, n);\n\n\t\tif (msrc4_sc && n == 12) {\n\t\t\t; /* send it as is */\n\t\t} else {\n\t\t\t/* extract them to their buffers: */\n\t\t\tmemcpy(salt, buf, salt_size);\n\t\t\tmemcpy(ivec, buf+salt_size, ivec_size);\n\n\t\t\t/* the rest is some encrypted data: */\n\t\t\tn = n - salt_size - ivec_size;\n\t\t\tpsrc = buf + salt_size + ivec_size;\n\t\t\n\t\t\tif (n > 0) {\n\t\t\t\t/*\n\t\t\t\t * copy it down to the start of buf for\n\t\t\t\t * sending below:\n\t\t\t\t */\n\t\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\t\tbuf[i] = psrc[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* debug output */\n\tPRINT_KEYDATA;\n\tPRINT_IVEC;\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\t/* special cases for MSRC4: */\n\n\t\tif (whoops) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: MSRC4 mode and IGNORING random salt\\n\", prog, encstr);\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: and initialization vector!!\\n\", prog, encstr);\n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tif (pw_in) {\n\t\t\t    /* for pw=xxxx a md5 hash is used */\n\t\t\t    EVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t        keydata_len, 1, keystr, NULL);\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL, keystr, NULL,\n\t\t\t        encrypt);\n\t\t\t} else {\n\t\t\t    /* otherwise keydata as is */\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL,\n\t\t\t        (unsigned char *) keydata, NULL, encrypt);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX might not be correct, just exit. */\n\t\t\tfprintf(stderr, \"%s: %s - Not sure about msrc4 && !whoops case, exiting.\\n\", prog, encstr);\n\t\t\texit(1);\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec); \n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec,\n\t\t\t    encrypt);\n\t\t}\n\n\t} else {\n\t\tunsigned char *in_salt = NULL;\n\n\t\t/* check salt and IV source and size. */\n\t\tif (securevnc) {\n\t\t\tin_salt = NULL;\n\t\t} else if (salt_size <= 0) {\n\t\t\t/* let salt_size = 0 mean keep it out of the MD5 */\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no salt\\n\",\n\t\t\t    prog, encstr);\n\t\t\tin_salt = NULL;\n\t\t} else {\n\t\t\tin_salt = salt;\n\t\t}\n\n\t\tif (ivec_size < EVP_CIPHER_iv_length(Cipher) && !securevnc) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: short IV %d < %d\\n\",\n\t\t\t    prog, encstr, ivec_size, EVP_CIPHER_iv_length(Cipher));\n\t\t}\n\n\t\t/* make the hashed value and place in keystr */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin had count=0, and overwrote ivec\n\t\t * by not passing NULL iv.\n\t\t */\n\n\t\tif (nomd) {\n\t\t\t/* special mode: no salt or md5, use keydata directly */\n\n\t\t\tint sz = keydata_len < EVP_MAX_KEY_LENGTH ?\n\t\t\t    keydata_len : EVP_MAX_KEY_LENGTH; \n\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no-md5 specified: ignoring salt & hash\\n\", prog, encstr);\n\t\t\tmemcpy(keystr, keydata, sz);\n\n\t\t} else if (noultra && ivec_size > 0) {\n\t\t\t/* \"normal\" mode, don't overwrite ivec. */\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, NULL);\n\n\t\t} else {\n\t\t\t/* \n\t\t\t * Ultra DSM compatibility mode.  Note that this\n\t\t\t * clobbers the ivec we set up above!  Under\n\t\t\t * noultra we overwrite ivec only if ivec_size=0.\n\t\t\t *\n\t\t\t * SecureVNC also goes through here. in_salt and ivec are NULL.\n\t\t\t * And ivec is NULL below in the EVP_CipherInit_ex() call.\n\t\t\t */\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec);\n\t\t}\n\n\n\t\t/* initialize the context */\n\t\tEVP_CIPHER_CTX_init(ctx);\n\n\n\t\t/* set the cipher & initialize */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin implementation had encrypt=1\n\t\t * for both (i.e. perfectly symmetric)\n\t\t */\n\n\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec, encrypt);\n\t}\n\n\tif (securevnc && securevnc_arc4) {\n\t\t/* need to discard initial 3072 bytes */\n\t\tunsigned char buf1[SECUREVNC_RC4_DROP_BYTES];\n\t\tunsigned char buf2[SECUREVNC_RC4_DROP_BYTES];\n\t\tint cnt = 0;\n\t\tEVP_CipherUpdate(ctx, buf1, &cnt, buf2, SECUREVNC_RC4_DROP_BYTES);\n\t}\n\n\t/* debug output */\n\tPRINT_KEYSTR_AND_FRIENDS;\n\n\t/* now loop forever processing the data stream */\n\n\twhile (1) {\n\t\terrno = 0;\n\t\tif (first && n > 0) {\n\t\t\tif (encrypt && msrc4_sc) {\n\t\t\t\t/* skip sending salt+iv */\n\t\t\t\tfirst = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* use that first block of data placed in buf */\n\t\t\t}\n\t\t} else if (first && n == 0 && salt_size + ivec_size == 0) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* general case of loop, read some in: */\n\t\t\tn = read(sock_fr, buf, BSIZE);\n\t\t}\n\n\t\t/* debug output: */\n\t\tif (vb) fprintf(stderr, \"%s%d/%d \", encsym, n, errno);\n\t\tPRINT_LOOP_DBG1;\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tPRINT_LOOP_DBG2;\n\t\t\tfprintf(stderr, \"%s: %s - input stream finished: n=%d, err=%d\", prog, encstr, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\t\t\t/* we read in some data, now transform it: */\n\n\t\t\tif (first && encrypt) {\n\t\t\t\t/* first time, copy the salt and ivec to out[] for sending */\n\t\t\t\tmemcpy(out, buf, n);\n\t\t\t\tcnt = n;\n\n\t\t\t} else if (!EVP_CipherUpdate(ctx, out, &cnt, buf, n)) {\n\t\t\t\t/* otherwise, we transform the data */\n\t\t\t\tfprintf(stderr, \"%s: enc_xfer EVP_CipherUpdate failed.\\n\", prog);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* debug output: */\n\t\t\tif (vb) fprintf(stderr, \"%sc%d/%d \", encsym, cnt, n);\n\t\t\tPRINT_LOOP_DBG3;\n\n\t\t\t/* write transformed data to the other end: */\n\t\t\tlen = cnt;\n\t\t\tpsrc = out;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\t/* debug output: */\n\t\t\t\tif (vb) fprintf(stderr, \"m%s%d/%d \", encsym, m, errno);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\tfinished:\n\n\tfprintf(stderr, \"\\n%s: %s - close sock_to\\n\", prog, encstr);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: %s - close sock_fr\\n\", prog, encstr);\n\tclose(sock_fr);\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(E_ctx);\n\tEVP_CIPHER_CTX_free(D_ctx);\n#endif\n\n\t/* kill our partner after 2 secs. */\n\tsleep(2);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) parent);\n\t\t}\n\t}\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SECUREVNC_RC4_DROP_BYTES 3072",
      "#define BSIZE 8192",
      "#define MSRC4_SALT 11",
      "#define SALT 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s[%d]: %s - killed my partner: %d\\n\"",
            "prog",
            "(int) getpid()",
            "encstr",
            "(int) parent"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "parent",
            "SIGTERM"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s[%d]: %s - killed my partner: %d\\n\"",
            "prog",
            "(int) getpid()",
            "encstr",
            "(int) child"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "do_sleepin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1929-1959",
          "snippet": "static void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_free",
          "args": [
            "D_ctx"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_free",
          "args": [
            "E_ctx"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock_fr"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - close sock_fr\\n\"",
            "prog",
            "encstr"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n%s: %s - close sock_to\\n\"",
            "prog",
            "encstr"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"m%s%d/%d \"",
            "encsym",
            "m",
            "errno"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock_to",
            "psrc",
            "len"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%sc%d/%d \"",
            "encsym",
            "cnt",
            "n"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: enc_xfer EVP_CipherUpdate failed.\\n\"",
            "prog"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CipherUpdate",
          "args": [
            "ctx",
            "out",
            "&cnt",
            "buf",
            "n"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "buf",
            "n"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - input stream finished: n=%d, err=%d\"",
            "prog",
            "encstr",
            "n",
            "err"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s%d/%d \"",
            "encsym",
            "n",
            "errno"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock_fr",
            "buf",
            "BSIZE"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CipherUpdate",
          "args": [
            "ctx",
            "buf1",
            "&cnt",
            "buf2",
            "SECUREVNC_RC4_DROP_BYTES"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CipherInit_ex",
          "args": [
            "ctx",
            "Cipher",
            "NULL",
            "keystr",
            "ivec",
            "encrypt"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_init",
          "args": [
            "ctx"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "Cipher",
            "Digest",
            "in_salt",
            "(unsigned char *) keydata",
            "keydata_len",
            "1",
            "keystr",
            "ivec"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "Cipher",
            "Digest",
            "in_salt",
            "(unsigned char *) keydata",
            "keydata_len",
            "1",
            "keystr",
            "NULL"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "keystr",
            "keydata",
            "sz"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - WARNING: no-md5 specified: ignoring salt & hash\\n\"",
            "prog",
            "encstr"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - WARNING: short IV %d < %d\\n\"",
            "prog",
            "encstr",
            "ivec_size",
            "EVP_CIPHER_iv_length(Cipher)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_iv_length",
          "args": [
            "Cipher"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_iv_length",
          "args": [
            "Cipher"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - WARNING: no salt\\n\"",
            "prog",
            "encstr"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CipherInit_ex",
          "args": [
            "ctx",
            "Cipher",
            "NULL",
            "keystr",
            "ivec",
            "encrypt"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_init",
          "args": [
            "ctx"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "Cipher",
            "Digest",
            "NULL",
            "(unsigned char *) keydata",
            "keydata_len",
            "1",
            "keystr",
            "ivec"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - Not sure about msrc4 && !whoops case, exiting.\\n\"",
            "prog",
            "encstr"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CipherInit_ex",
          "args": [
            "ctx",
            "Cipher",
            "NULL",
            "(unsigned char *) keydata",
            "NULL",
            "encrypt"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CipherInit_ex",
          "args": [
            "ctx",
            "Cipher",
            "NULL",
            "keystr",
            "NULL",
            "encrypt"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "Cipher",
            "Digest",
            "NULL",
            "(unsigned char *) keydata",
            "keydata_len",
            "1",
            "keystr",
            "NULL"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_init",
          "args": [
            "ctx"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - WARNING: and initialization vector!!\\n\"",
            "prog",
            "encstr"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s - WARNING: MSRC4 mode and IGNORING random salt\\n\"",
            "prog",
            "encstr"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"msrc4\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ivec",
            "buf+salt_size",
            "ivec_size"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "salt",
            "buf",
            "salt_size"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEC_CT_DBG",
          "args": [
            "buf",
            "n"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: could not read enough for salt \"\n\t\t\t    \"and ivec: n=%d\\n\"",
            "prog",
            "n"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"read\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: only %d bytes read. Assuming \"\n\t\t\t    \"UVNC Single Click server.\\n\"",
            "prog",
            "n"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: decrypt finished.\\n\"",
            "prog"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "1",
            "NULL",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENC_PT_DBG",
          "args": [
            "buf",
            "n"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf+salt_size",
            "ivec",
            "ivec_size"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "salt",
            "salt_size"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "ivec",
            "ivec_size"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "salt",
            "salt_size"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_new",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_new",
          "args": [],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ENCRYPT_VERBOSE\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"msrc4\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "D_keystr",
            "0",
            "sizeof(D_keystr)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "E_keystr",
            "0",
            "sizeof(E_keystr)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ivec_real",
            "0",
            "sizeof(ivec_real)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "salt",
            "0",
            "sizeof(salt)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "out",
            "0",
            "BSIZE"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "BSIZE"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SECUREVNC_RC4_DROP_BYTES 3072\n#define BSIZE 8192\n#define MSRC4_SALT 11\n#define SALT 16\n\nstatic void enc_xfer(int sock_fr, int sock_to, int encrypt) {\n\t/*\n\t * We keep both E and D aspects in case we revert back to a\n\t * single process calling select(2) on all fds...\n\t */\n\tunsigned char E_keystr[EVP_MAX_KEY_LENGTH];\n\tunsigned char D_keystr[EVP_MAX_KEY_LENGTH];\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX *E_ctx, *D_ctx;\n#else\n\tEVP_CIPHER_CTX E_ctx, D_ctx;\n#endif\n\tEVP_CIPHER_CTX *ctx = NULL;\n\n\tunsigned char buf[BSIZE], out[BSIZE];\n\tunsigned char *psrc = NULL, *keystr;\n\tunsigned char salt[SALT+1];\n\tunsigned char ivec_real[EVP_MAX_IV_LENGTH];\n\tunsigned char *ivec = ivec_real;\n\n\tint i, cnt, len, m, n = 0, vb = 0, first = 1;\n\tint whoops = 1; /* for the msrc4 problem */\n\tchar *encstr, *encsym;\n\t\n\t/* zero the buffers */\n\tmemset(buf,  0, BSIZE);\n\tmemset(out,  0, BSIZE);\n\tmemset(salt, 0, sizeof(salt));\n\tmemset(ivec_real, 0, sizeof(ivec_real));\n\tmemset(E_keystr, 0, sizeof(E_keystr));\n\tmemset(D_keystr, 0, sizeof(D_keystr));\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\tsalt_size = MSRC4_SALT; /* 11 vs. 16 */\n\t}\n\n\tif (msrc4_sc) {\n\t\twhoops = 1;\t/* force workaround in SC mode */\n\t}\n\n\tif (getenv(\"ENCRYPT_VERBOSE\")) {\n\t\tvb = 1;\t/* let user turn on some debugging via env. var. */\n\t}\n\n\t/*\n\t * reverse mode, e.g. we help a vnc server instead of a viewer.\n\t */\n\tif (reverse) {\n\t\tencrypt = (!encrypt);\n\t}\n\tencstr = encrypt ? \"encrypt\" : \"decrypt\";  /* string for messages */\n\tencsym = encrypt ? \"+\" : \"-\";\n\n\t/* use the encryption/decryption context variables below */\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tE_ctx = EVP_CIPHER_CTX_new();\n\tD_ctx = EVP_CIPHER_CTX_new();\n\tctx = encrypt ? E_ctx : D_ctx;\n#else\n\tctx = encrypt ? &E_ctx : &D_ctx;\n#endif\n\tif (encrypt) {\n\t\tkeystr = E_keystr;\n\t} else {\n\t\tkeystr = D_keystr;\n\t}\n\n\tif (securevnc) {\n\t\tfirst = 0;\t/* no need for salt+iv on first time */\n\t\tsalt_size = 0;\t/* we want no salt */\n\t\tn = 0;\t\t/* nothing read */\n\t\tivec_size = 0;\t/* we want no IV. */\n\t\tivec = NULL;\n\t} else if (encrypt) {\n\t\t/* encrypter initializes the salt and initialization vector */\n\n\t\t/*\n\t\t * Our salt is 16 bytes but I believe only the first 8\n\t\t * bytes are used by EVP_BytesToKey(3).  Since we send it\n\t\t * to the other \"plugin\" we need to keep it 16.  Also,\n\t\t * the IV size can depend on the cipher type.  Again, 16.\n\t\t */\n\t\tRAND_bytes(salt, salt_size);\n\t\tRAND_bytes(ivec, ivec_size);\n\n\t\t/* place them in the send buffer: */\n\t\tmemcpy(buf, salt, salt_size);\n\t\tmemcpy(buf+salt_size, ivec, ivec_size);\n\n\t\tn = salt_size + ivec_size;\n\n\t\tENC_PT_DBG(buf, n);\n\n\t} else {\n\t\t/* decrypter needs to read salt + iv from the wire: */\n\n\t\t/* sleep 100 ms (TODO: select on fd) */\n\t\tstruct timeval tv;\n\t\ttv.tv_sec  = 0;\n\t\ttv.tv_usec = 100 * 1000;\n\t\tselect(1, NULL, NULL, NULL, &tv);\n\n\t\tif (salt_size+ivec_size == 0) {\n\t\t\tn = 0;\t/* no salt or iv, skip reading. */\n\t\t} else {\n\t\t\tn = read(sock_fr, buf, salt_size+ivec_size+96);\n\t\t}\n\t\tif (n == 0 && salt_size+ivec_size > 0) {\n\t\t\tfprintf(stderr, \"%s: decrypt finished.\\n\", prog);\n\t\t\tgoto finished;\n\t\t}\n\t\tif (n < salt_size+ivec_size) {\n\t\t    if (msrc4_sc && n == 12) {\n\t\t\tfprintf(stderr, \"%s: only %d bytes read. Assuming \"\n\t\t\t    \"UVNC Single Click server.\\n\", prog, n);\n\t\t    } else {\n\t\t\tif (n < 0) perror(\"read\");\n\t\t\tfprintf(stderr, \"%s: could not read enough for salt \"\n\t\t\t    \"and ivec: n=%d\\n\", prog, n);\n\t\t\tgoto finished;\n\t\t    }\n\t\t}\n\n\t\tDEC_CT_DBG(buf, n);\n\n\t\tif (msrc4_sc && n == 12) {\n\t\t\t; /* send it as is */\n\t\t} else {\n\t\t\t/* extract them to their buffers: */\n\t\t\tmemcpy(salt, buf, salt_size);\n\t\t\tmemcpy(ivec, buf+salt_size, ivec_size);\n\n\t\t\t/* the rest is some encrypted data: */\n\t\t\tn = n - salt_size - ivec_size;\n\t\t\tpsrc = buf + salt_size + ivec_size;\n\t\t\n\t\t\tif (n > 0) {\n\t\t\t\t/*\n\t\t\t\t * copy it down to the start of buf for\n\t\t\t\t * sending below:\n\t\t\t\t */\n\t\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\t\tbuf[i] = psrc[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* debug output */\n\tPRINT_KEYDATA;\n\tPRINT_IVEC;\n\n\tif (!strcmp(cipher, \"msrc4\")) {\n\t\t/* special cases for MSRC4: */\n\n\t\tif (whoops) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: MSRC4 mode and IGNORING random salt\\n\", prog, encstr);\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: and initialization vector!!\\n\", prog, encstr);\n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tif (pw_in) {\n\t\t\t    /* for pw=xxxx a md5 hash is used */\n\t\t\t    EVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t        keydata_len, 1, keystr, NULL);\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL, keystr, NULL,\n\t\t\t        encrypt);\n\t\t\t} else {\n\t\t\t    /* otherwise keydata as is */\n\t\t\t    EVP_CipherInit_ex(ctx, Cipher, NULL,\n\t\t\t        (unsigned char *) keydata, NULL, encrypt);\n\t\t\t}\n\t\t} else {\n\t\t\t/* XXX might not be correct, just exit. */\n\t\t\tfprintf(stderr, \"%s: %s - Not sure about msrc4 && !whoops case, exiting.\\n\", prog, encstr);\n\t\t\texit(1);\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, NULL, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec); \n\t\t\tEVP_CIPHER_CTX_init(ctx);\n\t\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec,\n\t\t\t    encrypt);\n\t\t}\n\n\t} else {\n\t\tunsigned char *in_salt = NULL;\n\n\t\t/* check salt and IV source and size. */\n\t\tif (securevnc) {\n\t\t\tin_salt = NULL;\n\t\t} else if (salt_size <= 0) {\n\t\t\t/* let salt_size = 0 mean keep it out of the MD5 */\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no salt\\n\",\n\t\t\t    prog, encstr);\n\t\t\tin_salt = NULL;\n\t\t} else {\n\t\t\tin_salt = salt;\n\t\t}\n\n\t\tif (ivec_size < EVP_CIPHER_iv_length(Cipher) && !securevnc) {\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: short IV %d < %d\\n\",\n\t\t\t    prog, encstr, ivec_size, EVP_CIPHER_iv_length(Cipher));\n\t\t}\n\n\t\t/* make the hashed value and place in keystr */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin had count=0, and overwrote ivec\n\t\t * by not passing NULL iv.\n\t\t */\n\n\t\tif (nomd) {\n\t\t\t/* special mode: no salt or md5, use keydata directly */\n\n\t\t\tint sz = keydata_len < EVP_MAX_KEY_LENGTH ?\n\t\t\t    keydata_len : EVP_MAX_KEY_LENGTH; \n\n\t\t\tfprintf(stderr, \"%s: %s - WARNING: no-md5 specified: ignoring salt & hash\\n\", prog, encstr);\n\t\t\tmemcpy(keystr, keydata, sz);\n\n\t\t} else if (noultra && ivec_size > 0) {\n\t\t\t/* \"normal\" mode, don't overwrite ivec. */\n\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, NULL);\n\n\t\t} else {\n\t\t\t/* \n\t\t\t * Ultra DSM compatibility mode.  Note that this\n\t\t\t * clobbers the ivec we set up above!  Under\n\t\t\t * noultra we overwrite ivec only if ivec_size=0.\n\t\t\t *\n\t\t\t * SecureVNC also goes through here. in_salt and ivec are NULL.\n\t\t\t * And ivec is NULL below in the EVP_CipherInit_ex() call.\n\t\t\t */\n\t\t\tEVP_BytesToKey(Cipher, Digest, in_salt, (unsigned char *) keydata,\n\t\t\t    keydata_len, 1, keystr, ivec);\n\t\t}\n\n\n\t\t/* initialize the context */\n\t\tEVP_CIPHER_CTX_init(ctx);\n\n\n\t\t/* set the cipher & initialize */\n\n\t\t/*\n\t\t * XXX N.B.: DSM plugin implementation had encrypt=1\n\t\t * for both (i.e. perfectly symmetric)\n\t\t */\n\n\t\tEVP_CipherInit_ex(ctx, Cipher, NULL, keystr, ivec, encrypt);\n\t}\n\n\tif (securevnc && securevnc_arc4) {\n\t\t/* need to discard initial 3072 bytes */\n\t\tunsigned char buf1[SECUREVNC_RC4_DROP_BYTES];\n\t\tunsigned char buf2[SECUREVNC_RC4_DROP_BYTES];\n\t\tint cnt = 0;\n\t\tEVP_CipherUpdate(ctx, buf1, &cnt, buf2, SECUREVNC_RC4_DROP_BYTES);\n\t}\n\n\t/* debug output */\n\tPRINT_KEYSTR_AND_FRIENDS;\n\n\t/* now loop forever processing the data stream */\n\n\twhile (1) {\n\t\terrno = 0;\n\t\tif (first && n > 0) {\n\t\t\tif (encrypt && msrc4_sc) {\n\t\t\t\t/* skip sending salt+iv */\n\t\t\t\tfirst = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/* use that first block of data placed in buf */\n\t\t\t}\n\t\t} else if (first && n == 0 && salt_size + ivec_size == 0) {\n\t\t\tfirst = 0;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* general case of loop, read some in: */\n\t\t\tn = read(sock_fr, buf, BSIZE);\n\t\t}\n\n\t\t/* debug output: */\n\t\tif (vb) fprintf(stderr, \"%s%d/%d \", encsym, n, errno);\n\t\tPRINT_LOOP_DBG1;\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tPRINT_LOOP_DBG2;\n\t\t\tfprintf(stderr, \"%s: %s - input stream finished: n=%d, err=%d\", prog, encstr, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\t\t\t/* we read in some data, now transform it: */\n\n\t\t\tif (first && encrypt) {\n\t\t\t\t/* first time, copy the salt and ivec to out[] for sending */\n\t\t\t\tmemcpy(out, buf, n);\n\t\t\t\tcnt = n;\n\n\t\t\t} else if (!EVP_CipherUpdate(ctx, out, &cnt, buf, n)) {\n\t\t\t\t/* otherwise, we transform the data */\n\t\t\t\tfprintf(stderr, \"%s: enc_xfer EVP_CipherUpdate failed.\\n\", prog);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* debug output: */\n\t\t\tif (vb) fprintf(stderr, \"%sc%d/%d \", encsym, cnt, n);\n\t\t\tPRINT_LOOP_DBG3;\n\n\t\t\t/* write transformed data to the other end: */\n\t\t\tlen = cnt;\n\t\t\tpsrc = out;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\t/* debug output: */\n\t\t\t\tif (vb) fprintf(stderr, \"m%s%d/%d \", encsym, m, errno);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\tfinished:\n\n\tfprintf(stderr, \"\\n%s: %s - close sock_to\\n\", prog, encstr);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: %s - close sock_fr\\n\", prog, encstr);\n\tclose(sock_fr);\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tEVP_CIPHER_CTX_free(E_ctx);\n\tEVP_CIPHER_CTX_free(D_ctx);\n#endif\n\n\t/* kill our partner after 2 secs. */\n\tsleep(2);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: %s - killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), encstr, (int) parent);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "enc_raw_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "614-687",
    "snippet": "static void enc_raw_xfer(int sock_fr, int sock_to) {\n\n\tunsigned char buf[BSIZE];\n\tunsigned char *psrc = NULL;\n\tint len, m, n = 0;\n\t\n\t/* zero the buffers */\n\tmemset(buf, 0, BSIZE);\n\n\t/* now loop forever processing the data stream */\n\twhile (1) {\n\t\terrno = 0;\n\n\t\t/* general case of loop, read some in: */\n\t\tn = read(sock_fr, buf, BSIZE);\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tfprintf(stderr, \"%s: input stream finished: n=%d, err=%d\", prog, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\n\t\t\t/* write data to the other end: */\n\t\t\tlen = n;\n\t\t\tpsrc = buf;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\n\tfprintf(stderr, \"\\n%s: close sock_to\\n\", prog);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: close sock_fr\\n\", prog);\n\tclose(sock_fr);\n\n\t/* kill our partner after 1 secs. */\n\tsleep(1);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) parent);\n\t\t}\n\t}\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define BSIZE 8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s[%d]: killed my partner: %d\\n\"",
            "prog",
            "(int) getpid()",
            "(int) parent"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "parent",
            "SIGTERM"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s[%d]: killed my partner: %d\\n\"",
            "prog",
            "(int) getpid()",
            "(int) child"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "do_sleepin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1929-1959",
          "snippet": "static void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock_fr"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: close sock_fr\\n\"",
            "prog"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n%s: close sock_to\\n\"",
            "prog"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock_to",
            "psrc",
            "len"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: input stream finished: n=%d, err=%d\"",
            "prog",
            "n",
            "err"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock_fr",
            "buf",
            "BSIZE"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "BSIZE"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define BSIZE 8192\n\nstatic void enc_raw_xfer(int sock_fr, int sock_to) {\n\n\tunsigned char buf[BSIZE];\n\tunsigned char *psrc = NULL;\n\tint len, m, n = 0;\n\t\n\t/* zero the buffers */\n\tmemset(buf, 0, BSIZE);\n\n\t/* now loop forever processing the data stream */\n\twhile (1) {\n\t\terrno = 0;\n\n\t\t/* general case of loop, read some in: */\n\t\tn = read(sock_fr, buf, BSIZE);\n\n\t\tif (n == 0 || (n < 0 && errno != EINTR)) {\n\t\t\t/* failure to read any data, it is EOF or fatal error */\n\t\t\tint err = errno;\n\n\t\t\t/* debug output: */\n\t\t\tfprintf(stderr, \"%s: input stream finished: n=%d, err=%d\", prog, n, err);\n\n\t\t\t/* EOF or fatal error */\n\t\t\tbreak;\n\n\t\t} else if (n > 0) {\n\n\t\t\t/* write data to the other end: */\n\t\t\tlen = n;\n\t\t\tpsrc = buf;\n\t\t\twhile (len > 0) {\n\t\t\t\terrno = 0;\n\t\t\t\tm = write(sock_to, psrc, len);\n\n\t\t\t\tif (m > 0) {\n\t\t\t\t\t/* scoot them by how much was written: */\n\t\t\t\t\tpsrc += m;\n\t\t\t\t\tlen  -= m;\n\t\t\t\t}\n\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t/* interrupted or blocked */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* EOF or fatal error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this is EINTR */\n\t\t}\n\t}\n\n\t/* transfer done (viewer exited or some error) */\n\n\tfprintf(stderr, \"\\n%s: close sock_to\\n\", prog);\n\tclose(sock_to);\n\n\tfprintf(stderr,   \"%s: close sock_fr\\n\", prog);\n\tclose(sock_fr);\n\n\t/* kill our partner after 1 secs. */\n\tsleep(1);\n\tif (child)  {\n\t\tif (kill(child, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) child);\n\t\t}\n\t} else {\n\t\tif (kill(parent, SIGTERM) == 0) {\n\t\t\tfprintf(stderr, \"%s[%d]: killed my partner: %d\\n\",\n\t\t\t    prog, (int) getpid(), (int) parent);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "enc_do",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "347-611",
    "snippet": "extern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\n\tstruct stat sb;\n\tchar *q, *p, *connect_host;\n\tchar tmp[16];\n\tint fd, len = 0, listen_port = 0, connect_port, mbits;\n\n\tq = ciph;\n\n\t/* check for noultra mode: */\n\tif (strstr(q, \"noultra:\") == q) {\n\t\tnoultra = 1;\n\t\tq += strlen(\"noultra:\");\n\t}\n\n\t/* check for reverse mode: */\n\tif (strstr(q, \"rev:\") == q) {\n\t\treverse = 1;\n\t\tq += strlen(\"rev:\");\n\t}\n\n\t/* work out which cipher and set Cipher to the selected one. */\n\tif (!strcasecmp(q, \"msrc4\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t} else if (!strcasecmp(q, \"msrc4_sc\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\t\tmsrc4_sc = 1;\t\t\t/* no salt/iv workaround */\n\n\t} else if (strstr(q, \"arc4\") == q) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t} else if (strstr(q, \"aesv2\") == q || strstr(q, \"aes-ofb\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t} else if (strstr(q, \"aes-cfb\") == q) {\n\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t} else if (strstr(q, \"aes256\") == q) {\n\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t} else if (strstr(q, \"blowfish\") == q) {\n\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t} else if (strstr(q, \"3des\") == q) {\n\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t} else if (strstr(q, \"securevnc\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\tsecurevnc = 1;\n\n\t} else if (strstr(q, \"none\") == q || strstr(q, \"relay\") == q) {\n\t\tcipher = \"none\";\n\n\t} else if (strstr(q, \"showcert\") == q) {\n\t\tcipher = \"showcert\";\n\n\t} else if (strstr(q, \".\") == q) {\n\t\t/* otherwise, try to guess cipher from key filename: */\n\t\tif (strstr(keyfile, \"arc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t\t} else if (strstr(keyfile, \"rc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t\t} else if (strstr(keyfile, \"aesv2.key\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t\t} else if (strstr(keyfile, \"aes-cfb.key\")) {\n\t\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t\t} else if (strstr(keyfile, \"aes256.key\")) {\n\t\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t\t} else if (strstr(keyfile, \"blowfish.key\")) {\n\t\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t\t} else if (strstr(keyfile, \"3des.key\")) {\n\t\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t\t} else if (strstr(keyfile, \"securevnc.\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\t\tsecurevnc = 1;\n\n\t\t} else {\n\t\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\texit(1);\n\t}\n\n\t/* set the default message digest (md5) */\n\tif (!securevnc) {\n\t\tDigest = EVP_md5();\n\t} else {\n\t\tDigest = EVP_sha1();\n\t}\n\n\t/*\n\t * Look for user specified salt and IV sizes at the end\n\t * ( ciph@salt,iv and ciph@[md+]salt,iv ):\n\t */\n\tp = strchr(q, '@');\n\tif (p) {\n\t\tint s, v;\n\t\tp++;\n\t\tif (strstr(p, \"md5+\") == p) {\n\t\t\tDigest = EVP_md5();        p += strlen(\"md5+\");\n#if OPENSSL_VERSION_NUMBER < 0x10100000L && !defined OPENSSL_NO_SHA0\n\t\t} else if (strstr(p, \"sha+\") == p) {\n\t\t\tDigest = EVP_sha();        p += strlen(\"sha+\");\n#endif\n\t\t} else if (strstr(p, \"sha1+\") == p) {\n\t\t\tDigest = EVP_sha1();       p += strlen(\"sha1+\");\n\t\t} else if (strstr(p, \"ripe+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripe+\");\n\t\t} else if (strstr(p, \"ripemd160+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripemd160+\");\n\t\t}\n\t\tif (sscanf(p, \"%d,%d\", &s, &v) == 2) {\n\t\t\t/* cipher@n,m */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (0 <= v && v <= EVP_MAX_IV_LENGTH) {\n\t\t\t\tivec_size = v;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid IV size: %d\\n\",\n\t\t\t\t    prog, v);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (sscanf(p, \"%d\", &s) == 1) {\n\t\t\t/* cipher@n */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (salt_size == -1) {\n\t\t\t/* let salt = -1 mean skip both MD5 and salt */\n\t\t\tnomd = 1;\n\t\t\tsalt_size = 0;\n\t\t}\n\t}\n\n\t/* port to listen on (0 => stdio, negative => localhost) */\n\tif (lport != NULL) {\n\t\tlisten_port = atoi(lport);\n\t}\n\n\t/* extract remote hostname and port */\n\tq = strrchr(rhp, ':');\n\tif (q) {\n\t\tconnect_port = atoi(q+1);\n\t\t*q = '\\0';\n\t} else {\n\t\t/* otherwise guess VNC display 0 ... */\n\t\tconnect_port = 5900;\n\t}\n\tconnect_host = strdup(rhp);\n\n\t/* check for and read in the key file */\n\tmemset(keydata, 0, sizeof(keydata));\n\n\tif (!strcmp(cipher, \"none\")) {\n\t\tgoto readed_in;\n\t}\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto readed_in;\n\t}\n\n\tif (securevnc) {\n\t\t/* note the keyfile for rsa verification later */\n\t\tif (keyfile != NULL && strcasecmp(keyfile, \"none\")) {\n\t\t\tsecurevnc_file = keyfile;\n\t\t}\n\t\tgoto readed_in;\n\t}\n\n\tif (stat(keyfile, &sb) != 0) {\n\t\tif (strstr(keyfile, \"pw=\") == keyfile) {\n\t\t\t/* user specified key/password on cmdline */\n\t\t\tint i;\n\t\t\tlen = 0;\n\t\t\tpw_in = 1;\n\t\t\tfor (i=0; i < (int) strlen(keyfile); i++) {\n\t\t\t\t/* load the string to keydata: */\n\t\t\t\tint n = i + strlen(\"pw=\");\n\t\t\t\tkeydata[i] = keyfile[n];\n\t\t\t\tif (keyfile[n] == '\\0') break;\n\t\t\t\tlen++;\n\t\t\t\tif (i > 100) break;\n\t\t\t}\n\t\t\tgoto readed_in;\n\t\t}\n\t\t/* otherwise invalid file */\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tif (sb.st_size > 1024) {\n\t\tfprintf(stderr, \"%s: key file too big.\\n\", prog);\n\t\texit(1);\n\t}\n\tfd = open(keyfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\texit(1);\n\t}\n\n\t/* read it all in */\n\tlen = (int) read(fd, keydata, (size_t) sb.st_size);\n\tif (len != sb.st_size) {\n\t\tperror(\"read\");\n\t\tfprintf(stderr, \"%s, could not read key file.\\n\", prog);\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\treaded_in:\n\n\n\t/* check for ultravnc msrc4 format 'rc4.key' */\n\tmbits = 0;\n\tif (strstr(keydata, \"128 bit\") == keydata) {\n\t\tmbits = 128;\n\t} else if (strstr(keydata, \" 56 bit\") == keydata) {\n\t\tmbits = 56;\n\t} else if (strstr(keydata, \" 40 bit\") == keydata) {\n\t\tmbits = 40;\n\t}\n\tif (mbits > 0) {\n\t\t/* 4 is for int key length, 12 is for BLOBHEADER. */\n\t\tint i, offset = strlen(\"xxx bit\") + 4 + 12;\n\n\t\t/* the key is stored in reverse order! */\n\t\tlen = mbits/8;\n\t\tfor (i=0; i < len; i++) {\n\t\t\ttmp[i] = keydata[offset + len - i - 1];\n\t\t}\n\n\t\t/* clear keydata and then copy the reversed bytes there: */\n\t\tmemset(keydata, 0, sizeof(keydata));\n\t\tmemcpy(keydata, tmp, len);\n\t}\n\n\tkeydata_len = len;\n\n\t/* initialize random */\n\tRAND_poll();\n\n\t/*\n\t * Setup connections, then transfer data when they are all\n\t * hooked up.\n\t */\n\tenc_connections(listen_port, connect_host, connect_port);\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SALT 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enc_connections",
          "args": [
            "listen_port",
            "connect_host",
            "connect_port"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "enc_connections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1721-2075",
          "snippet": "static void enc_connections(int listen_port, char *connect_host, int connect_port) {\n\tint listen_fd = -1, listen_fd6 = -1, conn1 = -1, conn2 = -1, ret, one = 1;\n\tsocklen_t clen;\n\tstruct hostent *hp;\n\tstruct sockaddr_in client, server;\n\tfd_set fds;\n\tint maxfd = -1;\n\n\t/* zero means use stdio (preferably from socketpair()) */\n\tif (listen_port == 0) {\n\t\tconn1 = fileno(stdin);\n\t\tgoto use_stdio;\n\t}\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto use_stdio;\n\t}\n\n\t/* fd=n,m means use the supplied already established sockets */\n\tif (sscanf(connect_host, \"fd=%d,%d\", &conn1, &conn2) == 2) {\n\t\tgoto use_input_fds;\n\t}\n\n\t/* create the listening socket: */\n\tmemset(&client, 0, sizeof(client));\n\tclient.sin_family = AF_INET;\n\tif (listen_port < 0) {\n\t\t/* negative port means use loopback */\n\t\tclient.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tclient.sin_port = htons(-listen_port);\n\t} else {\n\t\tclient.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tclient.sin_port = htons(listen_port);\n\t}\n\n\tlisten_fd = socket(AF_INET, SOCK_STREAM, 0); \n\tif (listen_fd < 0) {\n\t\tperror(\"socket\");\n\t\tgoto try6;\n\t}\n\n\tret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR,\n\t    (char *)&one, sizeof(one));\n\tif (ret < 0) {\n\t\tperror(\"setsockopt\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = bind(listen_fd, (struct sockaddr *) &client, sizeof(client));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = listen(listen_fd, 2);\n\tif (ret < 0) {\n\t\tperror(\"listen\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\ttry6:\n#ifdef AF_INET6\n\tif (!getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tstruct sockaddr_in6 sin;\n\t\tint one = 1, sock = -1;\n\n\t\tsock = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket6\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 SO_REUSEADDR\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 IPV6_V6ONLY\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n#endif\n\n\t\tmemset((char *)&sin, 0, sizeof(sin));\n\t\tsin.sin6_family = AF_INET6;\n\n\t\tif (listen_port < 0) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t\tsin.sin6_port = htons(-listen_port);\n\t\t} else {\n\t\t\tsin.sin6_addr = in6addr_any;\n\t\t\tsin.sin6_port = htons(listen_port);\n\t\t}\n\n\t\tif (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\t\tperror(\"bind6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (listen(sock, 2) < 0) {\n\t\t\tperror(\"listen6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfail:\n\t\tlisten_fd6 = sock;\n\t}\n#endif\n\n\tif (listen_fd < 0 && listen_fd6 < 0) {\n\t\tfprintf(stderr, \"%s: could not listen on port: %d\\n\",\n\t\t    prog, listen_port);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"%s: waiting for connection on port: %d\\n\",\n\t    prog, listen_port);\n\n\t/* wait for a connection: */\n\tFD_ZERO(&fds);\n\tif (listen_fd >= 0) {\n\t\tFD_SET(listen_fd, &fds);\n\t\tif (listen_fd > maxfd) {\n\t\t\tmaxfd = listen_fd;\n\t\t}\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tFD_SET(listen_fd6, &fds);\n\t\tif (listen_fd6 > maxfd) {\n\t\t\tmaxfd = listen_fd6;\n\t\t}\n\t}\n\tif (select(maxfd+1, &fds, NULL, NULL, NULL) <= 0) {\n\t\tperror(\"select\");\n\t\texit(1);\n\t}\n\n\tif (FD_ISSET(listen_fd, &fds)) {\n\t\tclen = sizeof(client);\n\t\tconn1 = accept(listen_fd, (struct sockaddr *) &client, &clen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t} else if (FD_ISSET(listen_fd6, &fds)) {\n#ifdef AF_INET6\n\t\tstruct sockaddr_in6 addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\n\t\tconn1 = accept(listen_fd6, (struct sockaddr *) &addr, &addrlen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept6\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tfprintf(stderr, \"No IPv6 / AF_INET6 support.\\n\");\n\t\texit(1);\n#endif\n\t}\n\n\tif (setsockopt(conn1, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t\texit(1);\n\t}\n\n\t/* done with the listening socket(s): */\n\tif (listen_fd >= 0) {\n\t\tclose(listen_fd);\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tclose(listen_fd6);\n\t}\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_BG\")) {\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\tfprintf(stderr, \"%s: putting child %d in background.\\n\",\n\t\t\t    prog, p);\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"%s: could not fork\\n\", prog);\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\tfprintf(stderr, \"%s: setsid failed\\n\", prog);\n\t\t\tperror(\"setsid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t}\n\n\tuse_stdio:\n\n\tfprintf(stderr, \"%s: got connection: %d\\n\", prog, conn1);\n\n\t/* now connect to remote server: */\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family = AF_INET;\n\tserver.sin_port = htons(connect_port);\n\n\tif ((server.sin_addr.s_addr = inet_addr(connect_host)) == htonl(INADDR_NONE)) {\n\t\tif (!(hp = gethostbyname(connect_host))) {\n\t\t\tperror(\"gethostbyname\");\n\t\t\tgoto tryconn6;\n\t\t}\n\t\tserver.sin_addr.s_addr = *(unsigned long *)hp->h_addr;\n\t}\n\n\tconn2 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (conn2 < 0) {\n\t\tperror(\"socket\");\n\t\tgoto tryconn6;\n\t}\n\n\tif (connect(conn2, (struct sockaddr *)&server, (sizeof(server))) < 0) {\n\t\tperror(\"connect\");\n\t\tgoto tryconn6;\n\t}\n\n\ttryconn6:\n#ifdef AF_INET6\n\tif (conn2 < 0 && !getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32];\n\n\t\tfprintf(stderr, \"connect[ipv6]: trying to connect via IPv6 to %s\\n\", connect_host);\n\t\tconn2 = -1;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", connect_port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\terr = getaddrinfo(connect_host, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint fd = -1;\n\t\t\t\tfd = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tperror(\"socket6\");\n\t\t\t\t} else {\n\t\t\t\t\tint dmsg = 0; \n\t\t\t\t\tint res = connect(fd, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\tperror(\"connect6\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\tfprintf(stderr, \"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(fd, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tconn2 = fd; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) perror(\"connect6\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t}\n#endif\n\tif (conn2 < 0) {\n\t\tfprintf(stderr, \"could not connect to %s\\n\", connect_host);\n\t\texit(1);\n\t}\n\tif (conn2 >= 0 && setsockopt(conn2, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t}\n\n\tuse_input_fds:\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tshow_cert(conn2);\n\t\tclose(conn2);\n\t\texit(0);\n\t}\n\n\tif (securevnc) {\n\t\tsecurevnc_setup(conn1, conn2);\n\t}\n\n\t/* fork into two processes; one for each direction: */\n\tparent = getpid();\n\t\n\tchild = fork();\n\t\n\tif (child == (pid_t) -1) {\n\t\t/* couldn't fork... */\n\t\tperror(\"fork\");\n\t\tclose(conn1);\n\t\tclose(conn2);\n\t\texit(1);\n\t}\n\n\t/* Do transfer/encode/decode loop: */\n\n\tif (child == 0) {\n\t\t/* encrypter: local-viewer -> remote-server */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn1, conn2);\n\t\t} else {\n\t\t\tenc_xfer(conn1, conn2, 1);\n\t\t}\n\t} else {\n\t\t/* decrypter: remote-server -> local-viewer */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn2, conn1);\n\t\t} else {\n\t\t\tenc_xfer(conn2, conn1, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SOL_IPV6 IPPROTO_IPV6",
            "#define INADDR_NONE ((in_addr_t) 0xffffffff)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SOL_IPV6 IPPROTO_IPV6\n#define INADDR_NONE ((in_addr_t) 0xffffffff)\n\nstatic void enc_connections(int listen_port, char *connect_host, int connect_port) {\n\tint listen_fd = -1, listen_fd6 = -1, conn1 = -1, conn2 = -1, ret, one = 1;\n\tsocklen_t clen;\n\tstruct hostent *hp;\n\tstruct sockaddr_in client, server;\n\tfd_set fds;\n\tint maxfd = -1;\n\n\t/* zero means use stdio (preferably from socketpair()) */\n\tif (listen_port == 0) {\n\t\tconn1 = fileno(stdin);\n\t\tgoto use_stdio;\n\t}\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto use_stdio;\n\t}\n\n\t/* fd=n,m means use the supplied already established sockets */\n\tif (sscanf(connect_host, \"fd=%d,%d\", &conn1, &conn2) == 2) {\n\t\tgoto use_input_fds;\n\t}\n\n\t/* create the listening socket: */\n\tmemset(&client, 0, sizeof(client));\n\tclient.sin_family = AF_INET;\n\tif (listen_port < 0) {\n\t\t/* negative port means use loopback */\n\t\tclient.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tclient.sin_port = htons(-listen_port);\n\t} else {\n\t\tclient.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\tclient.sin_port = htons(listen_port);\n\t}\n\n\tlisten_fd = socket(AF_INET, SOCK_STREAM, 0); \n\tif (listen_fd < 0) {\n\t\tperror(\"socket\");\n\t\tgoto try6;\n\t}\n\n\tret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR,\n\t    (char *)&one, sizeof(one));\n\tif (ret < 0) {\n\t\tperror(\"setsockopt\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = bind(listen_fd, (struct sockaddr *) &client, sizeof(client));\n\tif (ret < 0) {\n\t\tperror(\"bind\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\tret = listen(listen_fd, 2);\n\tif (ret < 0) {\n\t\tperror(\"listen\");\n\t\tclose(listen_fd);\n\t\tlisten_fd = -1;\n\t\tgoto try6;\n\t}\n\n\ttry6:\n#ifdef AF_INET6\n\tif (!getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tstruct sockaddr_in6 sin;\n\t\tint one = 1, sock = -1;\n\n\t\tsock = socket(AF_INET6, SOCK_STREAM, 0);\n\t\tif (sock < 0) {\n\t\t\tperror(\"socket6\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 SO_REUSEADDR\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\t\tperror(\"setsockopt6 IPV6_V6ONLY\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n#endif\n\n\t\tmemset((char *)&sin, 0, sizeof(sin));\n\t\tsin.sin6_family = AF_INET6;\n\n\t\tif (listen_port < 0) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t\tsin.sin6_port = htons(-listen_port);\n\t\t} else {\n\t\t\tsin.sin6_addr = in6addr_any;\n\t\t\tsin.sin6_port = htons(listen_port);\n\t\t}\n\n\t\tif (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\t\tperror(\"bind6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (listen(sock, 2) < 0) {\n\t\t\tperror(\"listen6\");\n\t\t\tclose(sock);\n\t\t\tsock = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfail:\n\t\tlisten_fd6 = sock;\n\t}\n#endif\n\n\tif (listen_fd < 0 && listen_fd6 < 0) {\n\t\tfprintf(stderr, \"%s: could not listen on port: %d\\n\",\n\t\t    prog, listen_port);\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"%s: waiting for connection on port: %d\\n\",\n\t    prog, listen_port);\n\n\t/* wait for a connection: */\n\tFD_ZERO(&fds);\n\tif (listen_fd >= 0) {\n\t\tFD_SET(listen_fd, &fds);\n\t\tif (listen_fd > maxfd) {\n\t\t\tmaxfd = listen_fd;\n\t\t}\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tFD_SET(listen_fd6, &fds);\n\t\tif (listen_fd6 > maxfd) {\n\t\t\tmaxfd = listen_fd6;\n\t\t}\n\t}\n\tif (select(maxfd+1, &fds, NULL, NULL, NULL) <= 0) {\n\t\tperror(\"select\");\n\t\texit(1);\n\t}\n\n\tif (FD_ISSET(listen_fd, &fds)) {\n\t\tclen = sizeof(client);\n\t\tconn1 = accept(listen_fd, (struct sockaddr *) &client, &clen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\t} else if (FD_ISSET(listen_fd6, &fds)) {\n#ifdef AF_INET6\n\t\tstruct sockaddr_in6 addr;\n\t\tsocklen_t addrlen = sizeof(addr);\n\n\t\tconn1 = accept(listen_fd6, (struct sockaddr *) &addr, &addrlen);\n\t\tif (conn1 < 0) {\n\t\t\tperror(\"accept6\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tfprintf(stderr, \"No IPv6 / AF_INET6 support.\\n\");\n\t\texit(1);\n#endif\n\t}\n\n\tif (setsockopt(conn1, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t\texit(1);\n\t}\n\n\t/* done with the listening socket(s): */\n\tif (listen_fd >= 0) {\n\t\tclose(listen_fd);\n\t}\n\tif (listen_fd6 >= 0) {\n\t\tclose(listen_fd6);\n\t}\n\n\tif (getenv(\"ULTRAVNC_DSM_HELPER_BG\")) {\n\t\tint p, n;\n\t\tif ((p = fork()) > 0)  {\n\t\t\tfprintf(stderr, \"%s: putting child %d in background.\\n\",\n\t\t\t    prog, p);\n\t\t\texit(0);\n\t\t} else if (p == -1) {\n\t\t\tfprintf(stderr, \"%s: could not fork\\n\", prog);\n\t\t\tperror(\"fork\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setsid() == -1) {\n\t\t\tfprintf(stderr, \"%s: setsid failed\\n\", prog);\n\t\t\tperror(\"setsid\");\n\t\t\texit(1);\n\t\t}\n\t\t/* adjust our stdio */\n\t\tn = open(\"/dev/null\", O_RDONLY);\n\t\tdup2(n, 0);\n\t\tdup2(n, 1);\n\t\tdup2(n, 2);\n\t\tif (n > 2) {\n\t\t\tclose(n);\n\t\t}\n\t}\n\n\tuse_stdio:\n\n\tfprintf(stderr, \"%s: got connection: %d\\n\", prog, conn1);\n\n\t/* now connect to remote server: */\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family = AF_INET;\n\tserver.sin_port = htons(connect_port);\n\n\tif ((server.sin_addr.s_addr = inet_addr(connect_host)) == htonl(INADDR_NONE)) {\n\t\tif (!(hp = gethostbyname(connect_host))) {\n\t\t\tperror(\"gethostbyname\");\n\t\t\tgoto tryconn6;\n\t\t}\n\t\tserver.sin_addr.s_addr = *(unsigned long *)hp->h_addr;\n\t}\n\n\tconn2 = socket(AF_INET, SOCK_STREAM, 0);\n\tif (conn2 < 0) {\n\t\tperror(\"socket\");\n\t\tgoto tryconn6;\n\t}\n\n\tif (connect(conn2, (struct sockaddr *)&server, (sizeof(server))) < 0) {\n\t\tperror(\"connect\");\n\t\tgoto tryconn6;\n\t}\n\n\ttryconn6:\n#ifdef AF_INET6\n\tif (conn2 < 0 && !getenv(\"ULTRAVNC_DSM_HELPER_NOIPV6\")) {\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32];\n\n\t\tfprintf(stderr, \"connect[ipv6]: trying to connect via IPv6 to %s\\n\", connect_host);\n\t\tconn2 = -1;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", connect_port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\terr = getaddrinfo(connect_host, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\tfprintf(stderr, \"getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint fd = -1;\n\t\t\t\tfd = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tperror(\"socket6\");\n\t\t\t\t} else {\n\t\t\t\t\tint dmsg = 0; \n\t\t\t\t\tint res = connect(fd, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\tperror(\"connect6\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\tfprintf(stderr, \"connect[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(fd, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tconn2 = fd; \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) perror(\"connect6\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n\t}\n#endif\n\tif (conn2 < 0) {\n\t\tfprintf(stderr, \"could not connect to %s\\n\", connect_host);\n\t\texit(1);\n\t}\n\tif (conn2 >= 0 && setsockopt(conn2, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one)) < 0) {\n\t\tperror(\"setsockopt TCP_NODELAY\");\n\t}\n\n\tuse_input_fds:\n\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tshow_cert(conn2);\n\t\tclose(conn2);\n\t\texit(0);\n\t}\n\n\tif (securevnc) {\n\t\tsecurevnc_setup(conn1, conn2);\n\t}\n\n\t/* fork into two processes; one for each direction: */\n\tparent = getpid();\n\t\n\tchild = fork();\n\t\n\tif (child == (pid_t) -1) {\n\t\t/* couldn't fork... */\n\t\tperror(\"fork\");\n\t\tclose(conn1);\n\t\tclose(conn2);\n\t\texit(1);\n\t}\n\n\t/* Do transfer/encode/decode loop: */\n\n\tif (child == 0) {\n\t\t/* encrypter: local-viewer -> remote-server */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn1, conn2);\n\t\t} else {\n\t\t\tenc_xfer(conn1, conn2, 1);\n\t\t}\n\t} else {\n\t\t/* decrypter: remote-server -> local-viewer */\n\t\tif (!strcmp(cipher, \"none\") || !strcmp(cipher, \"relay\")) {\n\t\t\tenc_raw_xfer(conn2, conn1);\n\t\t} else {\n\t\t\tenc_xfer(conn2, conn1, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_poll",
          "args": [],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "keydata",
            "tmp",
            "len"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "keydata",
            "0",
            "sizeof(keydata)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"xxx bit\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keydata",
            "\" 40 bit\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keydata",
            "\" 56 bit\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keydata",
            "\"128 bit\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s, could not read key file.\\n\"",
            "prog"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"read\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "keydata",
            "(size_t) sb.st_size"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"open\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "keyfile",
            "O_RDONLY"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: key file too big.\\n\"",
            "prog"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"stat\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pw=\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "keyfile"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"pw=\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "keyfile",
            "&sb"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "keyfile",
            "\"none\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"showcert\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cipher",
            "\"none\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "keydata",
            "0",
            "sizeof(keydata)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "rhp"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "rhp",
            "':'"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "lport"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: invalid salt size: %d\\n\"",
            "prog",
            "s"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d\"",
            "&s"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: invalid IV size: %d\\n\"",
            "prog",
            "v"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: invalid salt size: %d\\n\"",
            "prog",
            "s"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"%d,%d\"",
            "&s",
            "&v"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"ripemd160+\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_ripemd160",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ripemd160+\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"ripe+\""
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_ripemd160",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ripe+\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sha1+\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha1",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sha1+\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"sha+\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"sha+\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"md5+\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_md5",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"md5+\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "'@'"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha1",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_md5",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_128_ofb",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"securevnc.\""
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_des_ede3_cfb",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"3des.key\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_bf_cfb",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"blowfish.key\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_256_cfb",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"aes256.key\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_128_cfb",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"aes-cfb.key\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_128_ofb",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"aesv2.key\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"rc4.key\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "keyfile",
            "\"arc4.key\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\".\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"showcert\""
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"relay\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"none\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_128_ofb",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"securevnc\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_des_ede3_cfb",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"3des\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_bf_cfb",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"blowfish\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_256_cfb",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"aes256\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_128_cfb",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"aes-cfb\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_128_ofb",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"aes-ofb\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"aesv2\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"arc4\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "q",
            "\"msrc4_sc\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_rc4",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "q",
            "\"msrc4\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"rev:\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"rev:\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"noultra:\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"noultra:\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SALT 16\n\nextern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\n\tstruct stat sb;\n\tchar *q, *p, *connect_host;\n\tchar tmp[16];\n\tint fd, len = 0, listen_port = 0, connect_port, mbits;\n\n\tq = ciph;\n\n\t/* check for noultra mode: */\n\tif (strstr(q, \"noultra:\") == q) {\n\t\tnoultra = 1;\n\t\tq += strlen(\"noultra:\");\n\t}\n\n\t/* check for reverse mode: */\n\tif (strstr(q, \"rev:\") == q) {\n\t\treverse = 1;\n\t\tq += strlen(\"rev:\");\n\t}\n\n\t/* work out which cipher and set Cipher to the selected one. */\n\tif (!strcasecmp(q, \"msrc4\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t} else if (!strcasecmp(q, \"msrc4_sc\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\t\tmsrc4_sc = 1;\t\t\t/* no salt/iv workaround */\n\n\t} else if (strstr(q, \"arc4\") == q) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t} else if (strstr(q, \"aesv2\") == q || strstr(q, \"aes-ofb\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t} else if (strstr(q, \"aes-cfb\") == q) {\n\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t} else if (strstr(q, \"aes256\") == q) {\n\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t} else if (strstr(q, \"blowfish\") == q) {\n\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t} else if (strstr(q, \"3des\") == q) {\n\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t} else if (strstr(q, \"securevnc\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\tsecurevnc = 1;\n\n\t} else if (strstr(q, \"none\") == q || strstr(q, \"relay\") == q) {\n\t\tcipher = \"none\";\n\n\t} else if (strstr(q, \"showcert\") == q) {\n\t\tcipher = \"showcert\";\n\n\t} else if (strstr(q, \".\") == q) {\n\t\t/* otherwise, try to guess cipher from key filename: */\n\t\tif (strstr(keyfile, \"arc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t\t} else if (strstr(keyfile, \"rc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t\t} else if (strstr(keyfile, \"aesv2.key\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t\t} else if (strstr(keyfile, \"aes-cfb.key\")) {\n\t\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t\t} else if (strstr(keyfile, \"aes256.key\")) {\n\t\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t\t} else if (strstr(keyfile, \"blowfish.key\")) {\n\t\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t\t} else if (strstr(keyfile, \"3des.key\")) {\n\t\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t\t} else if (strstr(keyfile, \"securevnc.\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\t\tsecurevnc = 1;\n\n\t\t} else {\n\t\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\texit(1);\n\t}\n\n\t/* set the default message digest (md5) */\n\tif (!securevnc) {\n\t\tDigest = EVP_md5();\n\t} else {\n\t\tDigest = EVP_sha1();\n\t}\n\n\t/*\n\t * Look for user specified salt and IV sizes at the end\n\t * ( ciph@salt,iv and ciph@[md+]salt,iv ):\n\t */\n\tp = strchr(q, '@');\n\tif (p) {\n\t\tint s, v;\n\t\tp++;\n\t\tif (strstr(p, \"md5+\") == p) {\n\t\t\tDigest = EVP_md5();        p += strlen(\"md5+\");\n#if OPENSSL_VERSION_NUMBER < 0x10100000L && !defined OPENSSL_NO_SHA0\n\t\t} else if (strstr(p, \"sha+\") == p) {\n\t\t\tDigest = EVP_sha();        p += strlen(\"sha+\");\n#endif\n\t\t} else if (strstr(p, \"sha1+\") == p) {\n\t\t\tDigest = EVP_sha1();       p += strlen(\"sha1+\");\n\t\t} else if (strstr(p, \"ripe+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripe+\");\n\t\t} else if (strstr(p, \"ripemd160+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripemd160+\");\n\t\t}\n\t\tif (sscanf(p, \"%d,%d\", &s, &v) == 2) {\n\t\t\t/* cipher@n,m */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (0 <= v && v <= EVP_MAX_IV_LENGTH) {\n\t\t\t\tivec_size = v;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid IV size: %d\\n\",\n\t\t\t\t    prog, v);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (sscanf(p, \"%d\", &s) == 1) {\n\t\t\t/* cipher@n */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (salt_size == -1) {\n\t\t\t/* let salt = -1 mean skip both MD5 and salt */\n\t\t\tnomd = 1;\n\t\t\tsalt_size = 0;\n\t\t}\n\t}\n\n\t/* port to listen on (0 => stdio, negative => localhost) */\n\tif (lport != NULL) {\n\t\tlisten_port = atoi(lport);\n\t}\n\n\t/* extract remote hostname and port */\n\tq = strrchr(rhp, ':');\n\tif (q) {\n\t\tconnect_port = atoi(q+1);\n\t\t*q = '\\0';\n\t} else {\n\t\t/* otherwise guess VNC display 0 ... */\n\t\tconnect_port = 5900;\n\t}\n\tconnect_host = strdup(rhp);\n\n\t/* check for and read in the key file */\n\tmemset(keydata, 0, sizeof(keydata));\n\n\tif (!strcmp(cipher, \"none\")) {\n\t\tgoto readed_in;\n\t}\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto readed_in;\n\t}\n\n\tif (securevnc) {\n\t\t/* note the keyfile for rsa verification later */\n\t\tif (keyfile != NULL && strcasecmp(keyfile, \"none\")) {\n\t\t\tsecurevnc_file = keyfile;\n\t\t}\n\t\tgoto readed_in;\n\t}\n\n\tif (stat(keyfile, &sb) != 0) {\n\t\tif (strstr(keyfile, \"pw=\") == keyfile) {\n\t\t\t/* user specified key/password on cmdline */\n\t\t\tint i;\n\t\t\tlen = 0;\n\t\t\tpw_in = 1;\n\t\t\tfor (i=0; i < (int) strlen(keyfile); i++) {\n\t\t\t\t/* load the string to keydata: */\n\t\t\t\tint n = i + strlen(\"pw=\");\n\t\t\t\tkeydata[i] = keyfile[n];\n\t\t\t\tif (keyfile[n] == '\\0') break;\n\t\t\t\tlen++;\n\t\t\t\tif (i > 100) break;\n\t\t\t}\n\t\t\tgoto readed_in;\n\t\t}\n\t\t/* otherwise invalid file */\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tif (sb.st_size > 1024) {\n\t\tfprintf(stderr, \"%s: key file too big.\\n\", prog);\n\t\texit(1);\n\t}\n\tfd = open(keyfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\texit(1);\n\t}\n\n\t/* read it all in */\n\tlen = (int) read(fd, keydata, (size_t) sb.st_size);\n\tif (len != sb.st_size) {\n\t\tperror(\"read\");\n\t\tfprintf(stderr, \"%s, could not read key file.\\n\", prog);\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\treaded_in:\n\n\n\t/* check for ultravnc msrc4 format 'rc4.key' */\n\tmbits = 0;\n\tif (strstr(keydata, \"128 bit\") == keydata) {\n\t\tmbits = 128;\n\t} else if (strstr(keydata, \" 56 bit\") == keydata) {\n\t\tmbits = 56;\n\t} else if (strstr(keydata, \" 40 bit\") == keydata) {\n\t\tmbits = 40;\n\t}\n\tif (mbits > 0) {\n\t\t/* 4 is for int key length, 12 is for BLOBHEADER. */\n\t\tint i, offset = strlen(\"xxx bit\") + 4 + 12;\n\n\t\t/* the key is stored in reverse order! */\n\t\tlen = mbits/8;\n\t\tfor (i=0; i < len; i++) {\n\t\t\ttmp[i] = keydata[offset + len - i - 1];\n\t\t}\n\n\t\t/* clear keydata and then copy the reversed bytes there: */\n\t\tmemset(keydata, 0, sizeof(keydata));\n\t\tmemcpy(keydata, tmp, len);\n\t}\n\n\tkeydata_len = len;\n\n\t/* initialize random */\n\tRAND_poll();\n\n\t/*\n\t * Setup connections, then transfer data when they are all\n\t * hooked up.\n\t */\n\tenc_connections(listen_port, connect_host, connect_port);\n}"
  },
  {
    "function_name": "enc_do",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
    "lines": "326-329",
    "snippet": "extern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\tfprintf(stderr, \"%s: not compiled with OpenSSL\\n\", prog);\n\texit(1);\n}",
    "includes": [
      "#  include \"dbg.h\"",
      "#include <openssl/rsa.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/rand.h>",
      "#include <openssl/evp.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <fcntl.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "sslexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "1247-1250",
          "snippet": "static void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic void sslexit(char *msg) {\n\tfprintf(stderr, \"%s: %s\\n\", msg, ERR_error_string(ERR_get_error(), NULL));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: not compiled with OpenSSL\\n\"",
            "prog"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nextern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\tfprintf(stderr, \"%s: not compiled with OpenSSL\\n\", prog);\n\texit(1);\n}"
  }
]