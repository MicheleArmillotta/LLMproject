[
  {
    "function_name": "check_new_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "4374-4495",
    "snippet": "void check_new_clients(void) {\n\tstatic int last_count = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint i, send_info = 0;\n\tint run_after_accept = 0;\n\n\tif (unixpw_in_progress) {\n\t\tstatic double lping = 0.0;\n\t\tif (lping < dnow() + 5) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlping = dnow();\n\t\t}\n\t\tif (unixpw_client && unixpw_client->viewOnly) {\n\t\t\tunixpw_login_viewonly = 1;\n\t\t\tunixpw_client->viewOnly = FALSE;\n\t\t}\n\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\tunixpw_deny();\n\t\t}\n\t\treturn;\n\t}\n\n\tif (grab_always) {\n\t\t;\n\t} else if (grab_kbd || grab_ptr) {\n\t\tstatic double last_force = 0.0;\n\t\tif (client_count != last_count || dnow() > last_force + 0.25) {\n\t\t\tint q = (client_count == last_count);\n\t\t\tlast_force = dnow();\n\t\t\tX_LOCK;\n\t\t\tif (client_count) {\n\t\t\t\tadjust_grabs(1, q);\n\t\t\t} else {\n\t\t\t\tadjust_grabs(0, q);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n\t\n\tif (last_count == -1) {\n\t\tlast_count = 0;\n\t} else if (client_count == last_count) {\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\treturn;\n\t}\n\n\tif (client_count > last_count) {\n\t\tif (afteraccept_cmd != NULL && afteraccept_cmd[0] != '\\0') {\n\t\t\trun_after_accept = 1;\n\t\t}\n\t}\n\n\tlast_count = client_count;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tif (! client_count) {\n\t\tsend_client_info(\"clients:none\");\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *s;\n\n\t\tclient_set_net(cl);\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cd->login_viewonly < 0) {\n\t\t\t/* this is a general trigger to initialize things */\n\t\t\tif (cl->viewOnly) {\n\t\t\t\tcd->login_viewonly = 1;\n\t\t\t\ts = allowed_input_view_only;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd->login_viewonly = 0;\n\t\t\t\ts = allowed_input_normal;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (run_after_accept) {\n\t\t\t\trun_user_command(afteraccept_cmd, cl,\n\t\t\t\t    \"afteraccept\", NULL, 0, NULL);\n\t\t\t}\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (icon_mode_fh) {\n\t\tsend_info++;\n\t}\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (send_info || icon_mode_socks[i] >= 0) {\n\t\t\tsend_info++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (send_info) {\n\t\tchar *str, *s = list_clients();\n\t\tstr = (char *) malloc(strlen(\"clients:\") + strlen(s) + 1);\n\t\tsprintf(str, \"clients:%s\", s);\n\t\tsend_client_info(str);\n\t\tfree(str);\n\t\tfree(s);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int all_clients_initialized(void);",
      "char *list_clients(void);",
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "void check_new_clients(void);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 4493
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_client_info",
          "args": [
            "str"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "send_client_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "4281-4333",
          "snippet": "void send_client_info(char *str) {\n\tint i;\n\tstatic char *pstr = NULL;\n\tstatic int len = 128; \n\n\tif (!str || strlen(str) == 0) {\n\t\treturn;\n\t}\n\n\tif (!pstr)  {\n\t\tpstr = (char *)malloc(len);\n\t}\n\tif (strlen(str) + 2 > (size_t) len) {\n\t\tfree(pstr);\n\t\tlen *= 2;\n\t\tpstr = (char *)malloc(len);\n\t}\n\tstrcpy(pstr, str);\n\tstrcat(pstr, \"\\n\");\n\n\tif (icon_mode_fh) {\n\t\tif (0) fprintf(icon_mode_fh, \"\\n\");\n\t\tfprintf(icon_mode_fh, \"%s\", pstr);\n\t\tfflush(icon_mode_fh);\n\t}\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tint len, n, sock = icon_mode_socks[i];\n\t\tchar *buf = pstr;\n\n\t\tif (sock < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = strlen(pstr);\n\t\twhile (len > 0) {\n\t\t\tif (0) write(sock, \"\\n\", 1);\n\t\t\tn = write(sock, buf, len);\n\t\t\tif (n > 0) {\n\t\t\t\tbuf += n;\n\t\t\t\tlen -= n;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (n < 0 && errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(sock);\n\t\t\ticon_mode_socks[i] = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid send_client_info(char *str) {\n\tint i;\n\tstatic char *pstr = NULL;\n\tstatic int len = 128; \n\n\tif (!str || strlen(str) == 0) {\n\t\treturn;\n\t}\n\n\tif (!pstr)  {\n\t\tpstr = (char *)malloc(len);\n\t}\n\tif (strlen(str) + 2 > (size_t) len) {\n\t\tfree(pstr);\n\t\tlen *= 2;\n\t\tpstr = (char *)malloc(len);\n\t}\n\tstrcpy(pstr, str);\n\tstrcat(pstr, \"\\n\");\n\n\tif (icon_mode_fh) {\n\t\tif (0) fprintf(icon_mode_fh, \"\\n\");\n\t\tfprintf(icon_mode_fh, \"%s\", pstr);\n\t\tfflush(icon_mode_fh);\n\t}\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tint len, n, sock = icon_mode_socks[i];\n\t\tchar *buf = pstr;\n\n\t\tif (sock < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = strlen(pstr);\n\t\twhile (len > 0) {\n\t\t\tif (0) write(sock, \"\\n\", 1);\n\t\t\tn = write(sock, buf, len);\n\t\t\tif (n > 0) {\n\t\t\t\tbuf += n;\n\t\t\t\tlen -= n;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (n < 0 && errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(sock);\n\t\t\ticon_mode_socks[i] = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"clients:%s\"",
            "s"
          ],
          "line": 4490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"clients:\") + strlen(s) + 1"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"clients:\""
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_clients",
          "args": [],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "list_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "144-229",
          "snippet": "char *list_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *list, tmp[256];\n\tint count = 0;\n\n\tif (!screen) {\n\t\treturn strdup(\"\");\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tclient_set_net(cl);\n\t\tcount++;\n\t}\n\trfbReleaseClientIterator(iter);\n\n\t/*\n\t * each client:\n         * <id>:<ip>:<port>:<user>:<unix>:<hostname>:<input>:<loginview>:<time>,\n\t * 8+1+64+1+5+1+24+1+24+1+256+1+5+1+1+1+10+1\n\t * 123.123.123.123:60000/0x11111111-rw,\n\t * so count+1 * 1000 must cover it.\n\t */\n\tlist = (char *) malloc((count+1)*1000);\n\t\n\tlist[0] = '\\0';\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *tmp_host, *p;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*list != '\\0') {\n\t\t\tstrcat(list, \",\");\n\t\t}\n\t\tsprintf(tmp, \"0x%x:\", cd->uid);\n\t\tstrcat(list, tmp);\n\t\tp = tmp_host = strdup(cl->host);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d:\", cd->client_port);\n\t\tstrcat(list, tmp);\n\t\tif (cd->username[0] == '\\0') {\n\t\t\tchar *s = ident_username(cl);\n\t\t\tif (s) free(s);\n\t\t}\n\t\tif (strstr(cd->username, \"UNIX:\") == cd->username) {\n\t\t\tstrcat(list, cd->username + strlen(\"UNIX:\"));\n\t\t} else {\n\t\t\tstrcat(list, cd->username);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tif (cd->unixname[0] == '\\0') {\n\t\t\tstrcat(list, \"none\");\n\t\t} else {\n\t\t\tstrcat(list, cd->unixname);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tp = tmp_host = strdup(cd->hostname);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tstrcat(list, cd->input);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", cd->login_viewonly);\n\t\tstrcat(list, tmp);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", (int) cd->login_time);\n\t\tstrcat(list, tmp);\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn list;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *list_clients(void);",
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *list_clients(void);\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nchar *list_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *list, tmp[256];\n\tint count = 0;\n\n\tif (!screen) {\n\t\treturn strdup(\"\");\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tclient_set_net(cl);\n\t\tcount++;\n\t}\n\trfbReleaseClientIterator(iter);\n\n\t/*\n\t * each client:\n         * <id>:<ip>:<port>:<user>:<unix>:<hostname>:<input>:<loginview>:<time>,\n\t * 8+1+64+1+5+1+24+1+24+1+256+1+5+1+1+1+10+1\n\t * 123.123.123.123:60000/0x11111111-rw,\n\t * so count+1 * 1000 must cover it.\n\t */\n\tlist = (char *) malloc((count+1)*1000);\n\t\n\tlist[0] = '\\0';\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *tmp_host, *p;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*list != '\\0') {\n\t\t\tstrcat(list, \",\");\n\t\t}\n\t\tsprintf(tmp, \"0x%x:\", cd->uid);\n\t\tstrcat(list, tmp);\n\t\tp = tmp_host = strdup(cl->host);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d:\", cd->client_port);\n\t\tstrcat(list, tmp);\n\t\tif (cd->username[0] == '\\0') {\n\t\t\tchar *s = ident_username(cl);\n\t\t\tif (s) free(s);\n\t\t}\n\t\tif (strstr(cd->username, \"UNIX:\") == cd->username) {\n\t\t\tstrcat(list, cd->username + strlen(\"UNIX:\"));\n\t\t} else {\n\t\t\tstrcat(list, cd->username);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tif (cd->unixname[0] == '\\0') {\n\t\t\tstrcat(list, \"none\");\n\t\t} else {\n\t\t\tstrcat(list, cd->unixname);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tp = tmp_host = strdup(cd->hostname);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tstrcat(list, cd->input);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", cd->login_viewonly);\n\t\tstrcat(list, tmp);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", (int) cd->login_time);\n\t\tstrcat(list, tmp);\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "afteraccept_cmd",
            "cl",
            "\"afteraccept\"",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cd->input",
            "s",
            "CILEN"
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cd->input",
            "s",
            "CILEN"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_set_net",
          "args": [
            "cl"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "client_set_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3903-3920",
          "snippet": "void client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_clients_initialized",
          "args": [],
          "line": 4421
        },
        "resolved": true,
        "details": {
          "function_name": "all_clients_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "122-142",
          "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int all_clients_initialized(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_grabs",
          "args": [
            "0",
            "q"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_grabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "4335-4372",
          "snippet": "void adjust_grabs(int grab, int quiet) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\tif (!grab || !quiet) {}\n\treturn;\n#else\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (grab) {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing keyboard with XGrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXGrabKeyboard(dpy, window, False, GrabModeAsync,\n\t\t\t    GrabModeAsync, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing pointer with XGrabPointer\\n\");\n\t\t\t}\n\t\t\tXGrabPointer(dpy, window, False, 0, GrabModeAsync,\n\t\t\t    GrabModeAsync, None, None, CurrentTime);\n\t\t}\n\t} else {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing keyboard with XUngrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing pointer with XUngrabPointer\\n\");\n\t\t\t}\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void adjust_grabs(int grab, int quiet);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid adjust_grabs(int grab, int quiet);\n\nvoid adjust_grabs(int grab, int quiet) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\tif (!grab || !quiet) {}\n\treturn;\n#else\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (grab) {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing keyboard with XGrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXGrabKeyboard(dpy, window, False, GrabModeAsync,\n\t\t\t    GrabModeAsync, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing pointer with XGrabPointer\\n\");\n\t\t\t}\n\t\t\tXGrabPointer(dpy, window, False, 0, GrabModeAsync,\n\t\t\t    GrabModeAsync, None, None, CurrentTime);\n\t\t}\n\t} else {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing keyboard with XUngrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing pointer with XUngrabPointer\\n\");\n\t\t\t}\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4404
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixpw_deny",
          "args": [],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "2218-2258",
          "snippet": "void unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int unixpw_in_progress = 0;",
            "int unixpw_denied = 0;",
            "int unixpw_tightvnc_xfer_save = 0;",
            "rfbBool unixpw_file_xfer_save = FALSE;",
            "rfbClientPtr unixpw_client = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint unixpw_in_progress = 0;\nint unixpw_denied = 0;\nint unixpw_tightvnc_xfer_save = 0;\nrfbBool unixpw_file_xfer_save = FALSE;\nrfbClientPtr unixpw_client = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_deny(void) {\n\tint x, y, i;\n\tchar pd[] = \"Permission denied.\";\n\n\trfbLog(\"unixpw_deny: %d, %d\\n\", unixpw_denied, unixpw_in_progress);\n\tif (! unixpw_denied) {\n\t\tunixpw_denied = 1;\n\n\t\tchar_row += 2;\n\t\tchar_col = 0;\n\t\tx = char_x + char_col * char_w;\n\t\ty = char_y + char_row * char_h;\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, pd, white_pixel());\n\t\tunixpw_mark();\n\n\t\tfor (i=0; i<5; i++) {\n\t\t\trfbPE(-1);\n\t\t\trfbPE(-1);\n\t\t\tusleep(500 * 1000);\n\t\t}\n\t}\n\n\tif (unixpw_client) {\n\t\trfbCloseClient(unixpw_client);\n\t\trfbClientConnectionGone(unixpw_client);\n\t\trfbPE(-1);\n\t}\n\n\tunixpw_in_progress = 0;\n\t/* mutex */\n\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 2\\n\");\n                rfbRegisterTightVNCFileTransferExtension();\n#endif\n\t}\n\tunixpw_client = NULL;\n\tcopy_screen();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unixpw_deny: timed out waiting for reply.\\n\""
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 4391
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_connect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2631-2638",
          "snippet": "static void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define USE_TIMEOUT_INTERRUPT 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define USE_TIMEOUT_INTERRUPT 0\n\nstatic void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "0",
            "0",
            "1",
            "1",
            "1"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\nchar *list_clients(void);\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nvoid check_new_clients(void);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid check_new_clients(void) {\n\tstatic int last_count = -1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint i, send_info = 0;\n\tint run_after_accept = 0;\n\n\tif (unixpw_in_progress) {\n\t\tstatic double lping = 0.0;\n\t\tif (lping < dnow() + 5) {\n\t\t\tmark_rect_as_modified(0, 0, 1, 1, 1);\n\t\t\tlping = dnow();\n\t\t}\n\t\tif (unixpw_client && unixpw_client->viewOnly) {\n\t\t\tunixpw_login_viewonly = 1;\n\t\t\tunixpw_client->viewOnly = FALSE;\n\t\t}\n\t\tif (time(NULL) > unixpw_last_try_time + 45) {\n\t\t\trfbLog(\"unixpw_deny: timed out waiting for reply.\\n\");\n\t\t\tunixpw_deny();\n\t\t}\n\t\treturn;\n\t}\n\n\tif (grab_always) {\n\t\t;\n\t} else if (grab_kbd || grab_ptr) {\n\t\tstatic double last_force = 0.0;\n\t\tif (client_count != last_count || dnow() > last_force + 0.25) {\n\t\t\tint q = (client_count == last_count);\n\t\t\tlast_force = dnow();\n\t\t\tX_LOCK;\n\t\t\tif (client_count) {\n\t\t\t\tadjust_grabs(1, q);\n\t\t\t} else {\n\t\t\t\tadjust_grabs(0, q);\n\t\t\t}\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n\t\n\tif (last_count == -1) {\n\t\tlast_count = 0;\n\t} else if (client_count == last_count) {\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\treturn;\n\t}\n\n\tif (client_count > last_count) {\n\t\tif (afteraccept_cmd != NULL && afteraccept_cmd[0] != '\\0') {\n\t\t\trun_after_accept = 1;\n\t\t}\n\t}\n\n\tlast_count = client_count;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tif (! client_count) {\n\t\tsend_client_info(\"clients:none\");\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *s;\n\n\t\tclient_set_net(cl);\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cd->login_viewonly < 0) {\n\t\t\t/* this is a general trigger to initialize things */\n\t\t\tif (cl->viewOnly) {\n\t\t\t\tcd->login_viewonly = 1;\n\t\t\t\ts = allowed_input_view_only;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcl->viewOnly = FALSE;\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd->login_viewonly = 0;\n\t\t\t\ts = allowed_input_normal;\n\t\t\t\tif (s && cd->input[0] == '-') {\n\t\t\t\t\tcd->input[0] = '\\0';\n\t\t\t\t\tstrncpy(cd->input, s, CILEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (run_after_accept) {\n\t\t\t\trun_user_command(afteraccept_cmd, cl,\n\t\t\t\t    \"afteraccept\", NULL, 0, NULL);\n\t\t\t}\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (icon_mode_fh) {\n\t\tsend_info++;\n\t}\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (send_info || icon_mode_socks[i] >= 0) {\n\t\t\tsend_info++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (send_info) {\n\t\tchar *str, *s = list_clients();\n\t\tstr = (char *) malloc(strlen(\"clients:\") + strlen(s) + 1);\n\t\tsprintf(str, \"clients:%s\", s);\n\t\tsend_client_info(str);\n\t\tfree(str);\n\t\tfree(s);\n\t}\n}"
  },
  {
    "function_name": "adjust_grabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "4335-4372",
    "snippet": "void adjust_grabs(int grab, int quiet) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\tif (!grab || !quiet) {}\n\treturn;\n#else\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (grab) {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing keyboard with XGrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXGrabKeyboard(dpy, window, False, GrabModeAsync,\n\t\t\t    GrabModeAsync, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing pointer with XGrabPointer\\n\");\n\t\t\t}\n\t\t\tXGrabPointer(dpy, window, False, 0, GrabModeAsync,\n\t\t\t    GrabModeAsync, None, None, CurrentTime);\n\t\t}\n\t} else {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing keyboard with XUngrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing pointer with XUngrabPointer\\n\");\n\t\t\t}\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void adjust_grabs(int grab, int quiet);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XUngrabPointer",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 4368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ungrabbing pointer with XUngrabPointer\\n\""
          ],
          "line": 4366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUngrabKeyboard",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ungrabbing keyboard with XUngrabKeyboard\\n\""
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGrabPointer",
          "args": [
            "dpy",
            "window",
            "False",
            "0",
            "GrabModeAsync",
            "GrabModeAsync",
            "None",
            "None",
            "CurrentTime"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"grabbing pointer with XGrabPointer\\n\""
          ],
          "line": 4352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGrabKeyboard",
          "args": [
            "dpy",
            "window",
            "False",
            "GrabModeAsync",
            "GrabModeAsync",
            "CurrentTime"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"grabbing keyboard with XGrabKeyboard\\n\""
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid adjust_grabs(int grab, int quiet);\n\nvoid adjust_grabs(int grab, int quiet) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\tif (!grab || !quiet) {}\n\treturn;\n#else\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (grab) {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing keyboard with XGrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXGrabKeyboard(dpy, window, False, GrabModeAsync,\n\t\t\t    GrabModeAsync, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"grabbing pointer with XGrabPointer\\n\");\n\t\t\t}\n\t\t\tXGrabPointer(dpy, window, False, 0, GrabModeAsync,\n\t\t\t    GrabModeAsync, None, None, CurrentTime);\n\t\t}\n\t} else {\n\t\tif (grab_kbd) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing keyboard with XUngrabKeyboard\\n\");\n\t\t\t}\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t}\n\t\tif (grab_ptr) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"ungrabbing pointer with XUngrabPointer\\n\");\n\t\t\t}\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "send_client_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "4281-4333",
    "snippet": "void send_client_info(char *str) {\n\tint i;\n\tstatic char *pstr = NULL;\n\tstatic int len = 128; \n\n\tif (!str || strlen(str) == 0) {\n\t\treturn;\n\t}\n\n\tif (!pstr)  {\n\t\tpstr = (char *)malloc(len);\n\t}\n\tif (strlen(str) + 2 > (size_t) len) {\n\t\tfree(pstr);\n\t\tlen *= 2;\n\t\tpstr = (char *)malloc(len);\n\t}\n\tstrcpy(pstr, str);\n\tstrcat(pstr, \"\\n\");\n\n\tif (icon_mode_fh) {\n\t\tif (0) fprintf(icon_mode_fh, \"\\n\");\n\t\tfprintf(icon_mode_fh, \"%s\", pstr);\n\t\tfflush(icon_mode_fh);\n\t}\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tint len, n, sock = icon_mode_socks[i];\n\t\tchar *buf = pstr;\n\n\t\tif (sock < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = strlen(pstr);\n\t\twhile (len > 0) {\n\t\t\tif (0) write(sock, \"\\n\", 1);\n\t\t\tn = write(sock, buf, len);\n\t\t\tif (n > 0) {\n\t\t\t\tbuf += n;\n\t\t\t\tlen -= n;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (n < 0 && errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(sock);\n\t\t\ticon_mode_socks[i] = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 4328
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 4318
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pstr"
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "icon_mode_fh"
          ],
          "line": 4304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "icon_mode_fh",
            "\"%s\"",
            "pstr"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "icon_mode_fh",
            "\"\\n\""
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "pstr",
            "\"\\n\""
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "pstr",
            "str"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pstr"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 4293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid send_client_info(char *str) {\n\tint i;\n\tstatic char *pstr = NULL;\n\tstatic int len = 128; \n\n\tif (!str || strlen(str) == 0) {\n\t\treturn;\n\t}\n\n\tif (!pstr)  {\n\t\tpstr = (char *)malloc(len);\n\t}\n\tif (strlen(str) + 2 > (size_t) len) {\n\t\tfree(pstr);\n\t\tlen *= 2;\n\t\tpstr = (char *)malloc(len);\n\t}\n\tstrcpy(pstr, str);\n\tstrcat(pstr, \"\\n\");\n\n\tif (icon_mode_fh) {\n\t\tif (0) fprintf(icon_mode_fh, \"\\n\");\n\t\tfprintf(icon_mode_fh, \"%s\", pstr);\n\t\tfflush(icon_mode_fh);\n\t}\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tint len, n, sock = icon_mode_socks[i];\n\t\tchar *buf = pstr;\n\n\t\tif (sock < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = strlen(pstr);\n\t\twhile (len > 0) {\n\t\t\tif (0) write(sock, \"\\n\", 1);\n\t\t\tn = write(sock, buf, len);\n\t\t\tif (n > 0) {\n\t\t\t\tbuf += n;\n\t\t\t\tlen -= n;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (n < 0 && errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(sock);\n\t\t\ticon_mode_socks[i] = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "start_client_info_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "4206-4279",
    "snippet": "void start_client_info_sock(char *host_port_cookie) {\n\tchar *host = NULL, *cookie = NULL, *p;\n\tchar *str = strdup(host_port_cookie);\n\tint i, port, sock, next = -1;\n\tstatic time_t start_time[ICON_MODE_SOCKS];\n\ttime_t oldest = 0;\n\tint db = 0;\n\n\tport = -1;\n\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] < 0) {\n\t\t\tnext = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (oldest == 0 || start_time[i] < oldest) {\n\t\t\tnext = i;\n\t\t\toldest = start_time[i];\n\t\t}\n\t}\n\n\tp = strtok(str, \":\");\n\ti = 0;\n\twhile (p) {\n\t\tif (i == 0) {\n\t\t\thost = strdup(p);\n\t\t} else if (i == 1) {\n\t\t\tport = atoi(p);\n\t\t} else if (i == 2) {\n\t\t\tcookie = strdup(p);\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(str);\n\n\tif (db) fprintf(stderr, \"%s/%d/%s next=%d\\n\", host, port, cookie, next);\n\n\tif (host && port && cookie) {\n\t\tif (*host == '\\0') {\n\t\t\tfree(host);\n\t\t\thost = strdup(\"localhost\");\n\t\t}\n\t\tsock = connect_tcp(host, port);\n\t\tif (sock < 0) {\n\t\t\tusleep(200 * 1000);\n\t\t\tsock = connect_tcp(host, port);\n\t\t}\n\t\tif (sock >= 0) {\n\t\t\tchar *lst = list_clients();\n\t\t\ticon_mode_socks[next] = sock;\n\t\t\tstart_time[next] = time(NULL);\n\t\t\twrite(sock, \"COOKIE:\", strlen(\"COOKIE:\"));\n\t\t\twrite(sock, cookie, strlen(cookie));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, lst, strlen(lst));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\tif (db) {\n\t\t\t\tfprintf(stderr, \"list: %s\\n\", lst);\n\t\t\t}\n\t\t\tfree(lst);\n\t\t\trfbLog(\"client_info_sock to: %s:%d\\n\", host, port);\n\t\t} else {\n\t\t\trfbLog(\"failed client_info_sock: %s:%d\\n\", host, port);\n\t\t}\n\t} else {\n\t\trfbLog(\"malformed client_info_sock: %s\\n\", host_port_cookie);\t\n\t}\n\n\tif (host) free(host);\n\tif (cookie) free(cookie);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *list_clients(void);",
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void start_client_info_sock(char *host_port_cookie);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cookie"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"malformed client_info_sock: %s\\n\"",
            "host_port_cookie"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed client_info_sock: %s:%d\\n\"",
            "host",
            "port"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"client_info_sock to: %s:%d\\n\"",
            "host",
            "port"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"list: %s\\n\"",
            "lst"
          ],
          "line": 4266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock",
            "\"\\n\"",
            "strlen(\"\\n\")"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"\\n\""
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lst"
          ],
          "line": 4263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"none\\n\""
          ],
          "line": 4262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"none\\n\""
          ],
          "line": 4261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"\\n\""
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"COOKIE:\""
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 4257
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_connect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2631-2638",
          "snippet": "static void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define USE_TIMEOUT_INTERRUPT 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define USE_TIMEOUT_INTERRUPT 0\n\nstatic void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_clients",
          "args": [],
          "line": 4255
        },
        "resolved": true,
        "details": {
          "function_name": "list_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "144-229",
          "snippet": "char *list_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *list, tmp[256];\n\tint count = 0;\n\n\tif (!screen) {\n\t\treturn strdup(\"\");\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tclient_set_net(cl);\n\t\tcount++;\n\t}\n\trfbReleaseClientIterator(iter);\n\n\t/*\n\t * each client:\n         * <id>:<ip>:<port>:<user>:<unix>:<hostname>:<input>:<loginview>:<time>,\n\t * 8+1+64+1+5+1+24+1+24+1+256+1+5+1+1+1+10+1\n\t * 123.123.123.123:60000/0x11111111-rw,\n\t * so count+1 * 1000 must cover it.\n\t */\n\tlist = (char *) malloc((count+1)*1000);\n\t\n\tlist[0] = '\\0';\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *tmp_host, *p;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*list != '\\0') {\n\t\t\tstrcat(list, \",\");\n\t\t}\n\t\tsprintf(tmp, \"0x%x:\", cd->uid);\n\t\tstrcat(list, tmp);\n\t\tp = tmp_host = strdup(cl->host);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d:\", cd->client_port);\n\t\tstrcat(list, tmp);\n\t\tif (cd->username[0] == '\\0') {\n\t\t\tchar *s = ident_username(cl);\n\t\t\tif (s) free(s);\n\t\t}\n\t\tif (strstr(cd->username, \"UNIX:\") == cd->username) {\n\t\t\tstrcat(list, cd->username + strlen(\"UNIX:\"));\n\t\t} else {\n\t\t\tstrcat(list, cd->username);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tif (cd->unixname[0] == '\\0') {\n\t\t\tstrcat(list, \"none\");\n\t\t} else {\n\t\t\tstrcat(list, cd->unixname);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tp = tmp_host = strdup(cd->hostname);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tstrcat(list, cd->input);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", cd->login_viewonly);\n\t\tstrcat(list, tmp);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", (int) cd->login_time);\n\t\tstrcat(list, tmp);\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn list;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *list_clients(void);",
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *list_clients(void);\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nchar *list_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *list, tmp[256];\n\tint count = 0;\n\n\tif (!screen) {\n\t\treturn strdup(\"\");\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tclient_set_net(cl);\n\t\tcount++;\n\t}\n\trfbReleaseClientIterator(iter);\n\n\t/*\n\t * each client:\n         * <id>:<ip>:<port>:<user>:<unix>:<hostname>:<input>:<loginview>:<time>,\n\t * 8+1+64+1+5+1+24+1+24+1+256+1+5+1+1+1+10+1\n\t * 123.123.123.123:60000/0x11111111-rw,\n\t * so count+1 * 1000 must cover it.\n\t */\n\tlist = (char *) malloc((count+1)*1000);\n\t\n\tlist[0] = '\\0';\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *tmp_host, *p;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*list != '\\0') {\n\t\t\tstrcat(list, \",\");\n\t\t}\n\t\tsprintf(tmp, \"0x%x:\", cd->uid);\n\t\tstrcat(list, tmp);\n\t\tp = tmp_host = strdup(cl->host);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d:\", cd->client_port);\n\t\tstrcat(list, tmp);\n\t\tif (cd->username[0] == '\\0') {\n\t\t\tchar *s = ident_username(cl);\n\t\t\tif (s) free(s);\n\t\t}\n\t\tif (strstr(cd->username, \"UNIX:\") == cd->username) {\n\t\t\tstrcat(list, cd->username + strlen(\"UNIX:\"));\n\t\t} else {\n\t\t\tstrcat(list, cd->username);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tif (cd->unixname[0] == '\\0') {\n\t\t\tstrcat(list, \"none\");\n\t\t} else {\n\t\t\tstrcat(list, cd->unixname);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tp = tmp_host = strdup(cd->hostname);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tstrcat(list, cd->input);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", cd->login_viewonly);\n\t\tstrcat(list, tmp);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", (int) cd->login_time);\n\t\tstrcat(list, tmp);\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "host",
            "port"
          ],
          "line": 4252
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "200 * 1000"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"localhost\""
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s/%d/%s next=%d\\n\"",
            "host",
            "port",
            "cookie",
            "next"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\":\""
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host_port_cookie"
          ],
          "line": 4208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *list_clients(void);\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid start_client_info_sock(char *host_port_cookie);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid start_client_info_sock(char *host_port_cookie) {\n\tchar *host = NULL, *cookie = NULL, *p;\n\tchar *str = strdup(host_port_cookie);\n\tint i, port, sock, next = -1;\n\tstatic time_t start_time[ICON_MODE_SOCKS];\n\ttime_t oldest = 0;\n\tint db = 0;\n\n\tport = -1;\n\n\tfor (i = 0; i < ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] < 0) {\n\t\t\tnext = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (oldest == 0 || start_time[i] < oldest) {\n\t\t\tnext = i;\n\t\t\toldest = start_time[i];\n\t\t}\n\t}\n\n\tp = strtok(str, \":\");\n\ti = 0;\n\twhile (p) {\n\t\tif (i == 0) {\n\t\t\thost = strdup(p);\n\t\t} else if (i == 1) {\n\t\t\tport = atoi(p);\n\t\t} else if (i == 2) {\n\t\t\tcookie = strdup(p);\n\t\t}\n\t\ti++;\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(str);\n\n\tif (db) fprintf(stderr, \"%s/%d/%s next=%d\\n\", host, port, cookie, next);\n\n\tif (host && port && cookie) {\n\t\tif (*host == '\\0') {\n\t\t\tfree(host);\n\t\t\thost = strdup(\"localhost\");\n\t\t}\n\t\tsock = connect_tcp(host, port);\n\t\tif (sock < 0) {\n\t\t\tusleep(200 * 1000);\n\t\t\tsock = connect_tcp(host, port);\n\t\t}\n\t\tif (sock >= 0) {\n\t\t\tchar *lst = list_clients();\n\t\t\ticon_mode_socks[next] = sock;\n\t\t\tstart_time[next] = time(NULL);\n\t\t\twrite(sock, \"COOKIE:\", strlen(\"COOKIE:\"));\n\t\t\twrite(sock, cookie, strlen(cookie));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, \"none\\n\", strlen(\"none\\n\"));\n\t\t\twrite(sock, lst, strlen(lst));\n\t\t\twrite(sock, \"\\n\", strlen(\"\\n\"));\n\t\t\tif (db) {\n\t\t\t\tfprintf(stderr, \"list: %s\\n\", lst);\n\t\t\t}\n\t\t\tfree(lst);\n\t\t\trfbLog(\"client_info_sock to: %s:%d\\n\", host, port);\n\t\t} else {\n\t\t\trfbLog(\"failed client_info_sock: %s:%d\\n\", host, port);\n\t\t}\n\t} else {\n\t\trfbLog(\"malformed client_info_sock: %s\\n\", host_port_cookie);\t\n\t}\n\n\tif (host) free(host);\n\tif (cookie) free(cookie);\n}"
  },
  {
    "function_name": "new_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3924-4204",
    "snippet": "enum rfbNewClientAction new_client(rfbClientPtr client) {\n\tClientData *cd; \n\n\tCLIENT_LOCK;\n\n\tlast_event = last_input = time(NULL);\n\n\tlatest_client = client;\n\n\tif (inetd) {\n\t\t/* \n\t\t * Set this so we exit as soon as connection closes,\n\t\t * otherwise client_gone is only called after RFB_CLIENT_ACCEPT\n\t\t */\n\t\tif (inetd_client == NULL) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t}\n\n\tclients_served++;\n\n\tif (use_openssl || use_stunnel) {\n\t\tif (! ssl_initialized) {\n\t\t\trfbLog(\"denying additional client: %s ssl not setup\"\n\t\t\t    \" yet.\\n\", client->host);\n\t\t\tCLIENT_UNLOCK;\n\t\t\treturn(RFB_CLIENT_REFUSE);\n\t\t}\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"denying additional client: %s during -unixpw login.\\n\",\n\t\t     client->host);\n\t\tCLIENT_UNLOCK;\n\t\treturn(RFB_CLIENT_REFUSE);\n\t}\n\tif (connect_once) {\n\t\tif (screen->dontDisconnect && screen->neverShared) {\n\t\t\tif (! shared && accepted_client) {\n\t\t\t\trfbLog(\"denying additional client: %s:%d\\n\",\n\t\t\t\t     client->host, get_remote_port(client->sock));\n\t\t\t\tCLIENT_UNLOCK;\n\t\t\t\treturn(RFB_CLIENT_REFUSE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ipv6_client_ip_str != NULL) {\n\t\trfbLog(\"renaming client->host from '%s' to '%s'\\n\",\n\t\t    client->host ? client->host : \"\", ipv6_client_ip_str);\n\t\tif (client->host) {\n\t\t\tfree(client->host);\n\t\t}\n\t\tclient->host = strdup(ipv6_client_ip_str);\n\t}\n\n\tif (! check_access(client->host)) {\n\t\trfbLog(\"denying client: %s does not match %s\\n\", client->host,\n\t\t    allow_list ? allow_list : \"(null)\" );\n\t\tCLIENT_UNLOCK;\n\t\treturn(RFB_CLIENT_REFUSE);\n\t}\n\n        if(use_multipointer && xi2_device_creation_in_progress) {\n            rfbLog(\"denying additional client: %s during MD creation.\\n\", client->host);\n\t    CLIENT_UNLOCK;\n            return(RFB_CLIENT_REFUSE);\n        }\n\n\tclient->clientData = (void *) calloc(sizeof(ClientData), 1);\n\tcd = (ClientData *) client->clientData;\n\n\t/* see client_set_net() we delay the DNS lookups during handshake */\n\tcd->client_port = -1;\n\tcd->username = strdup(\"\");\n\tcd->unixname = strdup(\"\");\n\tcd->cursor_x_saved = cd->cursor_y_saved = -1;\n\n\tcd->input[0] = '-';\n\tcd->login_viewonly = -1;\n\tcd->login_time = time(NULL);\n\tcd->ssl_helper_pid = 0;\n\n\tif (use_openssl && openssl_last_helper_pid) {\n\t\tcd->ssl_helper_pid = openssl_last_helper_pid;\n\t\topenssl_last_helper_pid = 0;\n\t}\n\n\tif (! accept_client(client)) {\n\t\trfbLog(\"denying client: %s local user rejected connection.\\n\",\n\t\t    client->host);\n\t\trfbLog(\"denying client: accept_cmd=\\\"%s\\\"\\n\",\n\t\t    accept_cmd ? accept_cmd : \"(null)\" );\n\n\t\tfree_client_data(client);\n\n\t\tCLIENT_UNLOCK;\n\t\treturn(RFB_CLIENT_REFUSE);\n\t}\n\n\t/* We will RFB_CLIENT_ACCEPT or RFB_CLIENT_ON_HOLD from here on. */\n\n\tif (passwdfile) {\n\t\tif (strstr(passwdfile, \"read:\") == passwdfile ||\n\t\t    strstr(passwdfile, \"cmd:\") == passwdfile) {\n\t\t\tif (read_passwds(passwdfile)) {\n\t\t\t\tinstall_passwds();\n\t\t\t} else {\n\t\t\t\trfbLog(\"problem reading: %s\\n\", passwdfile);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else if (strstr(passwdfile, \"custom:\") == passwdfile) {\n\t\t\tif (screen) {\n\t\t\t\t/* mutex */\n\t\t\t\tscreen->passwordCheck = custom_passwd_check;\n\t\t\t}\n\t\t}\n\t}\n\n\tcd->uid = clients_served;\n\n        /*\n\t  create new XInput2 master device and add it it to client\n\t*/\n        if(use_multipointer)\n          {\n\t    char tmp[256];\n            snprintf(tmp, sizeof tmp, \"x11vnc %s\", client->host);\n\n            xi2_device_creation_in_progress = 1;\n\n\t    if((cd->ptr_id = createMD(dpy, tmp)) < 0) {\n\t      rfbLog(\"ERROR creating XInput2 MD for client %s, denying client.\\n\", client->host);\n\t      free_client_data(client);\n\t      xi2_device_creation_in_progress = 0;\n\t      CLIENT_UNLOCK;\n\t      return(RFB_CLIENT_REFUSE);\n\t    }\n\n            cd->kbd_id = getPairedMD(dpy, cd->ptr_id);\n\n            rfbLog(\"Created XInput2 MD %i %i for client %s.\\n\", cd->ptr_id, cd->kbd_id, client->host);\n\n            xi2_device_creation_in_progress = 0;\n\n            snprintf(tmp, sizeof tmp, \"%i\", cd->uid);\n\t    cd->cursor = setClientCursor(dpy, cd->ptr_id, 0.4*(cd->ptr_id%3), 0.2*(cd->ptr_id%5), 1*(cd->ptr_id%2), tmp);\n\t    if(!cd->cursor)\n              rfbLog(\"Setting cursor for client %s failed.\\n\", client->host);\n\n\t    cd->cursor_region = sraRgnCreate();\n          }\n\n\tclient->clientGoneHook = client_gone;\n\n\tif (client_count) {\n\t\tspeeds_net_rate_measured = 0;\n\t\tspeeds_net_latency_measured = 0;\n\t}\n\tclient_count++;\n\n\tlast_keyboard_input = last_pointer_input = time(NULL);\n\n\tif (no_autorepeat && client_count == 1 && ! view_only) {\n\t\t/*\n\t\t * first client, turn off X server autorepeat\n\t\t * XXX handle dynamic change of view_only and per-client.\n\t\t */\n\t\tautorepeat(0, 0);\n\t}\n#ifdef MACOSX\n\tif (macosx_console && client_count == 1) {\n\t\tmacosxCG_refresh_callback_on();\n\t}\n#endif\n\tif (use_solid_bg && client_count == 1) {\n\t\tsolid_bg(0);\n\t}\n\n\tif (pad_geometry) {\n\t\tinstall_padded_fb(pad_geometry);\n\t}\n\n\tcd->timer = last_new_client = dnow();\n\tcd->send_cmp_rate = 0.0;\n\tcd->send_raw_rate = 0.0;\n\tcd->latency = 0.0;\n\tcd->cmp_bytes_sent = 0;\n\tcd->raw_bytes_sent = 0;\n\n\taccepted_client++;\n\trfbLog(\"incr accepted_client=%d for %s:%d  sock=%d\\n\", accepted_client,\n\t    client->host, get_remote_port(client->sock), client->sock);\n\tlast_client = time(NULL);\n\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tif (advertise_truecolor && indexed_color) {\n\t\tint rs = 0, gs = 2, bs = 4;\n\t\tint rm = 3, gm = 3, bm = 3;\n\t\tif (bpp >= 24) {\n\t\t\trs = 0, gs = 8, bs = 16;\n\t\t\trm = 255, gm = 255, bm = 255;\n\t\t} else if (bpp >= 16) {\n\t\t\trs = 0, gs = 5, bs = 10;\n\t\t\trm = 31, gm = 31, bm = 31;\n\t\t}\n\t\trfbLog(\"advertising truecolor.\\n\");\n\t\tif (getenv(\"ADVERT_BMSHIFT\")) {\n\t\t\tbm--;\n\t\t}\n\n\t\tif (use_threads) LOCK(client->updateMutex);\n\n\t\tclient->format.trueColour = TRUE;\n\t\tclient->format.redShift   = rs;\n\t\tclient->format.greenShift = gs;\n\t\tclient->format.blueShift  = bs;\n\t\tclient->format.redMax     = rm;\n\t\tclient->format.greenMax   = gm;\n\t\tclient->format.blueMax    = bm;\n\n\t\tif (use_threads) UNLOCK(client->updateMutex);\n\n\t\trfbSetTranslateFunction(client);\n\n\t\t/* mutex */\n\t\tscreen->serverFormat.trueColour = TRUE;\n\t\tscreen->serverFormat.redShift   = rs;\n\t\tscreen->serverFormat.greenShift = gs;\n\t\tscreen->serverFormat.blueShift  = bs;\n\t\tscreen->serverFormat.redMax     = rm;\n\t\tscreen->serverFormat.greenMax   = gm;\n\t\tscreen->serverFormat.blueMax    = bm;\n\t\tscreen->displayHook = turn_off_truecolor_ad;\n\n\t\tturn_off_truecolor = 1;\n\t}\n\n\tif (unixpw) {\n\t\tunixpw_in_progress = 1;\n\t\tunixpw_client = client;\n\t\tunixpw_login_viewonly = 0;\n\n\t\tunixpw_file_xfer_save = screen->permitFileTransfer;\n\t\tscreen->permitFileTransfer = FALSE;\n\t\tunixpw_tightvnc_xfer_save = tightfilexfer;\n\t\ttightfilexfer = 0;\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 1\\n\");\n\t\trfbUnregisterTightVNCFileTransferExtension();\n#endif\n\n\t\tif (client->viewOnly) {\n\t\t\tunixpw_login_viewonly = 1;\n\t\t\tclient->viewOnly = FALSE;\n\t\t}\n\t\tunixpw_last_try_time = time(NULL) + 10;\n\n\t\tunixpw_screen(1);\n\t\tunixpw_keystroke(0, 0, 1);\n\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"new client: %s in non-unixpw_in_rfbPE.\\n\",\n\t\t\t     client->host);\n\t\t}\n\t\tCLIENT_UNLOCK;\n\t\tif (!use_threads) {\n\t\t\t/* always put client on hold even if unixpw_in_rfbPE is true */\n\t\t\treturn(RFB_CLIENT_ON_HOLD);\n\t\t} else {\n\t\t\t/* unixpw threads is still in testing mode, disabled by default. See UNIXPW_THREADS */\n\t\t\treturn(RFB_CLIENT_ACCEPT);\n\t\t}\n\t}\n\n\tCLIENT_UNLOCK;\n\treturn(RFB_CLIENT_ACCEPT);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbClientPtr inetd_client = NULL;",
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "int cmd_ok(char *cmd);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);",
      "static int accepted_client = 0;",
      "static int turn_off_truecolor = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"new client: %s in non-unixpw_in_rfbPE.\\n\"",
            "client->host"
          ],
          "line": 4189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_keystroke",
          "args": [
            "0",
            "0",
            "1"
          ],
          "line": 4186
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_keystroke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1666-2055",
          "snippet": "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init) {\n\tint x, y, i, rc, nmax = 100;\n\tstatic char user_r[100], user[100], pass[100];\n\tstatic int  u_cnt = 0, p_cnt = 0, t_cnt = 0, first = 1;\n\tstatic int echo = 1;\n\tchar keystr[100];\n\tchar *str;\n\n\tif (skip_it) {\n\t\treturn;\n\t}\n\n\tif (first) {\n\t\tset_db();\n\t\tfirst = 0;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t}\n\n\tif (init) {\n\t\tin_login = 1;\n\t\tin_passwd = 0;\n\t\tunixpw_denied = 0;\n\t\techo = 1;\n\t\tif (init == 1) {\n\t\t\ttries = 0;\n\t\t}\n\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tt_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t\tif (keep_unixpw_user) {\n\t\t\tfree(keep_unixpw_user);\n\t\t\tkeep_unixpw_user = NULL;\n\t\t}\n\t\tif (keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tfree(keep_unixpw_pass);\n\t\t\tkeep_unixpw_pass = NULL;\n\t\t}\n\t\tif (keep_unixpw_opts) {\n\t\t\tstrzero(keep_unixpw_opts);\n\t\t\tfree(keep_unixpw_opts);\n\t\t\tkeep_unixpw_opts = NULL;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (unixpw_denied) {\n\t\trfbLog(\"unixpw_keystroke: unixpw_denied state: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\tif (keysym <= 0) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym1: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\t/* rfbKeySym = uint32_t */\n\t/* KeySym = XID = CARD32 = (unsigned long or unsigned int on LONG64) */\n\tX_LOCK;\n\tstr = XKeysymToString(keysym);\n\tX_UNLOCK;\n\tif (str == NULL) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym2: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\trc = snprintf(keystr, sizeof keystr, \"%s\", str);\n\tif (rc < 1 || rc > 90) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym3: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"%s / %s  0x%x %s\\n\", in_login ? \"login\":\"pass \",\n\t\t    down ? \"down\":\"up  \", keysym, keystr);\n\t}\n\n\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t/* let \"up\" pass down below for Return case */\n\t\tif (down) {\n\t\t\treturn;\n\t\t}\n\t} else if (! down) {\n\t\treturn;\n\t}\n\tif (keysym == XK_F1) {\n\t\tchar h1[] = \"F1-Help:  For 'login:' type in the username and press Enter, then for 'Password:' enter the password.\";\n\t\tchar hf[] = \"  Once logged in, username's X session will be searched for and if found then attached to.\";\n\t\tchar hc[] = \"  Once logged in, username's X session is sought and attached to, otherwise a new session is created.\";\n\t\tchar hx[] = \"  Once logged in, username's X session is sought and attached to, otherwise a login greeter is presented.\";\n\t\tchar h2[] = \"  Specify options after a ':' like this:  username:opt,opt=val,...    Where an opt may be any of:\";\n\t\tchar h3[] = \"    scale=... (n/m); scale_cursor=... (sc=); solid (so); id=; repeat; clear_mods (cm); clear_keys (ck);\";\n\t\tchar h4[] = \"    clear_all (ca); speeds=... (sp=); readtimeout=... (rd=) rotate=... (ro=); noncache (nc) (nc=n);\";\n\t\tchar h5[] = \"    geom=WxHxD (ge=); nodisplay=... (nd=); viewonly (vo); tag=...; gnome kde twm fvwm mwm dtwm wmaker\";\n\t\tchar h6[] = \"    xfce lxde enlightenment Xsession failsafe.   Examples:  fred:3/4,so,cm  wilma:geom=1024x768x16,kde\";\n\t\tint ch = 13, p;\n\t\tif (!pscreen || pscreen->width < 640 || pscreen->height < 480) {\n\t\t\treturn;\n\t\t}\n\t\tif (f1_help) {\n\t\t\tp = black_pixel();\n\t\t\tf1_help = 0;\n\t\t} else {\n\t\t\tp = white_pixel();\n\t\t\tf1_help = 1;\n\t\t\tunixpw_last_try_time = time(NULL) + 45;\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, h1, p);\n\t\tif (use_dpy == NULL) {\n\t\t\t;\n\t\t} else if (strstr(use_dpy, \"cmd=FINDDISPLAY\")) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hf, p);\n\t\t} else if (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY\")) {\n\t\t\tif (strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hx, p);\n\t\t\t} else {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hc, p);\n\t\t\t}\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+3*ch, h2, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+4*ch, h3, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+5*ch, h4, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+6*ch, h5, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+7*ch, h6, p);\n\t\tif (!f1_help) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tunixpw_mark();\n\t\treturn;\n\t}\n\tif (unixpw_system_greeter_active && keysym == XK_Escape) {\n\t\tchar *u = get_user_name();\n\t\tif (keep_unixpw) {\n\t\t\tchar *colon = strchr(user, ':');\n\t\t\tkeep_unixpw_user = strdup(u);\n\t\t\tkeep_unixpw_pass = strdup(\"\");\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\t\tunixpw_system_greeter_active = 2;\n\t\tset_env(\"X11VNC_XDM_ONLY\", \"1\");\n\t\trfbLog(\"unixpw_system_greeter: VNC client pressed 'Escape'. Allowing\\n\");\n\t\trfbLog(\"unixpw_system_greeter: a *FREE* (no password) connection to\\n\");\n\t\trfbLog(\"unixpw_system_greeter: the system XDM/GDM/KDM login greeter.\\n\");\n\t\tif (1) {\n\t\t\tchar msg[] = \" Please wait... \";\n\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\tunixpw_mark();\n\n\t\t\tprogress_skippy();\n\t\t}\n\t\tunixpw_accept(u);\n\t\tfree(u);\n\t\treturn;\n\t}\n\n\tif (in_login && keysym == XK_Escape && u_cnt == 0) {\n\t\techo = 0;\t\n\t\trfbLog(\"unixpw_keystroke: echo off.\\n\");\n\t\treturn;\n\t}\n\n\tt_cnt++;\n\n\tif (in_login) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (u_cnt > 0) {\n\t\t\t\tuser[u_cnt-1] = '\\0';\n\t\t\t\tu_cnt--;\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (scaling) {\n\t\t\t\t\tint x2 = x / scale_fac_x;\n\t\t\t\t\tint y2 = y / scale_fac_y;\n\t\t\t\t\tint w2 = char_w / scale_fac_x;\n\t\t\t\t\tint h2 = char_h / scale_fac_y;\n\n\t\t\t\t\tx2 = nfix(x2, dpy_x);\n\t\t\t\t\ty2 = nfix(y2, dpy_y);\n\t\t\t\t\t\n\t\t\t\t\tzero_fb(x2 - w2, y2 - h2, x2, y2);\n\t\t\t\t\tmark_rect_as_modified(x2 - w2,\n\t\t\t\t\t    y2 - h2, x2, y2, 0);\n\t\t\t\t} else {\n\t\t\t\t\tzero_fb(x - char_w, y - char_h, x, y);\n\t\t\t\t\tmark_rect_as_modified(x - char_w,\n\t\t\t\t\t    y - char_h, x, y, 0);\n\t\t\t\t}\n\t\t\t\tchar_col--;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t\tchar pw[] = \"Password: \";\n\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t_cnt == 1) {\n\t\t\t\t/* accidental initial return, e.g. from xterm */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 1;\n\n\t\t\tchar_row++;\n\t\t\tchar_col = 0;\n\n\t\t\tx = text_x();\n\t\t\ty = text_y();\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, pw,\n\t\t\t    white_pixel());\n\n\t\t\tchar_col = strlen(pw);\n\t\t\tunixpw_mark();\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt == 0 && keysym == XK_Up) {\n\t\t\t/*\n\t\t\t * Allow user to hit Up arrow at beginning to\n\t\t\t * regain their username plus any options.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t}\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tchar str[10];\n\t\t\t\tuser[u_cnt++] = user_r[i];\n\t\t\t\tif (user_r[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr[0] = (char) user_r[i];\n\t\t\t\tstr[1] = '\\0';\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (echo) {\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x, y,\n\t\t\t\t\t    str, white_pixel());\n\t\t\t\t}\n\t\t\t\tmark_rect_as_modified(x, y-char_h, x+char_w,\n\t\t\t\t    y, scaling);\n\t\t\t\tchar_col++;\n\t\t\t\tusleep(10*1000);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for username */\n\t\t\trfbLog(\"unixpw_keystroke: bad keysym4: 0x%x\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt >= nmax - 1) {\n\t\t\t/* user[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: username too long: %d\\n\", u_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n#if 0\n\t\tuser[u_cnt++] = keystr[0];\n#else\n\t\tuser[u_cnt++] = (char) keysym;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\t/* keep a full copy of username */\n\t\t\tuser_r[i] = user[i];\n\t\t}\n\t\tkeystr[0] = (char) keysym;\n#endif\n\t\tkeystr[1] = '\\0';\n\n\t\tx = text_x();\n\t\ty = text_y();\n\nif (db && db <= 2) fprintf(stderr, \"u_cnt: %d %d/%d ks: 0x%x  '%s'\\n\", u_cnt, x, y, keysym, keystr);\n\n\t\tif (echo ) {\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, keystr, white_pixel());\n\t\t}\n\n\t\tmark_rect_as_modified(x, y-char_h, x+char_w, y, scaling);\n\t\tchar_col++;\n\n\t\treturn;\n\n\t} else if (in_passwd) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (p_cnt > 0) {\n\t\t\t\tpass[p_cnt-1] = '\\0';\n\t\t\t\tp_cnt--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed) {\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (1) {\n\t\t\t\tchar msg[] = \" Please wait... \";\n\t\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\t\tunixpw_mark();\n\n\t\t\t\tprogress_skippy();\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 0;\n\n\t\t\tpass[p_cnt++] = '\\n';\n\t\t\tunixpw_verify_screen(user, pass);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for password */\n\t\t\treturn;\n\t\t}\n\n\t\tif (p_cnt >= nmax - 2) {\n\t\t\t/* pass[u_cnt=98] will be '\\n' */\n\t\t\t/* pass[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: password too long: %d\\n\", p_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n\t\tpass[p_cnt++] = (char) keysym;\n\n\t\treturn;\n\n\t} else {\n\t\t/* should not happen... anyway clean up a bit. */\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_screen(int init);",
            "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);",
            "void unixpw_accept(char *user);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "static int text_x(void);",
            "static int text_y(void);",
            "static void set_db(void);",
            "int unixpw_denied = 0;",
            "time_t unixpw_last_try_time = 0;",
            "int keep_unixpw = 0;",
            "char *keep_unixpw_user = NULL;",
            "char *keep_unixpw_pass = NULL;",
            "char *keep_unixpw_opts = NULL;",
            "static rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};",
            "static int in_login = 0, in_passwd = 0, tries = 0;",
            "static int char_row = 0, char_col = 0;",
            "static int db = 0;",
            "static rfbScreenInfoPtr pscreen;",
            "static int f1_help = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_screen(int init);\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int text_x(void);\nstatic int text_y(void);\nstatic void set_db(void);\nint unixpw_denied = 0;\ntime_t unixpw_last_try_time = 0;\nint keep_unixpw = 0;\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_pass = NULL;\nchar *keep_unixpw_opts = NULL;\nstatic rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};\nstatic int in_login = 0, in_passwd = 0, tries = 0;\nstatic int char_row = 0, char_col = 0;\nstatic int db = 0;\nstatic rfbScreenInfoPtr pscreen;\nstatic int f1_help = 0;\n\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init) {\n\tint x, y, i, rc, nmax = 100;\n\tstatic char user_r[100], user[100], pass[100];\n\tstatic int  u_cnt = 0, p_cnt = 0, t_cnt = 0, first = 1;\n\tstatic int echo = 1;\n\tchar keystr[100];\n\tchar *str;\n\n\tif (skip_it) {\n\t\treturn;\n\t}\n\n\tif (first) {\n\t\tset_db();\n\t\tfirst = 0;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t}\n\n\tif (init) {\n\t\tin_login = 1;\n\t\tin_passwd = 0;\n\t\tunixpw_denied = 0;\n\t\techo = 1;\n\t\tif (init == 1) {\n\t\t\ttries = 0;\n\t\t}\n\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tt_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\t\tif (keep_unixpw_user) {\n\t\t\tfree(keep_unixpw_user);\n\t\t\tkeep_unixpw_user = NULL;\n\t\t}\n\t\tif (keep_unixpw_pass) {\n\t\t\tstrzero(keep_unixpw_pass);\n\t\t\tfree(keep_unixpw_pass);\n\t\t\tkeep_unixpw_pass = NULL;\n\t\t}\n\t\tif (keep_unixpw_opts) {\n\t\t\tstrzero(keep_unixpw_opts);\n\t\t\tfree(keep_unixpw_opts);\n\t\t\tkeep_unixpw_opts = NULL;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (unixpw_denied) {\n\t\trfbLog(\"unixpw_keystroke: unixpw_denied state: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\tif (keysym <= 0) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym1: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\t/* rfbKeySym = uint32_t */\n\t/* KeySym = XID = CARD32 = (unsigned long or unsigned int on LONG64) */\n\tX_LOCK;\n\tstr = XKeysymToString(keysym);\n\tX_UNLOCK;\n\tif (str == NULL) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym2: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\trc = snprintf(keystr, sizeof keystr, \"%s\", str);\n\tif (rc < 1 || rc > 90) {\n\t\trfbLog(\"unixpw_keystroke: bad keysym3: 0x%x\\n\", (int) keysym);\n\t\treturn;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"%s / %s  0x%x %s\\n\", in_login ? \"login\":\"pass \",\n\t\t    down ? \"down\":\"up  \", keysym, keystr);\n\t}\n\n\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t/* let \"up\" pass down below for Return case */\n\t\tif (down) {\n\t\t\treturn;\n\t\t}\n\t} else if (! down) {\n\t\treturn;\n\t}\n\tif (keysym == XK_F1) {\n\t\tchar h1[] = \"F1-Help:  For 'login:' type in the username and press Enter, then for 'Password:' enter the password.\";\n\t\tchar hf[] = \"  Once logged in, username's X session will be searched for and if found then attached to.\";\n\t\tchar hc[] = \"  Once logged in, username's X session is sought and attached to, otherwise a new session is created.\";\n\t\tchar hx[] = \"  Once logged in, username's X session is sought and attached to, otherwise a login greeter is presented.\";\n\t\tchar h2[] = \"  Specify options after a ':' like this:  username:opt,opt=val,...    Where an opt may be any of:\";\n\t\tchar h3[] = \"    scale=... (n/m); scale_cursor=... (sc=); solid (so); id=; repeat; clear_mods (cm); clear_keys (ck);\";\n\t\tchar h4[] = \"    clear_all (ca); speeds=... (sp=); readtimeout=... (rd=) rotate=... (ro=); noncache (nc) (nc=n);\";\n\t\tchar h5[] = \"    geom=WxHxD (ge=); nodisplay=... (nd=); viewonly (vo); tag=...; gnome kde twm fvwm mwm dtwm wmaker\";\n\t\tchar h6[] = \"    xfce lxde enlightenment Xsession failsafe.   Examples:  fred:3/4,so,cm  wilma:geom=1024x768x16,kde\";\n\t\tint ch = 13, p;\n\t\tif (!pscreen || pscreen->width < 640 || pscreen->height < 480) {\n\t\t\treturn;\n\t\t}\n\t\tif (f1_help) {\n\t\t\tp = black_pixel();\n\t\t\tf1_help = 0;\n\t\t} else {\n\t\t\tp = white_pixel();\n\t\t\tf1_help = 1;\n\t\t\tunixpw_last_try_time = time(NULL) + 45;\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, h1, p);\n\t\tif (use_dpy == NULL) {\n\t\t\t;\n\t\t} else if (strstr(use_dpy, \"cmd=FINDDISPLAY\")) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hf, p);\n\t\t} else if (strstr(use_dpy, \"cmd=FINDCREATEDISPLAY\")) {\n\t\t\tif (strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hx, p);\n\t\t\t} else {\n\t\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+2*ch, hc, p);\n\t\t\t}\n\t\t}\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+3*ch, h2, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+4*ch, h3, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+5*ch, h4, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+6*ch, h5, p);\n\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+7*ch, h6, p);\n\t\tif (!f1_help) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*ch, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tunixpw_mark();\n\t\treturn;\n\t}\n\tif (unixpw_system_greeter_active && keysym == XK_Escape) {\n\t\tchar *u = get_user_name();\n\t\tif (keep_unixpw) {\n\t\t\tchar *colon = strchr(user, ':');\n\t\t\tkeep_unixpw_user = strdup(u);\n\t\t\tkeep_unixpw_pass = strdup(\"\");\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\t\tunixpw_system_greeter_active = 2;\n\t\tset_env(\"X11VNC_XDM_ONLY\", \"1\");\n\t\trfbLog(\"unixpw_system_greeter: VNC client pressed 'Escape'. Allowing\\n\");\n\t\trfbLog(\"unixpw_system_greeter: a *FREE* (no password) connection to\\n\");\n\t\trfbLog(\"unixpw_system_greeter: the system XDM/GDM/KDM login greeter.\\n\");\n\t\tif (1) {\n\t\t\tchar msg[] = \" Please wait... \";\n\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\tunixpw_mark();\n\n\t\t\tprogress_skippy();\n\t\t}\n\t\tunixpw_accept(u);\n\t\tfree(u);\n\t\treturn;\n\t}\n\n\tif (in_login && keysym == XK_Escape && u_cnt == 0) {\n\t\techo = 0;\t\n\t\trfbLog(\"unixpw_keystroke: echo off.\\n\");\n\t\treturn;\n\t}\n\n\tt_cnt++;\n\n\tif (in_login) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (u_cnt > 0) {\n\t\t\t\tuser[u_cnt-1] = '\\0';\n\t\t\t\tu_cnt--;\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (scaling) {\n\t\t\t\t\tint x2 = x / scale_fac_x;\n\t\t\t\t\tint y2 = y / scale_fac_y;\n\t\t\t\t\tint w2 = char_w / scale_fac_x;\n\t\t\t\t\tint h2 = char_h / scale_fac_y;\n\n\t\t\t\t\tx2 = nfix(x2, dpy_x);\n\t\t\t\t\ty2 = nfix(y2, dpy_y);\n\t\t\t\t\t\n\t\t\t\t\tzero_fb(x2 - w2, y2 - h2, x2, y2);\n\t\t\t\t\tmark_rect_as_modified(x2 - w2,\n\t\t\t\t\t    y2 - h2, x2, y2, 0);\n\t\t\t\t} else {\n\t\t\t\t\tzero_fb(x - char_w, y - char_h, x, y);\n\t\t\t\t\tmark_rect_as_modified(x - char_w,\n\t\t\t\t\t    y - char_h, x, y, 0);\n\t\t\t\t}\n\t\t\t\tchar_col--;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed || keysym == XK_Tab) {\n\t\t\tchar pw[] = \"Password: \";\n\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t_cnt == 1) {\n\t\t\t\t/* accidental initial return, e.g. from xterm */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 1;\n\n\t\t\tchar_row++;\n\t\t\tchar_col = 0;\n\n\t\t\tx = text_x();\n\t\t\ty = text_y();\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, pw,\n\t\t\t    white_pixel());\n\n\t\t\tchar_col = strlen(pw);\n\t\t\tunixpw_mark();\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt == 0 && keysym == XK_Up) {\n\t\t\t/*\n\t\t\t * Allow user to hit Up arrow at beginning to\n\t\t\t * regain their username plus any options.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t}\n\t\t\tfor (i=0; i < nmax; i++) {\n\t\t\t\tchar str[10];\n\t\t\t\tuser[u_cnt++] = user_r[i];\n\t\t\t\tif (user_r[i] == '\\0') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr[0] = (char) user_r[i];\n\t\t\t\tstr[1] = '\\0';\n\n\t\t\t\tx = text_x();\n\t\t\t\ty = text_y();\n\t\t\t\tif (echo) {\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x, y,\n\t\t\t\t\t    str, white_pixel());\n\t\t\t\t}\n\t\t\t\tmark_rect_as_modified(x, y-char_h, x+char_w,\n\t\t\t\t    y, scaling);\n\t\t\t\tchar_col++;\n\t\t\t\tusleep(10*1000);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for username */\n\t\t\trfbLog(\"unixpw_keystroke: bad keysym4: 0x%x\\n\", (int) keysym);\n\t\t\treturn;\n\t\t}\n\n\t\tif (u_cnt >= nmax - 1) {\n\t\t\t/* user[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: username too long: %d\\n\", u_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n#if 0\n\t\tuser[u_cnt++] = keystr[0];\n#else\n\t\tuser[u_cnt++] = (char) keysym;\n\t\tfor (i=0; i < nmax; i++) {\n\t\t\t/* keep a full copy of username */\n\t\t\tuser_r[i] = user[i];\n\t\t}\n\t\tkeystr[0] = (char) keysym;\n#endif\n\t\tkeystr[1] = '\\0';\n\n\t\tx = text_x();\n\t\ty = text_y();\n\nif (db && db <= 2) fprintf(stderr, \"u_cnt: %d %d/%d ks: 0x%x  '%s'\\n\", u_cnt, x, y, keysym, keystr);\n\n\t\tif (echo ) {\n\t\t\trfbDrawString(pscreen, &default8x16Font, x, y, keystr, white_pixel());\n\t\t}\n\n\t\tmark_rect_as_modified(x, y-char_h, x+char_w, y, scaling);\n\t\tchar_col++;\n\n\t\treturn;\n\n\t} else if (in_passwd) {\n\t\tif (keysym == XK_BackSpace || keysym == XK_Delete) {\n\t\t\tif (p_cnt > 0) {\n\t\t\t\tpass[p_cnt-1] = '\\0';\n\t\t\t\tp_cnt--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (keysym == XK_Return || keysym == XK_Linefeed) {\n\t\t\tif (down) {\n\t\t\t\t/*\n\t\t\t\t * require Up so the Return Up is not processed\n\t\t\t\t * by the normal session after login.\n\t\t\t\t * (actually we already returned above)\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (1) {\n\t\t\t\tchar msg[] = \" Please wait... \";\n\t\t\t\trfbDrawString(pscreen, &default8x16Font,\n\t\t\t\t    text_x(), text_y(), msg, white_pixel());\n\t\t\t\tunixpw_mark();\n\n\t\t\t\tprogress_skippy();\n\t\t\t}\n\n\t\t\tin_login = 0;\n\t\t\tin_passwd = 0;\n\n\t\t\tpass[p_cnt++] = '\\n';\n\t\t\tunixpw_verify_screen(user, pass);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (keysym < ' ' || keysym >= 0x7f) {\n\t\t\t/* require normal keyboard characters for password */\n\t\t\treturn;\n\t\t}\n\n\t\tif (p_cnt >= nmax - 2) {\n\t\t\t/* pass[u_cnt=98] will be '\\n' */\n\t\t\t/* pass[u_cnt=99] will be '\\0' */\n\t\t\trfbLog(\"unixpw_deny: password too long: %d\\n\", p_cnt);\n\t\t\tfor (i=0; i<nmax; i++) {\n\t\t\t\tuser[i] = '\\0';\n\t\t\t\tpass[i] = '\\0';\n\t\t\t}\n\t\t\tunixpw_deny();\n\t\t\treturn;\n\t\t}\n\n\t\tpass[p_cnt++] = (char) keysym;\n\n\t\treturn;\n\n\t} else {\n\t\t/* should not happen... anyway clean up a bit. */\n\t\tu_cnt = 0;\n\t\tp_cnt = 0;\n\t\tfor (i=0; i<nmax; i++) {\n\t\t\tuser_r[i] = '\\0';\n\t\t\tuser[i] = '\\0';\n\t\t\tpass[i] = '\\0';\n\t\t}\n\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unixpw_screen",
          "args": [
            "1"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "423-500",
          "snippet": "void unixpw_screen(int init) {\n\tif (unixpw_cmd) {\n\t\t;\t/* OK */\n\t} else if (unixpw_nis) {\n#ifndef UNIXPW_CRYPT\n\trfbLog(\"-unixpw_nis is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t} else {\n#ifndef UNIXPW_SU\n\trfbLog(\"-unixpw is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t}\n\tif (init) {\n\t\tint x, y;\n\t\tchar log[] = \"login: \";\n\n\t\tzero_fb(0, 0, dpy_x, dpy_y);\n\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\n\t\tx = nfix(dpy_x / 2 -  strlen(log) * char_w, dpy_x);\n\t\ty = (int) (dpy_y / 3.5);\n\t\tif (unixpw_system_greeter) {\n\t\t\ty = (int) (dpy_y / 3);\n\t\t}\n\n\t\tif (scaling) {\n\t\t\tx = (int) (x * scale_fac_x);\n\t\t\ty = (int) (y * scale_fac_y);\n\t\t\tx = nfix(x, scaled_x);\n\t\t\ty = nfix(y, scaled_y);\n\t\t}\n\n\t\tif (rotating) {\n\t\t\tfscreen.serverFormat.bitsPerPixel = bpp;\n\t\t\tfscreen.paddedWidthInBytes = rfb_bytes_per_line;\n\t\t\tfscreen.frameBuffer = rfb_fb;\n\t\t\tpscreen = &fscreen;\n\t\t} else {\n\t\t\tpscreen = screen;\n\t\t}\n\n\t\tif (pscreen && pscreen->width >= 640 && pscreen->height >= 480) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*13, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tf1_help = 0;\n\n\t\tif (unixpw_system_greeter) {\n\t\t\tunixpw_system_greeter_active = 0;\n\t\t\tif (use_dpy && strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\tif (getenv(\"X11VNC_SYSTEM_GREETER1\")) {\n\t\t\t\t\tchar moo[] = \"Press 'Escape' for System Greeter\";\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x-90, y-30, moo, white_pixel());\n\t\t\t\t} else {\n\t\t\t\t\tchar moo1[] = \"Press 'Escape' for a New Session via System Greeter, or\";\n\t\t\t\t\tchar moo2[] = \"otherwise login here to connect to an Existing Session:\";\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-38, moo1, white_pixel());\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-25, moo2, white_pixel());\n\t\t\t\t}\n\t\t\t\tset_env(\"X11VNC_XDM_ONLY\", \"0\");\n\t\t\t\tunixpw_system_greeter_active = 1;\n\t\t\t}\n\t\t}\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_x = x;\n\t\tchar_y = y;\n\t\tchar_col = strlen(log);\n\t\tchar_row = 0;\n\n\t\tset_warrow_cursor();\n\t}\n\n\tunixpw_mark();\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UNIXPW_CRYPT",
            "#define UNIXPW_SU"
          ],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_screen(int init);",
            "void unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "static rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};",
            "static int char_row = 0, char_col = 0;",
            "static int char_x = 0, char_y = 0, char_w = 8, char_h = 16;",
            "static rfbScreenInfo fscreen;",
            "static rfbScreenInfoPtr pscreen;",
            "static int f1_help = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\n#define UNIXPW_CRYPT\n#define UNIXPW_SU\n\nint white_pixel(void);\nvoid unixpw_screen(int init);\nvoid unixpw_keystroke(rfbBool down, rfbKeySym keysym, int init);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nstatic rfbFontData default6x13Font={default6x13FontData, default6x13FontMetaData};\nstatic int char_row = 0, char_col = 0;\nstatic int char_x = 0, char_y = 0, char_w = 8, char_h = 16;\nstatic rfbScreenInfo fscreen;\nstatic rfbScreenInfoPtr pscreen;\nstatic int f1_help = 0;\n\nvoid unixpw_screen(int init) {\n\tif (unixpw_cmd) {\n\t\t;\t/* OK */\n\t} else if (unixpw_nis) {\n#ifndef UNIXPW_CRYPT\n\trfbLog(\"-unixpw_nis is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t} else {\n#ifndef UNIXPW_SU\n\trfbLog(\"-unixpw is not supported on this OS/machine\\n\");\n\tclean_up_exit(1);\n#endif\n\t}\n\tif (init) {\n\t\tint x, y;\n\t\tchar log[] = \"login: \";\n\n\t\tzero_fb(0, 0, dpy_x, dpy_y);\n\n\t\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\n\t\tx = nfix(dpy_x / 2 -  strlen(log) * char_w, dpy_x);\n\t\ty = (int) (dpy_y / 3.5);\n\t\tif (unixpw_system_greeter) {\n\t\t\ty = (int) (dpy_y / 3);\n\t\t}\n\n\t\tif (scaling) {\n\t\t\tx = (int) (x * scale_fac_x);\n\t\t\ty = (int) (y * scale_fac_y);\n\t\t\tx = nfix(x, scaled_x);\n\t\t\ty = nfix(y, scaled_y);\n\t\t}\n\n\t\tif (rotating) {\n\t\t\tfscreen.serverFormat.bitsPerPixel = bpp;\n\t\t\tfscreen.paddedWidthInBytes = rfb_bytes_per_line;\n\t\t\tfscreen.frameBuffer = rfb_fb;\n\t\t\tpscreen = &fscreen;\n\t\t} else {\n\t\t\tpscreen = screen;\n\t\t}\n\n\t\tif (pscreen && pscreen->width >= 640 && pscreen->height >= 480) {\n\t\t\trfbDrawString(pscreen, &default6x13Font, 8, 2+1*13, \"F1-Help:\", white_pixel());\n\t\t}\n\t\tf1_help = 0;\n\n\t\tif (unixpw_system_greeter) {\n\t\t\tunixpw_system_greeter_active = 0;\n\t\t\tif (use_dpy && strstr(use_dpy, \"xdmcp\")) {\n\t\t\t\tif (getenv(\"X11VNC_SYSTEM_GREETER1\")) {\n\t\t\t\t\tchar moo[] = \"Press 'Escape' for System Greeter\";\n\t\t\t\t\trfbDrawString(pscreen, &default8x16Font, x-90, y-30, moo, white_pixel());\n\t\t\t\t} else {\n\t\t\t\t\tchar moo1[] = \"Press 'Escape' for a New Session via System Greeter, or\";\n\t\t\t\t\tchar moo2[] = \"otherwise login here to connect to an Existing Session:\";\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-38, moo1, white_pixel());\n\t\t\t\t\trfbDrawString(pscreen, &default6x13Font, x-110, y-25, moo2, white_pixel());\n\t\t\t\t}\n\t\t\t\tset_env(\"X11VNC_XDM_ONLY\", \"0\");\n\t\t\t\tunixpw_system_greeter_active = 1;\n\t\t\t}\n\t\t}\n\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_x = x;\n\t\tchar_y = y;\n\t\tchar_col = strlen(log);\n\t\tchar_row = 0;\n\n\t\tset_warrow_cursor();\n\t}\n\n\tunixpw_mark();\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 4183
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_connect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2631-2638",
          "snippet": "static void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define USE_TIMEOUT_INTERRUPT 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define USE_TIMEOUT_INTERRUPT 0\n\nstatic void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbUnregisterTightVNCFileTransferExtension",
          "args": [],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbUnregisterTightVNCFileTransferExtension: 1\\n\""
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSetTranslateFunction",
          "args": [
            "client"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "client->updateMutex"
          ],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "client->updateMutex"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ADVERT_BMSHIFT\""
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"advertising truecolor.\\n\""
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ncache",
          "args": [
            "1",
            "0"
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "check_ncache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "8880-10195",
          "snippet": "int check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}",
            "#define EV_OLD_WM_NOTMAPPED\t16",
            "#define EV_OLD_WM_OFF\t\t15",
            "#define EV_OLD_WM_UNMAP\t\t14",
            "#define EV_OLD_WM_MAP\t\t13",
            "#define EV_CONFIGURE_SIZE\t7",
            "#define EV_REPARENT\t\t5",
            "#define EV_MAP\t\t\t4",
            "#define EV_UNMAP\t\t3",
            "#define EV_DESTROY\t\t2",
            "#define EV_CREATE\t\t1",
            "#define EV_RESET\t\t0",
            "#define NSCHED 128",
            "#define NRECENT 32"
          ],
          "globals_used": [
            "int get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);",
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void mark_region_for_xdamage(sraRegionPtr region);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int check_user_input(double dt, double dtr, int tile_diffs, int *cnt);",
            "void do_copyregion(sraRegionPtr region, int dx, int dy, int mode);",
            "int check_ncache(int reset, int mode);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "int try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);",
            "int try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);",
            "int lookup_win_index(Window);",
            "void set_ncache_xrootpmap(void);",
            "static int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);",
            "winattr_t *cache_list;",
            "void batch_push(int ncr, double delay);",
            "int clipped(int idx);",
            "void snap_old(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n#define EV_OLD_WM_NOTMAPPED\t16\n#define EV_OLD_WM_OFF\t\t15\n#define EV_OLD_WM_UNMAP\t\t14\n#define EV_OLD_WM_MAP\t\t13\n#define EV_CONFIGURE_SIZE\t7\n#define EV_REPARENT\t\t5\n#define EV_MAP\t\t\t4\n#define EV_UNMAP\t\t3\n#define EV_DESTROY\t\t2\n#define EV_CREATE\t\t1\n#define EV_RESET\t\t0\n#define NSCHED 128\n#define NRECENT 32\n\nint get_wm_frame_pos(int *px, int *py, int *x, int *y, int *w, int *h,\n    Window *frame, Window *win);\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid mark_region_for_xdamage(sraRegionPtr region);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint check_user_input(double dt, double dtr, int tile_diffs, int *cnt);\nvoid do_copyregion(sraRegionPtr region, int dx, int dy, int mode);\nint check_ncache(int reset, int mode);\nint find_rect(int idx, int x, int y, int w, int h);\nint try_to_fix_su(Window win, int idx, Window above, int *nbatch, char *mode);\nint try_to_fix_resize_su(Window orig_frame, int orig_x, int orig_y, int orig_w, int orig_h,\n    int x, int y, int w, int h, int try_batch);\nint lookup_win_index(Window);\nvoid set_ncache_xrootpmap(void);\nstatic int try_copyrect(Window orig_frame, Window frame, int x, int y, int w, int h,\n    int dx, int dy, int *obscured, sraRegionPtr extra_clip, double max_wait, int *nbatch);\nwinattr_t *cache_list;\nvoid batch_push(int ncr, double delay);\nint clipped(int idx);\nvoid snap_old(void);\n\nint check_ncache(int reset, int mode) {\n\tstatic int first = 1;\n\tstatic int last_client_count = -1;\n\tint i, k, n; \n\tint did_sched = 0;\n\n\tWindow win, win2;\n\tXWindowAttributes attr;\n\tint valid;\n\tint try_batch = 1; /* XXX Y */\n\tint use_batch = 0;\n\tint nreg = 0, *nbatch;\n\tint create_cnt;\n\tint su_fix_cnt;\n\tint pixels = 0, ttot;\n\tint desktop_change = 0, n1, n2;\n\tint desktop_change_old_wm = 0;\n\tint missed_su_restore = 0;\n\tint missed_bs_restore = 0;\n\tsraRegionPtr r0, r;\n\tsraRegionPtr missed_su_restore_rgn;\n\tsraRegionPtr missed_bs_restore_rgn;\n\tsraRegionPtr unmapped_rgn;\n\n\tint nrects = 0;\n\tint nsave, nxsel;\n\tdouble now;\n\n\tint skipwins_n = 0;\n\tint skipwins_max = 256;\n\tWindow skipwins[256];\n\n\tstatic char *dt_guess = NULL;\n\tstatic double dt_last = 0.0;\n\tint dt_gnome = 0, gnome_animation = 0;\n\tint dt_kde = 0;\n\n\tif (unixpw_in_progress) return -1;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET(-1)\n\t}\n\tif (! screen) {\n\t\treturn -1;\n\t}\n#else\n\tRAWFB_RET(-1)\n\tif (! screen || ! dpy) {\n\t\treturn -1;\n\t}\n#endif\n\n\tnow = dnow();\n\n#ifdef NO_NCACHE\n\tncache = 0;\n#endif\n\n\tif (reset && (first || cache_list_len == 0)) {\n\t\treturn -1;\n\t}\n\tif (use_threads) {\n\t\ttry_batch = 0;\n\t}\n\n\tif (ncache0) {\n\t\tif (reset) {\n\t\t\t;\n\t\t} else if (!client_count || !ncache || nofb) {\n\t\t\tstatic double last_purge = 0.0;\n\t\t\tdouble delay = client_count ? 0.5 : 2.0;\n\t\t\tif (now > last_purge + delay) {\n\t\t\t\tint c = 0;\n\t\t\t\tXEvent ev;\n\t\t\t\tX_LOCK;\n\t\t\t\twhile (xcheckmaskevent(dpy, all_ev, &ev)) {\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tX_UNLOCK;\n\t\t\t\tlast_purge = dnow();\nif (ncdb && c) fprintf(stderr, \"check_ncache purged %d events\\n\", c); \n\t\t\t}\n\t\t\tif (!client_count && last_client_count >= 0 &&\n\t\t\t    client_count != last_client_count) {\n\t\t\t\t/* this should use less RAM when no clients */\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t\tlast_client_count = client_count;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tlast_client_count = client_count;\n\n\tif (ncache && ! ncache0) {\n\t\tncache0 = ncache;\n\t}\n\n\tif (! ncache || ! ncache0) {\n\t\treturn -1;\n\t}\n\tif (subwin) {\n\t\treturn -1;\n\t}\n\tif (nofb) {\n\t\treturn -1;\n\t}\n\tif (now < last_client + 4) {\n\t\treturn -1;\n\t}\n\tif (! all_clients_initialized()) {\n\t\t/* play it safe */\n\t\treturn -1;\n\t}\n\n\n\n\tif (reset) {\n\t\trfbLog(\"check_ncache: resetting cache: %d/%d %d %d\\n\", cache_list_num, cache_list_len, ncache, first);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tfree_rect(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\tif (rect_reg[n] != NULL) {\n\t\t\t\tsraRgnDestroy(rect_reg[n]);\n\t\t\t\trect_reg[n] = NULL;\n\t\t\t}\n\t\t}\n\t\tzero_fb(0, dpy_y, dpy_x, (ncache+1)*dpy_y);\n\t\tmark_rect_as_modified(0, dpy_y, dpy_x, (ncache+1)*dpy_y, 0);\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t\treturn -1;\n\t}\n\n\tif (first) {\n\t\tint dx = 10, dy = 24, ds = 0;\n\t\tint Dx = dpy_x, Dy = dpy_y;\n\t\tfirst = 0;\n\t\tfor (i=0; i < NRECENT; i++) {\n\t\t\trecent[i] = None;\n\t\t}\n\t\tfor (i=0; i < NSCHED; i++) {\n\t\t\tsched_bs[i] = None;\n\t\t}\n\t\trlast = 0;\n\n\t\tX_LOCK;\n\t\t/* event leak with client_count == 0 */\n\t\txselectinput_rootwin |= SubstructureNotifyMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\t\tX_UNLOCK;\n\n\t\tif (scaling) {\n\t\t\tDx = scaled_x;\n\t\t\tDy = scaled_y;\n\t\t}\n\t\tif (!rotating_same) {\n\t\t\tint t = Dx;\n\t\t\tDx = Dy;\n\t\t\tDy = t;\n\t\t}\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+1*dy,\n\t\t\t    \"This is the Pixel buffer cache region. Your VNC Viewer is not hiding it from you.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+2*dy,\n\t\t\t    \"Try resizing your VNC Viewer so you don't see it!!\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+3*dy,\n\t\t\t    \"Pay no attention to the man behind the curtain...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+4*dy,\n\t\t\t    \"To disable caching run the server with:  x11vnc -noncache ...\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+5*dy,\n\t\t\t    \"If there are painting errors press 3 Alt_L's (Left \\\"Alt\\\" key) in a row to repaint the screen.\",\n\t\t\t    white_pixel());\n\t\t\trfbDrawString(screen, &default8x16Font, dx, ds + Dy+6*dy,\n\t\t\t    \"More info:  http://www.karlrunge.com/x11vnc/faq.html#faq-client-caching\",\n\t\t\t    white_pixel());\n\n\t\t\tds += 11 * dy;\n\t\t}\n\n\t\tsnapshot_cache_list(0, 100.0);\n\t\tfor (i=0; i < cache_list_num; i++) {\n\t\t\tCLEAR(i);\n\t\t}\n\t\tfor (n = 1; n <= ncache; n++) {\n\t\t\trect_reg[n] = NULL;\n\t\t}\n\n\t\tif (ncache_xrootpmap) {\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\n\t\tsnap_old();\n\t}\n\n\tcheck_zero_rects();\n\nif (hack_val == 2) {\n\tblock_stats();\n\thack_val = 1;\n}\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tstatic double last_all_windows = 0.0;\n\t\tif (! macosx_checkevent(NULL)) {\n\t\t\tif (now > last_all_windows + 0.05) {\n\t\t\t\tmacosxCGS_get_all_windows();\n\t\t\t\tlast_all_windows = dnow();\n\t\t\t}\n\t\t}\n\t\t/* XXX Y */\n\t\trootwin = -1;\n\t}\n#endif\n\n\tn = 0;\n\tttot = 0;\n\n\tif (dt_guess == NULL || now > dt_last + 60) {\n\t\tstatic char *dt_prev = NULL;\n\t\tdt_prev = dt_guess;\n\t\tdt_guess = strdup(guess_desktop());\n\t\tif (ncache_xrootpmap && dt_prev && dt_guess) {\n\t\t\tif (strcmp(dt_prev, dt_guess)) {\n\t\t\t\tset_ncache_xrootpmap();\n\t\t\t}\n\t\t}\n\t\tdt_last = now;\n\t\tif (dt_prev) {\n\t\t\tfree(dt_prev);\n\t\t}\n\t}\n\tif (dt_guess && !strcmp(dt_guess, \"gnome\")) {\n\t\tdt_gnome = 1;\n\t} else if (dt_guess && !strcmp(dt_guess, \"kde\")) {\n\t\tdt_kde = 1;\n\t}\n\tif (dt_kde) {\n\t\tkde_no_animate(0);\n\t}\n\n\tev_store(None, EV_RESET);\n\n\tX_LOCK;\n\tfor (k = 1; k <= 3; k++) {\n\t\tint j, retry = 0;\n\n\t\tif (retry) {}\n\n\t\tnsave = n;\n\n\t\tif (k > 1 && ncdb) fprintf(stderr, \"read_events-%d\\n\", k);\n\t\tread_events(&n);\n\n#if 0\n\t\tif (dt_gnome && (n_MN || n_UN)) {\n\t\t\tretry = 1;\n\t\t} else if (ncache_old_wm && n_ON_po >= 2) {\n\t\t\tretry = 1;\n\t\t} else if (n > nsave) {\n\t\t\t/* XXX Y */\n\t\t\tretry = 1;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tint n0 = n;\n\t\t\tusleep(25 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tread_events(&n);\n\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t}\n#endif\n\n\t\tif (n > nsave) {\n\t\t\tint n0 = n;\n\n\t\t\tfor (j=0; j<4; j++) {\n\t\t\t\tif (j < 2) {\n\t\t\t\t\tusleep(30 * 1000);\n\t\t\t\t} else {\n\t\t\t\t\tusleep(10 * 1000);\n\t\t\t\t}\n\t\t\t\tXFlush_wr(dpy);\n\t\t\t\tread_events(&n);\n\t\t\t\tif (ncdb) fprintf(stderr, \"read_events retry: %d -> %d\\n\", n0, n);\n\t\t\t\tif (n == n0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn0 = n;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tnxsel = 0;\n\n\t\t/* handle creates and reparenting: */\n\t\tfor (n1 = nsave; n1 < n; n1++) {\n\t\t\tWindow win2;\n\t\t\tint idx;\n\t\t\tXEvent ev = Ev[n1];\n\t\t\twin = Ev_win[n1];\n\t\t\tif (ev.type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tif (ev_lookup(win2, EV_REPARENT) || ev_lookup(win2, EV_DESTROY)) {\n\t\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: CreateNotify: 0x%lx %d\\n\", win2, n1);\n\t\t\t\t\t\tskipwins[skipwins_n++] = win2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = lookup_win_index(win);\n\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\tidx = lookup_free_index();\n\t\t\t\t\t\tif (idx < 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t}\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d valid_window\\n\", win2, n1);\n\t\t\t\t\tif (valid_window(win2, &attr, 1)) {\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\t\t\t\t\t\tCLEAR(idx);\n\t\t\t\t\t\tcache_list[idx].selectinput = 1;\n\t\t\t\t\t\tcache_list[idx].create_cnt = 1;\nif (ncdb) fprintf(stderr, \"PRELOOP:  CreateNotify: 0x%lx %d xselectinput\\n\", win2, n1);\n\t\t\t\t\t\txselectinput(win2, win_ev, 1);\n\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t\tnxsel++;\n\t\t\t\t}\n\t\t\t} else if (ev.type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"PRELOOP:  RepartNotify: 0x%lx %d idx=%d\\n\", win2, n1, idx);\n\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (! ev_lookup(win2, EV_CREATE)) {\n\t\t\t\t\t\t\txselectinput(win2, 0, 1);\n\t\t\t\t\t\t\tnxsel++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nxsel == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX_UNLOCK;\n\n\tif (got_NET_CURRENT_DESKTOP > 0.0) {\n\t\tif (dnow() < got_NET_CURRENT_DESKTOP + 0.25) {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d\\n\", n);\n\t\t\tdesktop_change = 1;\n\t\t\tn_DC++;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"***got_NET_CURRENT_DESKTOP n=%d STALE\\n\", n);\n\t\t}\n\t\tgot_NET_CURRENT_DESKTOP = 0.0;\n\t}\n\n\tif (n == 0) {\n\t\tcheck_sched(try_batch, &did_sched);\n\t\treturn 0;\n\t}\nif (ncdb) fprintf(stderr, \"\\n\"); if (ncdb) rfbLog(\"IN  check_ncache() %d events.  %.4f\\n\", n, now - x11vnc_start);\n\n\tif (try_batch) {\n\t\tuse_batch = 1;\n\t}\n\n\tif (rotating) {\n\t\tuse_batch = 0;\n\t}\n\tif (cursor_noshape_updates_clients(screen)) {\n\t\tuse_batch = 0;\n\t}\n\n\tif (! use_batch) {\n\t\tnbatch = NULL;\n\t} else {\n\t\tnreg = 0;\n\t\tnbatch = &nreg;\n\t}\n\n\t/* XXX Y */\n\tfor (n1 = 0; n1 < n; n1++) {\n\t\tWindow twin = Ev_map[n1];\n\t\tif (twin == None || twin == rootwin) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (n2 = 0; n2 < n; n2++) {\n\t\t\tif (Ev_unmap[n2] == twin) {\n\t\t\t\tif (skipwins_n < skipwins_max) {\nif (ncdb) fprintf(stderr, \"SKIPWINS: Ev_unmap/map: 0x%lx %d\\n\", twin, n2);\n\t\t\t\t\tskipwins[skipwins_n++] = twin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!desktop_change) {\n\t\tif (skipwins_n) {\n\t\t\tif (n_MN + n_UN >= 2 + 2*skipwins_n) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (n_MN + n_UN >= 3) {\n\t\t\t\tdesktop_change = 1;\n\t\t\t\tn_DC++;\n\t\t\t}\n\t\t}\n\t}\n\tif (ncache_old_wm) {\n\t\tint shifts = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tXEvent ev;\n\t\t\tint type, idx = -1;\n\t\t\tint ik = Ev_order[i];\n\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\tint old_wm = 0;\n\n\t\t\tif (Ev_done[ik]) continue;\n\t\t\twin = Ev_win[ik];\n\n\t\t\tev = Ev[ik];\n\t\t\ttype = ev.type;\n\t\t\tif (type != ConfigureNotify) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\tcontinue;\n\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tidx = lookup_win_index(win);\n\t\t\tif (idx < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx_new = ev.xconfigure.x; \n\t\t\ty_new = ev.xconfigure.y; \n\t\t\tw_new = ev.xconfigure.width; \n\t\t\th_new = ev.xconfigure.height; \n\n\t\t\tx_old = cache_list[idx].x;\n\t\t\ty_old = cache_list[idx].y;\n\t\t\tw_old = cache_list[idx].width;\n\t\t\th_old = cache_list[idx].height;\n\n\t\t\tif (w_new == w_old && h_new == h_old) {\n\t\t\t\tif (nabs(x_new - x_old) >= dpy_x || nabs(y_new - y_old) >= dpy_y) {\n\t\t\t\t\tsraRegionPtr r_old, r_new, r0;\n\t\t\t\t\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\t\tr_old = sraRgnCreateRect(x_old, y_old, x_old+w_old, y_old+h_old);\n\t\t\t\t\tsraRgnAnd(r_old, r0);\n\t\t\t\t\tr_new = sraRgnCreateRect(x_new, y_new, x_new+w_new, y_new+h_new);\n\t\t\t\t\tsraRgnAnd(r_new, r0);\n\t\t\t\t\tif (cache_list[idx].map_state != IsViewable) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_NOTMAPPED);\n\t\t\t\t\t} else if (sraRgnEmpty(r_old) && !sraRgnEmpty(r_new)) {\n\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_MAP);\n\t\t\t\t\t\tEv_map[i] = win;\n\t\t\t\t\t} else if (!sraRgnEmpty(r_old) && sraRgnEmpty(r_new)) {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_UNMAP);\n\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\tEv_unmap[i] = win;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tev_store(win, EV_OLD_WM_OFF);\n\t\t\t\t\t}\n\t\t\t\t\tsraRgnDestroy(r_old);\n\t\t\t\t\tsraRgnDestroy(r_new);\n\t\t\t\t\tsraRgnDestroy(r0);\n\t\t\t\t\tshifts++;\nif (ncdb) fprintf(stderr, \"old_wm[%d]  +%04d+%04d  +%04d+%04d  old_wm: %d\\n\", i, x_old, y_old, x_new, y_new, old_wm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (shifts >= 3) {\nif (ncdb) fprintf(stderr, \"DESKTOP_CHANGE_OLD_WM: %d\\n\", shifts);\n\t\t\tdesktop_change = 1;\n\t\t\tdesktop_change_old_wm = 1;\n\t\t}\n\t}\n\n#define SKIPUMS \\\n\tok = 1; \\\n\tif (twin == None || twin == rootwin) { \\\n\t\tcontinue; \\\n\t} \\\n\tfor (ns = 0; ns < skipwins_n; ns++) { \\\n\t\tif (skipwins[ns] == twin) { \\\n\t\t\tok = 0; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t}\n\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp[%d] = %d\\n\", cnt, i);\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\nif (ncdb) fprintf(stderr, \"U Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tif (twin == None || twin == rootwin) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\nif (ncdb) fprintf(stderr, \"M Ev_tmp2[%d] = %d\\n\", add, i);\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tWindow wu, wm;\n\t\t\tint j;\n\t\t\tint oku = 0, okm = 0;\n\t\t\twu = Ev_unmap[i];\n\t\t\twm = Ev_map[i];\n\t\t\tok = 0;\n\t\t\tif (wu != None && wu != rootwin) oku = 1;\n\t\t\tif (wm != None && wm != rootwin) okm = 1;\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (oku) {\n\t\t\t\ttwin = wu;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\toku = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (okm) {\n\t\t\t\ttwin = wm;\n\t\t\t\tSKIPUMS\n\t\t\t\tif (!ok) {\n\t\t\t\t\tokm = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!oku && !okm) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tj = Ev_tmp2[k++];\n\t\t\tif (j >= 0) {\nif (ncdb) fprintf(stderr, \"UM Ev_order[%d] = %d oku=%d okm=%d\\n\", i, j, oku, okm);\n\t\t\t\tEv_order[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tif (desktop_change) {\n\t\tWindow twin;\n\t\tint ok, s, k, add, cnt, ns;\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* unmap from top to bottom */\n\t\tfor (s = old_stack_n - 1; s >= 0; s--) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_unmap[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_unmap[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tadd = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tEv_tmp[cnt++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < cnt; k++) {\n\t\t\tEv_tmp2[k] = -1;\n\t\t}\n\t\t/* map from bottom to top */\n\t\tfor (s = 0; s < old_stack_n; s++) {\n\t\t\ttwin = old_stack[s];\t\n\t\t\tfor (k = 0; k < cnt; k++) {\n\t\t\t\ti = Ev_tmp[k];\n\t\t\t\tif (twin == Ev_map[i]) {\n\t\t\t\t\tEv_tmp2[add++] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (i=0; i < n; i++) {\n\t\t\tint j;\n\t\t\ttwin = Ev_map[i];\n\t\t\tSKIPUMS\n\t\t\tif (ok) {\n\t\t\t\tj = Ev_tmp2[k++];\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tEv_order[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (!desktop_change && (n_VN_p && !n_UN && (n_MN || n_ON_st))) {\n\t\tif (now < last_vis_unobs_time + 0.75 || now < last_vis_obs_time + 0.75) {\n\t\t\t;\n\t\t} else if (n_MN <= 2 && n_ON_st <= 1) {\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tXEvent ev;\n\t\t\t\tint type, idx = -1, state, valid;\n\t\t\t\tint ik = Ev_order[i];\n\n\t\t\t\tif (Ev_done[ik]) continue;\n\t\t\t\twin = Ev_win[ik];\n\n\t\t\t\tev = Ev[ik];\n\t\t\t\ttype = ev.type;\n\t\t\t\tif (type != VisibilityNotify) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tstate = ev.xvisibility.state;\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].vis_state == VisibilityFullyObscured) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (now < cache_list[idx].vis_unobs_time + 3.00 || now < cache_list[idx].vis_obs_time + 3.00) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  (*PRELOOP*) state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\t\t\t\tvalid = 0;\n\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\tif (valid) {\n\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t} else {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].vis_state = state;\n\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\tEv_done[ik] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (desktop_change) {\n\t\tif (ncache_dt_change) {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE.\\n\");\n\t\t\tsaw_desktop_change = 1;\n\t\t} else {\n\t\t\tif (ncdb) fprintf(stderr, \"GUESSED DESKTOP CHANGE. Skipping.\\n\");\n\t\t\tdesktop_change = 0;\n\t\t}\n\t}\n\n\n\tcreate_cnt = 0;\n\tmissed_su_restore = 0;\n\tmissed_bs_restore = 0;\n\tmissed_su_restore_rgn = sraRgnCreate();\n\tmissed_bs_restore_rgn = sraRgnCreate();\n\tr0 = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\tunmapped_rgn = sraRgnCreate();\n\tsu_fix_cnt = 0;\n\nfor (k = 0; k < skipwins_n; k++) {\n\tif (ncdb) fprintf(stderr, \"skipwins[%d] 0x%lx\\n\", k, skipwins[k]);\n}\n\n\tX_LOCK;\n\tfor (i=0; i < n; i++) {\n\t\tXEvent ev;\n\t\tint ns, skip = 0, type, idx = -1;\n\t\tint ik = Ev_order[i];\n\n\t\tif (Ev_done[ik]) continue;\n\t\twin = Ev_win[ik];\n\n\t\tev = Ev[ik];\n\t\ttype = ev.type;\n\t\tEv_done[ik] = 1;\n\n\t\twin2 = win;\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t}\n\t\t}\n\t\tfor (ns = 0; ns < skipwins_n; ns++) {\n\t\t\tif (win2 == skipwins[ns]) {\n\t\t\t\tskip = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skip) {\nif (ncdb) fprintf(stderr, \"skip%02d: ** SpecialSkip   0x%lx/0x%lx type: %s\\n\", ik, win, win2, Etype(type));\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (win == rootwin) {\n\t\t\tif (type == CreateNotify) {\n\t\t\t\tint x=0, y=0, w=0, h=0;\n\t\t\t\tvalid = 0;\n\t\t\t\twin2 = ev.xcreatewindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (cache_list[idx].valid) {\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tx=cache_list[idx].x;\n\t\t\t\t\ty=cache_list[idx].y;\n\t\t\t\t\tw=cache_list[idx].width;\n\t\t\t\t\th=cache_list[idx].height;\n\t\t\t\t\tif (w*h > 64 * 64 && ev_lookup(win2, EV_MAP)) {\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tSTORE(idx, win2, attr);\n\n\t\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\t\tif (! desktop_change) {\n\t\t\t\t\t\t\tSCHED(win2, 1) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreate_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\nif (ncdb) fprintf(stderr, \"root%02d: ** CreateNotify  0x%lx  %3d  -- %dx%d+%d+%d valid=%d\\n\", ik, win2, idx, w, h, x, y, valid);\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"root%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"root%02d: ** IgnoringRoot  0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\t\t} else {\n\t\t\tif (type == ConfigureNotify) {\n\t\t\t\tint x_new, y_new, w_new, h_new;\n\t\t\t\tint x_old, y_old, w_old, h_old;\n\t\t\t\tint stack_change, old_wm = 0;\n\t\t\t\tWindow oabove = None;\n\n\t\t\t\tidx = lookup_win_index(win);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\toabove = cache_list[idx].above;\n\t\t\t\t}\n\nif (ncdb) fprintf(stderr, \"----%02d: ConfigureNotify  0x%lx  %3d  -- above: 0x%lx -> 0x%lx  %dx%d+%d+%d\\n\", ik, win, idx,\n    oabove, ev.xconfigure.above, ev.xconfigure.width, ev.xconfigure.height, ev.xconfigure.x, ev.xconfigure.y);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tx_new = ev.xconfigure.x; \n\t\t\t\ty_new = ev.xconfigure.y; \n\t\t\t\tw_new = ev.xconfigure.width; \n\t\t\t\th_new = ev.xconfigure.height; \n\n\t\t\t\tx_old = cache_list[idx].x;\n\t\t\t\ty_old = cache_list[idx].y;\n\t\t\t\tw_old = cache_list[idx].width;\n\t\t\t\th_old = cache_list[idx].height;\n\n\t\t\t\tif (desktop_change_old_wm) {\n\t\t\t\t\tif (ev_lookup(win, EV_OLD_WM_MAP)) {\n\t\t\t\t\t\tif (Ev_map[ik] == win) {\n\t\t\t\t\t\t\told_wm = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_UNMAP)) {\n\t\t\t\t\t\tif (Ev_unmap[ik] == win) {\n\t\t\t\t\t\t\told_wm = -1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_OFF)) {\n\t\t\t\t\t\told_wm = 2;\n\t\t\t\t\t} else if (ev_lookup(win, EV_OLD_WM_NOTMAPPED)) {\n\t\t\t\t\t\told_wm = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!old_wm)  {\n\t\t\t\t\tif (x_old != x_new || y_old != y_new) {\n\t\t\t\t\t\t/* invalidate su */\n\t\t\t\t\t\tcache_list[idx].su_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE su: 0x%lx xy: +%d+%d  +%d+%d \\n\", win, x_old, y_old, x_new, y_new);\n\t\t\t\t\t}\n\t\t\t\t\tif (w_old != w_new || h_old != h_new) {\n\t\t\t\t\t\t/* invalidate bs */\n\t\t\t\t\t\tcache_list[idx].bs_time = 0.0;\nif (ncdb) fprintf(stderr, \"          INVALIDATE bs: 0x%lx wh:  %dx%d   %dx%d \\n\", win, w_old, h_old, w_new, h_new);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint valid;\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (old_wm == 1) {\n\t\t\t\t\t\t/* XXX Y */\nif (ncdb) fprintf(stderr, \"          OLD_WM_MAP:    0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1);\n\n\t\t\t\t\t} else if (old_wm == -1) {\nif (ncdb) fprintf(stderr, \"          OLD_WM_UNMAP:  0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d \\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new);\n\t\t\t\t\t\tvalid = 1;\n\t\t\t\t\t\tsu_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t} else {\nif (ncdb) fprintf(stderr, \"          OLD_WM_OFF::   0x%lx wh:  %dx%d+%d+%d   %dx%d+%d+%d  old_wm=%d\\n\", win, w_old, h_old, x_old, y_old, w_new, h_new, x_new, y_new, old_wm);\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t}\n\n\t\t\t\tstack_change = 0;\n\t\t\t\tif (old_wm) {\n\t\t\t\t\t;\n\t\t\t\t} else if (cache_list[idx].above != ev.xconfigure.above) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t} else if (x_new == x_old && y_new == y_old && w_new == w_old && h_new == h_old) {\n\t\t\t\t\tstack_change = 1;\n\t\t\t\t}\n\t\t\t\tif (stack_change) {\n\t\t\t\t\tint i2, ok = 1;\n\t\t\t\t\tfor (i2=0; i2 < n; i2++)  {\n\t\t\t\t\t\tif (Ev_map[i2] == win) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tif (su_fix_cnt > 0) {\n\t\t\t\t\t\t\t\tok = 0;\nif (ncdb) fprintf(stderr, \"          CONF_IGNORE: Too many stacking changes: 0x%lx\\n\", win);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tif (ev_lookup(ev.xconfigure.above, EV_UNMAP)) {\n\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #1\\n\");\n\t\t\t\t\t\t\tif (dt_gnome) {\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok && dt_gnome) {\n\t\t\t\t\t\tif (valid_window(ev.xconfigure.above, &attr, 1)) {\n\t\t\t\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip try_to_fix_su for GNOME deiconify #2\\n\");\n\t\t\t\t\t\t\t\tgnome_animation = 1;\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint rc = try_to_fix_su(win, idx, ev.xconfigure.above, nbatch, NULL);\t\n\t\t\t\t\t\tif (rc == 0 && su_fix_cnt == 0 && n_MN == 0 && n_UN == 0) {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\ttry_to_synthesize_su(1, 1, nbatch);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn_ST++;\n\t\t\t\t\t\tsu_fix_cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcache_list[idx].x = x_new;\n\t\t\t\tcache_list[idx].y = y_new;\n\t\t\t\tcache_list[idx].width = w_new;\n\t\t\t\tcache_list[idx].height = h_new;\n\n\t\t\t\tcache_list[idx].above = ev.xconfigure.above;\n\t\t\t\tcache_list[idx].time = dnow();\n\n\t\t\t} else if (type == VisibilityNotify) {\n\t\t\t\tint state = ev.xvisibility.state;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: VisibilityNotify 0x%lx  %3d  state: %s U/P %d/%d\\n\", ik, win, idx, VState(state), n_VN_u, n_VN_p);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (desktop_change) {\n\t\t\t\t\t;\n\t\t\t\t} else if (macosx_console && n_VN_p == 0) {\n\t\t\t\t\t;\t/* XXXX not working well yet with UnmapNotify ... */\n\t\t\t\t} else if (state == VisibilityUnobscured) {\n\t\t\t\t\tint ok = 1;\n\t\t\t\t\tif (ncache <= 2) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_MAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_UNMAP)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (ev_lookup(win, EV_DESTROY)) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else if (gnome_animation) {\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* this is for gnome iconify */\n\t\t\t\t\t\tint i2;\n\t\t\t\t\t\tfor (i2=i+1; i2 < n; i2++) {\n\t\t\t\t\t\t\tint idx2, ik2 = Ev_order[i2];\n\t\t\t\t\t\t\tsraRegionPtr ro1, ro2;\n\t\t\t\t\t\t\tWindow win2 = Ev_unmap[ik2];\n\n\t\t\t\t\t\t\tif (win2 == None) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx2 = lookup_win_index(win2);\n\t\t\t\t\t\t\tif (idx2 < 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tro1 = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tro2 = idx_create_rgn(r0, idx2);\n\n\t\t\t\t\t\t\tif (sraRgnAnd(ro1, ro2)) {\n\t\t\t\t\t\t\t\tif (ncdb) fprintf(stderr, \"        skip VisibilityUnobscured for GNOME iconify.\\n\");\n\t\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(ro1);\n\t\t\t\t\t\t\tsraRgnDestroy(ro2);\n\t\t\t\t\t\t\tif (! ok) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\t\t\tsraRegionPtr rmask = NULL;\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tif (dnow() < cache_list[idx].vis_unobs_time + 3.00 && !sraRgnEmpty(unmapped_rgn)) {\n\t\t\t\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\t\t\t\trmask = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\t\t\t\tsraRgnAnd(rmask, unmapped_rgn);\n\t\t\t\t\t\t\tif (sraRgnEmpty(rmask)) {\n\t\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t\t\trmask = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\t\tbs_restore(idx, nbatch, rmask, &attr, 0, 1, &valid, 1);\n\t\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rmask != NULL) {\n\t\t\t\t\t\t\tsraRgnDestroy(rmask);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\n\t\t\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\t\t\tcache_list[idx].vis_cnt++;\n\t\t\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\t\t\tnrects++;\n\t\t\t\t\t\t\tSCHED(win, 1) \n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_unobs_time = last_vis_unobs_time = dnow();\n\t\t\t\t} else if (cache_list[idx].vis_state == VisibilityUnobscured) {\n\t\t\t\t\tcache_list[idx].vis_obs_time = last_vis_obs_time = dnow();\n\t\t\t\t}\n\t\t\t\tcache_list[idx].vis_state = state;\n\n\t\t\t} else if (type == MapNotify) {\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: MapNotify        0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsUnmapped || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].su_time != 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 1, &valid, 1);\n\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tsu_save(idx, nbatch, &attr, 0, &valid, 1);\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (ev_lookup(win, EV_CONFIGURE_SIZE)) {\n\t\t\t\t\t\tX_LOCK;\n\t\t\t\t\t\tvalid = valid_window(win, &attr, 1);\n\t\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t} else if (bs_restore(idx, nbatch, NULL, &attr, 0, 0, &valid, 1)) { /* XXX clip? */\n\t\t\t\t\t\t;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_bs_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_bs_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\t\t\t\tmacosxCGS_follow_animation_win(win, -1, 1);\n\t\t\t\t\t\tif (valid_window(win, &attr, 1)) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t\tSCHED(win, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* XXX Y */\n\t\t\t\t\t\tif (cache_list[idx].vis_state == -1)  {\n\t\t\t\t\t\t\tcache_list[idx].vis_state = VisibilityUnobscured;\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].map_cnt++;\n\t\t\t\t\tEv_map[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\n\t\t\t\t\tif (! valid) {\n\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcache_list[idx].map_state = IsViewable;\n\n\t\t\t} else if (type == UnmapNotify) {\n\t\t\t\tint x2, y2, w2, h2;\n\t\t\t\tidx = lookup_win_index(win);\nif (ncdb) fprintf(stderr, \"----%02d: UnmapNotify      0x%lx  %3d\\n\", ik, win, idx);\n\n\t\t\t\tif (idx < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (macosx_console) {\n\t\t\t\t\tif (mode == 2) {\n\t\t\t\t\t\tcache_list[idx].map_state = IsViewable;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if 0\n/*\n\t\t\t\tif (cache_list[idx].map_state == IsViewable || desktop_change || macosx_console)\n */\n#endif\n\t\t\t\tif (1) {\n\t\t\t\t\tX_UNLOCK;\n\t\t\t\t\tif (desktop_change) {\n\t\t\t\t\t\tint save = 1;\n\t\t\t\t\t\tsraRegionPtr r;\n\t\t\t\t\t\tif (cache_list[idx].bs_time > 0.0) {\n\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t} else if (missed_su_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_su_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (missed_bs_restore) {\n\t\t\t\t\t\t\tr = idx_create_rgn(r0, idx);\n\t\t\t\t\t\t\tif (sraRgnAnd(r, missed_bs_restore_rgn)) {\n\t\t\t\t\t\t\t\tsave = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsraRgnDestroy(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (save) {\n\t\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = 0;\n\t\t\t\t\t\tbs_save(idx, nbatch, &attr, 1, 0, &valid, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvalid = 0;\n\t\t\t\t\tif (su_restore(idx, nbatch, NULL, &attr, 1, 0, &valid, 1)) {\n\t\t\t\t\t\ttry_to_fix_su(win, idx, None, nbatch, \"unmapped\");\t\n\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\tSTORE(idx, win, attr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDELETE(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tidx_add_rgn(missed_su_restore_rgn, r0, idx);\n\t\t\t\t\t\tmissed_su_restore++;\n\t\t\t\t\t}\n\t\t\t\t\tX_LOCK;\n\n\t\t\t\t\tpixels += cache_list[idx].width * cache_list[idx].height;\n\t\t\t\t\tcache_list[idx].time = dnow();\n\t\t\t\t\tcache_list[idx].unmap_cnt++;\n\t\t\t\t\tEv_unmap[ik] = win;\n\t\t\t\t\tEv_rects[nrects].x1 = cache_list[idx].x;\n\t\t\t\t\tEv_rects[nrects].y1 = cache_list[idx].y;\n\t\t\t\t\tEv_rects[nrects].x2 = cache_list[idx].width;\n\t\t\t\t\tEv_rects[nrects].y2 = cache_list[idx].height;\n\t\t\t\t\tnrects++;\n\t\t\t\t}\n\n\t\t\t\tx2 = cache_list[idx].x;\n\t\t\t\ty2 = cache_list[idx].y;\n\t\t\t\tw2 = cache_list[idx].width;\n\t\t\t\th2 = cache_list[idx].height;\n\t\t\t\tr = sraRgnCreateRect(x2, y2, x2+w2, y2+h2);\n\t\t\t\tsraRgnAnd(r, r0); \n\t\t\t\tsraRgnOr(unmapped_rgn, r); \n\t\t\t\tsraRgnDestroy(r);\n\n\t\t\t\tcache_list[idx].map_state = IsUnmapped;\n\n\t\t\t} else if (type == ReparentNotify) {\n\t\t\t\tif (ev.xreparent.parent != rootwin) {\n\t\t\t\t\twin2 = ev.xreparent.window;\n\t\t\t\t\tif (win2 != rootwin) {\n\t\t\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: ReparentNotifyRM 0x%lx  %3d\\n\", ik, win2, idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (type == DestroyNotify) {\n\t\t\t\twin2 = ev.xdestroywindow.window;\n\t\t\t\tidx = lookup_win_index(win2);\nif (ncdb) fprintf(stderr, \"----%02d: DestroyNotify    0x%lx  %3d\\n\", ik, win2, idx);\n\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tDELETE(idx);\n\t\t\t\t}\n\t\t\t} else {\nif (ncdb) fprintf(stderr, \"igno%02d: ** Ignoring      0x%lx type: %s\\n\", ik, win, Etype(type));\n\t\t\t}\n\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (use_batch && nreg) {\n\t\tbatch_push(nreg, -1.0);\n\t}\n\tif (nrects) {\n\t\tif (scaling) {\n\t\t\tpush_borders(Ev_rects, nrects);\n\t\t}\n\t}\n\n\tcheck_sched(try_batch, &did_sched);\n\n\tif (n_CN || n_RN || n_DN || n_MN || n_UN || n_ST || n_DC || did_sched) {\n\t\tsnap_old();\n\t}\n\n\tsraRgnDestroy(r0);\n\tsraRgnDestroy(missed_su_restore_rgn);\n\tsraRgnDestroy(missed_bs_restore_rgn);\n\nif (ncdb) rfbLog(\"OUT check_ncache(): %.4f %.6f events: %d  pixels: %d\\n\", dnowx(), dnow() - now, n, pixels);\nif (ncdb) fprintf(stderr, \"\\n\");\n\treturn pixels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"incr accepted_client=%d for %s:%d  sock=%d\\n\"",
            "accepted_client",
            "client->host",
            "get_remote_port(client->sock)",
            "client->sock"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_remote_port",
          "args": [
            "client->sock"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "226-228",
          "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_padded_fb",
          "args": [
            "pad_geometry"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "install_padded_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1129-1149",
          "snippet": "void install_padded_fb(char *geom) {\n\tint w, h;\n\tint ok = 1;\n\tif (! geom || *geom == '\\0') {\n\t\tok = 0;\n\t} else if (sscanf(geom, \"%dx%d\", &w, &h) != 2)  {\n\t\tok = 0;\n\t}\n\tw = nabs(w);\n\th = nabs(h);\n\n\tif (w < 5) w = 5;\n\tif (h < 5) h = 5;\n\n\tif (!ok) {\n\t\trfbLog(\"skipping invalid pad geometry: '%s'\\n\", NONUL(geom));\n\t\treturn;\n\t}\n\tinstall_fake_fb(w, h, bpp);\n\tpad_geometry_time = time(NULL);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void install_padded_fb(char *geom);",
            "static void install_fake_fb(int w, int h, int bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid install_padded_fb(char *geom);\nstatic void install_fake_fb(int w, int h, int bpp);\n\nvoid install_padded_fb(char *geom) {\n\tint w, h;\n\tint ok = 1;\n\tif (! geom || *geom == '\\0') {\n\t\tok = 0;\n\t} else if (sscanf(geom, \"%dx%d\", &w, &h) != 2)  {\n\t\tok = 0;\n\t}\n\tw = nabs(w);\n\th = nabs(h);\n\n\tif (w < 5) w = 5;\n\tif (h < 5) h = 5;\n\n\tif (!ok) {\n\t\trfbLog(\"skipping invalid pad geometry: '%s'\\n\", NONUL(geom));\n\t\treturn;\n\t}\n\tinstall_fake_fb(w, h, bpp);\n\tpad_geometry_time = time(NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "solid_bg",
          "args": [
            "0"
          ],
          "line": 4100
        },
        "resolved": true,
        "details": {
          "function_name": "solid_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1330-1425",
          "snippet": "void solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);",
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);",
            "static char *last_color = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\nstatic char *last_color = NULL;\n\nvoid solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_refresh_callback_on",
          "args": [],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_refresh_callback_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "113-123",
          "snippet": "void macosxCG_refresh_callback_on(void) {\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\tif (! callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: register\\n\");\n\t\tCGRegisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 1;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_refresh_callback_on(void) {\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\tif (! callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: register\\n\");\n\t\tCGRegisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autorepeat",
          "args": [
            "0",
            "0"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "autorepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "386-442",
          "snippet": "void autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);",
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static int save_auto_repeat = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic int save_auto_repeat = -1;\n\nvoid autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Setting cursor for client %s failed.\\n\"",
            "client->host"
          ],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setClientCursor",
          "args": [
            "dpy",
            "cd->ptr_id",
            "0.4*(cd->ptr_id%3)",
            "0.2*(cd->ptr_id%5)",
            "1*(cd->ptr_id%2)",
            "tmp"
          ],
          "line": 4070
        },
        "resolved": true,
        "details": {
          "function_name": "setClientCursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
          "lines": "208-312",
          "snippet": "rfbCursorPtr setClientCursor(Display *dpy, int dev_id, float r, float g, float b, char *label)\n{\n#ifndef HAVE_LIBXCURSOR\n  return NULL;\n#else\n#ifndef HAVE_CAIRO\n  return NULL;\n#else\n\n  /* label setup */\n  const int idFontSize = 18;\n  const int idXOffset = 11;\n  const int idYOffset = 25;\n  const size_t textsz = 64;\n  char text[textsz];\n  int total_width, total_height;\n  cairo_surface_t* main_surface;\n  cairo_surface_t* dummy_surface;\n  cairo_surface_t* barecursor_surface;\n  cairo_t* cr;\n  cairo_text_extents_t est;\n  Cursor cursor;\n  XcursorImage *cursor_image = NULL;\n  rfbCursorPtr rfbcursor = NULL;\n\n  if(dev_id < 0)\n    return NULL;\n\n  if(label)\n    snprintf(text, textsz, \"%s\", label);\n  else\n    snprintf(text, textsz, \"%i\", (int) dev_id);\n \n  /* simple cursor w/o label */\n  barecursor_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 24, 24);\n  cr = cairo_create(barecursor_surface);\n  cairo_move_to (cr, 1, 1);\n  cairo_line_to (cr, 12, 8);\n  cairo_line_to (cr, 5, 15);\n  cairo_close_path (cr);\n  cairo_set_source_rgba(cr, r, g, b, 0.9);\n  cairo_fill_preserve (cr);\n  cairo_set_source_rgba(cr, 0, 0, 0, 0.8);\n  cairo_set_line_width (cr, 0.8);\n  cairo_stroke (cr);\n\n    \n  /* get estimated text extents */\n  dummy_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 500, 10);/* ah well, but should fit */\n  cr = cairo_create(dummy_surface);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_text_extents(cr, text, &est);\n\n  /* an from these calculate our final size */\n  total_width = (int)(idXOffset + est.width + est.x_bearing);\t\n  total_height = (int)(idYOffset + est.height + est.y_bearing);\t\n\n  /* draw evrything */\n  main_surface = cairo_image_surface_create( CAIRO_FORMAT_ARGB32, total_width, total_height );\n  cr = cairo_create(main_surface);\n  cairo_set_source_surface(cr, barecursor_surface, 0, 0);\n  cairo_paint (cr);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_set_source_rgba (cr, r, g, b, 0.8);\n  cairo_move_to(cr, idXOffset, idYOffset);\n  cairo_show_text(cr,text);\n    \n  X_LOCK;\n  /* copy cairo surface to cursor image */\n  cursor_image = XcursorImageCreate(total_width, total_height);\n  /* this is important! otherwise we get badmatch, badcursor xerrrors galore... */\n  cursor_image->xhot = cursor_image->yhot = 0; \n  memcpy(cursor_image->pixels, cairo_image_surface_get_data (main_surface), sizeof(CARD32) * total_width * total_height);\n  X_UNLOCK;\n\n  /* convert to rfb cursor which we return later */\n  rfbcursor = pixels2curs(cursor_image->pixels,\n\t\t\t  cursor_image->width,\n\t\t\t  cursor_image->height,\n\t\t\t  cursor_image->xhot,\n\t\t\t  cursor_image->yhot,\n\t\t\t  bpp/8);\n  \n  X_LOCK;\n\n  /* and display  */\n  cursor = XcursorImageLoadCursor(dpy, cursor_image);\n  XIDefineCursor(dpy, dev_id, RootWindow(dpy, DefaultScreen(dpy)), cursor);\n  XFreeCursor(dpy, cursor);\n\n  /* clean up */\n  cairo_destroy(cr);\n  cairo_surface_destroy(dummy_surface);\n  cairo_surface_destroy(main_surface);\n  cairo_surface_destroy(barecursor_surface);\n  XcursorImageDestroy(cursor_image);\n\n  X_UNLOCK;\n\n  return rfbcursor;\n#endif\n#endif\n}",
          "includes": [
            "#include <cairo.h>",
            "#include <X11/Xcursor/Xcursor.h>",
            "#include \"xi2_devices.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"cursor.h\"",
            "#include \"x11vnc.h\"",
            "#include <X11/keysym.h>",
            "#include <X11/Xproto.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nrfbCursorPtr setClientCursor(Display *dpy, int dev_id, float r, float g, float b, char *label)\n{\n#ifndef HAVE_LIBXCURSOR\n  return NULL;\n#else\n#ifndef HAVE_CAIRO\n  return NULL;\n#else\n\n  /* label setup */\n  const int idFontSize = 18;\n  const int idXOffset = 11;\n  const int idYOffset = 25;\n  const size_t textsz = 64;\n  char text[textsz];\n  int total_width, total_height;\n  cairo_surface_t* main_surface;\n  cairo_surface_t* dummy_surface;\n  cairo_surface_t* barecursor_surface;\n  cairo_t* cr;\n  cairo_text_extents_t est;\n  Cursor cursor;\n  XcursorImage *cursor_image = NULL;\n  rfbCursorPtr rfbcursor = NULL;\n\n  if(dev_id < 0)\n    return NULL;\n\n  if(label)\n    snprintf(text, textsz, \"%s\", label);\n  else\n    snprintf(text, textsz, \"%i\", (int) dev_id);\n \n  /* simple cursor w/o label */\n  barecursor_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 24, 24);\n  cr = cairo_create(barecursor_surface);\n  cairo_move_to (cr, 1, 1);\n  cairo_line_to (cr, 12, 8);\n  cairo_line_to (cr, 5, 15);\n  cairo_close_path (cr);\n  cairo_set_source_rgba(cr, r, g, b, 0.9);\n  cairo_fill_preserve (cr);\n  cairo_set_source_rgba(cr, 0, 0, 0, 0.8);\n  cairo_set_line_width (cr, 0.8);\n  cairo_stroke (cr);\n\n    \n  /* get estimated text extents */\n  dummy_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 500, 10);/* ah well, but should fit */\n  cr = cairo_create(dummy_surface);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_text_extents(cr, text, &est);\n\n  /* an from these calculate our final size */\n  total_width = (int)(idXOffset + est.width + est.x_bearing);\t\n  total_height = (int)(idYOffset + est.height + est.y_bearing);\t\n\n  /* draw evrything */\n  main_surface = cairo_image_surface_create( CAIRO_FORMAT_ARGB32, total_width, total_height );\n  cr = cairo_create(main_surface);\n  cairo_set_source_surface(cr, barecursor_surface, 0, 0);\n  cairo_paint (cr);\n  cairo_select_font_face (cr, \"Sans\", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);\n  cairo_set_font_size (cr, idFontSize);\n  cairo_set_source_rgba (cr, r, g, b, 0.8);\n  cairo_move_to(cr, idXOffset, idYOffset);\n  cairo_show_text(cr,text);\n    \n  X_LOCK;\n  /* copy cairo surface to cursor image */\n  cursor_image = XcursorImageCreate(total_width, total_height);\n  /* this is important! otherwise we get badmatch, badcursor xerrrors galore... */\n  cursor_image->xhot = cursor_image->yhot = 0; \n  memcpy(cursor_image->pixels, cairo_image_surface_get_data (main_surface), sizeof(CARD32) * total_width * total_height);\n  X_UNLOCK;\n\n  /* convert to rfb cursor which we return later */\n  rfbcursor = pixels2curs(cursor_image->pixels,\n\t\t\t  cursor_image->width,\n\t\t\t  cursor_image->height,\n\t\t\t  cursor_image->xhot,\n\t\t\t  cursor_image->yhot,\n\t\t\t  bpp/8);\n  \n  X_LOCK;\n\n  /* and display  */\n  cursor = XcursorImageLoadCursor(dpy, cursor_image);\n  XIDefineCursor(dpy, dev_id, RootWindow(dpy, DefaultScreen(dpy)), cursor);\n  XFreeCursor(dpy, cursor);\n\n  /* clean up */\n  cairo_destroy(cr);\n  cairo_surface_destroy(dummy_surface);\n  cairo_surface_destroy(main_surface);\n  cairo_surface_destroy(barecursor_surface);\n  XcursorImageDestroy(cursor_image);\n\n  X_UNLOCK;\n\n  return rfbcursor;\n#endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp",
            "sizeof tmp",
            "\"%i\"",
            "cd->uid"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Created XInput2 MD %i %i for client %s.\\n\"",
            "cd->ptr_id",
            "cd->kbd_id",
            "client->host"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPairedMD",
          "args": [
            "dpy",
            "cd->ptr_id"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "getPairedMD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
          "lines": "174-197",
          "snippet": "int getPairedMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int paired = -1;\n  XIDeviceInfo* devinfo;\n  int devicecount = 0;\n\n  if(dev_id < 0)\n    return paired;\n\n  X_LOCK;\n\n  devinfo = XIQueryDevice(dpy, dev_id, &devicecount);\n  if(devicecount)\n    paired = devinfo->attachment;\n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return paired;\n#endif\n}",
          "includes": [
            "#include <cairo.h>",
            "#include <X11/Xcursor/Xcursor.h>",
            "#include \"xi2_devices.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"cursor.h\"",
            "#include \"x11vnc.h\"",
            "#include <X11/keysym.h>",
            "#include <X11/Xproto.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint getPairedMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int paired = -1;\n  XIDeviceInfo* devinfo;\n  int devicecount = 0;\n\n  if(dev_id < 0)\n    return paired;\n\n  X_LOCK;\n\n  devinfo = XIQueryDevice(dpy, dev_id, &devicecount);\n  if(devicecount)\n    paired = devinfo->attachment;\n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return paired;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_client_data",
          "args": [
            "client"
          ],
          "line": 4057
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ERROR creating XInput2 MD for client %s, denying client.\\n\"",
            "client->host"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "createMD",
          "args": [
            "dpy",
            "tmp"
          ],
          "line": 4055
        },
        "resolved": true,
        "details": {
          "function_name": "createMD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
          "lines": "54-106",
          "snippet": "int createMD(Display* dpy, char* name)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int dev_id = -1;\n  XErrorHandler old_handler;\n  XIAddMasterInfo c;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n  char handle[256]; /* device name */\n  snprintf(handle, sizeof handle, \"%s pointer\", name);\n\n  c.type = XIAddMaster;\n  c.name = name;\n  c.send_core = 1;\n  c.enable = 1;\n\n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n\t\n  XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&c, 1);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return -1;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  /* find newly created dev by name\n     FIXME: better wait for XIHierarchy event here? */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = num_devices-1; i >= 0; --i) \n    if(strcmp(devinfo[i].name, handle) == 0)\n      {\n\tdev_id = devinfo[i].deviceid;\n\tbreak;\n      }\n \n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return dev_id;\n#endif\n}",
          "includes": [
            "#include <cairo.h>",
            "#include <X11/Xcursor/Xcursor.h>",
            "#include \"xi2_devices.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"cursor.h\"",
            "#include \"x11vnc.h\"",
            "#include <X11/keysym.h>",
            "#include <X11/Xproto.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint createMD(Display* dpy, char* name)\n{\n#ifndef HAVE_XI2\n  return -1;\n#else\n  int dev_id = -1;\n  XErrorHandler old_handler;\n  XIAddMasterInfo c;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n  char handle[256]; /* device name */\n  snprintf(handle, sizeof handle, \"%s pointer\", name);\n\n  c.type = XIAddMaster;\n  c.name = name;\n  c.send_core = 1;\n  c.enable = 1;\n\n  X_LOCK;\n\n  trapped_xerror = 0;\n  old_handler = XSetErrorHandler(trap_xerror);\n\t\n  XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&c, 1);\n  XSync(dpy, False);\n\n  if(trapped_xerror) {\n    XSetErrorHandler(old_handler);\n    trapped_xerror = 0;\n    X_UNLOCK;\n    return -1;\n  }\n\n  XSetErrorHandler(old_handler);\n  trapped_xerror = 0;\n\n  /* find newly created dev by name\n     FIXME: better wait for XIHierarchy event here? */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = num_devices-1; i >= 0; --i) \n    if(strcmp(devinfo[i].name, handle) == 0)\n      {\n\tdev_id = devinfo[i].deviceid;\n\tbreak;\n      }\n \n  XIFreeDeviceInfo(devinfo);\n\n  X_UNLOCK;\n\n  return dev_id;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tmp",
            "sizeof tmp",
            "\"x11vnc %s\"",
            "client->host"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "passwdfile",
            "\"custom:\""
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"problem reading: %s\\n\"",
            "passwdfile"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "install_passwds",
          "args": [],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "install_passwds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "1081-1103",
          "snippet": "void install_passwds(void) {\n\tif (viewonly_passwd) {\n\t\t/* append the view only passwd after the normal passwd */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\tpasswds_new[0] = passwds_old[0];\n\t\tpasswds_new[1] = viewonly_passwd;\n\t\tpasswds_new[2] = NULL;\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t} else if (passwd_list) {\n\t\tint i = 0;\n\t\twhile(passwd_list[i] != NULL) {\n\t\t\ti++;\n\t\t}\n\t\tif (begin_viewonly < 0) {\n\t\t\tbegin_viewonly = i+1;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwd_list;\n\t\tscreen->authPasswdFirstViewOnly = begin_viewonly;\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void install_passwds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid install_passwds(void);\n\nvoid install_passwds(void) {\n\tif (viewonly_passwd) {\n\t\t/* append the view only passwd after the normal passwd */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\tpasswds_new[0] = passwds_old[0];\n\t\tpasswds_new[1] = viewonly_passwd;\n\t\tpasswds_new[2] = NULL;\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t} else if (passwd_list) {\n\t\tint i = 0;\n\t\twhile(passwd_list[i] != NULL) {\n\t\t\ti++;\n\t\t}\n\t\tif (begin_viewonly < 0) {\n\t\t\tbegin_viewonly = i+1;\n\t\t}\n\t\t/* mutex */\n\t\tscreen->authPasswdData = (void*) passwd_list;\n\t\tscreen->authPasswdFirstViewOnly = begin_viewonly;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_passwds",
          "args": [
            "passwdfile"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "read_passwds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "867-1079",
          "snippet": "int read_passwds(char *passfile) {\n\tchar line[1024];\n\tchar *filename;\n\tchar **old_passwd_list = passwd_list;\n\tint linecount = 0, i, remove = 0, read_mode = 0, begin_vo = -1;\n\tstruct stat sbuf;\n\tstatic int max = -1;\n\tFILE *in = NULL;\n\tstatic time_t last_read = 0;\n\tstatic int read_cnt = 0;\n\tint db_passwd = 0;\n\n\tif (max < 0) {\n\t\tmax = 1000;\n\t\tif (getenv(\"X11VNC_MAX_PASSWDS\")) {\n\t\t\tmax = atoi(getenv(\"X11VNC_MAX_PASSWDS\"));\n\t\t}\n\t}\n\n\tfilename = passfile;\n\tif (strstr(filename, \"rm:\") == filename) {\n\t\tfilename += strlen(\"rm:\");\n\t\tremove = 1;\n\t} else if (strstr(filename, \"read:\") == filename) {\n\t\tfilename += strlen(\"read:\");\n\t\tread_mode = 1;\n\t\tif (stat(filename, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mtime <= last_read) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlast_read = sbuf.st_mtime;\n\t\t}\n\t} else if (strstr(filename, \"cmd:\") == filename) {\n\t\tint rc;\n\n\t\tfilename += strlen(\"cmd:\");\n\t\tread_mode = 1;\n\t\tin = tmpfile();\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"run_user_command tmpfile() failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trc = run_user_command(filename, latest_client, \"read_passwds\",\n\t\t    NULL, 0, in);\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"run_user_command command failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trewind(in);\n\t} else if (strstr(filename, \"custom:\") == filename) {\n\t\treturn 1;\n\t}\n\n\tif (in == NULL && stat(filename, &sbuf) == 0) {\n\t\t/* (poor...) upper bound to number of lines */\n\t\tmax = (int) sbuf.st_size;\n\t\tlast_read = sbuf.st_mtime;\n\t}\n\n\t/* create 1 more than max to have it be the ending NULL */\n\tpasswd_list = (char **) malloc( (max+1) * (sizeof(char *)) );\n\tfor (i=0; i<max+1; i++) {\n\t\tpasswd_list[i] = NULL;\n\t}\n\t\n\tif (in == NULL) {\n\t\tin = fopen(filename, \"r\");\n\t}\n\tif (in == NULL) {\n\t\trfbLog(\"cannot open passwdfile: %s\\n\", passfile);\n\t\trfbLogPerror(\"fopen\");\n\t\tif (remove) {\n\t\t\tunlink(filename);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\tif (getenv(\"DEBUG_PASSWDFILE\") != NULL) {\n\t\tdb_passwd = 1;\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tchar *p;\n\t\tint blank = 1;\n\t\tint len = strlen(line); \n\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: raw line: %s\\n\", line);\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tcontinue;\n\t\t} else if (line[len-1] == '\\n') {\n\t\t\tline[len-1] = '\\0';\n\t\t}\n\t\tif (line[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__SKIP__\") != NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__COMM__\") == line) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(line, \"__BEGIN_VIEWONLY__\")) {\n\t\t\tif (begin_vo < 0) {\n\t\t\t\tbegin_vo = linecount;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[0] == '#') {\n\t\t\t/* commented out, cannot have password beginning with # */\n\t\t\tcontinue;\n\t\t}\n\t\tp = line;\n\t\twhile (*p != '\\0') {\n\t\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\t\tblank = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (blank) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpasswd_list[linecount++] = strdup(line);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: keepline: %s\\n\", line);\n\t\t\tfprintf(stderr, \"read_passwds: begin_vo: %d\\n\", begin_vo);\n\t\t}\n\n\t\tif (linecount >= max) {\n\t\t\trfbLog(\"read_passwds: hit max passwd: %d\\n\", max);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in);\n\n\tfor (i=0; i<1024; i++) {\n\t\tline[i] = '\\0';\n\t}\n\n\tif (remove) {\n\t\tunlink(filename);\n\t}\n\n\tif (! linecount) {\n\t\trfbLog(\"cannot read a valid line from passwdfile: %s\\n\",\n\t\t    passfile);\n\t\tif (read_cnt == 0) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_cnt++;\n\n\tfor (i=0; i<linecount; i++) {\n\t\tchar *q, *p = passwd_list[i];\n\t\tif (!strcmp(p, \"__EMPTY__\")) {\n\t\t\t*p = '\\0';\n\t\t} else if ((q = strstr(p, \"__COMM__\")) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tpasswd_list[i] = strdup(p);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: trimline: %s\\n\", p);\n\t\t}\n\t\tstrzero(p);\n\t}\n\n\tbegin_viewonly = begin_vo;\n\tif (read_mode && read_cnt > 1) {\n\t\tif (viewonly_passwd) {\n\t\t\tfree(viewonly_passwd);\n\t\t\tviewonly_passwd = NULL;\n\t\t}\n\t}\n\n\tif (begin_viewonly < 0 && linecount == 2) {\n\t\t/* for compatibility with previous 2-line usage: */\n\t\tviewonly_passwd = strdup(passwd_list[1]);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: linecount is 2.\\n\");\n\t\t}\n\t\tif (screen) {\n\t\t\tchar **apd = (char **) screen->authPasswdData;\n\t\t\tif (apd) {\n\t\t\t\tif (apd[0] != NULL) {\n\t\t\t\t\tstrzero(apd[0]);\n\t\t\t\t}\n\t\t\t\tapd[0] = strdup(passwd_list[0]);\n\t\t\t}\n\t\t}\n\t\tbegin_viewonly = 1;\n\t}\n\n\tif (old_passwd_list != NULL) {\n\t\tchar *p;\n\t\ti = 0;\n\t\twhile (old_passwd_list[i] != NULL) {\n\t\t\tp = old_passwd_list[i];\n\t\t\tstrzero(p);\n\t\t\tfree(old_passwd_list[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(old_passwd_list);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int read_passwds(char *passfile);",
            "rfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nint read_passwds(char *passfile);\nrfbBool custom_passwd_check(rfbClientPtr cl, const char *response, int len);\n\nint read_passwds(char *passfile) {\n\tchar line[1024];\n\tchar *filename;\n\tchar **old_passwd_list = passwd_list;\n\tint linecount = 0, i, remove = 0, read_mode = 0, begin_vo = -1;\n\tstruct stat sbuf;\n\tstatic int max = -1;\n\tFILE *in = NULL;\n\tstatic time_t last_read = 0;\n\tstatic int read_cnt = 0;\n\tint db_passwd = 0;\n\n\tif (max < 0) {\n\t\tmax = 1000;\n\t\tif (getenv(\"X11VNC_MAX_PASSWDS\")) {\n\t\t\tmax = atoi(getenv(\"X11VNC_MAX_PASSWDS\"));\n\t\t}\n\t}\n\n\tfilename = passfile;\n\tif (strstr(filename, \"rm:\") == filename) {\n\t\tfilename += strlen(\"rm:\");\n\t\tremove = 1;\n\t} else if (strstr(filename, \"read:\") == filename) {\n\t\tfilename += strlen(\"read:\");\n\t\tread_mode = 1;\n\t\tif (stat(filename, &sbuf) == 0) {\n\t\t\tif (sbuf.st_mtime <= last_read) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlast_read = sbuf.st_mtime;\n\t\t}\n\t} else if (strstr(filename, \"cmd:\") == filename) {\n\t\tint rc;\n\n\t\tfilename += strlen(\"cmd:\");\n\t\tread_mode = 1;\n\t\tin = tmpfile();\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"run_user_command tmpfile() failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trc = run_user_command(filename, latest_client, \"read_passwds\",\n\t\t    NULL, 0, in);\n\t\tif (rc != 0) {\n\t\t\trfbLog(\"run_user_command command failed: %s\\n\",\n\t\t\t    filename);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\trewind(in);\n\t} else if (strstr(filename, \"custom:\") == filename) {\n\t\treturn 1;\n\t}\n\n\tif (in == NULL && stat(filename, &sbuf) == 0) {\n\t\t/* (poor...) upper bound to number of lines */\n\t\tmax = (int) sbuf.st_size;\n\t\tlast_read = sbuf.st_mtime;\n\t}\n\n\t/* create 1 more than max to have it be the ending NULL */\n\tpasswd_list = (char **) malloc( (max+1) * (sizeof(char *)) );\n\tfor (i=0; i<max+1; i++) {\n\t\tpasswd_list[i] = NULL;\n\t}\n\t\n\tif (in == NULL) {\n\t\tin = fopen(filename, \"r\");\n\t}\n\tif (in == NULL) {\n\t\trfbLog(\"cannot open passwdfile: %s\\n\", passfile);\n\t\trfbLogPerror(\"fopen\");\n\t\tif (remove) {\n\t\t\tunlink(filename);\n\t\t}\n\t\tclean_up_exit(1);\n\t}\n\n\tif (getenv(\"DEBUG_PASSWDFILE\") != NULL) {\n\t\tdb_passwd = 1;\n\t}\n\n\twhile (fgets(line, sizeof line, in) != NULL) {\n\t\tchar *p;\n\t\tint blank = 1;\n\t\tint len = strlen(line); \n\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: raw line: %s\\n\", line);\n\t\t}\n\n\t\tif (len == 0) {\n\t\t\tcontinue;\n\t\t} else if (line[len-1] == '\\n') {\n\t\t\tline[len-1] = '\\0';\n\t\t}\n\t\tif (line[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__SKIP__\") != NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(line, \"__COMM__\") == line) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(line, \"__BEGIN_VIEWONLY__\")) {\n\t\t\tif (begin_vo < 0) {\n\t\t\t\tbegin_vo = linecount;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[0] == '#') {\n\t\t\t/* commented out, cannot have password beginning with # */\n\t\t\tcontinue;\n\t\t}\n\t\tp = line;\n\t\twhile (*p != '\\0') {\n\t\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\t\tblank = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (blank) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpasswd_list[linecount++] = strdup(line);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: keepline: %s\\n\", line);\n\t\t\tfprintf(stderr, \"read_passwds: begin_vo: %d\\n\", begin_vo);\n\t\t}\n\n\t\tif (linecount >= max) {\n\t\t\trfbLog(\"read_passwds: hit max passwd: %d\\n\", max);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(in);\n\n\tfor (i=0; i<1024; i++) {\n\t\tline[i] = '\\0';\n\t}\n\n\tif (remove) {\n\t\tunlink(filename);\n\t}\n\n\tif (! linecount) {\n\t\trfbLog(\"cannot read a valid line from passwdfile: %s\\n\",\n\t\t    passfile);\n\t\tif (read_cnt == 0) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_cnt++;\n\n\tfor (i=0; i<linecount; i++) {\n\t\tchar *q, *p = passwd_list[i];\n\t\tif (!strcmp(p, \"__EMPTY__\")) {\n\t\t\t*p = '\\0';\n\t\t} else if ((q = strstr(p, \"__COMM__\")) != NULL) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tpasswd_list[i] = strdup(p);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: trimline: %s\\n\", p);\n\t\t}\n\t\tstrzero(p);\n\t}\n\n\tbegin_viewonly = begin_vo;\n\tif (read_mode && read_cnt > 1) {\n\t\tif (viewonly_passwd) {\n\t\t\tfree(viewonly_passwd);\n\t\t\tviewonly_passwd = NULL;\n\t\t}\n\t}\n\n\tif (begin_viewonly < 0 && linecount == 2) {\n\t\t/* for compatibility with previous 2-line usage: */\n\t\tviewonly_passwd = strdup(passwd_list[1]);\n\t\tif (db_passwd) {\n\t\t\tfprintf(stderr, \"read_passwds: linecount is 2.\\n\");\n\t\t}\n\t\tif (screen) {\n\t\t\tchar **apd = (char **) screen->authPasswdData;\n\t\t\tif (apd) {\n\t\t\t\tif (apd[0] != NULL) {\n\t\t\t\t\tstrzero(apd[0]);\n\t\t\t\t}\n\t\t\t\tapd[0] = strdup(passwd_list[0]);\n\t\t\t}\n\t\t}\n\t\tbegin_viewonly = 1;\n\t}\n\n\tif (old_passwd_list != NULL) {\n\t\tchar *p;\n\t\ti = 0;\n\t\twhile (old_passwd_list[i] != NULL) {\n\t\t\tp = old_passwd_list[i];\n\t\t\tstrzero(p);\n\t\t\tfree(old_passwd_list[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(old_passwd_list);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "passwdfile",
            "\"cmd:\""
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "passwdfile",
            "\"read:\""
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"denying client: accept_cmd=\\\"%s\\\"\\n\"",
            "accept_cmd ? accept_cmd : \"(null)\""
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"denying client: %s local user rejected connection.\\n\"",
            "client->host"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept_client",
          "args": [
            "client"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "accept_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1592-1744",
          "snippet": "int accept_client(rfbClientPtr client) {\n\n\tchar xmessage[200], *cmd = NULL;\n\tchar *addr = client->host;\n\tchar *action = NULL;\n\n\tif (accept_cmd == NULL || *accept_cmd == '\\0') {\n\t\treturn 1;\t/* no command specified, so we accept */\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\tif (strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\t/* use our builtin popup button */\n\n\t\t/* (popup|popupkey|popupmouse)[+-X+-Y][:timeout] */\n\n\t\tint ret, timeout = 120;\n\t\tint x = -64000, y = -64000;\n\t\tchar *p, *mode;\n\t\tchar *userhost = ident_username(client);\n\n\t\t/* extract timeout */\n\t\tif ((p = strchr(accept_cmd, ':')) != NULL) {\n\t\t\tint in;\n\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\ttimeout = in;\n\t\t\t}\n\t\t}\n\t\t/* extract geometry */\n\t\tif ((p = strpbrk(accept_cmd, \"+-\")) != NULL) {\n\t\t\tugly_geom(p, &x, &y);\n\t\t}\n\n\t\t/* find mode: mouse, key, or both */\n\t\tif (strstr(accept_cmd, \"popupmouse\") == accept_cmd) {\n\t\t\tmode = \"mouse_only\";\n\t\t} else if (strstr(accept_cmd, \"popupkey\") == accept_cmd) {\n\t\t\tmode = \"key_only\";\n\t\t} else {\n\t\t\tmode = \"both\";\n\t\t}\n\n\t\tif (dpy == NULL && use_dpy && strstr(use_dpy, \"WAIT:\") ==\n\t\t    use_dpy) {\n\t\t\trfbLog(\"accept_client: warning allowing client under conditions:\\n\");\n\t\t\trfbLog(\"  -display WAIT:, dpy == NULL, -accept popup.\\n\");\n\t\t\trfbLog(\"   There will be another popup.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\trfbLog(\"accept_client: using builtin popup for: %s\\n\", addr);\n\t\tif ((ret = ugly_window(addr, userhost, x, y, timeout,\n\t\t    mode, 1))) {\n\t\t\tfree(userhost);\n\t\t\tif (ret == 2) {\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t}\n\t\t\trfbLog(\"accept_client: popup accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfree(userhost);\n\t\t\trfbLog(\"accept_client: popup rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(accept_cmd, \"xmessage\")) {\n\t\t/* make our own command using xmessage(1) */\n\n\t\tif (view_only) {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2 -center\"\n\t\t\t    \" 'x11vnc: accept connection from %s?'\", addr);\n\t\t} else {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2,\"\n\t\t\t    \"view-only:3 -center\" \" 'x11vnc: accept connection\"\n\t\t\t    \" from %s?'\", addr);\n\t\t\taction = \"yes:0,no:*,view:3\";\n\t\t}\n\t\tcmd = xmessage;\n\t\t\n\t} else {\n\t\t/* use the user supplied command: */\n\n\t\tcmd = accept_cmd;\n\n\t\t/* extract any action prefix:  yes:N,no:M,view:K */\n\t\tif (strstr(accept_cmd, \"yes:\") == accept_cmd) {\n\t\t\tchar *p;\n\t\t\tif ((p = strpbrk(accept_cmd, \" \\t\")) != NULL) {\n\t\t\t\tint i;\n\t\t\t\tcmd = p;\n\t\t\t\tp = accept_cmd;\n\t\t\t\tfor (i=0; i<200; i++) {\n\t\t\t\t\tif (*p == ' ' || *p == '\\t') {\n\t\t\t\t\t\txmessage[i] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\txmessage[i] = *p;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\txmessage[200-1] = '\\0';\n\t\t\t\taction = xmessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd) {\n\t\tint rc;\n\n\t\trfbLog(\"accept_client: using cmd for: %s\\n\", addr);\n\t\trc = run_user_command(cmd, client, \"accept\", NULL, 0, NULL);\n\n\t\tif (action) {\n\t\t\tint result;\n\n\t\t\tif (rc < 0) {\n\t\t\t\trfbLog(\"accept_client: cannot use negative \"\n\t\t\t\t    \"rc: %d, action %s\\n\", rc, action);\n\t\t\t\tresult = 2;\n\t\t\t} else {\n\t\t\t\tresult = action_match(action, rc);\n\t\t\t}\n\n\t\t\tif (result == 1) {\n\t\t\t\trc = 0;\n\t\t\t} else if (result == 2) {\n\t\t\t\trc = 1;\n\t\t\t} else if (result == 3) {\n\t\t\t\trc = 0;\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t} else {\n\t\t\t\trc = 1;\t/* NOTREACHED */\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\trfbLog(\"accept_client: accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"accept_client: rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\trfbLog(\"accept_client: no command, rejecting %s\\n\", addr);\n\t\treturn 0;\n\t}\n\n\t/* return 0; NOTREACHED */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);",
            "static void ugly_geom(char *p, int *x, int *y);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint accept_client(rfbClientPtr client) {\n\n\tchar xmessage[200], *cmd = NULL;\n\tchar *addr = client->host;\n\tchar *action = NULL;\n\n\tif (accept_cmd == NULL || *accept_cmd == '\\0') {\n\t\treturn 1;\t/* no command specified, so we accept */\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\tif (strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\t/* use our builtin popup button */\n\n\t\t/* (popup|popupkey|popupmouse)[+-X+-Y][:timeout] */\n\n\t\tint ret, timeout = 120;\n\t\tint x = -64000, y = -64000;\n\t\tchar *p, *mode;\n\t\tchar *userhost = ident_username(client);\n\n\t\t/* extract timeout */\n\t\tif ((p = strchr(accept_cmd, ':')) != NULL) {\n\t\t\tint in;\n\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\ttimeout = in;\n\t\t\t}\n\t\t}\n\t\t/* extract geometry */\n\t\tif ((p = strpbrk(accept_cmd, \"+-\")) != NULL) {\n\t\t\tugly_geom(p, &x, &y);\n\t\t}\n\n\t\t/* find mode: mouse, key, or both */\n\t\tif (strstr(accept_cmd, \"popupmouse\") == accept_cmd) {\n\t\t\tmode = \"mouse_only\";\n\t\t} else if (strstr(accept_cmd, \"popupkey\") == accept_cmd) {\n\t\t\tmode = \"key_only\";\n\t\t} else {\n\t\t\tmode = \"both\";\n\t\t}\n\n\t\tif (dpy == NULL && use_dpy && strstr(use_dpy, \"WAIT:\") ==\n\t\t    use_dpy) {\n\t\t\trfbLog(\"accept_client: warning allowing client under conditions:\\n\");\n\t\t\trfbLog(\"  -display WAIT:, dpy == NULL, -accept popup.\\n\");\n\t\t\trfbLog(\"   There will be another popup.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\trfbLog(\"accept_client: using builtin popup for: %s\\n\", addr);\n\t\tif ((ret = ugly_window(addr, userhost, x, y, timeout,\n\t\t    mode, 1))) {\n\t\t\tfree(userhost);\n\t\t\tif (ret == 2) {\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t}\n\t\t\trfbLog(\"accept_client: popup accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfree(userhost);\n\t\t\trfbLog(\"accept_client: popup rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(accept_cmd, \"xmessage\")) {\n\t\t/* make our own command using xmessage(1) */\n\n\t\tif (view_only) {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2 -center\"\n\t\t\t    \" 'x11vnc: accept connection from %s?'\", addr);\n\t\t} else {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2,\"\n\t\t\t    \"view-only:3 -center\" \" 'x11vnc: accept connection\"\n\t\t\t    \" from %s?'\", addr);\n\t\t\taction = \"yes:0,no:*,view:3\";\n\t\t}\n\t\tcmd = xmessage;\n\t\t\n\t} else {\n\t\t/* use the user supplied command: */\n\n\t\tcmd = accept_cmd;\n\n\t\t/* extract any action prefix:  yes:N,no:M,view:K */\n\t\tif (strstr(accept_cmd, \"yes:\") == accept_cmd) {\n\t\t\tchar *p;\n\t\t\tif ((p = strpbrk(accept_cmd, \" \\t\")) != NULL) {\n\t\t\t\tint i;\n\t\t\t\tcmd = p;\n\t\t\t\tp = accept_cmd;\n\t\t\t\tfor (i=0; i<200; i++) {\n\t\t\t\t\tif (*p == ' ' || *p == '\\t') {\n\t\t\t\t\t\txmessage[i] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\txmessage[i] = *p;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\txmessage[200-1] = '\\0';\n\t\t\t\taction = xmessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd) {\n\t\tint rc;\n\n\t\trfbLog(\"accept_client: using cmd for: %s\\n\", addr);\n\t\trc = run_user_command(cmd, client, \"accept\", NULL, 0, NULL);\n\n\t\tif (action) {\n\t\t\tint result;\n\n\t\t\tif (rc < 0) {\n\t\t\t\trfbLog(\"accept_client: cannot use negative \"\n\t\t\t\t    \"rc: %d, action %s\\n\", rc, action);\n\t\t\t\tresult = 2;\n\t\t\t} else {\n\t\t\t\tresult = action_match(action, rc);\n\t\t\t}\n\n\t\t\tif (result == 1) {\n\t\t\t\trc = 0;\n\t\t\t} else if (result == 2) {\n\t\t\t\trc = 1;\n\t\t\t} else if (result == 3) {\n\t\t\t\trc = 0;\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t} else {\n\t\t\t\trc = 1;\t/* NOTREACHED */\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\trfbLog(\"accept_client: accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"accept_client: rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\trfbLog(\"accept_client: no command, rejecting %s\\n\", addr);\n\t\treturn 0;\n\t}\n\n\t/* return 0; NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(ClientData)",
            "1"
          ],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"denying additional client: %s during MD creation.\\n\"",
            "client->host"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"denying client: %s does not match %s\\n\"",
            "client->host",
            "allow_list ? allow_list : \"(null)\""
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_access",
          "args": [
            "client->host"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "check_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "969-1141",
          "snippet": "int check_access(char *addr) {\n\tint allowed = 0;\n\tint ssl = 0;\n\tchar *p, *list;\n\n\tif (use_openssl || use_stunnel) {\n\t\tssl = 1;\n\t}\n\tif (deny_all) {\n\t\trfbLog(\"check_access: new connections are currently \"\n\t\t    \"blocked.\\n\");\n\t\treturn 0;\n\t}\n\tif (addr == NULL || *addr == '\\0') {\n\t\trfbLog(\"check_access: denying empty host IP address string.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (allow_list == NULL) {\n\t\t/* set to \"\" to possibly append allow_once */\n\t\tallow_list = strdup(\"\");\n\t}\n\tif (*allow_list == '\\0' && allow_once == NULL) {\n\t\t/* no constraints, accept it */\n\t\treturn 1;\n\t}\n\n\tif (strchr(allow_list, '/')) {\n\t\t/* a file of IP addresess or prefixes */\n\t\tint len, len2 = 0;\n\t\tstruct stat sbuf;\n\t\tFILE *in;\n\t\tchar line[1024], *q;\n\n\t\tif (stat(allow_list, &sbuf) != 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: failure stating file: %s\\n\",\n\t\t\t    allow_list);\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tlen = sbuf.st_size + 1;\t/* 1 more for '\\0' at end */\n\t\tif (allow_once) {\n\t\t\tlen2 = strlen(allow_once) + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen2 = strlen(\"127.0.0.1\") + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\t\n\t\tin = fopen(allow_list, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: cannot open: %s\\n\", allow_list);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif ( (q = strchr(line, '#')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strlen(list) + strlen(line) >=\n\t\t\t    (size_t) (len - len2)) {\n\t\t\t\t/* file grew since our stat() */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcat(list, line);\n\t\t}\n\t\tfclose(in);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, allow_once);\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t} else {\n\t\tint len = strlen(allow_list) + 1;\n\t\tif (allow_once) {\n\t\t\tlen += strlen(allow_once) + 1;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen += strlen(\"127.0.0.1\") + 1;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\tstrcat(list, allow_list);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, allow_once);\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t}\n\t}\n\n\tif (allow_once) {\n\t\tfree(allow_once);\n\t\tallow_once = NULL;\n\t}\n\t\n\tp = strtok(list, \", \\t\\n\\r\");\n\twhile (p) {\n\t\tchar *chk, *q, *r = NULL;\n\t\tif (*p == '\\0') {\n\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\tcontinue;\t\n\t\t}\n\t\tif (ipv6_ip(p)) {\n\t\t\tchk = p;\n\t\t} else if (! dotted_ip(p, 1)) {\n\t\t\tr = host2ip(p);\n\t\t\tif (r == NULL || *r == '\\0') {\n\t\t\t\trfbLog(\"check_access: bad lookup \\\"%s\\\"\\n\", p);\n\t\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"check_access: lookup %s -> %s\\n\", p, r);\n\t\t\tchk = r;\n\t\t} else {\n\t\t\tchk = p;\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_ACCESS\")) fprintf(stderr, \"chk: %s  part: %s  addr: %s\\n\", chk, p, addr);\n\n\t\tq = strstr(addr, chk);\n\t\tif (ipv6_ip(addr)) {\n\t\t\tif (!strcmp(chk, \"localhost\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"::1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"127.0.0.1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\t/* this if for host2ip(\"localhost\") */\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (q == addr) {\n\t\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (chk[strlen(chk)-1] != '.') {\n\t\t\tif (!strcmp(addr, chk)) {\n\t\t\t\tif (chk != p) {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s=%s\\n\", addr, chk, p);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s\\n\", addr, chk);\n\t\t\t\t}\n\t\t\t\tallowed = 1;\n\t\t\t} else if(!strcmp(chk, \"localhost\") && !strcmp(addr, \"127.0.0.1\")) {\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (q == addr) {\n\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\tallowed = 1;\n\t\t}\n\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\tif (r) {\n\t\t\tfree(r);\n\t\t}\n\t\tif (allowed) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(list);\n\treturn allowed;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "int accept_client(rfbClientPtr client);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static void check_connect_file(char *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic void check_connect_file(char *file);\n\nint check_access(char *addr) {\n\tint allowed = 0;\n\tint ssl = 0;\n\tchar *p, *list;\n\n\tif (use_openssl || use_stunnel) {\n\t\tssl = 1;\n\t}\n\tif (deny_all) {\n\t\trfbLog(\"check_access: new connections are currently \"\n\t\t    \"blocked.\\n\");\n\t\treturn 0;\n\t}\n\tif (addr == NULL || *addr == '\\0') {\n\t\trfbLog(\"check_access: denying empty host IP address string.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (allow_list == NULL) {\n\t\t/* set to \"\" to possibly append allow_once */\n\t\tallow_list = strdup(\"\");\n\t}\n\tif (*allow_list == '\\0' && allow_once == NULL) {\n\t\t/* no constraints, accept it */\n\t\treturn 1;\n\t}\n\n\tif (strchr(allow_list, '/')) {\n\t\t/* a file of IP addresess or prefixes */\n\t\tint len, len2 = 0;\n\t\tstruct stat sbuf;\n\t\tFILE *in;\n\t\tchar line[1024], *q;\n\n\t\tif (stat(allow_list, &sbuf) != 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: failure stating file: %s\\n\",\n\t\t\t    allow_list);\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tlen = sbuf.st_size + 1;\t/* 1 more for '\\0' at end */\n\t\tif (allow_once) {\n\t\t\tlen2 = strlen(allow_once) + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen2 = strlen(\"127.0.0.1\") + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\t\n\t\tin = fopen(allow_list, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: cannot open: %s\\n\", allow_list);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif ( (q = strchr(line, '#')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strlen(list) + strlen(line) >=\n\t\t\t    (size_t) (len - len2)) {\n\t\t\t\t/* file grew since our stat() */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcat(list, line);\n\t\t}\n\t\tfclose(in);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, allow_once);\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t} else {\n\t\tint len = strlen(allow_list) + 1;\n\t\tif (allow_once) {\n\t\t\tlen += strlen(allow_once) + 1;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen += strlen(\"127.0.0.1\") + 1;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\tstrcat(list, allow_list);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, allow_once);\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t}\n\t}\n\n\tif (allow_once) {\n\t\tfree(allow_once);\n\t\tallow_once = NULL;\n\t}\n\t\n\tp = strtok(list, \", \\t\\n\\r\");\n\twhile (p) {\n\t\tchar *chk, *q, *r = NULL;\n\t\tif (*p == '\\0') {\n\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\tcontinue;\t\n\t\t}\n\t\tif (ipv6_ip(p)) {\n\t\t\tchk = p;\n\t\t} else if (! dotted_ip(p, 1)) {\n\t\t\tr = host2ip(p);\n\t\t\tif (r == NULL || *r == '\\0') {\n\t\t\t\trfbLog(\"check_access: bad lookup \\\"%s\\\"\\n\", p);\n\t\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"check_access: lookup %s -> %s\\n\", p, r);\n\t\t\tchk = r;\n\t\t} else {\n\t\t\tchk = p;\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_ACCESS\")) fprintf(stderr, \"chk: %s  part: %s  addr: %s\\n\", chk, p, addr);\n\n\t\tq = strstr(addr, chk);\n\t\tif (ipv6_ip(addr)) {\n\t\t\tif (!strcmp(chk, \"localhost\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"::1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"127.0.0.1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\t/* this if for host2ip(\"localhost\") */\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (q == addr) {\n\t\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (chk[strlen(chk)-1] != '.') {\n\t\t\tif (!strcmp(addr, chk)) {\n\t\t\t\tif (chk != p) {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s=%s\\n\", addr, chk, p);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s\\n\", addr, chk);\n\t\t\t\t}\n\t\t\t\tallowed = 1;\n\t\t\t} else if(!strcmp(chk, \"localhost\") && !strcmp(addr, \"127.0.0.1\")) {\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (q == addr) {\n\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\tallowed = 1;\n\t\t}\n\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\tif (r) {\n\t\t\tfree(r);\n\t\t}\n\t\tif (allowed) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(list);\n\treturn allowed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ipv6_client_ip_str"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"renaming client->host from '%s' to '%s'\\n\"",
            "client->host ? client->host : \"\"",
            "ipv6_client_ip_str"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"denying additional client: %s:%d\\n\"",
            "client->host",
            "get_remote_port(client->sock)"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"denying additional client: %s during -unixpw login.\\n\"",
            "client->host"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"denying additional client: %s ssl not setup\"\n\t\t\t    \" yet.\\n\"",
            "client->host"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nrfbClientPtr inetd_client = NULL;\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic int accepted_client = 0;\nstatic int turn_off_truecolor = 0;\n\nenum rfbNewClientAction new_client(rfbClientPtr client) {\n\tClientData *cd; \n\n\tCLIENT_LOCK;\n\n\tlast_event = last_input = time(NULL);\n\n\tlatest_client = client;\n\n\tif (inetd) {\n\t\t/* \n\t\t * Set this so we exit as soon as connection closes,\n\t\t * otherwise client_gone is only called after RFB_CLIENT_ACCEPT\n\t\t */\n\t\tif (inetd_client == NULL) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t}\n\n\tclients_served++;\n\n\tif (use_openssl || use_stunnel) {\n\t\tif (! ssl_initialized) {\n\t\t\trfbLog(\"denying additional client: %s ssl not setup\"\n\t\t\t    \" yet.\\n\", client->host);\n\t\t\tCLIENT_UNLOCK;\n\t\t\treturn(RFB_CLIENT_REFUSE);\n\t\t}\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"denying additional client: %s during -unixpw login.\\n\",\n\t\t     client->host);\n\t\tCLIENT_UNLOCK;\n\t\treturn(RFB_CLIENT_REFUSE);\n\t}\n\tif (connect_once) {\n\t\tif (screen->dontDisconnect && screen->neverShared) {\n\t\t\tif (! shared && accepted_client) {\n\t\t\t\trfbLog(\"denying additional client: %s:%d\\n\",\n\t\t\t\t     client->host, get_remote_port(client->sock));\n\t\t\t\tCLIENT_UNLOCK;\n\t\t\t\treturn(RFB_CLIENT_REFUSE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ipv6_client_ip_str != NULL) {\n\t\trfbLog(\"renaming client->host from '%s' to '%s'\\n\",\n\t\t    client->host ? client->host : \"\", ipv6_client_ip_str);\n\t\tif (client->host) {\n\t\t\tfree(client->host);\n\t\t}\n\t\tclient->host = strdup(ipv6_client_ip_str);\n\t}\n\n\tif (! check_access(client->host)) {\n\t\trfbLog(\"denying client: %s does not match %s\\n\", client->host,\n\t\t    allow_list ? allow_list : \"(null)\" );\n\t\tCLIENT_UNLOCK;\n\t\treturn(RFB_CLIENT_REFUSE);\n\t}\n\n        if(use_multipointer && xi2_device_creation_in_progress) {\n            rfbLog(\"denying additional client: %s during MD creation.\\n\", client->host);\n\t    CLIENT_UNLOCK;\n            return(RFB_CLIENT_REFUSE);\n        }\n\n\tclient->clientData = (void *) calloc(sizeof(ClientData), 1);\n\tcd = (ClientData *) client->clientData;\n\n\t/* see client_set_net() we delay the DNS lookups during handshake */\n\tcd->client_port = -1;\n\tcd->username = strdup(\"\");\n\tcd->unixname = strdup(\"\");\n\tcd->cursor_x_saved = cd->cursor_y_saved = -1;\n\n\tcd->input[0] = '-';\n\tcd->login_viewonly = -1;\n\tcd->login_time = time(NULL);\n\tcd->ssl_helper_pid = 0;\n\n\tif (use_openssl && openssl_last_helper_pid) {\n\t\tcd->ssl_helper_pid = openssl_last_helper_pid;\n\t\topenssl_last_helper_pid = 0;\n\t}\n\n\tif (! accept_client(client)) {\n\t\trfbLog(\"denying client: %s local user rejected connection.\\n\",\n\t\t    client->host);\n\t\trfbLog(\"denying client: accept_cmd=\\\"%s\\\"\\n\",\n\t\t    accept_cmd ? accept_cmd : \"(null)\" );\n\n\t\tfree_client_data(client);\n\n\t\tCLIENT_UNLOCK;\n\t\treturn(RFB_CLIENT_REFUSE);\n\t}\n\n\t/* We will RFB_CLIENT_ACCEPT or RFB_CLIENT_ON_HOLD from here on. */\n\n\tif (passwdfile) {\n\t\tif (strstr(passwdfile, \"read:\") == passwdfile ||\n\t\t    strstr(passwdfile, \"cmd:\") == passwdfile) {\n\t\t\tif (read_passwds(passwdfile)) {\n\t\t\t\tinstall_passwds();\n\t\t\t} else {\n\t\t\t\trfbLog(\"problem reading: %s\\n\", passwdfile);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else if (strstr(passwdfile, \"custom:\") == passwdfile) {\n\t\t\tif (screen) {\n\t\t\t\t/* mutex */\n\t\t\t\tscreen->passwordCheck = custom_passwd_check;\n\t\t\t}\n\t\t}\n\t}\n\n\tcd->uid = clients_served;\n\n        /*\n\t  create new XInput2 master device and add it it to client\n\t*/\n        if(use_multipointer)\n          {\n\t    char tmp[256];\n            snprintf(tmp, sizeof tmp, \"x11vnc %s\", client->host);\n\n            xi2_device_creation_in_progress = 1;\n\n\t    if((cd->ptr_id = createMD(dpy, tmp)) < 0) {\n\t      rfbLog(\"ERROR creating XInput2 MD for client %s, denying client.\\n\", client->host);\n\t      free_client_data(client);\n\t      xi2_device_creation_in_progress = 0;\n\t      CLIENT_UNLOCK;\n\t      return(RFB_CLIENT_REFUSE);\n\t    }\n\n            cd->kbd_id = getPairedMD(dpy, cd->ptr_id);\n\n            rfbLog(\"Created XInput2 MD %i %i for client %s.\\n\", cd->ptr_id, cd->kbd_id, client->host);\n\n            xi2_device_creation_in_progress = 0;\n\n            snprintf(tmp, sizeof tmp, \"%i\", cd->uid);\n\t    cd->cursor = setClientCursor(dpy, cd->ptr_id, 0.4*(cd->ptr_id%3), 0.2*(cd->ptr_id%5), 1*(cd->ptr_id%2), tmp);\n\t    if(!cd->cursor)\n              rfbLog(\"Setting cursor for client %s failed.\\n\", client->host);\n\n\t    cd->cursor_region = sraRgnCreate();\n          }\n\n\tclient->clientGoneHook = client_gone;\n\n\tif (client_count) {\n\t\tspeeds_net_rate_measured = 0;\n\t\tspeeds_net_latency_measured = 0;\n\t}\n\tclient_count++;\n\n\tlast_keyboard_input = last_pointer_input = time(NULL);\n\n\tif (no_autorepeat && client_count == 1 && ! view_only) {\n\t\t/*\n\t\t * first client, turn off X server autorepeat\n\t\t * XXX handle dynamic change of view_only and per-client.\n\t\t */\n\t\tautorepeat(0, 0);\n\t}\n#ifdef MACOSX\n\tif (macosx_console && client_count == 1) {\n\t\tmacosxCG_refresh_callback_on();\n\t}\n#endif\n\tif (use_solid_bg && client_count == 1) {\n\t\tsolid_bg(0);\n\t}\n\n\tif (pad_geometry) {\n\t\tinstall_padded_fb(pad_geometry);\n\t}\n\n\tcd->timer = last_new_client = dnow();\n\tcd->send_cmp_rate = 0.0;\n\tcd->send_raw_rate = 0.0;\n\tcd->latency = 0.0;\n\tcd->cmp_bytes_sent = 0;\n\tcd->raw_bytes_sent = 0;\n\n\taccepted_client++;\n\trfbLog(\"incr accepted_client=%d for %s:%d  sock=%d\\n\", accepted_client,\n\t    client->host, get_remote_port(client->sock), client->sock);\n\tlast_client = time(NULL);\n\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tif (advertise_truecolor && indexed_color) {\n\t\tint rs = 0, gs = 2, bs = 4;\n\t\tint rm = 3, gm = 3, bm = 3;\n\t\tif (bpp >= 24) {\n\t\t\trs = 0, gs = 8, bs = 16;\n\t\t\trm = 255, gm = 255, bm = 255;\n\t\t} else if (bpp >= 16) {\n\t\t\trs = 0, gs = 5, bs = 10;\n\t\t\trm = 31, gm = 31, bm = 31;\n\t\t}\n\t\trfbLog(\"advertising truecolor.\\n\");\n\t\tif (getenv(\"ADVERT_BMSHIFT\")) {\n\t\t\tbm--;\n\t\t}\n\n\t\tif (use_threads) LOCK(client->updateMutex);\n\n\t\tclient->format.trueColour = TRUE;\n\t\tclient->format.redShift   = rs;\n\t\tclient->format.greenShift = gs;\n\t\tclient->format.blueShift  = bs;\n\t\tclient->format.redMax     = rm;\n\t\tclient->format.greenMax   = gm;\n\t\tclient->format.blueMax    = bm;\n\n\t\tif (use_threads) UNLOCK(client->updateMutex);\n\n\t\trfbSetTranslateFunction(client);\n\n\t\t/* mutex */\n\t\tscreen->serverFormat.trueColour = TRUE;\n\t\tscreen->serverFormat.redShift   = rs;\n\t\tscreen->serverFormat.greenShift = gs;\n\t\tscreen->serverFormat.blueShift  = bs;\n\t\tscreen->serverFormat.redMax     = rm;\n\t\tscreen->serverFormat.greenMax   = gm;\n\t\tscreen->serverFormat.blueMax    = bm;\n\t\tscreen->displayHook = turn_off_truecolor_ad;\n\n\t\tturn_off_truecolor = 1;\n\t}\n\n\tif (unixpw) {\n\t\tunixpw_in_progress = 1;\n\t\tunixpw_client = client;\n\t\tunixpw_login_viewonly = 0;\n\n\t\tunixpw_file_xfer_save = screen->permitFileTransfer;\n\t\tscreen->permitFileTransfer = FALSE;\n\t\tunixpw_tightvnc_xfer_save = tightfilexfer;\n\t\ttightfilexfer = 0;\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 1\\n\");\n\t\trfbUnregisterTightVNCFileTransferExtension();\n#endif\n\n\t\tif (client->viewOnly) {\n\t\t\tunixpw_login_viewonly = 1;\n\t\t\tclient->viewOnly = FALSE;\n\t\t}\n\t\tunixpw_last_try_time = time(NULL) + 10;\n\n\t\tunixpw_screen(1);\n\t\tunixpw_keystroke(0, 0, 1);\n\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"new client: %s in non-unixpw_in_rfbPE.\\n\",\n\t\t\t     client->host);\n\t\t}\n\t\tCLIENT_UNLOCK;\n\t\tif (!use_threads) {\n\t\t\t/* always put client on hold even if unixpw_in_rfbPE is true */\n\t\t\treturn(RFB_CLIENT_ON_HOLD);\n\t\t} else {\n\t\t\t/* unixpw threads is still in testing mode, disabled by default. See UNIXPW_THREADS */\n\t\t\treturn(RFB_CLIENT_ACCEPT);\n\t\t}\n\t}\n\n\tCLIENT_UNLOCK;\n\treturn(RFB_CLIENT_ACCEPT);\n}"
  },
  {
    "function_name": "client_set_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3903-3920",
    "snippet": "void client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"client_set_net: %s  %.4f\\n\"",
            "client->host",
            "dnow() - dt"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ip2host",
          "args": [
            "client->host"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "ip2host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "112-136",
          "snippet": "char *ip2host(char *ip) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\tin_addr_t iaddr;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\tiaddr = inet_addr(ip);\n\tif (iaddr == htonl(INADDR_NONE)) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr((char *)&iaddr, sizeof(in_addr_t), AF_INET);\n\tif (!hp) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *ip2host(char *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ip2host(char *ip);\n\nchar *ip2host(char *ip) {\n\tchar *str;\n#if HAVE_NETDB_H && LIBVNCSERVER_HAVE_NETINET_IN_H\n\tstruct hostent *hp;\n\tin_addr_t iaddr;\n\n\tif (! host_lookup) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\tiaddr = inet_addr(ip);\n\tif (iaddr == htonl(INADDR_NONE)) {\n\t\treturn strdup(\"unknown\");\n\t}\n\n\thp = gethostbyaddr((char *)&iaddr, sizeof(in_addr_t), AF_INET);\n\tif (!hp) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tstr = strdup(hp->h_name);\n#else\n\tstr = strdup(\"unknown\");\n#endif\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_host",
          "args": [
            "client->sock"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "262-264",
          "snippet": "char *get_local_host(int sock) {\n\treturn get_host(sock, 0);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nchar *get_local_host(int sock) {\n\treturn get_host(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_local_port",
          "args": [
            "client->sock"
          ],
          "line": 3915
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "230-232",
          "snippet": "int get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_remote_port",
          "args": [
            "client->sock"
          ],
          "line": 3914
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "226-228",
          "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}"
  },
  {
    "function_name": "client_gone_chat_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3897-3901",
    "snippet": "void client_gone_chat_helper(rfbClientPtr client) {\n\tif (client) {}\n\trfbLog(\"finished chat helper\\n\");\n\tchat_window_client = NULL;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"finished chat helper\\n\""
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid client_gone_chat_helper(rfbClientPtr client) {\n\tif (client) {}\n\trfbLog(\"finished chat helper\\n\");\n\tchat_window_client = NULL;\n}"
  },
  {
    "function_name": "new_client_chat_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3890-3895",
    "snippet": "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client) {\n\tif (client) {}\n\tclient->clientGoneHook = client_gone_chat_helper;\n\trfbLog(\"new chat helper\\n\");\n\treturn(RFB_CLIENT_ACCEPT);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"new chat helper\\n\""
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client) {\n\tif (client) {}\n\tclient->clientGoneHook = client_gone_chat_helper;\n\trfbLog(\"new chat helper\\n\");\n\treturn(RFB_CLIENT_ACCEPT);\n}"
  },
  {
    "function_name": "password_check_chat_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3871-3888",
    "snippet": "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len) {\n\tif (response || len) {}\n\tif (cl != chat_window_client) {\n\t\trfbLog(\"invalid client during chat_helper login\\n\");\n\t\treturn FALSE;\n\t} else {\n\t\tif (!cl->host) {\n\t\t\trfbLog(\"empty cl->host during chat_helper login\\n\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (strcmp(cl->host, \"127.0.0.1\")) {\n\t\t\trfbLog(\"invalid cl->host during chat_helper login: %s\\n\", cl->host);\n\t\t\treturn FALSE;\n\t\t}\n\t\trfbLog(\"chat_helper login accepted\\n\");\n\t\treturn TRUE;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"chat_helper login accepted\\n\""
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid cl->host during chat_helper login: %s\\n\"",
            "cl->host"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cl->host",
            "\"127.0.0.1\""
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"empty cl->host during chat_helper login\\n\""
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid client during chat_helper login\\n\""
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len) {\n\tif (response || len) {}\n\tif (cl != chat_window_client) {\n\t\trfbLog(\"invalid client during chat_helper login\\n\");\n\t\treturn FALSE;\n\t} else {\n\t\tif (!cl->host) {\n\t\t\trfbLog(\"empty cl->host during chat_helper login\\n\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (strcmp(cl->host, \"127.0.0.1\")) {\n\t\t\trfbLog(\"invalid cl->host during chat_helper login: %s\\n\", cl->host);\n\t\t\treturn FALSE;\n\t\t}\n\t\trfbLog(\"chat_helper login accepted\\n\");\n\t\treturn TRUE;\n\t}\n}"
  },
  {
    "function_name": "turn_off_truecolor_ad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3849-3864",
    "snippet": "static void turn_off_truecolor_ad(rfbClientPtr client) {\n\tif (client) {}\n\tif (turn_off_truecolor) {\n\t\trfbLog(\"turning off truecolor advertising.\\n\");\n\t\t/* mutex */\n\t\tscreen->serverFormat.trueColour = FALSE;\n\t\tscreen->displayHook = NULL;\n\t\tscreen->serverFormat.redShift   = 0;\n\t\tscreen->serverFormat.greenShift = 0;\n\t\tscreen->serverFormat.blueShift  = 0;\n\t\tscreen->serverFormat.redMax     = 0;\n\t\tscreen->serverFormat.greenMax   = 0;\n\t\tscreen->serverFormat.blueMax    = 0;\n\t\tturn_off_truecolor = 0;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);",
      "static int turn_off_truecolor = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"turning off truecolor advertising.\\n\""
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic int turn_off_truecolor = 0;\n\nstatic void turn_off_truecolor_ad(rfbClientPtr client) {\n\tif (client) {}\n\tif (turn_off_truecolor) {\n\t\trfbLog(\"turning off truecolor advertising.\\n\");\n\t\t/* mutex */\n\t\tscreen->serverFormat.trueColour = FALSE;\n\t\tscreen->displayHook = NULL;\n\t\tscreen->serverFormat.redShift   = 0;\n\t\tscreen->serverFormat.greenShift = 0;\n\t\tscreen->serverFormat.blueShift  = 0;\n\t\tscreen->serverFormat.redMax     = 0;\n\t\tscreen->serverFormat.greenMax   = 0;\n\t\tscreen->serverFormat.blueMax    = 0;\n\t\tturn_off_truecolor = 0;\n\t}\n}"
  },
  {
    "function_name": "create_new_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3826-3845",
    "snippet": "rfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbClientPtr create_new_client(int sock, int start_thread);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbStartOnHoldClient",
          "args": [
            "cl"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbNewClient",
          "args": [
            "screen",
            "sock"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nrfbClientPtr create_new_client(int sock, int start_thread);\n\nrfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}"
  },
  {
    "function_name": "check_gui_inputs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3734-3824",
    "snippet": "void check_gui_inputs(void) {\n\tint i, gnmax = 0, n = 0, nfds;\n\tint socks[ICON_MODE_SOCKS];\n\tfd_set fds;\n\tstruct timeval tv;\n\tchar buf[X11VNC_REMOTE_MAX+1];\n\tssize_t nbytes;\n\n\tif (unixpw_in_progress) return;\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] >= 0) {\n\t\t\tsocks[n++] = i;\n\t\t\tif (icon_mode_socks[i] > gnmax) {\n\t\t\t\tgnmax = icon_mode_socks[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! n) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tfor (i=0; i<n; i++) {\n\t\tFD_SET(icon_mode_socks[socks[i]], &fds);\n\t}\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(gnmax+1, &fds, NULL, NULL, &tv);\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i<n; i++) {\n\t\tint k, fd = icon_mode_socks[socks[i]];\n\t\tchar *p;\n\t\tchar **list;\n\t\tint lind;\n\n\t\tif (! FD_ISSET(fd, &fds)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (k=0; k<=X11VNC_REMOTE_MAX; k++) {\n\t\t\tbuf[k] = '\\0';\n\t\t}\n\t\tnbytes = read(fd, buf, X11VNC_REMOTE_MAX);\n\t\tif (nbytes <= 0) {\n\t\t\tclose(fd);\n\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist = (char **) calloc((strlen(buf)+2) * sizeof(char *), 1);\n\n\t\tlind = 0;\n\t\tp = strtok(buf, \"\\r\\n\");\n\t\twhile (p) {\n\t\t\tlist[lind++] = strdup(p);\n\t\t\tp = strtok(NULL, \"\\r\\n\");\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (strstr(p, \"cmd=\") == p ||\n\t\t\t    strstr(p, \"qry=\") == p) {\n\t\t\t\tchar *str = process_remote_cmd(p, 1);\n\t\t\t\tif (! str) {\n\t\t\t\t\tstr = strdup(\"\");\n\t\t\t\t}\n\t\t\t\tnbytes = write(fd, str, strlen(str));\n\t\t\t\twrite(fd, \"\\n\", 1);\n\t\t\t\tfree(str);\n\t\t\t\tif (nbytes < 0) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (p) free(p);\n\t\t}\n\t\tfree(list);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "int cmd_ok(char *cmd);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void check_gui_inputs(void);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "list"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "\"\\n\"",
            "1"
          ],
          "line": 3807
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_remote_cmd",
          "args": [
            "p",
            "1"
          ],
          "line": 3802
        },
        "resolved": true,
        "details": {
          "function_name": "process_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "843-6324",
          "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}",
            "#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}"
          ],
          "globals_used": [
            "int send_remote_cmd(char *cmd, int query, int wait);",
            "void check_black_fb(void);",
            "int check_httpdir(void);",
            "void http_connections(int on);",
            "int remote_control_access_ok(void);",
            "char *process_remote_cmd(char *cmd, int stringonly);",
            "static void if_8bpp_do_new_fb(void);",
            "int rc_npieces = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\nint send_remote_cmd(char *cmd, int query, int wait);\nvoid check_black_fb(void);\nint check_httpdir(void);\nvoid http_connections(int on);\nint remote_control_access_ok(void);\nchar *process_remote_cmd(char *cmd, int stringonly);\nstatic void if_8bpp_do_new_fb(void);\nint rc_npieces = 0;\n\nchar *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"qry=\""
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"cmd=\""
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\\r\\n\""
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "buf",
            "\"\\r\\n\""
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(strlen(buf)+2) * sizeof(char *)",
            "1"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buf",
            "X11VNC_REMOTE_MAX"
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "fd",
            "&fds"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "gnmax+1",
            "&fds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "icon_mode_socks[socks[i]]",
            "&fds"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid check_gui_inputs(void);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid check_gui_inputs(void) {\n\tint i, gnmax = 0, n = 0, nfds;\n\tint socks[ICON_MODE_SOCKS];\n\tfd_set fds;\n\tstruct timeval tv;\n\tchar buf[X11VNC_REMOTE_MAX+1];\n\tssize_t nbytes;\n\n\tif (unixpw_in_progress) return;\n\n\tfor (i=0; i<ICON_MODE_SOCKS; i++) {\n\t\tif (icon_mode_socks[i] >= 0) {\n\t\t\tsocks[n++] = i;\n\t\t\tif (icon_mode_socks[i] > gnmax) {\n\t\t\t\tgnmax = icon_mode_socks[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (! n) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tfor (i=0; i<n; i++) {\n\t\tFD_SET(icon_mode_socks[socks[i]], &fds);\n\t}\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(gnmax+1, &fds, NULL, NULL, &tv);\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\t\n\tfor (i=0; i<n; i++) {\n\t\tint k, fd = icon_mode_socks[socks[i]];\n\t\tchar *p;\n\t\tchar **list;\n\t\tint lind;\n\n\t\tif (! FD_ISSET(fd, &fds)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (k=0; k<=X11VNC_REMOTE_MAX; k++) {\n\t\t\tbuf[k] = '\\0';\n\t\t}\n\t\tnbytes = read(fd, buf, X11VNC_REMOTE_MAX);\n\t\tif (nbytes <= 0) {\n\t\t\tclose(fd);\n\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist = (char **) calloc((strlen(buf)+2) * sizeof(char *), 1);\n\n\t\tlind = 0;\n\t\tp = strtok(buf, \"\\r\\n\");\n\t\twhile (p) {\n\t\t\tlist[lind++] = strdup(p);\n\t\t\tp = strtok(NULL, \"\\r\\n\");\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (strstr(p, \"cmd=\") == p ||\n\t\t\t    strstr(p, \"qry=\") == p) {\n\t\t\t\tchar *str = process_remote_cmd(p, 1);\n\t\t\t\tif (! str) {\n\t\t\t\t\tstr = strdup(\"\");\n\t\t\t\t}\n\t\t\t\tnbytes = write(fd, str, strlen(str));\n\t\t\t\twrite(fd, \"\\n\", 1);\n\t\t\t\tfree(str);\n\t\t\t\tif (nbytes < 0) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t\ticon_mode_socks[socks[i]] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlind = 0;\n\t\twhile (list[lind] != NULL) {\n\t\t\tp = list[lind++];\n\t\t\tif (p) free(p);\n\t\t}\n\t\tfree(list);\n\t}\n}"
  },
  {
    "function_name": "check_connect_inputs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3706-3732",
    "snippet": "void check_connect_inputs(void) {\n\n\tif (unixpw_in_progress) return;\n\n\t/* flush any already set: */\n\tsend_client_connect();\n\n\t/* connect file: */\n\tif (client_connect_file != NULL) {\n\t\tcheck_connect_file(client_connect_file);\t\t\n\t}\n\tsend_client_connect();\n\n\t/* VNC_CONNECT property (vncconnect program) */\n\tif (vnc_connect && *vnc_connect_str != '\\0') {\n\t\tclient_connect = strdup(vnc_connect_str);\n\t\tvnc_connect_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n\n\t/* X11VNC_REMOTE property */\n\tif (vnc_connect && *x11vnc_remote_str != '\\0') {\n\t\tclient_connect = strdup(x11vnc_remote_str);\n\t\tx11vnc_remote_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char vnc_connect_str[VNC_CONNECT_MAX+1];",
      "char x11vnc_remote_str[X11VNC_REMOTE_MAX+1];",
      "void check_connect_inputs(void);",
      "static void check_connect_file(char *file);",
      "static void send_client_connect(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_client_connect",
          "args": [],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "send_client_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3685-3701",
          "snippet": "static void send_client_connect(void) {\n\tif (client_connect != NULL) {\n\t\tchar *str = client_connect;\n\t\tif (strstr(str, \"cmd=\") == str || strstr(str, \"qry=\") == str) {\n\t\t\tprocess_remote_cmd(client_connect, 0);\n\t\t} else if (strstr(str, \"ans=\") == str\n\t\t    || strstr(str, \"aro=\") == str) {\n\t\t\t;\n\t\t} else if (strstr(str, \"ack=\") == str) {\n\t\t\t;\n\t\t} else {\n\t\t\treverse_connect(client_connect);\n\t\t}\n\t\tfree(client_connect);\n\t\tclient_connect = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);",
            "static void send_client_connect(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\nstatic void send_client_connect(void);\n\nstatic void send_client_connect(void) {\n\tif (client_connect != NULL) {\n\t\tchar *str = client_connect;\n\t\tif (strstr(str, \"cmd=\") == str || strstr(str, \"qry=\") == str) {\n\t\t\tprocess_remote_cmd(client_connect, 0);\n\t\t} else if (strstr(str, \"ans=\") == str\n\t\t    || strstr(str, \"aro=\") == str) {\n\t\t\t;\n\t\t} else if (strstr(str, \"ack=\") == str) {\n\t\t\t;\n\t\t} else {\n\t\t\treverse_connect(client_connect);\n\t\t}\n\t\tfree(client_connect);\n\t\tclient_connect = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "x11vnc_remote_str"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "vnc_connect_str"
          ],
          "line": 3721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_connect_file",
          "args": [
            "client_connect_file"
          ],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "check_connect_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1927-2009",
          "snippet": "static void check_connect_file(char *file) {\n\tFILE *in;\n\tchar line[VNC_CONNECT_MAX], host[VNC_CONNECT_MAX];\n\tstatic int first_warn = 1, truncate_ok = 1;\n\tstatic double last_time = 0.0, delay = 0.5; \n\tdouble now = dnow();\n\tstruct stat sbuf;\n\n\tif (last_time == 0.0) {\n\t\tif (!getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t/* skip first */\n\t\t\tlast_time = now;\n\t\t} else {\n\t\t\tdelay = 0.25;\n\t\t}\n\t}\n\tif (now - last_time < delay) {\n\t\t/* check only about once a second */\n\t\treturn;\n\t}\n\tlast_time = now;\n\n\tif (! truncate_ok) {\n\t\t/* check if permissions changed */\n\t\tif (access(file, W_OK) == 0) {\n\t\t\ttruncate_ok = 1;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat(file, &sbuf) == 0) {\n\t\t/* skip empty file directly */\n\t\tif (sbuf.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tin = fopen(file, \"r\");\n\tif (in == NULL) {\n\t\tif (first_warn) {\n\t\t\trfbLog(\"check_connect_file: fopen failure: %s\\n\", file);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfirst_warn = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fgets(line, VNC_CONNECT_MAX, in) != NULL) {\n\t\tif (sscanf(line, \"%s\", host) == 1) {\n\t\t\tif (strlen(host) > 0) {\n\t\t\t\tchar *str = strdup(host);\n\t\t\t\tif (strlen(str) > 38) {\n\t\t\t\t\tchar trim[100]; \n\t\t\t\t\ttrim[0] = '\\0';\n\t\t\t\t\tstrncat(trim, str, 38);\n\t\t\t\t\trfbLog(\"read connect file: %s ...\\n\",\n\t\t\t\t\t    trim);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"read connect file: %s\\n\", str);\n\t\t\t\t}\n\t\t\t\tif (!strcmp(str, \"cmd=stop\") &&\n\t\t\t\t    dnowx() < 3.0) {\n\t\t\t\t\trfbLog(\"ignoring stale cmd=stop\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tclient_connect = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(in);\n\n\t/* truncate file */\n\tin = fopen(file, \"w\");\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else {\n\t\t/* disable if we cannot truncate */\n\t\trfbLog(\"check_connect_file: could not truncate %s, \"\n\t\t   \"disabling checking.\\n\", file);\n\t\ttruncate_ok = 0;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);",
            "static void check_connect_file(char *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\nstatic void check_connect_file(char *file);\n\nstatic void check_connect_file(char *file) {\n\tFILE *in;\n\tchar line[VNC_CONNECT_MAX], host[VNC_CONNECT_MAX];\n\tstatic int first_warn = 1, truncate_ok = 1;\n\tstatic double last_time = 0.0, delay = 0.5; \n\tdouble now = dnow();\n\tstruct stat sbuf;\n\n\tif (last_time == 0.0) {\n\t\tif (!getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t/* skip first */\n\t\t\tlast_time = now;\n\t\t} else {\n\t\t\tdelay = 0.25;\n\t\t}\n\t}\n\tif (now - last_time < delay) {\n\t\t/* check only about once a second */\n\t\treturn;\n\t}\n\tlast_time = now;\n\n\tif (! truncate_ok) {\n\t\t/* check if permissions changed */\n\t\tif (access(file, W_OK) == 0) {\n\t\t\ttruncate_ok = 1;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat(file, &sbuf) == 0) {\n\t\t/* skip empty file directly */\n\t\tif (sbuf.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tin = fopen(file, \"r\");\n\tif (in == NULL) {\n\t\tif (first_warn) {\n\t\t\trfbLog(\"check_connect_file: fopen failure: %s\\n\", file);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfirst_warn = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fgets(line, VNC_CONNECT_MAX, in) != NULL) {\n\t\tif (sscanf(line, \"%s\", host) == 1) {\n\t\t\tif (strlen(host) > 0) {\n\t\t\t\tchar *str = strdup(host);\n\t\t\t\tif (strlen(str) > 38) {\n\t\t\t\t\tchar trim[100]; \n\t\t\t\t\ttrim[0] = '\\0';\n\t\t\t\t\tstrncat(trim, str, 38);\n\t\t\t\t\trfbLog(\"read connect file: %s ...\\n\",\n\t\t\t\t\t    trim);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"read connect file: %s\\n\", str);\n\t\t\t\t}\n\t\t\t\tif (!strcmp(str, \"cmd=stop\") &&\n\t\t\t\t    dnowx() < 3.0) {\n\t\t\t\t\trfbLog(\"ignoring stale cmd=stop\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tclient_connect = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(in);\n\n\t/* truncate file */\n\tin = fopen(file, \"w\");\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else {\n\t\t/* disable if we cannot truncate */\n\t\trfbLog(\"check_connect_file: could not truncate %s, \"\n\t\t   \"disabling checking.\\n\", file);\n\t\ttruncate_ok = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar vnc_connect_str[VNC_CONNECT_MAX+1];\nchar x11vnc_remote_str[X11VNC_REMOTE_MAX+1];\nvoid check_connect_inputs(void);\nstatic void check_connect_file(char *file);\nstatic void send_client_connect(void);\n\nvoid check_connect_inputs(void) {\n\n\tif (unixpw_in_progress) return;\n\n\t/* flush any already set: */\n\tsend_client_connect();\n\n\t/* connect file: */\n\tif (client_connect_file != NULL) {\n\t\tcheck_connect_file(client_connect_file);\t\t\n\t}\n\tsend_client_connect();\n\n\t/* VNC_CONNECT property (vncconnect program) */\n\tif (vnc_connect && *vnc_connect_str != '\\0') {\n\t\tclient_connect = strdup(vnc_connect_str);\n\t\tvnc_connect_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n\n\t/* X11VNC_REMOTE property */\n\tif (vnc_connect && *x11vnc_remote_str != '\\0') {\n\t\tclient_connect = strdup(x11vnc_remote_str);\n\t\tx11vnc_remote_str[0] = '\\0';\n\t}\n\tsend_client_connect();\n}"
  },
  {
    "function_name": "send_client_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3685-3701",
    "snippet": "static void send_client_connect(void) {\n\tif (client_connect != NULL) {\n\t\tchar *str = client_connect;\n\t\tif (strstr(str, \"cmd=\") == str || strstr(str, \"qry=\") == str) {\n\t\t\tprocess_remote_cmd(client_connect, 0);\n\t\t} else if (strstr(str, \"ans=\") == str\n\t\t    || strstr(str, \"aro=\") == str) {\n\t\t\t;\n\t\t} else if (strstr(str, \"ack=\") == str) {\n\t\t\t;\n\t\t} else {\n\t\t\treverse_connect(client_connect);\n\t\t}\n\t\tfree(client_connect);\n\t\tclient_connect = NULL;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "int cmd_ok(char *cmd);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);",
      "static void send_client_connect(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "client_connect"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reverse_connect",
          "args": [
            "client_connect"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2853-3026",
          "snippet": "void reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "void send_client_info(char *str);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nvoid send_client_info(char *str);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"ack=\""
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"aro=\""
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"ans=\""
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_remote_cmd",
          "args": [
            "client_connect",
            "0"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "process_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "843-6324",
          "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}",
            "#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}"
          ],
          "globals_used": [
            "int send_remote_cmd(char *cmd, int query, int wait);",
            "void check_black_fb(void);",
            "int check_httpdir(void);",
            "void http_connections(int on);",
            "int remote_control_access_ok(void);",
            "char *process_remote_cmd(char *cmd, int stringonly);",
            "static void if_8bpp_do_new_fb(void);",
            "int rc_npieces = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\nint send_remote_cmd(char *cmd, int query, int wait);\nvoid check_black_fb(void);\nint check_httpdir(void);\nvoid http_connections(int on);\nint remote_control_access_ok(void);\nchar *process_remote_cmd(char *cmd, int stringonly);\nstatic void if_8bpp_do_new_fb(void);\nint rc_npieces = 0;\n\nchar *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"qry=\""
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"cmd=\""
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\nstatic void send_client_connect(void);\n\nstatic void send_client_connect(void) {\n\tif (client_connect != NULL) {\n\t\tchar *str = client_connect;\n\t\tif (strstr(str, \"cmd=\") == str || strstr(str, \"qry=\") == str) {\n\t\t\tprocess_remote_cmd(client_connect, 0);\n\t\t} else if (strstr(str, \"ans=\") == str\n\t\t    || strstr(str, \"aro=\") == str) {\n\t\t\t;\n\t\t} else if (strstr(str, \"ack=\") == str) {\n\t\t\t;\n\t\t} else {\n\t\t\treverse_connect(client_connect);\n\t\t}\n\t\tfree(client_connect);\n\t\tclient_connect = NULL;\n\t}\n}"
  },
  {
    "function_name": "wininfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3617-3680",
    "snippet": "char *wininfo(Window win, int show_children) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!win || !show_children) {}\n\treturn NULL;\n#else\n\tXWindowAttributes attr;\n\tint n, size = X11VNC_REMOTE_MAX;\n\tchar get_str[X11VNC_REMOTE_MAX+1];\n\tunsigned int nchildren;\n\tWindow rr, pr, *children; \n\n\tRAWFB_RET(NULL)\n\n\tif (win == None) {\n\t\treturn strdup(\"None\");\n\t}\n\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn strdup(\"Invalid\");\n\t}\n\tget_str[0] = '\\0';\n\n\tif (show_children) {\n\t\tXQueryTree_wr(dpy, win, &rr, &pr, &children, &nchildren);\n\t} else {\n\t\tnchildren = 1;\n\t\tchildren = (Window *) calloc(2 * sizeof(Window), 1);\n\t\tchildren[0] = win;\n\t}\n\tfor (n=0; n < (int) nchildren; n++) {\n\t\tchar tmp[32];\n\t\tchar *str = \"Invalid\";\n\t\tWindow w = children[n];\n\t\tif (valid_window(w, &attr, 1)) {\n\t\t\tif (!show_children) {\n\t\t\t\tstr = win_fmt(w, attr);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"0x%lx\", w);\n\t\t\t\tstr = tmp;\n\t\t\t}\n\t\t}\n\t\tif ((int) (strlen(get_str) + 1 + strlen(str)) >= size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (n > 0) {\n\t\t\tstrcat(get_str, \",\");\n\t\t}\n\t\tstrcat(get_str, str);\n\t}\n\tget_str[size] = '\\0';\n\tif (!show_children) {\n\t\tfree(children);\n\t} else if (nchildren) {\n\t\tXFree_wr(children);\n\t}\n\trfbLog(\"wininfo computed: %s\\n\", get_str);\n\tX_UNLOCK;\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "char *get_xprop(char *prop, Window win);",
      "char *wininfo(Window win, int show_children);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "get_str"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wininfo computed: %s\\n\"",
            "get_str"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "children"
          ],
          "line": 3673
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "children"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "get_str",
            "str"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "get_str",
            "\",\""
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "get_str"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"0x%lx\"",
            "w"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "win_fmt",
          "args": [
            "w",
            "attr"
          ],
          "line": 3655
        },
        "resolved": true,
        "details": {
          "function_name": "win_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3609-3615",
          "snippet": "static char *win_fmt(Window win, XWindowAttributes a) {\n\tmemset(_win_fmt, 0, sizeof(_win_fmt));\n\tsprintf(_win_fmt, \"0x%lx:%dx%dx%d+%d+%d-map:%d-bw:%d-cl:%d-vis:%d-bs:%d/%d\",\n\t    win, a.width, a.height, a.depth, a.x, a.y, a.map_state, a.border_width, a.class,\n\t    (int) ((a.visual)->visualid), a.backing_store, a.save_under);\n\treturn _win_fmt;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_xprop(char *prop, Window win);",
            "static void ugly_geom(char *p, int *x, int *y);",
            "static char _win_fmt[1000];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_xprop(char *prop, Window win);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic char _win_fmt[1000];\n\nstatic char *win_fmt(Window win, XWindowAttributes a) {\n\tmemset(_win_fmt, 0, sizeof(_win_fmt));\n\tsprintf(_win_fmt, \"0x%lx:%dx%dx%d+%d+%d-map:%d-bw:%d-cl:%d-vis:%d-bs:%d/%d\",\n\t    win, a.width, a.height, a.depth, a.x, a.y, a.map_state, a.border_width, a.class,\n\t    (int) ((a.visual)->visualid), a.backing_store, a.save_under);\n\treturn _win_fmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "w",
            "&attr",
            "1"
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "2 * sizeof(Window)",
            "1"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "win",
            "&rr",
            "&pr",
            "&children",
            "&nchildren"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"Invalid\""
          ],
          "line": 3638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"None\""
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nchar *get_xprop(char *prop, Window win);\nchar *wininfo(Window win, int show_children);\nstatic rfbClientPtr *client_match(char *str);\n\nchar *wininfo(Window win, int show_children) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!win || !show_children) {}\n\treturn NULL;\n#else\n\tXWindowAttributes attr;\n\tint n, size = X11VNC_REMOTE_MAX;\n\tchar get_str[X11VNC_REMOTE_MAX+1];\n\tunsigned int nchildren;\n\tWindow rr, pr, *children; \n\n\tRAWFB_RET(NULL)\n\n\tif (win == None) {\n\t\treturn strdup(\"None\");\n\t}\n\n\tX_LOCK;\n\tif (!valid_window(win, &attr, 1)) {\n\t\tX_UNLOCK;\n\t\treturn strdup(\"Invalid\");\n\t}\n\tget_str[0] = '\\0';\n\n\tif (show_children) {\n\t\tXQueryTree_wr(dpy, win, &rr, &pr, &children, &nchildren);\n\t} else {\n\t\tnchildren = 1;\n\t\tchildren = (Window *) calloc(2 * sizeof(Window), 1);\n\t\tchildren[0] = win;\n\t}\n\tfor (n=0; n < (int) nchildren; n++) {\n\t\tchar tmp[32];\n\t\tchar *str = \"Invalid\";\n\t\tWindow w = children[n];\n\t\tif (valid_window(w, &attr, 1)) {\n\t\t\tif (!show_children) {\n\t\t\t\tstr = win_fmt(w, attr);\n\t\t\t} else {\n\t\t\t\tsprintf(tmp, \"0x%lx\", w);\n\t\t\t\tstr = tmp;\n\t\t\t}\n\t\t}\n\t\tif ((int) (strlen(get_str) + 1 + strlen(str)) >= size) {\n\t\t\tbreak;\n\t\t}\n\t\tif (n > 0) {\n\t\t\tstrcat(get_str, \",\");\n\t\t}\n\t\tstrcat(get_str, str);\n\t}\n\tget_str[size] = '\\0';\n\tif (!show_children) {\n\t\tfree(children);\n\t} else if (nchildren) {\n\t\tXFree_wr(children);\n\t}\n\trfbLog(\"wininfo computed: %s\\n\", get_str);\n\tX_UNLOCK;\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "win_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3609-3615",
    "snippet": "static char *win_fmt(Window win, XWindowAttributes a) {\n\tmemset(_win_fmt, 0, sizeof(_win_fmt));\n\tsprintf(_win_fmt, \"0x%lx:%dx%dx%d+%d+%d-map:%d-bw:%d-cl:%d-vis:%d-bs:%d/%d\",\n\t    win, a.width, a.height, a.depth, a.x, a.y, a.map_state, a.border_width, a.class,\n\t    (int) ((a.visual)->visualid), a.backing_store, a.save_under);\n\treturn _win_fmt;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_xprop(char *prop, Window win);",
      "static void ugly_geom(char *p, int *x, int *y);",
      "static char _win_fmt[1000];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "_win_fmt",
            "\"0x%lx:%dx%dx%d+%d+%d-map:%d-bw:%d-cl:%d-vis:%d-bs:%d/%d\"",
            "win",
            "a.width",
            "a.height",
            "a.depth",
            "a.x",
            "a.y",
            "a.map_state",
            "a.border_width",
            "a.class",
            "(int) ((a.visual)->visualid)",
            "a.backing_store",
            "a.save_under"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "_win_fmt",
            "0",
            "sizeof(_win_fmt)"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_xprop(char *prop, Window win);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic char _win_fmt[1000];\n\nstatic char *win_fmt(Window win, XWindowAttributes a) {\n\tmemset(_win_fmt, 0, sizeof(_win_fmt));\n\tsprintf(_win_fmt, \"0x%lx:%dx%dx%d+%d+%d-map:%d-bw:%d-cl:%d-vis:%d-bs:%d/%d\",\n\t    win, a.width, a.height, a.depth, a.x, a.y, a.map_state, a.border_width, a.class,\n\t    (int) ((a.visual)->visualid), a.backing_store, a.save_under);\n\treturn _win_fmt;\n}"
  },
  {
    "function_name": "get_xprop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3551-3605",
    "snippet": "char *get_xprop(char *prop, Window win) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!prop || !win) {}\n\treturn NULL;\n#else\n\tAtom type, aprop;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar get_str[VNC_CONNECT_MAX+1];\n\n\tRAWFB_RET(NULL)\n\n\tif (prop == NULL || !strcmp(prop, \"\")) {\n\t\treturn NULL;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, True);\n\tif (aprop == None) {\n\t\treturn NULL;\n\t}\n\n\tget_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read the property value into get_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, win, aprop, nitems/4,\n\t\t    VNC_CONNECT_MAX/16, False, AnyPropertyType, &type,\n\t\t    &format, &nitems, &bytes_after, &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"get_xprop: warning: truncating large '%s'\"\n\t\t\t\t   \" string > %d bytes.\\n\", prop, VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(get_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tget_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tget_str[VNC_CONNECT_MAX] = '\\0';\n\trfbLog(\"get_prop: read: '%s' = '%s'\\n\", prop, get_str);\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "char *get_xprop(char *prop, Window win);",
      "int set_xprop(char *prop, Window win, char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "get_str"
          ],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_prop: read: '%s' = '%s'\\n\"",
            "prop",
            "get_str"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "data"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "get_str+slen",
            "data",
            "dlen"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_xprop: warning: truncating large '%s'\"\n\t\t\t\t   \" string > %d bytes.\\n\"",
            "prop",
            "VNC_CONNECT_MAX"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "win",
            "aprop",
            "nitems/4",
            "VNC_CONNECT_MAX/16",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&nitems",
            "&bytes_after",
            "&data"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "prop",
            "True"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "prop",
            "\"\""
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nchar *get_xprop(char *prop, Window win);\nint set_xprop(char *prop, Window win, char *value);\n\nchar *get_xprop(char *prop, Window win) {\n#if NO_X11\n\tRAWFB_RET(NULL)\n\tif (!prop || !win) {}\n\treturn NULL;\n#else\n\tAtom type, aprop;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar get_str[VNC_CONNECT_MAX+1];\n\n\tRAWFB_RET(NULL)\n\n\tif (prop == NULL || !strcmp(prop, \"\")) {\n\t\treturn NULL;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, True);\n\tif (aprop == None) {\n\t\treturn NULL;\n\t}\n\n\tget_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read the property value into get_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, win, aprop, nitems/4,\n\t\t    VNC_CONNECT_MAX/16, False, AnyPropertyType, &type,\n\t\t    &format, &nitems, &bytes_after, &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"get_xprop: warning: truncating large '%s'\"\n\t\t\t\t   \" string > %d bytes.\\n\", prop, VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(get_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tget_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tget_str[VNC_CONNECT_MAX] = '\\0';\n\trfbLog(\"get_prop: read: '%s' = '%s'\\n\", prop, get_str);\n\n\treturn strdup(get_str);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "set_xprop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3524-3549",
    "snippet": "int set_xprop(char *prop, Window win, char *value) {\n\tint rc = -1;\n#if !NO_X11\n\tAtom aprop;\n\n\tRAWFB_RET(rc)\n\n\tif (!prop || !value) {\n\t\treturn rc;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, False);\n\tif (aprop == None) {\n\t\treturn rc;\n\t}\n\trc = XChangeProperty(dpy, win, aprop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)value, strlen(value));\n\treturn rc;\n#else\n\tRAWFB_RET(rc)\n\tif (!prop || !win || !value) {}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_xprop(char *prop, Window win);",
      "int set_xprop(char *prop, Window win, char *value);",
      "static int action_match(char *action, int rc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "win",
            "aprop",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)value",
            "strlen(value)"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "prop",
            "False"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_xprop(char *prop, Window win);\nint set_xprop(char *prop, Window win, char *value);\nstatic int action_match(char *action, int rc);\n\nint set_xprop(char *prop, Window win, char *value) {\n\tint rc = -1;\n#if !NO_X11\n\tAtom aprop;\n\n\tRAWFB_RET(rc)\n\n\tif (!prop || !value) {\n\t\treturn rc;\n\t}\n\tif (win == None) {\n\t\twin = rootwin;\n\t}\n\taprop = XInternAtom(dpy, prop, False);\n\tif (aprop == None) {\n\t\treturn rc;\n\t}\n\trc = XChangeProperty(dpy, win, aprop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)value, strlen(value));\n\treturn rc;\n#else\n\tRAWFB_RET(rc)\n\tif (!prop || !win || !value) {}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "bcx_xattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3239-3522",
    "snippet": "char *bcx_xattach(char *str, int *pg_init, int *kg_init) {\n\tint grab_check = 1;\n\tint shift = 20;\n\tint final_x = 30, final_y = 30;\n\tint extra_x = -1, extra_y = -1;\n\tint t1, t2, dt = 40 * 1000;\n\tint ifneeded = 0;\n\tchar *dir = \"none\", *flip = \"none\", *q;\n\tint pg1, kg1, pg2, kg2;\n\tchar _bcx_res[128];\n\t\n\t/* str:[up,down,left,right]+nograbcheck+shift=n+final=x+y+extra_move=x+y+[master_to_slave,slave_to_master,M2S,S2M]+dt=n+retry=n+ifneeded */\n\n\tif (strstr(str, \"up\")) {\n\t\tdir = \"up\";\n\t} else if (strstr(str, \"down\")) {\n\t\tdir = \"down\";\n\t} else if (strstr(str, \"left\")) {\n\t\tdir = \"left\";\n\t} else if (strstr(str, \"right\")) {\n\t\tdir = \"right\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_DIRECTION_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"master_to_slave\") || strstr(str, \"M2S\")) {\n\t\tflip = \"M2S\";\n\t} else if (strstr(str, \"slave_to_master\") || strstr(str, \"S2M\")) {\n\t\tflip = \"S2M\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_MODE_CHANGE_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"nograbcheck\")) {\n\t\tgrab_check = 0;\n\t}\n\tif (strstr(str, \"ifneeded\")) {\n\t\tifneeded = 1;\n\t}\n\tq = strstr(str, \"shift=\");\n\tif (q && sscanf(q, \"shift=%d\", &t1) == 1) {\n\t\tshift = t1;\n\t}\n\tq = strstr(str, \"final=\");\n\tif (q && sscanf(q, \"final=%d+%d\", &t1, &t2) == 2) {\n\t\tfinal_x = t1;\n\t\tfinal_y = t2;\n\t}\n\tq = strstr(str, \"extra_move=\");\n\tif (q && sscanf(q, \"extra_move=%d+%d\", &t1, &t2) == 2) {\n\t\textra_x = t1;\n\t\textra_y = t2;\n\t}\n\tq = strstr(str, \"dt=\");\n\tif (q && sscanf(q, \"dt=%d\", &t1) == 1) {\n\t\tdt = t1 * 1000;\n\t}\n\n\tif (grab_check) {\n\t\tint read_init = 0;\n\n\t\tif (*pg_init >=0 && *kg_init >=0)  {\n\t\t\tpg1 = *pg_init;\n\t\t\tkg1 = *kg_init;\n\t\t\tread_init = 1;\n\t\t} else {\n\t\t\tgrab_state(&pg1, &kg1);\n\t\t\tread_init = 0;\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (ifneeded && pg1 == 1 && kg1 == 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (ifneeded && pg1 == 0 && kg1 == 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t}\n\n\t\tif (read_init) {\n\t\t\t;\n\t\t} else if (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 != 0 || kg1 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 != 1 || kg1 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t}\n\t\tif (!read_init) {\n\t\t\t*pg_init = pg1;\n\t\t\t*kg_init = kg1;\n\t\t}\n\t}\n\n\t/*\n\t * A guide for BARCO xattach:\n\t *\n\t *   For -cursor_rule 'b(0):%:t(1),t(1):%:b(0)'\n\t *\tdown+M2S  up+S2M\n\t *   For -cursor_rule 'r(0):%:l(1),l(1):%:r(0)'\n\t *\tright+M2S  left+S2M\n\t *\n\t *   For -cursor_rule 't(0):%:b(1),b(1):%:t(0)'\n\t *\tup+M2S  down+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0)'\n\t *\tleft+M2S  right+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0),r(0):%:l(1),l(1):%:r(0)'\n\t *\tleft+M2S  right+S2M  (we used to do both 'right')\n\t */\n\n\tif (!strcmp(flip, \"M2S\")) {\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 0);\t\t/* go to top edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-1);\t/* go to bottom edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(0, shift);\t\t/* go to left edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-1, shift);\t\t/* go to right edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for Motion Notify  */\n\t\t}\n\t} else if (!strcmp(flip, \"S2M\")) {\n\t\tint dts = dt/2;\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 2);\t\t/* Approach top edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 0);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* go to height-2 for extra pixel (slave y now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* go to 1 to be sure slave y == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-3);\t/* Approach bottom edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-1);\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* go to 1 for extra pixel (slave y now == dpy_y-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* go to dpy_y-2 to be sure slave y == dpy_y-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(2, shift);\t\t/* Approach left edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* go to width-2 for extra pixel (slave x now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* go to 1 to be sure slave x == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-3, shift);\t\t/* Approach right edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* go to 1 to extra pixel (slave x now == dpy_x-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* go to dpy_x-2 to be sure slave x == dpy_x-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* move 1 for MotionNotify */\n\t\t}\n\t}\n\n\tusleep(dt);\n\tpmove(final_x, final_y);\n\tusleep(dt);\n\n\tif (extra_x >= 0 && extra_y >= 0) {\n\t\tpmove(extra_x, extra_y);\n\t\tusleep(dt);\n\t}\n\n\tstrcpy(_bcx_res, \"DONE\");\n\n\tif (grab_check) {\n\t\tchar st[64];\n\n\t\tusleep(3*dt);\n\t\tgrab_state(&pg2, &kg2);\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg2 != 1 || kg2 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg2 != 0 || kg2 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t}\n\n\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\n\t\tif (getenv(\"GRAB_CHECK_LOOP\")) {\n\t\t\tint i, n = atoi(getenv(\"GRAB_CHECK_LOOP\"));\n\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tusleep(dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\t\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 == 0 && kg1 == 0 && pg2 == 1 && kg2 == 1) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 1 && kg2 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 0 && kg1 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 == 1 && kg1 == 1 && pg2 == 0 && kg2 == 0) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 0 && kg2 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 1 && kg1 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t}\n\t}\n\treturn strdup(_bcx_res);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "char *bcx_xattach(char *str, int *pg_init, int *kg_init);",
      "static rfbClientPtr *client_match(char *str);",
      "static void ugly_geom(char *p, int *x, int *y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "_bcx_res"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "st"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\"_FINAL\""
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\"_INIT\""
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\",GRAB_FAIL\""
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: S2M grab state incorrect: %d,%d -> %d,%d\\n\"",
            "pg1",
            "kg1",
            "pg2",
            "kg2"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\",GRAB_OK\""
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"S2M\""
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "st"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\"_FINAL\""
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\"_INIT\""
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\",GRAB_FAIL\""
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: M2S grab state incorrect: %d,%d -> %d,%d\\n\"",
            "pg1",
            "kg1",
            "pg2",
            "kg2"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "_bcx_res",
            "\",GRAB_OK\""
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"M2S\""
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"grab st: %s\\n\"",
            "st"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "st",
            "\":%d,%d-%d,%d\"",
            "pg1",
            "kg1",
            "pg2",
            "kg2"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_state",
          "args": [
            "&pg2",
            "&kg2"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"grab st: %s\\n\"",
            "st"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"GRAB_CHECK_LOOP\")"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"GRAB_CHECK_LOOP\""
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"GRAB_CHECK_LOOP\""
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "st",
            "\":%d,%d-%d,%d\"",
            "pg1",
            "kg1",
            "pg2",
            "kg2"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\"",
            "pg2",
            "kg2"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*dt"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: S2M fini grab state incorrect:  %d,%d\\n\"",
            "pg2",
            "kg2"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"S2M\""
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\"",
            "pg2",
            "kg2"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*dt"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: M2S fini grab state incorrect:  %d,%d\\n\"",
            "pg2",
            "kg2"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"M2S\""
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "3*dt"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "_bcx_res",
            "\"DONE\""
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmove",
          "args": [
            "extra_x",
            "extra_y"
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "pmove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3226-3236",
          "snippet": "static void pmove(int x, int y) {\n\tif (x < 0 || y < 0) {\n\t\trfbLog(\"pmove: skipping negative x or y: %d %d\\n\", x, y);\n\t\treturn;\n\t}\n\trfbLog(\"pmove: x y: %d %d\\n\", x, y);\n\tpointer_event(0, x, y, NULL);\n\tX_LOCK;\n\tXFlush_wr(dpy);\n\tX_UNLOCK;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ugly_geom(char *p, int *x, int *y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void ugly_geom(char *p, int *x, int *y);\n\nstatic void pmove(int x, int y) {\n\tif (x < 0 || y < 0) {\n\t\trfbLog(\"pmove: skipping negative x or y: %d %d\\n\", x, y);\n\t\treturn;\n\t}\n\trfbLog(\"pmove: x y: %d %d\\n\", x, y);\n\tpointer_event(0, x, y, NULL);\n\tX_LOCK;\n\tXFlush_wr(dpy);\n\tX_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"right\""
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"left\""
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"down\""
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dts"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"up\""
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"S2M\""
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"right\""
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"left\""
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"down\""
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dir",
            "\"up\""
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"M2S\""
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\"",
            "pg1",
            "kg1"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*dt"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: S2M init grab state incorrect:  %d,%d\\n\"",
            "pg1",
            "kg1"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"S2M\""
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\"",
            "pg1",
            "kg1"
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*dt"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: M2S init grab state incorrect:  %d,%d\\n\"",
            "pg1",
            "kg1"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"M2S\""
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"DONE,GRAB_OK\""
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: S2M grab state is already what we want, skipping moves:  %d,%d\\n\"",
            "pg1",
            "kg1"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"S2M\""
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"DONE,GRAB_OK\""
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"bcx_xattach: M2S grab state is already what we want, skipping moves:  %d,%d\\n\"",
            "pg1",
            "kg1"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flip",
            "\"M2S\""
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"dt=%d\"",
            "&t1"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"dt=\""
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"extra_move=%d+%d\"",
            "&t1",
            "&t2"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"extra_move=\""
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"final=%d+%d\"",
            "&t1",
            "&t2"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"final=\""
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"shift=%d\"",
            "&t1"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"shift=\""
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"ifneeded\""
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"nograbcheck\""
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"FAIL,NO_MODE_CHANGE_SPECIFIED\""
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"S2M\""
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"slave_to_master\""
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"M2S\""
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"master_to_slave\""
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"FAIL,NO_DIRECTION_SPECIFIED\""
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"right\""
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"left\""
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"down\""
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"up\""
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nchar *bcx_xattach(char *str, int *pg_init, int *kg_init);\nstatic rfbClientPtr *client_match(char *str);\nstatic void ugly_geom(char *p, int *x, int *y);\n\nchar *bcx_xattach(char *str, int *pg_init, int *kg_init) {\n\tint grab_check = 1;\n\tint shift = 20;\n\tint final_x = 30, final_y = 30;\n\tint extra_x = -1, extra_y = -1;\n\tint t1, t2, dt = 40 * 1000;\n\tint ifneeded = 0;\n\tchar *dir = \"none\", *flip = \"none\", *q;\n\tint pg1, kg1, pg2, kg2;\n\tchar _bcx_res[128];\n\t\n\t/* str:[up,down,left,right]+nograbcheck+shift=n+final=x+y+extra_move=x+y+[master_to_slave,slave_to_master,M2S,S2M]+dt=n+retry=n+ifneeded */\n\n\tif (strstr(str, \"up\")) {\n\t\tdir = \"up\";\n\t} else if (strstr(str, \"down\")) {\n\t\tdir = \"down\";\n\t} else if (strstr(str, \"left\")) {\n\t\tdir = \"left\";\n\t} else if (strstr(str, \"right\")) {\n\t\tdir = \"right\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_DIRECTION_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"master_to_slave\") || strstr(str, \"M2S\")) {\n\t\tflip = \"M2S\";\n\t} else if (strstr(str, \"slave_to_master\") || strstr(str, \"S2M\")) {\n\t\tflip = \"S2M\";\n\t} else {\n\t\treturn strdup(\"FAIL,NO_MODE_CHANGE_SPECIFIED\");\n\t}\n\n\tif (strstr(str, \"nograbcheck\")) {\n\t\tgrab_check = 0;\n\t}\n\tif (strstr(str, \"ifneeded\")) {\n\t\tifneeded = 1;\n\t}\n\tq = strstr(str, \"shift=\");\n\tif (q && sscanf(q, \"shift=%d\", &t1) == 1) {\n\t\tshift = t1;\n\t}\n\tq = strstr(str, \"final=\");\n\tif (q && sscanf(q, \"final=%d+%d\", &t1, &t2) == 2) {\n\t\tfinal_x = t1;\n\t\tfinal_y = t2;\n\t}\n\tq = strstr(str, \"extra_move=\");\n\tif (q && sscanf(q, \"extra_move=%d+%d\", &t1, &t2) == 2) {\n\t\textra_x = t1;\n\t\textra_y = t2;\n\t}\n\tq = strstr(str, \"dt=\");\n\tif (q && sscanf(q, \"dt=%d\", &t1) == 1) {\n\t\tdt = t1 * 1000;\n\t}\n\n\tif (grab_check) {\n\t\tint read_init = 0;\n\n\t\tif (*pg_init >=0 && *kg_init >=0)  {\n\t\t\tpg1 = *pg_init;\n\t\t\tkg1 = *kg_init;\n\t\t\tread_init = 1;\n\t\t} else {\n\t\t\tgrab_state(&pg1, &kg1);\n\t\t\tread_init = 0;\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (ifneeded && pg1 == 1 && kg1 == 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (ifneeded && pg1 == 0 && kg1 == 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state is already what we want, skipping moves:  %d,%d\\n\", pg1, kg1);\n\t\t\t\treturn strdup(\"DONE,GRAB_OK\");\n\t\t\t}\n\t\t}\n\n\t\tif (read_init) {\n\t\t\t;\n\t\t} else if (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 != 0 || kg1 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 != 1 || kg1 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M init grab state incorrect:  %d,%d\\n\", pg1, kg1);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg1, &kg1);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg1, kg1);\n\t\t\t}\n\t\t}\n\t\tif (!read_init) {\n\t\t\t*pg_init = pg1;\n\t\t\t*kg_init = kg1;\n\t\t}\n\t}\n\n\t/*\n\t * A guide for BARCO xattach:\n\t *\n\t *   For -cursor_rule 'b(0):%:t(1),t(1):%:b(0)'\n\t *\tdown+M2S  up+S2M\n\t *   For -cursor_rule 'r(0):%:l(1),l(1):%:r(0)'\n\t *\tright+M2S  left+S2M\n\t *\n\t *   For -cursor_rule 't(0):%:b(1),b(1):%:t(0)'\n\t *\tup+M2S  down+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0)'\n\t *\tleft+M2S  right+S2M\n\t *   For -cursor_rule 'l(0):%:r(1),r(1):%:l(0),r(0):%:l(1),l(1):%:r(0)'\n\t *\tleft+M2S  right+S2M  (we used to do both 'right')\n\t */\n\n\tif (!strcmp(flip, \"M2S\")) {\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 0);\t\t/* go to top edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-1);\t/* go to bottom edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(0, shift);\t\t/* go to left edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-1, shift);\t\t/* go to right edge */\n\t\t\tusleep(dt);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for Motion Notify  */\n\t\t}\n\t} else if (!strcmp(flip, \"S2M\")) {\n\t\tint dts = dt/2;\n\t\tif (!strcmp(dir, \"up\")) {\n\t\t\tpmove(shift, 2);\t\t/* Approach top edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 0);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 0);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* go to height-2 for extra pixel (slave y now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* go to 1 to be sure slave y == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"down\")) {\n\t\t\tpmove(shift,   dpy_y-3);\t/* Approach bottom edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-1);\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, 1);\t\t/* go to 1 for extra pixel (slave y now == dpy_y-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift, 1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift,   dpy_y-2);\t/* go to dpy_y-2 to be sure slave y == dpy_y-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(shift+1, dpy_y-2);\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"left\")) {\n\t\t\tpmove(2, shift);\t\t/* Approach left edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(0, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* go to width-2 for extra pixel (slave x now == 0?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* go to 1 to be sure slave x == 0 */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* move 1 for MotionNotify */\n\t\t} else if (!strcmp(dir, \"right\")) {\n\t\t\tpmove(dpy_x-3, shift);\t\t/* Approach right edge in 3 moves.  1st move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* 2nd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift);\t\t/* 3rd move */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-1, shift+1);\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift+1);\t\t/* go to 1 to extra pixel (slave x now == dpy_x-1?) */\n\t\t\tusleep(dts);\n\t\t\tpmove(1, shift);\t\t/* move 1 for MotionNotify */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift);\t\t/* go to dpy_x-2 to be sure slave x == dpy_x-1 */\n\t\t\tusleep(dts);\n\t\t\tpmove(dpy_x-2, shift+1);\t/* move 1 for MotionNotify */\n\t\t}\n\t}\n\n\tusleep(dt);\n\tpmove(final_x, final_y);\n\tusleep(dt);\n\n\tif (extra_x >= 0 && extra_y >= 0) {\n\t\tpmove(extra_x, extra_y);\n\t\tusleep(dt);\n\t}\n\n\tstrcpy(_bcx_res, \"DONE\");\n\n\tif (grab_check) {\n\t\tchar st[64];\n\n\t\tusleep(3*dt);\n\t\tgrab_state(&pg2, &kg2);\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg2 != 1 || kg2 != 1) {\n\t\t\t\trfbLog(\"bcx_xattach: M2S fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg2 != 0 || kg2 != 0) {\n\t\t\t\trfbLog(\"bcx_xattach: S2M fini grab state incorrect:  %d,%d\\n\", pg2, kg2);\n\t\t\t\tusleep(2*dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\trfbLog(\"bcx_xattach: slept and retried, grab is now: %d,%d\\n\", pg2, kg2);\n\t\t\t}\n\t\t}\n\n\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\n\t\tif (getenv(\"GRAB_CHECK_LOOP\")) {\n\t\t\tint i, n = atoi(getenv(\"GRAB_CHECK_LOOP\"));\n\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\tfor (i=0; i < n; i++) {\n\t\t\t\tusleep(dt);\n\t\t\t\tgrab_state(&pg2, &kg2);\n\t\t\t\tsprintf(st, \":%d,%d-%d,%d\", pg1, kg1, pg2, kg2);\n\t\t\t\trfbLog(\"grab st: %s\\n\", st);\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(flip, \"M2S\")) {\n\t\t\tif (pg1 == 0 && kg1 == 0 && pg2 == 1 && kg2 == 1) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: M2S grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 1 && kg2 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 0 && kg1 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t} else if (!strcmp(flip, \"S2M\")) {\n\t\t\tif (pg1 == 1 && kg1 == 1 && pg2 == 0 && kg2 == 0) {\n\t\t\t\tstrcat(_bcx_res, \",GRAB_OK\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"bcx_xattach: S2M grab state incorrect: %d,%d -> %d,%d\\n\", pg1, kg1, pg2, kg2);\n\t\t\t\tstrcat(_bcx_res, \",GRAB_FAIL\");\n\t\t\t\tif (pg2 == 0 && kg2 == 0) {\n\t\t\t\t\tstrcat(_bcx_res, \"_INIT\");\n\t\t\t\t} else if (pg1 == 1 && kg1 == 1) {\n\t\t\t\t\tstrcat(_bcx_res, \"_FINAL\");\n\t\t\t\t}\n\t\t\t\tstrcat(_bcx_res, st);\n\t\t\t}\n\t\t}\n\t}\n\treturn strdup(_bcx_res);\n}"
  },
  {
    "function_name": "pmove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3226-3236",
    "snippet": "static void pmove(int x, int y) {\n\tif (x < 0 || y < 0) {\n\t\trfbLog(\"pmove: skipping negative x or y: %d %d\\n\", x, y);\n\t\treturn;\n\t}\n\trfbLog(\"pmove: x y: %d %d\\n\", x, y);\n\tpointer_event(0, x, y, NULL);\n\tX_LOCK;\n\tXFlush_wr(dpy);\n\tX_UNLOCK;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ugly_geom(char *p, int *x, int *y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pointer_event",
          "args": [
            "0",
            "x",
            "y",
            "NULL"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "pointer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "700-1005",
          "snippet": "void pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int pointer_queued_sent = 0;",
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint pointer_queued_sent = 0;\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client) {\n\tallowed_input_t input;\n\tint sent = 0, buffer_it = 0;\n\tdouble now;\n\tClientData *cd = NULL;\n        \n\tif(client && client->clientData)\n\t  cd = (ClientData *) client->clientData;\n\t\n\t/* needed to allow multiple dragging actions at once */\n        if(client && use_multipointer) \n          client->screen->pointerClient = NULL;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (mask >= 0) {\n\t\tgot_pointer_calls++;\n\t}\n\n\tif (debug_pointer && mask >= 0) {\n\t\tstatic int show_motion = -1;\n\t\tstatic double last_pointer = 0.0;\n\t\tdouble tnow, dt;\n\t\tstatic int last_x, last_y;\n\t\tif (show_motion == -1) {\n\t\t\tif (getenv(\"X11VNC_DB_NOMOTION\")) {\n\t\t\t\tshow_motion = 0;\n\t\t\t} else {\n\t\t\t\tshow_motion = 1;\n\t\t\t}\n\t\t}\n\t\tdtime0(&tnow);\n\t\ttnow -= x11vnc_start;\n\t\tdt = tnow - last_pointer;\n\t\tlast_pointer = tnow;\n\t\tif (show_motion) {\n\t\t\trfbLog(\"# pointer(mask: 0x%x, x:%4d, y:%4d) \"\n\t\t\t    \"dx: %3d dy: %3d dt: %.4f t: %.4f\\n\", mask, x, y,\n\t\t\t    x - last_x, y - last_y, dt, tnow);\n\t\t}\n\t\tlast_x = x;\n\t\tlast_y = y;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\tget_allowed_input(client, &input);\n\n\tif (rotating) {\n\t\trotate_coords_inverse(x, y, &x, &y, -1, -1);\n\t}\n\n\tif (scaling) {\n\t\t/* map from rfb size to X11 size: */\n\t\tx = ((double) x / scaled_x) * dpy_x;\n\t\tx = nfix(x, dpy_x);\n\t\ty = ((double) y / scaled_y) * dpy_y;\n\t\ty = nfix(y, dpy_y);\n\t}\n\n\tINPUT_LOCK;\n\n\tif ((pipeinput_fh != NULL || pipeinput_int) && mask >= 0) {\n\t\tpipe_pointer(mask, x, y, client);\t/* MACOSX here. */\n\t\tif (! pipeinput_tee) {\n\t\t\tif (! view_only || raw_fb) {\t/* raw_fb hack */\n\t\t\t\tgot_user_input++;\n\t\t\t\tgot_pointer_input++;\n\t\t\t\tlast_pointer_client = client;\n\t\t\t\tlast_pointer_time = dnow();\n\t\t\t\tlast_event = last_input = last_pointer_input = time(NULL);\n\t\t\t}\n\t\t\tif (input.motion) {\n\t\t\t\t/* raw_fb hack track button state */\n\t\t\t\tbutton_mask_prev = button_mask;\n\t\t\t\tbutton_mask = mask;\n\t\t\t\tif(cd)\n\t\t\t\t  cd->ptr_buttonmask = mask;\n\t\t\t}\n\t\t\tif (!view_only && (input.motion || input.button)) {\n\t\t\t\tlast_rfb_ptr_injected = dnow();\n\t\t\t}\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (view_only) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\n\tif (mask >= 0) {\n\t\t/*\n\t\t * mask = -1 is a special case call from scan_for_updates()\n\t\t * to flush the event queue; there is no real pointer event.\n\t\t */\n\t\tif (! input.motion && ! input.button) {\n\t\t\tINPUT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\tgot_user_input++;\n\t\tgot_pointer_input++;\n\t\tlast_pointer_client = client;\n\n\t\tlast_pointer_time = now;\n\t\tlast_rfb_ptr_injected = dnow();\n\n\t\tif (blackout_ptr && blackouts) {\n\t\t\tint b, ok = 1;\n\t\t\t/* see if it goes into the blacked out region */\n\t\t\tfor (b=0; b < blackouts; b++) {\n\t\t\t\tif (x < blackr[b].x1 || x > blackr[b].x2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (y < blackr[b].y1 || y > blackr[b].y2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* x1 <= x <= x2 and y1 <= y <= y2 */\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (! ok) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t    rfbLog(\"pointer(): blackout_ptr skipping \"\n\t\t\t\t\t\"x=%d y=%d in rectangle %d,%d %d,%d\\n\", x, y,\n\t\t\t\t\tblackr[b].x1, blackr[b].y1,\n\t\t\t\t\tblackr[b].x2, blackr[b].y2);\n\t\t\t\t}\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The following is hopefully an improvement wrt response during\n\t * pointer user input (window drags) for the threaded case.\n\t * See check_user_input() for the more complicated things we do\n\t * in the non-threaded case.\n\t */\n\tif ((use_threads && pointer_mode != 1) || pointer_flush_delay > 0.0) {\n#\t\tdefine NEV 32\n\t\t/* storage for the event queue */\n\t\tstatic int nevents = 0;\n\t\tstatic int ev[NEV][3];\n\t\tstatic rfbClientPtr ev_cl[NEV];\n\t\tint i;\n\t\t/* timer things */\n\t\tstatic double dt = 0.0, tmr = 0.0, maxwait = 0.4;\n\n\t\tif (pointer_flush_delay > 0.0) {\n\t\t\tmaxwait = pointer_flush_delay;\n\t\t}\n\t\tif (mask >= 0) {\n\t\t\tif (fb_copy_in_progress || pointer_flush_delay > 0.0) {\n\t\t\t\tbuffer_it = 1;\n\t\t\t}\n\t\t}\n\n\t\tPOINTER_LOCK;\n\n\t\t/* \n\t\t * If the framebuffer is being copied in another thread\n\t\t * (scan_for_updates()), we will queue up to 32 pointer\n\t\t * events for later.  The idea is by delaying these input\n\t\t * events, the screen is less likely to change during the\n\t\t * copying period, and so will give rise to less window\n\t\t * \"tearing\".\n\t\t *\n\t\t * Tearing is not completely eliminated because we do\n\t\t * not suspend work in the other libvncserver threads.\n\t\t * Maybe that is a possibility with a mutex...\n\t\t */\n\t\tif (buffer_it) {\n\t\t\t/* \n\t\t\t * mask = -1 is an all-clear signal from\n\t\t\t * scan_for_updates().\n\t\t\t *\n\t\t\t * dt is a timer in seconds; we only queue for so long.\n\t\t\t */\n\t\t\tdt += dtime(&tmr);\n\n\t\t\tif (nevents < NEV && dt < maxwait) {\n\t\t\t\ti = nevents++;\n\t\t\t\tev[i][0] = mask;\n\t\t\t\tev[i][1] = x;\n\t\t\t\tev[i][2] = y;\n\t\t\t\tev_cl[i] = client;\n\t\t\t\tif (! input.button) {\n\t\t\t\t\tev[i][0] = -1;\n\t\t\t\t}\n\t\t\t\tif (! input.motion) {\n\t\t\t\t\tev[i][1] = -1;\n\t\t\t\t\tev[i][2] = -1;\n\t\t\t\t}\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): deferring event %d\"\n\t\t\t\t\t    \" %.4f\\n\", i, tmr - x11vnc_start);\n\t\t\t\t}\n\t\t\t\tPOINTER_UNLOCK;\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* time to send the queue */\n\t\tfor (i=0; i<nevents; i++) {\n\t\t\tint sent = 0;\n\t\t\tif (mask < 0 && client != NULL) {\n\t\t\t\t/* hack to only push the latest event */\n\t\t\t\tif (i < nevents - 1) {\n\t\t\t\t\tif (debug_pointer) {\n\t\t\t\t\t\trfbLog(\"- skip deferred event:\"\n\t\t\t\t\t\t    \" %d\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"pointer(): sending event %d %.4f\\n\",\n\t\t\t\t    i+1, dnowx());\n\t\t\t}\n\t\t\tif (ev[i][1] >= 0) {\n\t\t\t\tupdate_x11_pointer_position(ev[i][1], ev[i][2], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\t\t\tif (ev[i][0] >= 0) {\n\t\t\t        update_x11_pointer_mask(ev[i][0], ev_cl[i]);\n\t\t\t\tsent = 1;\n\t\t\t}\n\n\t\t\tif (sent) {\n\t\t\t\tpointer_queued_sent++;\n\t\t\t}\n\t\t}\n\t\tif (nevents && dt > maxwait) {\n\t\t    if (dpy) {\t/* raw_fb hack */\n\t\t\tif (mask < 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"pointer(): calling XFlush \"\n\t\t\t\t\t    \"%.4f\\n\", dnowx());\n\t\t\t\t}\n\t\t\t\tX_LOCK;\n\t\t\t\tXFlush_wr(dpy);\t\n\t\t\t\tX_UNLOCK;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tnevents = 0;\t/* reset everything */\n\t\tdt = 0.0;\n\t\tdtime0(&tmr);\n\n\t\tPOINTER_UNLOCK;\n\t}\n\tif (mask < 0) {\t\t/* -1 just means flush the event queue */\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): flush only.  %.4f\\n\",\n\t\t\t    dnowx());\n\t\t}\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\t/* update the X display with the event: */\n\tif (input.motion) {\n\t        update_x11_pointer_position(x, y, client);\n\t\tsent = 1;\n\t}\n\tif (input.button) {\n\t\tif (mask != button_mask) {   /*FIXME multipointer?*/\n\t\t\tbutton_change_x = cursor_x;\n\t\t\tbutton_change_y = cursor_y;\n\t\t}\n \t        update_x11_pointer_mask(mask, client);\n\t\tsent = 1;\n\t}\n\n\tif (! dpy) {\n\t\t;\n\t} else if (nofb && sent) {\n\t\t/* \n\t\t * nofb is for, e.g. Win2VNC, where fastest pointer\n\t\t * updates are desired.\n\t\t */\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\t} else if (buffer_it) {\n\t\tif (debug_pointer) {\n\t\t\trfbLog(\"pointer(): calling XFlush+\"\n\t\t\t    \"%.4f\\n\", dnowx());\n\t\t}\n\t\tX_LOCK;\n\t\tXFlush_wr(dpy);\t\n\t\tX_UNLOCK;\n\t}\n\tINPUT_UNLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"pmove: x y: %d %d\\n\"",
            "x",
            "y"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"pmove: skipping negative x or y: %d %d\\n\"",
            "x",
            "y"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void ugly_geom(char *p, int *x, int *y);\n\nstatic void pmove(int x, int y) {\n\tif (x < 0 || y < 0) {\n\t\trfbLog(\"pmove: skipping negative x or y: %d %d\\n\", x, y);\n\t\treturn;\n\t}\n\trfbLog(\"pmove: x y: %d %d\\n\", x, y);\n\tpointer_event(0, x, y, NULL);\n\tX_LOCK;\n\tXFlush_wr(dpy);\n\tX_UNLOCK;\n}"
  },
  {
    "function_name": "grab_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3178-3224",
    "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
      "extern int rc_npieces;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\"",
            "*ptr_grabbed",
            "*kbd_grabbed",
            "t1-t0",
            "tb-ta",
            "tc-tb"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUngrabKeyboard",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGrabKeyboard",
          "args": [
            "dpy",
            "window",
            "False",
            "GrabModeAsync",
            "GrabModeAsync",
            "CurrentTime"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XUngrabPointer",
          "args": [
            "dpy",
            "CurrentTime"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGrabPointer",
          "args": [
            "dpy",
            "window",
            "False",
            "0",
            "GrabModeAsync",
            "GrabModeAsync",
            "None",
            "None",
            "CurrentTime"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
  },
  {
    "function_name": "read_x11vnc_remote_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3106-3174",
    "snippet": "void read_x11vnc_remote_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tx11vnc_remote_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || x11vnc_remote_prop == None) {\n\t\t/* not active or problem with X11VNC_REMOTE atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into x11vnc_remote_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    x11vnc_remote_prop, nitems/4, X11VNC_REMOTE_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > X11VNC_REMOTE_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large X11VNC_REMOTE\"\n\t\t\t\t   \" string > %d bytes.\\n\", X11VNC_REMOTE_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(x11vnc_remote_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tx11vnc_remote_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tx11vnc_remote_str[X11VNC_REMOTE_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ans=stop:N/A,ans=quit:N/A,ans=\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"qry=stop,quit,exit\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ack=\") == x11vnc_remote_str) {\n\t\t;\n\t} else if (quiet && strstr(x11vnc_remote_str, \"qry=ping\") ==\n\t    x11vnc_remote_str) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"cmd=\") &&\n\t    strstr(x11vnc_remote_str, \"passwd\")) {\n\t\trfbLog(\"read X11VNC_REMOTE: *\\n\");\n\t} else if (strlen(x11vnc_remote_str) > 36) {\n\t\tchar trim[100]; \n\t\ttrim[0] = '\\0';\n\t\tstrncat(trim, x11vnc_remote_str, 36);\n\t\trfbLog(\"read X11VNC_REMOTE: %s ...\\n\", trim);\n\t\t\n\t} else {\n\t\trfbLog(\"read X11VNC_REMOTE: %s\\n\", x11vnc_remote_str);\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char x11vnc_remote_str[X11VNC_REMOTE_MAX+1];",
      "Atom x11vnc_remote_prop = None;",
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "int cmd_ok(char *cmd);",
      "void read_x11vnc_remote_prop(int);",
      "void adjust_grabs(int grab, int quiet);",
      "int set_xprop(char *prop, Window win, char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read X11VNC_REMOTE: %s\\n\"",
            "x11vnc_remote_str"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read X11VNC_REMOTE: %s ...\\n\"",
            "trim"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "trim",
            "x11vnc_remote_str",
            "36"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "x11vnc_remote_str"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read X11VNC_REMOTE: *\\n\""
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "x11vnc_remote_str",
            "\"passwd\""
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "x11vnc_remote_str",
            "\"cmd=\""
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "x11vnc_remote_str",
            "\"qry=ping\""
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "x11vnc_remote_str",
            "\"ack=\""
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "x11vnc_remote_str",
            "\"qry=stop,quit,exit\""
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "x11vnc_remote_str",
            "\"ans=stop:N/A,ans=quit:N/A,ans=\""
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "data"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "x11vnc_remote_str+slen",
            "data",
            "dlen"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: truncating large X11VNC_REMOTE\"\n\t\t\t\t   \" string > %d bytes.\\n\"",
            "X11VNC_REMOTE_MAX"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "DefaultRootWindow(dpy)",
            "x11vnc_remote_prop",
            "nitems/4",
            "X11VNC_REMOTE_MAX/16",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&nitems",
            "&bytes_after",
            "&data"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar x11vnc_remote_str[X11VNC_REMOTE_MAX+1];\nAtom x11vnc_remote_prop = None;\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid read_x11vnc_remote_prop(int);\nvoid adjust_grabs(int grab, int quiet);\nint set_xprop(char *prop, Window win, char *value);\n\nvoid read_x11vnc_remote_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tx11vnc_remote_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || x11vnc_remote_prop == None) {\n\t\t/* not active or problem with X11VNC_REMOTE atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into x11vnc_remote_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    x11vnc_remote_prop, nitems/4, X11VNC_REMOTE_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > X11VNC_REMOTE_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large X11VNC_REMOTE\"\n\t\t\t\t   \" string > %d bytes.\\n\", X11VNC_REMOTE_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(x11vnc_remote_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tx11vnc_remote_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tx11vnc_remote_str[X11VNC_REMOTE_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ans=stop:N/A,ans=quit:N/A,ans=\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"qry=stop,quit,exit\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ack=\") == x11vnc_remote_str) {\n\t\t;\n\t} else if (quiet && strstr(x11vnc_remote_str, \"qry=ping\") ==\n\t    x11vnc_remote_str) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"cmd=\") &&\n\t    strstr(x11vnc_remote_str, \"passwd\")) {\n\t\trfbLog(\"read X11VNC_REMOTE: *\\n\");\n\t} else if (strlen(x11vnc_remote_str) > 36) {\n\t\tchar trim[100]; \n\t\ttrim[0] = '\\0';\n\t\tstrncat(trim, x11vnc_remote_str, 36);\n\t\trfbLog(\"read X11VNC_REMOTE: %s ...\\n\", trim);\n\t\t\n\t} else {\n\t\trfbLog(\"read X11VNC_REMOTE: %s\\n\", x11vnc_remote_str);\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "read_vnc_connect_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3054-3104",
    "snippet": "void read_vnc_connect_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tvnc_connect_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || vnc_connect_prop == None) {\n\t\t/* not active or problem with VNC_CONNECT atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into vnc_connect_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    vnc_connect_prop, nitems/4, VNC_CONNECT_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large VNC_CONNECT\"\n\t\t\t\t   \" string > %d bytes.\\n\", VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vnc_connect_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tvnc_connect_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tvnc_connect_str[VNC_CONNECT_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else {\n\t\trfbLog(\"read VNC_CONNECT: %s\\n\", vnc_connect_str);\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char vnc_connect_str[VNC_CONNECT_MAX+1];",
      "Atom vnc_connect_prop = None;",
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void read_vnc_connect_prop(int);",
      "int set_xprop(char *prop, Window win, char *value);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read VNC_CONNECT: %s\\n\"",
            "vnc_connect_str"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "data"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vnc_connect_str+slen",
            "data",
            "dlen"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"warning: truncating large VNC_CONNECT\"\n\t\t\t\t   \" string > %d bytes.\\n\"",
            "VNC_CONNECT_MAX"
          ],
          "line": 3085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "DefaultRootWindow(dpy)",
            "vnc_connect_prop",
            "nitems/4",
            "VNC_CONNECT_MAX/16",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&nitems",
            "&bytes_after",
            "&data"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar vnc_connect_str[VNC_CONNECT_MAX+1];\nAtom vnc_connect_prop = None;\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid read_vnc_connect_prop(int);\nint set_xprop(char *prop, Window win, char *value);\n\nvoid read_vnc_connect_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tvnc_connect_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || vnc_connect_prop == None) {\n\t\t/* not active or problem with VNC_CONNECT atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into vnc_connect_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    vnc_connect_prop, nitems/4, VNC_CONNECT_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large VNC_CONNECT\"\n\t\t\t\t   \" string > %d bytes.\\n\", VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vnc_connect_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tvnc_connect_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tvnc_connect_str[VNC_CONNECT_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else {\n\t\trfbLog(\"read VNC_CONNECT: %s\\n\", vnc_connect_str);\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "set_x11vnc_remote_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3043-3052",
    "snippet": "void set_x11vnc_remote_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (x11vnc_remote_prop == None) return;\n\tXChangeProperty(dpy, rootwin, x11vnc_remote_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Atom x11vnc_remote_prop = None;",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rootwin",
            "x11vnc_remote_prop",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)str",
            "strlen(str)"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nAtom x11vnc_remote_prop = None;\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid set_x11vnc_remote_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (x11vnc_remote_prop == None) return;\n\tXChangeProperty(dpy, rootwin, x11vnc_remote_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "set_vnc_connect_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "3032-3041",
    "snippet": "void set_vnc_connect_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (vnc_connect_prop == None) return;\n\tXChangeProperty(dpy, rootwin, vnc_connect_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Atom vnc_connect_prop = None;",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rootwin",
            "vnc_connect_prop",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *)str",
            "strlen(str)"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nAtom vnc_connect_prop = None;\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid set_vnc_connect_prop(char *str) {\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tif (vnc_connect_prop == None) return;\n\tXChangeProperty(dpy, rootwin, vnc_connect_prop, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *)str, strlen(str));\n#else\n\tif (!str) {}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "reverse_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2853-3026",
    "snippet": "void reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "void send_client_info(char *str);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static rfbClientPtr *client_match(char *str);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_xrandr_event",
          "args": [
            "\"reverse_connect2\""
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrandr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "184-290",
          "snippet": "int check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrandr_present = 0;",
            "int xrandr_width  = -1;",
            "int xrandr_height = -1;",
            "int xrandr_rotation = -1;",
            "Time xrandr_timestamp = 0;",
            "Time xrandr_cfg_time = 0;",
            "int check_xrandr_event(char *msg);",
            "int known_xrandr_mode(char *s);",
            "static int handle_subwin_resize(char *msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nTime xrandr_timestamp = 0;\nTime xrandr_cfg_time = 0;\nint check_xrandr_event(char *msg);\nint known_xrandr_mode(char *s);\nstatic int handle_subwin_resize(char *msg);\n\nint check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "gui_pid",
            "SIGTERM"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"killing gui_pid %d\\n\"",
            "gui_pid"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"exiting under -connect_or_exit\\n\""
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt * 1000"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_REVERSE_SLEEP_MAX\")"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REVERSE_SLEEP_MAX\""
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REVERSE_SLEEP_MAX\""
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"killing gui_pid %d\\n\"",
            "gui_pid"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"exiting under -connect_or_exit\\n\""
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "list"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "dt * 1000"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress_client",
          "args": [],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "progress_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2891-2919",
          "snippet": "void progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void progress_client(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid progress_client(void);\n\nvoid progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_reverse_connect",
          "args": [
            "p"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "do_reverse_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2645-2848",
          "snippet": "static int do_reverse_connect(char *str_in) {\n\trfbClientPtr cl;\n\tchar *host, *p, *str = str_in;\n\tchar *prestring = NULL;\n\tint prestring_len = 0;\n\tint rport = 5500, len = strlen(str);\n\tint set_alarm = 0;\n\n\tif (len < 1) {\n\t\treturn 0;\n\t}\n\tif (len > 1024) {\n\t\trfbLog(\"reverse_connect: string too long: %d bytes\\n\", len);\n\t\treturn 0;\n\t}\n\tif (!screen) {\n\t\trfbLog(\"reverse_connect: screen not setup yet.\\n\");\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\t/* look for repeater pre-string */\n\tif (strchr(str, '=') && strrchr(str, '+')\n\t    && (strstr(str, \"pre\") == str || strstr(str, \"repeater=\") == str)) {\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t} else if (strrchr(str, '+') && strstr(str, \"repeater://\") == str) {\n\t\t/* repeater://host:port+string */\n\t\t/*   repeater=string+host:port */\n\t\tchar *plus = strrchr(str, '+');\n\t\tstr = (char *) malloc(strlen(str_in)+1);\n\t\t*plus = '\\0';\n\t\tsprintf(str, \"repeater=%s+%s\", plus+1, str_in + strlen(\"repeater://\"));\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t\t*plus = '+';\n\t}\n\n\t/* copy in to host */\n\thost = (char *) malloc(len+1);\n\tif (! host) {\n\t\trfbLog(\"reverse_connect: could not malloc string %d\\n\", len);\n\t\treturn 0;\n\t}\n\tstrncpy(host, str, len);\n\thost[len] = '\\0';\n\n\t/* extract port, if any */\n\tif ((p = strrchr(host, ':')) != NULL) {\n\t\trport = atoi(p+1);\n\t\tif (rport < 0) {\n\t\t\trport = -rport;\n\t\t} else if (rport < 20) {\n\t\t\trport = 5500 + rport;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\tif (use_openssl) {\n\t\tint vncsock;\n\t\tif (connect_proxy) {\n\t\t\tvncsock = proxy_connect(host, rport);\n\t\t} else {\n\t\t\tvncsock = connect_tcp(host, rport);\n\t\t}\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"reverse_connect: failed to connect to: %s\\n\", str);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prestring != NULL) {\n\t\t\twrite(vncsock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t}\n/* XXX use header */\n#define OPENSSL_REVERSE 6\n\t\tif (!getenv(\"X11VNC_DISABLE_SSL_CLIENT_MODE\")) {\n\t\t\topenssl_init(1);\n\t\t}\n\n\t\tif (first_conn_timeout > 0) {\n\t\t\tset_alarm = 1;\n\t\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\taccept_openssl(OPENSSL_REVERSE, vncsock);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\n\t\topenssl_init(0);\n\t\tfree(host);\n\t\treturn 1;\n\t}\n\n\tif (use_stunnel) {\n\t\tif(strcmp(host, \"localhost\") && strcmp(host, \"127.0.0.1\")) {\n\t\t\tif (!getenv(\"STUNNEL_DISABLE_LOCALHOST\")) {\n\t\t\t\trfbLog(\"reverse_connect: error host not localhost in -stunnel mode.\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unixpw) {\n\t\tint is_localhost = 0, user_disabled_it = 0;\n\n\t\tif(!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\t\tis_localhost = 1;\n\t\t}\n\t\tif (getenv(\"UNIXPW_DISABLE_LOCALHOST\")) {\n\t\t\tuser_disabled_it = 1;\n\t\t}\n\n\t\tif (! is_localhost) {\n\t\t\tif (user_disabled_it) {\n\t\t\t\trfbLog(\"reverse_connect: warning disabling localhost constraint in -unixpw\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"reverse_connect: error not localhost in -unixpw\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (first_conn_timeout > 0) {\n\t\tset_alarm = 1;\n\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\talarm(first_conn_timeout);\n\t}\n\n\tif (connect_proxy != NULL) {\n\t\tint sock = proxy_connect(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\tif (prestring != NULL) {\n\t\t\t\twrite(sock, prestring, prestring_len);\n\t\t\t\tfree(prestring);\n\t\t\t}\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else if (prestring != NULL) {\n\t\tint sock = connect_tcp(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\twrite(sock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tcl = rfbReverseConnection(screen, host, rport);\n\t\tif (cl == NULL) {\n\t\t\tint sock = connect_tcp(host, rport);\n\t\t\tif (sock >= 0) {\n\t\t\t\tcl = create_new_client(sock, 1);\n\t\t\t}\n\t\t}\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (cl != NULL && use_threads) {\n\t\t\tcl->onHold = FALSE;\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\n\tfree(host);\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\n\tif (cl == NULL) {\n\t\tif (quiet && connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t}\n\t\trfbLog(\"reverse_connect: %s failed\\n\", str);\n\t\treturn 0;\n\t} else {\n\t\trfbLog(\"reverse_connect: %s/%s OK\\n\", str, cl->host);\n\t\t/* let's see if anyone complains: */\n\t\tif (! getenv(\"X11VNC_REVERSE_CONNECTION_NO_AUTH\")) {\n\t\t\trfbLog(\"reverse_connect: turning on auth for %s\\n\",\n\t\t\t    cl->host);\n\t\t\tcl->reverseConnection = FALSE;\n\t\t}\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define OPENSSL_REVERSE 6",
            "#define USE_TIMEOUT_INTERRUPT 0"
          ],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_REVERSE 6\n#define USE_TIMEOUT_INTERRUPT 0\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nstatic rfbClientPtr *client_match(char *str);\n\nstatic int do_reverse_connect(char *str_in) {\n\trfbClientPtr cl;\n\tchar *host, *p, *str = str_in;\n\tchar *prestring = NULL;\n\tint prestring_len = 0;\n\tint rport = 5500, len = strlen(str);\n\tint set_alarm = 0;\n\n\tif (len < 1) {\n\t\treturn 0;\n\t}\n\tif (len > 1024) {\n\t\trfbLog(\"reverse_connect: string too long: %d bytes\\n\", len);\n\t\treturn 0;\n\t}\n\tif (!screen) {\n\t\trfbLog(\"reverse_connect: screen not setup yet.\\n\");\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\t/* look for repeater pre-string */\n\tif (strchr(str, '=') && strrchr(str, '+')\n\t    && (strstr(str, \"pre\") == str || strstr(str, \"repeater=\") == str)) {\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t} else if (strrchr(str, '+') && strstr(str, \"repeater://\") == str) {\n\t\t/* repeater://host:port+string */\n\t\t/*   repeater=string+host:port */\n\t\tchar *plus = strrchr(str, '+');\n\t\tstr = (char *) malloc(strlen(str_in)+1);\n\t\t*plus = '\\0';\n\t\tsprintf(str, \"repeater=%s+%s\", plus+1, str_in + strlen(\"repeater://\"));\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t\t*plus = '+';\n\t}\n\n\t/* copy in to host */\n\thost = (char *) malloc(len+1);\n\tif (! host) {\n\t\trfbLog(\"reverse_connect: could not malloc string %d\\n\", len);\n\t\treturn 0;\n\t}\n\tstrncpy(host, str, len);\n\thost[len] = '\\0';\n\n\t/* extract port, if any */\n\tif ((p = strrchr(host, ':')) != NULL) {\n\t\trport = atoi(p+1);\n\t\tif (rport < 0) {\n\t\t\trport = -rport;\n\t\t} else if (rport < 20) {\n\t\t\trport = 5500 + rport;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\tif (use_openssl) {\n\t\tint vncsock;\n\t\tif (connect_proxy) {\n\t\t\tvncsock = proxy_connect(host, rport);\n\t\t} else {\n\t\t\tvncsock = connect_tcp(host, rport);\n\t\t}\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"reverse_connect: failed to connect to: %s\\n\", str);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prestring != NULL) {\n\t\t\twrite(vncsock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t}\n/* XXX use header */\n#define OPENSSL_REVERSE 6\n\t\tif (!getenv(\"X11VNC_DISABLE_SSL_CLIENT_MODE\")) {\n\t\t\topenssl_init(1);\n\t\t}\n\n\t\tif (first_conn_timeout > 0) {\n\t\t\tset_alarm = 1;\n\t\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\taccept_openssl(OPENSSL_REVERSE, vncsock);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\n\t\topenssl_init(0);\n\t\tfree(host);\n\t\treturn 1;\n\t}\n\n\tif (use_stunnel) {\n\t\tif(strcmp(host, \"localhost\") && strcmp(host, \"127.0.0.1\")) {\n\t\t\tif (!getenv(\"STUNNEL_DISABLE_LOCALHOST\")) {\n\t\t\t\trfbLog(\"reverse_connect: error host not localhost in -stunnel mode.\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unixpw) {\n\t\tint is_localhost = 0, user_disabled_it = 0;\n\n\t\tif(!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\t\tis_localhost = 1;\n\t\t}\n\t\tif (getenv(\"UNIXPW_DISABLE_LOCALHOST\")) {\n\t\t\tuser_disabled_it = 1;\n\t\t}\n\n\t\tif (! is_localhost) {\n\t\t\tif (user_disabled_it) {\n\t\t\t\trfbLog(\"reverse_connect: warning disabling localhost constraint in -unixpw\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"reverse_connect: error not localhost in -unixpw\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (first_conn_timeout > 0) {\n\t\tset_alarm = 1;\n\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\talarm(first_conn_timeout);\n\t}\n\n\tif (connect_proxy != NULL) {\n\t\tint sock = proxy_connect(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\tif (prestring != NULL) {\n\t\t\t\twrite(sock, prestring, prestring_len);\n\t\t\t\tfree(prestring);\n\t\t\t}\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else if (prestring != NULL) {\n\t\tint sock = connect_tcp(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\twrite(sock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tcl = rfbReverseConnection(screen, host, rport);\n\t\tif (cl == NULL) {\n\t\t\tint sock = connect_tcp(host, rport);\n\t\t\tif (sock >= 0) {\n\t\t\t\tcl = create_new_client(sock, 1);\n\t\t\t}\n\t\t}\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (cl != NULL && use_threads) {\n\t\t\tcl->onHold = FALSE;\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\n\tfree(host);\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\n\tif (cl == NULL) {\n\t\tif (quiet && connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t}\n\t\trfbLog(\"reverse_connect: %s failed\\n\", str);\n\t\treturn 0;\n\t} else {\n\t\trfbLog(\"reverse_connect: %s/%s OK\\n\", str, cl->host);\n\t\t/* let's see if anyone complains: */\n\t\tif (! getenv(\"X11VNC_REVERSE_CONNECTION_NO_AUTH\")) {\n\t\t\trfbLog(\"reverse_connect: turning on auth for %s\\n\",\n\t\t\t    cl->host);\n\t\t\tcl->reverseConnection = FALSE;\n\t\t}\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "choose_title",
          "args": [
            "DisplayString(dpy)"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "choose_title",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "713-790",
          "snippet": "char *choose_title(char *display) {\n\tstatic char title[(MAXN+10)];\t\n\n\tmemset(title, 0, sizeof(title));\n\tstrcpy(title, \"x11vnc\");\n\n\tif (display == NULL) {\n\t\tdisplay = getenv(\"DISPLAY\");\n\t}\n\n#ifdef MACOSX\n\tif (display == NULL || strstr(display, \"/tmp/\") == display) {\n\t\tchar *u = get_user_name();\n\t\tchar *th = this_host();\n\t\tif (strlen(u) > MAXN/4)  {\n\t\t\tu = \"someone\";\n\t\t}\n\t\tstrcpy(title, u);\n\t\tif (th || UT.nodename) {\n\t\t\tstrcat(title, \"@\");\n\t\t\tstrncat(title, th ? th : UT.nodename,\n\t\t\t\tMAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t\treturn title;\n\t}\n#endif\n\n\tif (display == NULL) {\n\t\treturn title;\n\t}\n\n\t/* use display: */\n\ttitle[0] = '\\0';\n\tif (display[0] == ':') {\n\t\tchar *th = this_host();\n\t\tif (th != NULL) {\n\t\t\tstrncpy(title, th, MAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t}\n\tstrncat(title, display, MAXN - strlen(title));\n\tX_LOCK;\n\tif (subwin && dpy && valid_window(subwin, NULL, 0)) {\n#if !NO_X11\n\t\tchar *name = NULL;\n\t\tint do_appshare = getenv(\"X11VNC_APPSHARE_ACTIVE\") ? 1 : 0;\n\t\tif (0 && do_appshare) {\n\t\t\ttitle[0] = '\\0';\n\t\t}\n\t\tif (XFetchName(dpy, subwin, &name)) {\n\t\t\tif (name) {\n\t\t\t\tif (title[0] != '\\0') {\n\t\t\t\t\tstrncat(title, \" \",  MAXN - strlen(title));\n\t\t\t\t}\n\t\t\t\tstrncat(title, name, MAXN - strlen(title));\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t\tif (do_appshare) {\n\t\t\tWindow c;\n\t\t\tint x, y;\n\t\t\tif (xtranslate(subwin, rootwin, 0, 0, &x, &y, &c, 1)) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tif (scaling) {\n\t\t\t\t\tx *= scale_fac_x;\n\t\t\t\t\ty *= scale_fac_y;\n\t\t\t\t}\n\t\t\t\tsprintf(tmp, \" XY=%d,%d\", x, y);\n\t\t\t\tstrncat(title, tmp, MAXN - strlen(title));\n\t\t\t}\n\t\t\trfbLog(\"appshare title: %s\\n\", title);\n\t\t}\n#endif\t/* NO_X11 */\n\t}\n\tX_UNLOCK;\n\treturn title;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dabs(double x);",
            "char *get_user_name(void);",
            "char *this_host(void);",
            "char *choose_title(char *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dabs(double x);\nchar *get_user_name(void);\nchar *this_host(void);\nchar *choose_title(char *display);\n\nchar *choose_title(char *display) {\n\tstatic char title[(MAXN+10)];\t\n\n\tmemset(title, 0, sizeof(title));\n\tstrcpy(title, \"x11vnc\");\n\n\tif (display == NULL) {\n\t\tdisplay = getenv(\"DISPLAY\");\n\t}\n\n#ifdef MACOSX\n\tif (display == NULL || strstr(display, \"/tmp/\") == display) {\n\t\tchar *u = get_user_name();\n\t\tchar *th = this_host();\n\t\tif (strlen(u) > MAXN/4)  {\n\t\t\tu = \"someone\";\n\t\t}\n\t\tstrcpy(title, u);\n\t\tif (th || UT.nodename) {\n\t\t\tstrcat(title, \"@\");\n\t\t\tstrncat(title, th ? th : UT.nodename,\n\t\t\t\tMAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t\treturn title;\n\t}\n#endif\n\n\tif (display == NULL) {\n\t\treturn title;\n\t}\n\n\t/* use display: */\n\ttitle[0] = '\\0';\n\tif (display[0] == ':') {\n\t\tchar *th = this_host();\n\t\tif (th != NULL) {\n\t\t\tstrncpy(title, th, MAXN - strlen(title));\n\t\t\tfree(th);\n\t\t}\n\t}\n\tstrncat(title, display, MAXN - strlen(title));\n\tX_LOCK;\n\tif (subwin && dpy && valid_window(subwin, NULL, 0)) {\n#if !NO_X11\n\t\tchar *name = NULL;\n\t\tint do_appshare = getenv(\"X11VNC_APPSHARE_ACTIVE\") ? 1 : 0;\n\t\tif (0 && do_appshare) {\n\t\t\ttitle[0] = '\\0';\n\t\t}\n\t\tif (XFetchName(dpy, subwin, &name)) {\n\t\t\tif (name) {\n\t\t\t\tif (title[0] != '\\0') {\n\t\t\t\t\tstrncat(title, \" \",  MAXN - strlen(title));\n\t\t\t\t}\n\t\t\t\tstrncat(title, name, MAXN - strlen(title));\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t\tif (do_appshare) {\n\t\t\tWindow c;\n\t\t\tint x, y;\n\t\t\tif (xtranslate(subwin, rootwin, 0, 0, &x, &y, &c, 1)) {\n\t\t\t\tchar tmp[32];\n\t\t\t\tif (scaling) {\n\t\t\t\t\tx *= scale_fac_x;\n\t\t\t\t\ty *= scale_fac_y;\n\t\t\t\t}\n\t\t\t\tsprintf(tmp, \" XY=%d,%d\", x, y);\n\t\t\t\tstrncat(title, tmp, MAXN - strlen(title));\n\t\t\t}\n\t\t\trfbLog(\"appshare title: %s\\n\", title);\n\t\t}\n#endif\t/* NO_X11 */\n\t}\n\tX_UNLOCK;\n\treturn title;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\""
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\""
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_ACTIVE\""
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\", \\t\\r\\n\""
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "tmp",
            "\", \\t\\r\\n\""
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(strlen(tmp)+2) * sizeof (char *)",
            "1"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REVERSE_USE_OLD_SLEEP\""
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nvoid send_client_info(char *str);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid reverse_connect(char *str) {\n\tchar *p, *tmp;\n\tint sleep_between_host = 300;\n\tint sleep_min = 1500, sleep_max = 4500, n_max = 5;\n\tint n, tot, t, dt = 100, cnt = 0;\n\tint nclients0 = client_count;\n\tint lcnt, j;\n\tchar **list;\n\tint do_appshare = 0;\n\n\tif (!getenv(\"X11VNC_REVERSE_USE_OLD_SLEEP\")) {\n\t\tsleep_min = 500;\n\t\tsleep_max = 2500;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\ttmp = strdup(str);\n\n\tlist = (char **) calloc( (strlen(tmp)+2) * sizeof (char *), 1);\n\tlcnt = 0;\n\n\tp = strtok(tmp, \", \\t\\r\\n\");\n\twhile (p) {\n\t\tlist[lcnt++] = strdup(p);\n\t\tp = strtok(NULL, \", \\t\\r\\n\");\n\t}\n\tfree(tmp);\n\n\tif (subwin && getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\tdo_appshare = 1;\n\t\tsleep_between_host = 0;\t/* too agressive??? */\n\t}\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\")) {\n\t\tsleep_between_host = atoi(getenv(\"X11VNC_REVERSE_SLEEP_BETWEEN_HOST\"));\n\t}\n\n\tif (do_appshare) {\n\t\tif (screen && dpy) {\n\t\t\tchar *s = choose_title(DisplayString(dpy));\n\n\t\t\t/* mutex */\n\t\t\tscreen->desktopName = s;\n\t\t\tif (rfb_desktop_name) {\n\t\t\t\tfree(rfb_desktop_name);\n\t\t\t}\n\t\t\trfb_desktop_name = strdup(s);\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\t\n\t\tif ((n = do_reverse_connect(p)) != 0) {\n\t\t\tint i;\n\t\t\tprogress_client();\n\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t}\n\t\t}\n\t\tcnt += n;\n\t\tif (list[j+1] != NULL) {\n\t\t\tt = 0;\n\t\t\twhile (t < sleep_between_host) {\n\t\t\t\tdouble t1, t2;\n\t\t\t\tint i;\n\t\t\t\tt1 = dnow();\n\t\t\t\tfor (i=0; i < 8; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t\tif (do_appshare && t == 0) {\n\t\t\t\t\t\trfbPE(-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt2 = dnow();\n\t\t\t\tt += (int) (1000 * (t2 - t1));\n\t\t\t\tif (t >= sleep_between_host) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep(dt * 1000);\n\t\t\t\tt += dt;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < lcnt; j++) {\n\t\tp = list[j];\n\t\tif (p) free(p);\n\t}\n\tfree(list);\n\n\tif (cnt == 0) {\n\t\tif (connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tcheck_xrandr_event(\"reverse_connect1\");\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * XXX: we need to process some of the initial handshaking\n\t * events, otherwise the client can get messed up (why??) \n\t * so we send rfbProcessEvents() all over the place.\n\t *\n\t * How much is this still needed?\n\t */\n\n\tn = cnt;\n\tif (n >= n_max) {\n\t\tn = n_max; \n\t}\n\tt = sleep_max - sleep_min;\n\ttot = sleep_min + ((n-1) * t) / (n_max-1);\n\n\tif (do_appshare) {\n\t\ttot /= 3;\n\t\tif (tot < dt) {\n\t\t\ttot = dt;\n\t\t}\n\t\ttot = 0;\t/* too agressive??? */\n\t}\n\n\tif (getenv(\"X11VNC_REVERSE_SLEEP_MAX\")) {\n\t\ttot = atoi(getenv(\"X11VNC_REVERSE_SLEEP_MAX\"));\n\t}\n\n\tt = 0;\n\twhile (t < tot) {\n\t\tint i;\n\t\tdouble t1, t2;\n\t\tt1 = dnow();\n\t\tfor (i=0; i < 8; i++) {\n\t\t\trfbPE(-1);\n\t\t\tif (t == 0) rfbPE(-1);\n\t\t}\n\t\tt2 = dnow();\n\t\tt += (int) (1000 * (t2 - t1));\n\t\tif (t >= tot) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(dt * 1000);\n\t\tt += dt;\n\t}\n\tif (connect_or_exit) {\n\t\tif (client_count <= nclients0)  {\n\t\t\tfor (t = 0; t < 10; t++) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i < 3; i++) {\n\t\t\t\t\trfbPE(-1);\n\t\t\t\t}\n\t\t\t\tusleep(100 * 1000);\n\t\t\t}\n\t\t}\n\t\tif (client_count <= nclients0)  {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"exiting under -connect_or_exit\\n\");\n\t\t\tif (gui_pid > 0) {\n\t\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\t\tkill(gui_pid, SIGTERM);\n\t\t\t}\n\t\t\tclean_up_exit(1);\n\t\t}\n\t}\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"reverse_connect2\");\n\t}\n}"
  },
  {
    "function_name": "do_reverse_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2645-2848",
    "snippet": "static int do_reverse_connect(char *str_in) {\n\trfbClientPtr cl;\n\tchar *host, *p, *str = str_in;\n\tchar *prestring = NULL;\n\tint prestring_len = 0;\n\tint rport = 5500, len = strlen(str);\n\tint set_alarm = 0;\n\n\tif (len < 1) {\n\t\treturn 0;\n\t}\n\tif (len > 1024) {\n\t\trfbLog(\"reverse_connect: string too long: %d bytes\\n\", len);\n\t\treturn 0;\n\t}\n\tif (!screen) {\n\t\trfbLog(\"reverse_connect: screen not setup yet.\\n\");\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\t/* look for repeater pre-string */\n\tif (strchr(str, '=') && strrchr(str, '+')\n\t    && (strstr(str, \"pre\") == str || strstr(str, \"repeater=\") == str)) {\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t} else if (strrchr(str, '+') && strstr(str, \"repeater://\") == str) {\n\t\t/* repeater://host:port+string */\n\t\t/*   repeater=string+host:port */\n\t\tchar *plus = strrchr(str, '+');\n\t\tstr = (char *) malloc(strlen(str_in)+1);\n\t\t*plus = '\\0';\n\t\tsprintf(str, \"repeater=%s+%s\", plus+1, str_in + strlen(\"repeater://\"));\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t\t*plus = '+';\n\t}\n\n\t/* copy in to host */\n\thost = (char *) malloc(len+1);\n\tif (! host) {\n\t\trfbLog(\"reverse_connect: could not malloc string %d\\n\", len);\n\t\treturn 0;\n\t}\n\tstrncpy(host, str, len);\n\thost[len] = '\\0';\n\n\t/* extract port, if any */\n\tif ((p = strrchr(host, ':')) != NULL) {\n\t\trport = atoi(p+1);\n\t\tif (rport < 0) {\n\t\t\trport = -rport;\n\t\t} else if (rport < 20) {\n\t\t\trport = 5500 + rport;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\tif (use_openssl) {\n\t\tint vncsock;\n\t\tif (connect_proxy) {\n\t\t\tvncsock = proxy_connect(host, rport);\n\t\t} else {\n\t\t\tvncsock = connect_tcp(host, rport);\n\t\t}\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"reverse_connect: failed to connect to: %s\\n\", str);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prestring != NULL) {\n\t\t\twrite(vncsock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t}\n/* XXX use header */\n#define OPENSSL_REVERSE 6\n\t\tif (!getenv(\"X11VNC_DISABLE_SSL_CLIENT_MODE\")) {\n\t\t\topenssl_init(1);\n\t\t}\n\n\t\tif (first_conn_timeout > 0) {\n\t\t\tset_alarm = 1;\n\t\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\taccept_openssl(OPENSSL_REVERSE, vncsock);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\n\t\topenssl_init(0);\n\t\tfree(host);\n\t\treturn 1;\n\t}\n\n\tif (use_stunnel) {\n\t\tif(strcmp(host, \"localhost\") && strcmp(host, \"127.0.0.1\")) {\n\t\t\tif (!getenv(\"STUNNEL_DISABLE_LOCALHOST\")) {\n\t\t\t\trfbLog(\"reverse_connect: error host not localhost in -stunnel mode.\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unixpw) {\n\t\tint is_localhost = 0, user_disabled_it = 0;\n\n\t\tif(!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\t\tis_localhost = 1;\n\t\t}\n\t\tif (getenv(\"UNIXPW_DISABLE_LOCALHOST\")) {\n\t\t\tuser_disabled_it = 1;\n\t\t}\n\n\t\tif (! is_localhost) {\n\t\t\tif (user_disabled_it) {\n\t\t\t\trfbLog(\"reverse_connect: warning disabling localhost constraint in -unixpw\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"reverse_connect: error not localhost in -unixpw\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (first_conn_timeout > 0) {\n\t\tset_alarm = 1;\n\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\talarm(first_conn_timeout);\n\t}\n\n\tif (connect_proxy != NULL) {\n\t\tint sock = proxy_connect(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\tif (prestring != NULL) {\n\t\t\t\twrite(sock, prestring, prestring_len);\n\t\t\t\tfree(prestring);\n\t\t\t}\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else if (prestring != NULL) {\n\t\tint sock = connect_tcp(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\twrite(sock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tcl = rfbReverseConnection(screen, host, rport);\n\t\tif (cl == NULL) {\n\t\t\tint sock = connect_tcp(host, rport);\n\t\t\tif (sock >= 0) {\n\t\t\t\tcl = create_new_client(sock, 1);\n\t\t\t}\n\t\t}\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (cl != NULL && use_threads) {\n\t\t\tcl->onHold = FALSE;\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\n\tfree(host);\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\n\tif (cl == NULL) {\n\t\tif (quiet && connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t}\n\t\trfbLog(\"reverse_connect: %s failed\\n\", str);\n\t\treturn 0;\n\t} else {\n\t\trfbLog(\"reverse_connect: %s/%s OK\\n\", str, cl->host);\n\t\t/* let's see if anyone complains: */\n\t\tif (! getenv(\"X11VNC_REVERSE_CONNECTION_NO_AUTH\")) {\n\t\t\trfbLog(\"reverse_connect: turning on auth for %s\\n\",\n\t\t\t    cl->host);\n\t\t\tcl->reverseConnection = FALSE;\n\t\t}\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define OPENSSL_REVERSE 6",
      "#define USE_TIMEOUT_INTERRUPT 0"
    ],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "void send_client_info(char *str);",
      "void adjust_grabs(int grab, int quiet);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: turning on auth for %s\\n\"",
            "cl->host"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REVERSE_CONNECTION_NO_AUTH\""
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: %s/%s OK\\n\"",
            "str",
            "cl->host"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: %s failed\\n\"",
            "str"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ipv6_client_ip_str"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbStartOnHoldClient",
          "args": [
            "cl"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm",
          "args": [
            "0"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_client",
          "args": [
            "sock",
            "1"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3826-3845",
          "snippet": "rfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "rfbClientPtr create_new_client(int sock, int start_thread);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nrfbClientPtr create_new_client(int sock, int start_thread);\n\nrfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "host",
            "rport"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReverseConnection",
          "args": [
            "screen",
            "host",
            "rport"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock",
            "prestring",
            "prestring_len"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proxy_connect",
          "args": [
            "host",
            "rport"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "proxy_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2333-2547",
          "snippet": "static int proxy_connect(char *host, int port) {\n\tchar *p, *q, *str;\n\tint i, n, pxy[PXY],pxy_p[PXY];\n\tint psock = -1;\n\tchar *pxy_h[PXY], *pxy_g[PXY];\n\n\tif (! connect_proxy) {\n\t\treturn -1;\n\t}\n\tstr = strdup(connect_proxy);\n\n\tfor (i=0; i<PXY; i++) {\n\t\tpxy[i] = 0;\n\t\tpxy_p[i] = 0;\n\t\tpxy_h[i] = NULL;\n\t\tpxy_g[i] = NULL;\n\t}\n\n\tn = 0;\n\tp = str;\n\twhile (p) {\n\t\tchar *hp, *c, *s = NULL;\n\n\t\tq = strchr(p, ',');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\tif (n==0) fprintf(stderr, \"\\n\");\n\t\trfbLog(\"proxy_connect[%d]: %s\\n\", n+1, p);\n\n\t\tpxy[n] = 0;\n\t\tpxy_p[n] = 0;\n\t\tpxy_h[n] = NULL;\n\t\tpxy_g[n] = NULL;\n\n\t\tif (strstr(p, \"socks://\") == p)\t{\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks4://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks5://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS5;\n\t\t} else if (strstr(p, \"ssh://\") == p) {\n\t\t\tif (n != 0) {\n\t\t\t\trfbLog(\"ssh:// proxy must be the first one\\n\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SSH;\n\t\t} else if (strstr(p, \"http://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else if (strstr(p, \"https://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else {\n\t\t\thp = p;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t}\n\t\tc = strstr(hp, \":\");\n\t\tif (!c && pxy[n] == PXY_SSH) {\n\t\t\tchar *hp2 = (char *) malloc(strlen(hp) + 5);\n\t\t\tsprintf(hp2, \"%s:1\", hp);\n\t\t\thp = hp2;\n\t\t\tc = strstr(hp, \":\");\n\t\t}\n\t\tif (!c) {\n\t\t\tpxy[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tif (pxy[n] == PXY_HTTP) {\n\t\t\ts = strstr(c, \"/\");\n\t\t\tif (s) {\n\t\t\t\tpxy[n] = PXY_GET;\n\t\t\t\tpxy_g[n] = strdup(s);\n\t\t\t\t*s = '\\0';\n\t\t\t}\n\t\t}\n\t\tpxy_p[n] = atoi(c+1);\n\n\t\tif (pxy_p[n] <= 0) {\n\t\t\tpxy[n] = 0;\n\t\t\tpxy_p[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t*c = '\\0';\n\t\tpxy_h[n] = strdup(hp);\n\n\t\tif (++n >= PXY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (q) {\n\t\t\t*q = ',';\n\t\t\tp = q + 1;\n\t\t} else {\n\t\t\tp = NULL;\n\t\t}\n\t}\n\tfree(str);\n\n\tif (!n) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\n\tif (pxy[0] == PXY_SSH) {\n\t\tint rc, len = 0;\n\t\tchar *cmd, *ssh;\n\t\tint sport = find_free_port(7300, 8000);\n\t\tif (getenv(\"SSH\")) {\n\t\t\tssh = getenv(\"SSH\");\n\t\t} else {\n\t\t\tssh = \"ssh\";\n\t\t}\n\t\tlen = 200 + strlen(ssh) + strlen(pxy_h[0]) + strlen(host);\n\t\tcmd = (char *) malloc(len);\n\t\tif (n == 1) {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, host, port, pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, host, port, pxy_h[0]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t}\n\t\t}\n\t\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tclose_exec_fds();\n\t\tfprintf(stderr, \"\\n\");\n\t\trfbLog(\"running: %s\\n\", cmd);\n\t\trc = system(cmd);\n\t\tfree(cmd);\n\t\tif (rc != 0) {\n\t\t\tpsock = -1;\n\t\t\tgoto pxy_clean;\n\t\t}\n\t\tpsock = connect_tcp(\"localhost\", sport);\n\n\t} else {\n\t\tpsock = connect_tcp(pxy_h[0], pxy_p[0]);\n\t}\n\n\tif (psock < 0) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\trfbLog(\"opened socket to proxy: %s:%d\\n\", pxy_h[0], pxy_p[0]);\n\n\tif (n >= 2) {\n\t\tif (! pconnect(psock, pxy_h[1], pxy_p[1], pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\n\t\tif (n >= 3) {\n\t\t\tif (! pconnect(psock, pxy_h[2], pxy_p[2], pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\tif (! pconnect(psock, host, port, pxy[2], pxy_g[2], pxy_h[2], pxy_p[2])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\t\n\t\t} else {\n\t\t\tif (! pconnect(psock, host, port, pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t}\n\t} else {\n\t\tif (! pconnect(psock, host, port, pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t}\n\n\tpxy_clean:\n\tfor (i=0; i < PXY; i++) {\n\t\tif (pxy_h[i] != NULL) {\n\t\t\tfree(pxy_h[i]);\n\t\t}\n\t\tif (pxy_g[i] != NULL) {\n\t\t\tfree(pxy_g[i]);\n\t\t}\n\t}\n\n\treturn psock;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define PXY 3",
            "#define PXY_SSH\t\t5",
            "#define PXY_SOCKS5\t4",
            "#define PXY_SOCKS\t3",
            "#define PXY_GET\t\t2",
            "#define PXY_HTTP\t1"
          ],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);",
            "static int action_match(char *action, int rc);",
            "static int pxy_get_sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define PXY 3\n#define PXY_SSH\t\t5\n#define PXY_SOCKS5\t4\n#define PXY_SOCKS\t3\n#define PXY_GET\t\t2\n#define PXY_HTTP\t1\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\nstatic int action_match(char *action, int rc);\nstatic int pxy_get_sock;\n\nstatic int proxy_connect(char *host, int port) {\n\tchar *p, *q, *str;\n\tint i, n, pxy[PXY],pxy_p[PXY];\n\tint psock = -1;\n\tchar *pxy_h[PXY], *pxy_g[PXY];\n\n\tif (! connect_proxy) {\n\t\treturn -1;\n\t}\n\tstr = strdup(connect_proxy);\n\n\tfor (i=0; i<PXY; i++) {\n\t\tpxy[i] = 0;\n\t\tpxy_p[i] = 0;\n\t\tpxy_h[i] = NULL;\n\t\tpxy_g[i] = NULL;\n\t}\n\n\tn = 0;\n\tp = str;\n\twhile (p) {\n\t\tchar *hp, *c, *s = NULL;\n\n\t\tq = strchr(p, ',');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\tif (n==0) fprintf(stderr, \"\\n\");\n\t\trfbLog(\"proxy_connect[%d]: %s\\n\", n+1, p);\n\n\t\tpxy[n] = 0;\n\t\tpxy_p[n] = 0;\n\t\tpxy_h[n] = NULL;\n\t\tpxy_g[n] = NULL;\n\n\t\tif (strstr(p, \"socks://\") == p)\t{\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks4://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks5://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS5;\n\t\t} else if (strstr(p, \"ssh://\") == p) {\n\t\t\tif (n != 0) {\n\t\t\t\trfbLog(\"ssh:// proxy must be the first one\\n\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SSH;\n\t\t} else if (strstr(p, \"http://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else if (strstr(p, \"https://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else {\n\t\t\thp = p;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t}\n\t\tc = strstr(hp, \":\");\n\t\tif (!c && pxy[n] == PXY_SSH) {\n\t\t\tchar *hp2 = (char *) malloc(strlen(hp) + 5);\n\t\t\tsprintf(hp2, \"%s:1\", hp);\n\t\t\thp = hp2;\n\t\t\tc = strstr(hp, \":\");\n\t\t}\n\t\tif (!c) {\n\t\t\tpxy[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tif (pxy[n] == PXY_HTTP) {\n\t\t\ts = strstr(c, \"/\");\n\t\t\tif (s) {\n\t\t\t\tpxy[n] = PXY_GET;\n\t\t\t\tpxy_g[n] = strdup(s);\n\t\t\t\t*s = '\\0';\n\t\t\t}\n\t\t}\n\t\tpxy_p[n] = atoi(c+1);\n\n\t\tif (pxy_p[n] <= 0) {\n\t\t\tpxy[n] = 0;\n\t\t\tpxy_p[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t*c = '\\0';\n\t\tpxy_h[n] = strdup(hp);\n\n\t\tif (++n >= PXY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (q) {\n\t\t\t*q = ',';\n\t\t\tp = q + 1;\n\t\t} else {\n\t\t\tp = NULL;\n\t\t}\n\t}\n\tfree(str);\n\n\tif (!n) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\n\tif (pxy[0] == PXY_SSH) {\n\t\tint rc, len = 0;\n\t\tchar *cmd, *ssh;\n\t\tint sport = find_free_port(7300, 8000);\n\t\tif (getenv(\"SSH\")) {\n\t\t\tssh = getenv(\"SSH\");\n\t\t} else {\n\t\t\tssh = \"ssh\";\n\t\t}\n\t\tlen = 200 + strlen(ssh) + strlen(pxy_h[0]) + strlen(host);\n\t\tcmd = (char *) malloc(len);\n\t\tif (n == 1) {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, host, port, pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, host, port, pxy_h[0]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t}\n\t\t}\n\t\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tclose_exec_fds();\n\t\tfprintf(stderr, \"\\n\");\n\t\trfbLog(\"running: %s\\n\", cmd);\n\t\trc = system(cmd);\n\t\tfree(cmd);\n\t\tif (rc != 0) {\n\t\t\tpsock = -1;\n\t\t\tgoto pxy_clean;\n\t\t}\n\t\tpsock = connect_tcp(\"localhost\", sport);\n\n\t} else {\n\t\tpsock = connect_tcp(pxy_h[0], pxy_p[0]);\n\t}\n\n\tif (psock < 0) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\trfbLog(\"opened socket to proxy: %s:%d\\n\", pxy_h[0], pxy_p[0]);\n\n\tif (n >= 2) {\n\t\tif (! pconnect(psock, pxy_h[1], pxy_p[1], pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\n\t\tif (n >= 3) {\n\t\t\tif (! pconnect(psock, pxy_h[2], pxy_p[2], pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\tif (! pconnect(psock, host, port, pxy[2], pxy_g[2], pxy_h[2], pxy_p[2])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\t\n\t\t} else {\n\t\t\tif (! pconnect(psock, host, port, pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t}\n\t} else {\n\t\tif (! pconnect(psock, host, port, pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t}\n\n\tpxy_clean:\n\tfor (i=0; i < PXY; i++) {\n\t\tif (pxy_h[i] != NULL) {\n\t\t\tfree(pxy_h[i]);\n\t\t}\n\t\tif (pxy_g[i] != NULL) {\n\t\t\tfree(pxy_g[i]);\n\t\t}\n\t}\n\n\treturn psock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: using alarm() timeout of %d seconds.\\n\"",
            "first_conn_timeout"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginterrupt",
          "args": [
            "SIGALRM",
            "1"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "reverse_connect_timeout"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: error not localhost in -unixpw\\n\""
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: warning disabling localhost constraint in -unixpw\\n\""
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"UNIXPW_DISABLE_LOCALHOST\""
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "host",
            "\"127.0.0.1\""
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "host",
            "\"localhost\""
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: error host not localhost in -stunnel mode.\\n\""
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"STUNNEL_DISABLE_LOCALHOST\""
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "host",
            "\"127.0.0.1\""
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "host",
            "\"localhost\""
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openssl_init",
          "args": [
            "0"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "openssl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1004-1290",
          "snippet": "void openssl_init(int isclient) {\n\tint db = 0, tmp_pem = 0, do_dh;\n\tconst SSL_METHOD *method;\n\tchar *method_name;\n\tFILE *in;\n\tdouble ds;\n\tlong mode;\n\tstatic int first = 1;\n\n\tdo_dh = DO_DH;\n\n\tif (enc_str != NULL) {\n\t\tif (first) {\n\t\t\tinit_prng();\n\t\t}\n\t\tfirst = 0;\n\t\treturn;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Initializing SSL (%s connect mode).\\n\", isclient ? \"client\":\"server\");\n\t}\n\tif (first) {\n\t\tif (db) fprintf(stderr, \"\\nSSL_load_error_strings()\\n\");\n\n\t\tSSL_load_error_strings();\n\n\t\tif (db) fprintf(stderr, \"SSL_library_init()\\n\");\n\n\t\tSSL_library_init();\n\n\t\tif (db) fprintf(stderr, \"init_prng()\\n\");\n\n\t\tinit_prng();\n\n\t\tfirst = 0;\n\t}\n\n\tif (isclient) {\n\t\tssl_client_mode = 1;\n\t} else {\n\t\tssl_client_mode = 0;\n\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"TLS_client_method()\" : \"TLS_server_method()\";\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"SSLv23_client_method()\" : \"SSLv23_server_method()\";\n#endif\n\tif (db) fprintf(stderr, \"%s\\n\", method_name);\n\tctx = SSL_CTX_new(method);\n\n\tif (ctx == NULL) {\n\t\trfbLog(\"openssl_init: SSL_CTX_new failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tds = dnow();\n\trsa_512 = RSA_generate_key(512, RSA_F4, NULL, NULL);\n\tif (rsa_512 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(512) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created  512 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tds = dnow();\n\trsa_1024 = RSA_generate_key(1024, RSA_F4, NULL, NULL);\n\tif (rsa_1024 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created 1024 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tif (db) fprintf(stderr, \"SSL_CTX_set_tmp_rsa()\\n\");\n\n\tif (! SSL_CTX_set_tmp_rsa(ctx, rsa_1024)) {\n\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n#define ssl_cache 0\n#if ssl_cache\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n#else\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\n\tSSL_CTX_set_timeout(ctx, 1);\n#endif\n\n\tds = dnow();\n\tif (! openssl_pem) {\n\t\topenssl_pem = create_tmp_pem(NULL, 0);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\n\t} else if (!strcmp(openssl_pem, \"ANON\")) {\n\t\tif (ssl_verify) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslverify mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslCRL mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* n.b. new ctx */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman setup\"\n\t\t\t    \" failed.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (strstr(openssl_pem, \"SAVE\") == openssl_pem) {\n\t\topenssl_pem = get_saved_pem(openssl_pem, 1);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create or open\"\n\t\t\t    \" saved PEM: %s\\n\", openssl_pem);\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 0;\n\t}\n\n\trfbLog(\"using PEM %s  %.3fs\\n\", openssl_pem, dnow() - ds);\n\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\n\tif (do_dh) {\n\t\tDH *dh;\n\t\tBIO *bio;\n\n\t\tds = dnow();\n\t\tin = fopen(openssl_pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\t\tif (! bio) {\n\t\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\t\tif (dh == NULL) {\n\t\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\t\tBIO_free(bio);\n\t\t\tsslerrexit();\n\t\t}\n\t\tBIO_free(bio);\n\t\tSSL_CTX_set_tmp_dh(ctx, dh);\n\t\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\",\n\t\t    8*DH_size(dh), dnow()-ds);\n\t\tDH_free(dh);\n\t}\n\n\tif (strcmp(openssl_pem, \"ANON\")) {\n\t\tif (! SSL_CTX_use_certificate_chain_file(ctx, openssl_pem)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_use_certificate_chain_file() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_use_RSAPrivateKey_file(ctx, openssl_pem,\n\t\t    SSL_FILETYPE_PEM)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_check_private_key(ctx)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t}\n\n\tif (tmp_pem && ! getenv(\"X11VNC_KEEP_TMP_PEM\")) {\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(openssl_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, 128, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\tunlink(openssl_pem);\n\t\tfree(openssl_pem);\n\t\topenssl_pem = NULL;\n\t}\n\n\tif (ssl_crl) {\n\t\tstruct stat sbuf;\n\t\tX509_LOOKUP *lookup;\n\n\t\tif (stat(ssl_crl, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslCRL does not exist %s.\\n\",\n\t\t\t    ssl_crl ? ssl_crl : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\trevocation_store = X509_STORE_new();\n\t\tif (!revocation_store) {\n\t\t\trfbLog(\"openssl_init: X509_STORE_new failed.\\n\");\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_file());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_load_file(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_load_file failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_hash_dir());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_add_dir(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_add_dir failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\t\trfbLog(\"loaded CRL file: %s\\n\", ssl_crl);\n\t}\n\n\tif (ssl_verify) {\n\t\tstruct stat sbuf;\n\t\tchar *file;\n\t\tint lvl;\n\n\t\tfile = get_ssl_verify_file(ssl_verify);\n\n\t\tif (!file || stat(file, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslverify does not exist %s.\\n\",\n\t\t\t    file ? file : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, file, NULL)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, NULL, file)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\n\t\tlvl = SSL_VERIFY_FAIL_IF_NO_PEER_CERT|SSL_VERIFY_PEER;\n\t\tif (ssl_crl == NULL) {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, verify_callback);\n\t\t}\n\t\tif (strstr(file, \"/sslverify-tmp-load-\")) {\n\t\t\t/* temporary file */\n\t\t\tunlink(file);\n\t\t}\n\t} else {\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\trfbLog(\"\\n\");\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ssl_cache 0",
            "#define DO_DH 0"
          ],
          "globals_used": [
            "char *get_saved_pem(char *string, int create);",
            "static char *get_input(char *tag, char **in);",
            "void openssl_init(int isclient);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define ssl_cache 0\n#define DO_DH 0\n\nchar *get_saved_pem(char *string, int create);\nstatic char *get_input(char *tag, char **in);\nvoid openssl_init(int isclient);\n\nvoid openssl_init(int isclient) {\n\tint db = 0, tmp_pem = 0, do_dh;\n\tconst SSL_METHOD *method;\n\tchar *method_name;\n\tFILE *in;\n\tdouble ds;\n\tlong mode;\n\tstatic int first = 1;\n\n\tdo_dh = DO_DH;\n\n\tif (enc_str != NULL) {\n\t\tif (first) {\n\t\t\tinit_prng();\n\t\t}\n\t\tfirst = 0;\n\t\treturn;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Initializing SSL (%s connect mode).\\n\", isclient ? \"client\":\"server\");\n\t}\n\tif (first) {\n\t\tif (db) fprintf(stderr, \"\\nSSL_load_error_strings()\\n\");\n\n\t\tSSL_load_error_strings();\n\n\t\tif (db) fprintf(stderr, \"SSL_library_init()\\n\");\n\n\t\tSSL_library_init();\n\n\t\tif (db) fprintf(stderr, \"init_prng()\\n\");\n\n\t\tinit_prng();\n\n\t\tfirst = 0;\n\t}\n\n\tif (isclient) {\n\t\tssl_client_mode = 1;\n\t} else {\n\t\tssl_client_mode = 0;\n\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"TLS_client_method()\" : \"TLS_server_method()\";\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"SSLv23_client_method()\" : \"SSLv23_server_method()\";\n#endif\n\tif (db) fprintf(stderr, \"%s\\n\", method_name);\n\tctx = SSL_CTX_new(method);\n\n\tif (ctx == NULL) {\n\t\trfbLog(\"openssl_init: SSL_CTX_new failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tds = dnow();\n\trsa_512 = RSA_generate_key(512, RSA_F4, NULL, NULL);\n\tif (rsa_512 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(512) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created  512 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tds = dnow();\n\trsa_1024 = RSA_generate_key(1024, RSA_F4, NULL, NULL);\n\tif (rsa_1024 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created 1024 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tif (db) fprintf(stderr, \"SSL_CTX_set_tmp_rsa()\\n\");\n\n\tif (! SSL_CTX_set_tmp_rsa(ctx, rsa_1024)) {\n\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n#define ssl_cache 0\n#if ssl_cache\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n#else\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\n\tSSL_CTX_set_timeout(ctx, 1);\n#endif\n\n\tds = dnow();\n\tif (! openssl_pem) {\n\t\topenssl_pem = create_tmp_pem(NULL, 0);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\n\t} else if (!strcmp(openssl_pem, \"ANON\")) {\n\t\tif (ssl_verify) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslverify mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslCRL mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* n.b. new ctx */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman setup\"\n\t\t\t    \" failed.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (strstr(openssl_pem, \"SAVE\") == openssl_pem) {\n\t\topenssl_pem = get_saved_pem(openssl_pem, 1);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create or open\"\n\t\t\t    \" saved PEM: %s\\n\", openssl_pem);\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 0;\n\t}\n\n\trfbLog(\"using PEM %s  %.3fs\\n\", openssl_pem, dnow() - ds);\n\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\n\tif (do_dh) {\n\t\tDH *dh;\n\t\tBIO *bio;\n\n\t\tds = dnow();\n\t\tin = fopen(openssl_pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\t\tif (! bio) {\n\t\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\t\tif (dh == NULL) {\n\t\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\t\tBIO_free(bio);\n\t\t\tsslerrexit();\n\t\t}\n\t\tBIO_free(bio);\n\t\tSSL_CTX_set_tmp_dh(ctx, dh);\n\t\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\",\n\t\t    8*DH_size(dh), dnow()-ds);\n\t\tDH_free(dh);\n\t}\n\n\tif (strcmp(openssl_pem, \"ANON\")) {\n\t\tif (! SSL_CTX_use_certificate_chain_file(ctx, openssl_pem)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_use_certificate_chain_file() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_use_RSAPrivateKey_file(ctx, openssl_pem,\n\t\t    SSL_FILETYPE_PEM)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_check_private_key(ctx)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t}\n\n\tif (tmp_pem && ! getenv(\"X11VNC_KEEP_TMP_PEM\")) {\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(openssl_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, 128, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\tunlink(openssl_pem);\n\t\tfree(openssl_pem);\n\t\topenssl_pem = NULL;\n\t}\n\n\tif (ssl_crl) {\n\t\tstruct stat sbuf;\n\t\tX509_LOOKUP *lookup;\n\n\t\tif (stat(ssl_crl, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslCRL does not exist %s.\\n\",\n\t\t\t    ssl_crl ? ssl_crl : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\trevocation_store = X509_STORE_new();\n\t\tif (!revocation_store) {\n\t\t\trfbLog(\"openssl_init: X509_STORE_new failed.\\n\");\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_file());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_load_file(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_load_file failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_hash_dir());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_add_dir(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_add_dir failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\t\trfbLog(\"loaded CRL file: %s\\n\", ssl_crl);\n\t}\n\n\tif (ssl_verify) {\n\t\tstruct stat sbuf;\n\t\tchar *file;\n\t\tint lvl;\n\n\t\tfile = get_ssl_verify_file(ssl_verify);\n\n\t\tif (!file || stat(file, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslverify does not exist %s.\\n\",\n\t\t\t    file ? file : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, file, NULL)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, NULL, file)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\n\t\tlvl = SSL_VERIFY_FAIL_IF_NO_PEER_CERT|SSL_VERIFY_PEER;\n\t\tif (ssl_crl == NULL) {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, verify_callback);\n\t\t}\n\t\tif (strstr(file, \"/sslverify-tmp-load-\")) {\n\t\t\t/* temporary file */\n\t\t\tunlink(file);\n\t\t}\n\t} else {\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\trfbLog(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept_openssl",
          "args": [
            "OPENSSL_REVERSE",
            "vncsock"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: using alarm() timeout of %d seconds.\\n\"",
            "first_conn_timeout"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginterrupt",
          "args": [
            "SIGALRM",
            "1"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "reverse_connect_timeout"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DISABLE_SSL_CLIENT_MODE\""
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: failed to connect to: %s\\n\"",
            "str"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p+1"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "host",
            "':'"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "host",
            "str",
            "len"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: could not malloc string %d\\n\"",
            "len"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len+1"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_repeater_string",
          "args": [
            "str",
            "&prestring_len"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "get_repeater_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2549-2625",
          "snippet": "char *get_repeater_string(char *str, int *len) {\n\tint pren, which = 0;\n\tint prestring_len = 0;\t\n\tchar *prestring = NULL, *ptmp = NULL;\n\tchar *equals = strchr(str, '=');\n\tchar *plus   = strrchr(str, '+');\n\n\t*len = 0;\n\tif (!plus || !equals) {\n\t\treturn NULL;\n\t}\n\n\t*plus = '\\0';\n\tif (strstr(str, \"repeater=\") == str) {\n\t\t/* ultravnc repeater http://www.uvnc.com/addons/repeater.html */\n\t\tprestring_len = 250;\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len, \"%s\", str + strlen(\"repeater=\"));\n\t\twhich = 1;\n\t} else if (strstr(str, \"pre=\") == str) {\n\t\tprestring_len = strlen(str + strlen(\"pre=\"));\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len+1, \"%s\", str + strlen(\"pre=\"));\n\t\twhich = 2;\n\t} else if (sscanf(str, \"pre%d=\", &pren) == 1) {\n\t\tif (pren > 0 && pren <= 16384) {\n\t\t\tprestring_len = pren;\n\t\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\t\tsnprintf(prestring, prestring_len, \"%s\", equals+1);\n\t\t\twhich = 3;\n\t\t}\n\t}\n\tif (ptmp != NULL) {\n\t\tint i, k = 0;\n\t\tchar *p = ptmp;\n\t\tprestring = (char *)calloc(prestring_len+1, 1);\n\t\t/* translate \\n to newline, etc. */\n\t\tfor (i=0; i < prestring_len; i++) {\n\t\t\tif (i < prestring_len-1 && *(p+i) == '\\\\') {\n\t\t\t\tif (*(p+i+1) == 'r') {\n\t\t\t\t\tprestring[k++] = '\\r'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'n') {\n\t\t\t\t\tprestring[k++] = '\\n'; i++;\n\t\t\t\t} else if (*(p+i+1) == 't') {\n\t\t\t\t\tprestring[k++] = '\\t'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'a') {\n\t\t\t\t\tprestring[k++] = '\\a'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'b') {\n\t\t\t\t\tprestring[k++] = '\\b'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'v') {\n\t\t\t\t\tprestring[k++] = '\\v'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'f') {\n\t\t\t\t\tprestring[k++] = '\\f'; i++;\n\t\t\t\t} else if (*(p+i+1) == '\\\\') {\n\t\t\t\t\tprestring[k++] = '\\\\'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'c') {\n\t\t\t\t\tprestring[k++] = ','; i++;\n\t\t\t\t} else {\n\t\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t}\n\t\t}\n\t\tif (which == 2) {\n\t\t\tprestring_len = k;\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"-connect prestring: '%s'\\n\", prestring);\n\t\t}\n\t\tfree(ptmp);\n\t}\n\t*plus = '+';\n\n\t*len = prestring_len;\n\treturn prestring;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nstatic rfbClientPtr *client_match(char *str);\n\nchar *get_repeater_string(char *str, int *len) {\n\tint pren, which = 0;\n\tint prestring_len = 0;\t\n\tchar *prestring = NULL, *ptmp = NULL;\n\tchar *equals = strchr(str, '=');\n\tchar *plus   = strrchr(str, '+');\n\n\t*len = 0;\n\tif (!plus || !equals) {\n\t\treturn NULL;\n\t}\n\n\t*plus = '\\0';\n\tif (strstr(str, \"repeater=\") == str) {\n\t\t/* ultravnc repeater http://www.uvnc.com/addons/repeater.html */\n\t\tprestring_len = 250;\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len, \"%s\", str + strlen(\"repeater=\"));\n\t\twhich = 1;\n\t} else if (strstr(str, \"pre=\") == str) {\n\t\tprestring_len = strlen(str + strlen(\"pre=\"));\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len+1, \"%s\", str + strlen(\"pre=\"));\n\t\twhich = 2;\n\t} else if (sscanf(str, \"pre%d=\", &pren) == 1) {\n\t\tif (pren > 0 && pren <= 16384) {\n\t\t\tprestring_len = pren;\n\t\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\t\tsnprintf(prestring, prestring_len, \"%s\", equals+1);\n\t\t\twhich = 3;\n\t\t}\n\t}\n\tif (ptmp != NULL) {\n\t\tint i, k = 0;\n\t\tchar *p = ptmp;\n\t\tprestring = (char *)calloc(prestring_len+1, 1);\n\t\t/* translate \\n to newline, etc. */\n\t\tfor (i=0; i < prestring_len; i++) {\n\t\t\tif (i < prestring_len-1 && *(p+i) == '\\\\') {\n\t\t\t\tif (*(p+i+1) == 'r') {\n\t\t\t\t\tprestring[k++] = '\\r'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'n') {\n\t\t\t\t\tprestring[k++] = '\\n'; i++;\n\t\t\t\t} else if (*(p+i+1) == 't') {\n\t\t\t\t\tprestring[k++] = '\\t'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'a') {\n\t\t\t\t\tprestring[k++] = '\\a'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'b') {\n\t\t\t\t\tprestring[k++] = '\\b'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'v') {\n\t\t\t\t\tprestring[k++] = '\\v'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'f') {\n\t\t\t\t\tprestring[k++] = '\\f'; i++;\n\t\t\t\t} else if (*(p+i+1) == '\\\\') {\n\t\t\t\t\tprestring[k++] = '\\\\'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'c') {\n\t\t\t\t\tprestring[k++] = ','; i++;\n\t\t\t\t} else {\n\t\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t}\n\t\t}\n\t\tif (which == 2) {\n\t\t\tprestring_len = k;\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"-connect prestring: '%s'\\n\", prestring);\n\t\t}\n\t\tfree(ptmp);\n\t}\n\t*plus = '+';\n\n\t*len = prestring_len;\n\treturn prestring;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"repeater=%s+%s\"",
            "plus+1",
            "str_in + strlen(\"repeater://\")"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"repeater://\""
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(str_in)+1"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_in"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"repeater://\""
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"repeater=\""
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"pre\""
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: screen not setup yet.\\n\""
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect: string too long: %d bytes\\n\"",
            "len"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_REVERSE 6\n#define USE_TIMEOUT_INTERRUPT 0\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nstatic rfbClientPtr *client_match(char *str);\n\nstatic int do_reverse_connect(char *str_in) {\n\trfbClientPtr cl;\n\tchar *host, *p, *str = str_in;\n\tchar *prestring = NULL;\n\tint prestring_len = 0;\n\tint rport = 5500, len = strlen(str);\n\tint set_alarm = 0;\n\n\tif (len < 1) {\n\t\treturn 0;\n\t}\n\tif (len > 1024) {\n\t\trfbLog(\"reverse_connect: string too long: %d bytes\\n\", len);\n\t\treturn 0;\n\t}\n\tif (!screen) {\n\t\trfbLog(\"reverse_connect: screen not setup yet.\\n\");\n\t\treturn 0;\n\t}\n\tif (unixpw_in_progress) return 0;\n\n\t/* look for repeater pre-string */\n\tif (strchr(str, '=') && strrchr(str, '+')\n\t    && (strstr(str, \"pre\") == str || strstr(str, \"repeater=\") == str)) {\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t} else if (strrchr(str, '+') && strstr(str, \"repeater://\") == str) {\n\t\t/* repeater://host:port+string */\n\t\t/*   repeater=string+host:port */\n\t\tchar *plus = strrchr(str, '+');\n\t\tstr = (char *) malloc(strlen(str_in)+1);\n\t\t*plus = '\\0';\n\t\tsprintf(str, \"repeater=%s+%s\", plus+1, str_in + strlen(\"repeater://\"));\n\t\tprestring = get_repeater_string(str, &prestring_len);\n\t\tstr = strrchr(str, '+') + 1;\n\t\t*plus = '+';\n\t}\n\n\t/* copy in to host */\n\thost = (char *) malloc(len+1);\n\tif (! host) {\n\t\trfbLog(\"reverse_connect: could not malloc string %d\\n\", len);\n\t\treturn 0;\n\t}\n\tstrncpy(host, str, len);\n\thost[len] = '\\0';\n\n\t/* extract port, if any */\n\tif ((p = strrchr(host, ':')) != NULL) {\n\t\trport = atoi(p+1);\n\t\tif (rport < 0) {\n\t\t\trport = -rport;\n\t\t} else if (rport < 20) {\n\t\t\trport = 5500 + rport;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\tif (use_openssl) {\n\t\tint vncsock;\n\t\tif (connect_proxy) {\n\t\t\tvncsock = proxy_connect(host, rport);\n\t\t} else {\n\t\t\tvncsock = connect_tcp(host, rport);\n\t\t}\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"reverse_connect: failed to connect to: %s\\n\", str);\n\t\t\treturn 0;\n\t\t}\n\t\tif (prestring != NULL) {\n\t\t\twrite(vncsock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t}\n/* XXX use header */\n#define OPENSSL_REVERSE 6\n\t\tif (!getenv(\"X11VNC_DISABLE_SSL_CLIENT_MODE\")) {\n\t\t\topenssl_init(1);\n\t\t}\n\n\t\tif (first_conn_timeout > 0) {\n\t\t\tset_alarm = 1;\n\t\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\t\talarm(first_conn_timeout);\n\t\t}\n\t\taccept_openssl(OPENSSL_REVERSE, vncsock);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\n\t\topenssl_init(0);\n\t\tfree(host);\n\t\treturn 1;\n\t}\n\n\tif (use_stunnel) {\n\t\tif(strcmp(host, \"localhost\") && strcmp(host, \"127.0.0.1\")) {\n\t\t\tif (!getenv(\"STUNNEL_DISABLE_LOCALHOST\")) {\n\t\t\t\trfbLog(\"reverse_connect: error host not localhost in -stunnel mode.\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unixpw) {\n\t\tint is_localhost = 0, user_disabled_it = 0;\n\n\t\tif(!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\t\tis_localhost = 1;\n\t\t}\n\t\tif (getenv(\"UNIXPW_DISABLE_LOCALHOST\")) {\n\t\t\tuser_disabled_it = 1;\n\t\t}\n\n\t\tif (! is_localhost) {\n\t\t\tif (user_disabled_it) {\n\t\t\t\trfbLog(\"reverse_connect: warning disabling localhost constraint in -unixpw\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"reverse_connect: error not localhost in -unixpw\\n\");\n\t\t\t\tfree(host);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (first_conn_timeout > 0) {\n\t\tset_alarm = 1;\n\t\tsignal(SIGALRM, reverse_connect_timeout);\n#if USE_TIMEOUT_INTERRUPT\n\t\tsiginterrupt(SIGALRM, 1);\n#endif\n\t\trfbLog(\"reverse_connect: using alarm() timeout of %d seconds.\\n\", first_conn_timeout);\n\t\talarm(first_conn_timeout);\n\t}\n\n\tif (connect_proxy != NULL) {\n\t\tint sock = proxy_connect(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\tif (prestring != NULL) {\n\t\t\t\twrite(sock, prestring, prestring_len);\n\t\t\t\tfree(prestring);\n\t\t\t}\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else if (prestring != NULL) {\n\t\tint sock = connect_tcp(host, rport);\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (sock >= 0) {\n\t\t\twrite(sock, prestring, prestring_len);\n\t\t\tfree(prestring);\n\t\t\tcl = create_new_client(sock, 1);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tcl = rfbReverseConnection(screen, host, rport);\n\t\tif (cl == NULL) {\n\t\t\tint sock = connect_tcp(host, rport);\n\t\t\tif (sock >= 0) {\n\t\t\t\tcl = create_new_client(sock, 1);\n\t\t\t}\n\t\t}\n\t\tif (set_alarm) {alarm(0); signal(SIGALRM, SIG_DFL);}\n\t\tif (cl != NULL && use_threads) {\n\t\t\tcl->onHold = FALSE;\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\n\tfree(host);\n\n\tif (ipv6_client_ip_str) {\n\t\tfree(ipv6_client_ip_str);\n\t\tipv6_client_ip_str = NULL;\n\t}\n\n\n\tif (cl == NULL) {\n\t\tif (quiet && connect_or_exit) {\n\t\t\trfbLogEnable(1);\n\t\t}\n\t\trfbLog(\"reverse_connect: %s failed\\n\", str);\n\t\treturn 0;\n\t} else {\n\t\trfbLog(\"reverse_connect: %s/%s OK\\n\", str, cl->host);\n\t\t/* let's see if anyone complains: */\n\t\tif (! getenv(\"X11VNC_REVERSE_CONNECTION_NO_AUTH\")) {\n\t\t\trfbLog(\"reverse_connect: turning on auth for %s\\n\",\n\t\t\t    cl->host);\n\t\t\tcl->reverseConnection = FALSE;\n\t\t}\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "reverse_connect_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2631-2638",
    "snippet": "static void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define USE_TIMEOUT_INTERRUPT 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "0"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\""
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sig: %d, reverse_connect_timeout.\\n\"",
            "sig"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define USE_TIMEOUT_INTERRUPT 0\n\nstatic void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}"
  },
  {
    "function_name": "get_repeater_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2549-2625",
    "snippet": "char *get_repeater_string(char *str, int *len) {\n\tint pren, which = 0;\n\tint prestring_len = 0;\t\n\tchar *prestring = NULL, *ptmp = NULL;\n\tchar *equals = strchr(str, '=');\n\tchar *plus   = strrchr(str, '+');\n\n\t*len = 0;\n\tif (!plus || !equals) {\n\t\treturn NULL;\n\t}\n\n\t*plus = '\\0';\n\tif (strstr(str, \"repeater=\") == str) {\n\t\t/* ultravnc repeater http://www.uvnc.com/addons/repeater.html */\n\t\tprestring_len = 250;\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len, \"%s\", str + strlen(\"repeater=\"));\n\t\twhich = 1;\n\t} else if (strstr(str, \"pre=\") == str) {\n\t\tprestring_len = strlen(str + strlen(\"pre=\"));\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len+1, \"%s\", str + strlen(\"pre=\"));\n\t\twhich = 2;\n\t} else if (sscanf(str, \"pre%d=\", &pren) == 1) {\n\t\tif (pren > 0 && pren <= 16384) {\n\t\t\tprestring_len = pren;\n\t\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\t\tsnprintf(prestring, prestring_len, \"%s\", equals+1);\n\t\t\twhich = 3;\n\t\t}\n\t}\n\tif (ptmp != NULL) {\n\t\tint i, k = 0;\n\t\tchar *p = ptmp;\n\t\tprestring = (char *)calloc(prestring_len+1, 1);\n\t\t/* translate \\n to newline, etc. */\n\t\tfor (i=0; i < prestring_len; i++) {\n\t\t\tif (i < prestring_len-1 && *(p+i) == '\\\\') {\n\t\t\t\tif (*(p+i+1) == 'r') {\n\t\t\t\t\tprestring[k++] = '\\r'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'n') {\n\t\t\t\t\tprestring[k++] = '\\n'; i++;\n\t\t\t\t} else if (*(p+i+1) == 't') {\n\t\t\t\t\tprestring[k++] = '\\t'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'a') {\n\t\t\t\t\tprestring[k++] = '\\a'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'b') {\n\t\t\t\t\tprestring[k++] = '\\b'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'v') {\n\t\t\t\t\tprestring[k++] = '\\v'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'f') {\n\t\t\t\t\tprestring[k++] = '\\f'; i++;\n\t\t\t\t} else if (*(p+i+1) == '\\\\') {\n\t\t\t\t\tprestring[k++] = '\\\\'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'c') {\n\t\t\t\t\tprestring[k++] = ','; i++;\n\t\t\t\t} else {\n\t\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t}\n\t\t}\n\t\tif (which == 2) {\n\t\t\tprestring_len = k;\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"-connect prestring: '%s'\\n\", prestring);\n\t\t}\n\t\tfree(ptmp);\n\t}\n\t*plus = '+';\n\n\t*len = prestring_len;\n\treturn prestring;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "void send_client_info(char *str);",
      "void adjust_grabs(int grab, int quiet);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptmp"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-connect prestring: '%s'\\n\"",
            "prestring"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "prestring_len+1",
            "1"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "prestring",
            "prestring_len",
            "\"%s\"",
            "equals+1"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "prestring_len+1",
            "1"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"pre%d=\"",
            "&pren"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptmp",
            "prestring_len+1",
            "\"%s\"",
            "str + strlen(\"pre=\")"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pre=\""
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "prestring_len+1",
            "1"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str + strlen(\"pre=\")"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pre=\""
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"pre=\""
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptmp",
            "prestring_len",
            "\"%s\"",
            "str + strlen(\"repeater=\")"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"repeater=\""
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "prestring_len+1",
            "1"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"repeater=\""
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'+'"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nstatic rfbClientPtr *client_match(char *str);\n\nchar *get_repeater_string(char *str, int *len) {\n\tint pren, which = 0;\n\tint prestring_len = 0;\t\n\tchar *prestring = NULL, *ptmp = NULL;\n\tchar *equals = strchr(str, '=');\n\tchar *plus   = strrchr(str, '+');\n\n\t*len = 0;\n\tif (!plus || !equals) {\n\t\treturn NULL;\n\t}\n\n\t*plus = '\\0';\n\tif (strstr(str, \"repeater=\") == str) {\n\t\t/* ultravnc repeater http://www.uvnc.com/addons/repeater.html */\n\t\tprestring_len = 250;\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len, \"%s\", str + strlen(\"repeater=\"));\n\t\twhich = 1;\n\t} else if (strstr(str, \"pre=\") == str) {\n\t\tprestring_len = strlen(str + strlen(\"pre=\"));\n\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\tsnprintf(ptmp, prestring_len+1, \"%s\", str + strlen(\"pre=\"));\n\t\twhich = 2;\n\t} else if (sscanf(str, \"pre%d=\", &pren) == 1) {\n\t\tif (pren > 0 && pren <= 16384) {\n\t\t\tprestring_len = pren;\n\t\t\tptmp = (char *) calloc(prestring_len+1, 1);\n\t\t\tsnprintf(prestring, prestring_len, \"%s\", equals+1);\n\t\t\twhich = 3;\n\t\t}\n\t}\n\tif (ptmp != NULL) {\n\t\tint i, k = 0;\n\t\tchar *p = ptmp;\n\t\tprestring = (char *)calloc(prestring_len+1, 1);\n\t\t/* translate \\n to newline, etc. */\n\t\tfor (i=0; i < prestring_len; i++) {\n\t\t\tif (i < prestring_len-1 && *(p+i) == '\\\\') {\n\t\t\t\tif (*(p+i+1) == 'r') {\n\t\t\t\t\tprestring[k++] = '\\r'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'n') {\n\t\t\t\t\tprestring[k++] = '\\n'; i++;\n\t\t\t\t} else if (*(p+i+1) == 't') {\n\t\t\t\t\tprestring[k++] = '\\t'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'a') {\n\t\t\t\t\tprestring[k++] = '\\a'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'b') {\n\t\t\t\t\tprestring[k++] = '\\b'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'v') {\n\t\t\t\t\tprestring[k++] = '\\v'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'f') {\n\t\t\t\t\tprestring[k++] = '\\f'; i++;\n\t\t\t\t} else if (*(p+i+1) == '\\\\') {\n\t\t\t\t\tprestring[k++] = '\\\\'; i++;\n\t\t\t\t} else if (*(p+i+1) == 'c') {\n\t\t\t\t\tprestring[k++] = ','; i++;\n\t\t\t\t} else {\n\t\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprestring[k++] = *(p+i);\n\t\t\t}\n\t\t}\n\t\tif (which == 2) {\n\t\t\tprestring_len = k;\n\t\t}\n\t\tif (!quiet) {\n\t\t\trfbLog(\"-connect prestring: '%s'\\n\", prestring);\n\t\t}\n\t\tfree(ptmp);\n\t}\n\t*plus = '+';\n\n\t*len = prestring_len;\n\treturn prestring;\n}"
  },
  {
    "function_name": "proxy_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2333-2547",
    "snippet": "static int proxy_connect(char *host, int port) {\n\tchar *p, *q, *str;\n\tint i, n, pxy[PXY],pxy_p[PXY];\n\tint psock = -1;\n\tchar *pxy_h[PXY], *pxy_g[PXY];\n\n\tif (! connect_proxy) {\n\t\treturn -1;\n\t}\n\tstr = strdup(connect_proxy);\n\n\tfor (i=0; i<PXY; i++) {\n\t\tpxy[i] = 0;\n\t\tpxy_p[i] = 0;\n\t\tpxy_h[i] = NULL;\n\t\tpxy_g[i] = NULL;\n\t}\n\n\tn = 0;\n\tp = str;\n\twhile (p) {\n\t\tchar *hp, *c, *s = NULL;\n\n\t\tq = strchr(p, ',');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\tif (n==0) fprintf(stderr, \"\\n\");\n\t\trfbLog(\"proxy_connect[%d]: %s\\n\", n+1, p);\n\n\t\tpxy[n] = 0;\n\t\tpxy_p[n] = 0;\n\t\tpxy_h[n] = NULL;\n\t\tpxy_g[n] = NULL;\n\n\t\tif (strstr(p, \"socks://\") == p)\t{\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks4://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks5://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS5;\n\t\t} else if (strstr(p, \"ssh://\") == p) {\n\t\t\tif (n != 0) {\n\t\t\t\trfbLog(\"ssh:// proxy must be the first one\\n\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SSH;\n\t\t} else if (strstr(p, \"http://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else if (strstr(p, \"https://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else {\n\t\t\thp = p;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t}\n\t\tc = strstr(hp, \":\");\n\t\tif (!c && pxy[n] == PXY_SSH) {\n\t\t\tchar *hp2 = (char *) malloc(strlen(hp) + 5);\n\t\t\tsprintf(hp2, \"%s:1\", hp);\n\t\t\thp = hp2;\n\t\t\tc = strstr(hp, \":\");\n\t\t}\n\t\tif (!c) {\n\t\t\tpxy[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tif (pxy[n] == PXY_HTTP) {\n\t\t\ts = strstr(c, \"/\");\n\t\t\tif (s) {\n\t\t\t\tpxy[n] = PXY_GET;\n\t\t\t\tpxy_g[n] = strdup(s);\n\t\t\t\t*s = '\\0';\n\t\t\t}\n\t\t}\n\t\tpxy_p[n] = atoi(c+1);\n\n\t\tif (pxy_p[n] <= 0) {\n\t\t\tpxy[n] = 0;\n\t\t\tpxy_p[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t*c = '\\0';\n\t\tpxy_h[n] = strdup(hp);\n\n\t\tif (++n >= PXY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (q) {\n\t\t\t*q = ',';\n\t\t\tp = q + 1;\n\t\t} else {\n\t\t\tp = NULL;\n\t\t}\n\t}\n\tfree(str);\n\n\tif (!n) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\n\tif (pxy[0] == PXY_SSH) {\n\t\tint rc, len = 0;\n\t\tchar *cmd, *ssh;\n\t\tint sport = find_free_port(7300, 8000);\n\t\tif (getenv(\"SSH\")) {\n\t\t\tssh = getenv(\"SSH\");\n\t\t} else {\n\t\t\tssh = \"ssh\";\n\t\t}\n\t\tlen = 200 + strlen(ssh) + strlen(pxy_h[0]) + strlen(host);\n\t\tcmd = (char *) malloc(len);\n\t\tif (n == 1) {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, host, port, pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, host, port, pxy_h[0]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t}\n\t\t}\n\t\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tclose_exec_fds();\n\t\tfprintf(stderr, \"\\n\");\n\t\trfbLog(\"running: %s\\n\", cmd);\n\t\trc = system(cmd);\n\t\tfree(cmd);\n\t\tif (rc != 0) {\n\t\t\tpsock = -1;\n\t\t\tgoto pxy_clean;\n\t\t}\n\t\tpsock = connect_tcp(\"localhost\", sport);\n\n\t} else {\n\t\tpsock = connect_tcp(pxy_h[0], pxy_p[0]);\n\t}\n\n\tif (psock < 0) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\trfbLog(\"opened socket to proxy: %s:%d\\n\", pxy_h[0], pxy_p[0]);\n\n\tif (n >= 2) {\n\t\tif (! pconnect(psock, pxy_h[1], pxy_p[1], pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\n\t\tif (n >= 3) {\n\t\t\tif (! pconnect(psock, pxy_h[2], pxy_p[2], pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\tif (! pconnect(psock, host, port, pxy[2], pxy_g[2], pxy_h[2], pxy_p[2])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\t\n\t\t} else {\n\t\t\tif (! pconnect(psock, host, port, pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t}\n\t} else {\n\t\tif (! pconnect(psock, host, port, pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t}\n\n\tpxy_clean:\n\tfor (i=0; i < PXY; i++) {\n\t\tif (pxy_h[i] != NULL) {\n\t\t\tfree(pxy_h[i]);\n\t\t}\n\t\tif (pxy_g[i] != NULL) {\n\t\t\tfree(pxy_g[i]);\n\t\t}\n\t}\n\n\treturn psock;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define PXY 3",
      "#define PXY_SSH\t\t5",
      "#define PXY_SOCKS5\t4",
      "#define PXY_SOCKS\t3",
      "#define PXY_GET\t\t2",
      "#define PXY_HTTP\t1"
    ],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "int cmd_ok(char *cmd);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);",
      "static int action_match(char *action, int rc);",
      "static int pxy_get_sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pxy_g[i]"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "psock"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pconnect",
          "args": [
            "psock",
            "host",
            "port",
            "pxy[0]",
            "pxy_g[0]",
            "pxy_h[0]",
            "pxy_p[0]"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "pconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2206-2331",
          "snippet": "static int pconnect(int psock, char *host, int port, int type, char *http_path, char *gethost, int getport) {\n\tchar reply[4096];\n\tint i, ok, len;\n\tchar *req;\n\n\tpxy_get_sock = -1;\n\n\tif (type == PXY_SOCKS) {\n\t\treturn socks_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SOCKS5) {\n\t\treturn socks5_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SSH) {\n\t\treturn 1;\n\t}\n\n\tlen = strlen(\"CONNECT \") + strlen(host);\n\tif (type == PXY_GET) {\n\t\tlen += strlen(http_path) + strlen(gethost);\n\t\tlen += strlen(\"host=\") + 1 + strlen(\"port=\") + 1 + 1;\n\t}\n\tlen += 1 + 20 + strlen(\"HTTP/1.1\\r\\n\") + 1;\n\n\treq = (char *)malloc(len);\n\n\tif (type == PXY_GET) {\n\t\tint noquery = 0;\n\t\tchar *t = strstr(http_path, \"__END__\");\n\t\tif (t) {\n\t\t\tnoquery = 1;\n\t\t\t*t = '\\0';\n\t\t}\n\n\t\tif (noquery) {\n\t\t\tsprintf(req, \"GET %s HTTP/1.1\\r\\n\", http_path);\n\t\t} else {\n\t\t\tsprintf(req, \"GET %shost=%s&port=%d HTTP/1.1\\r\\n\", http_path, host, port);\n\t\t}\n\t} else {\n\t\tsprintf(req, \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\t}\n\trfbLog(\"http proxy: %s\", req);\n\twrite(psock, req, strlen(req));\n\n\tif (type == PXY_GET) {\n\t\tchar *t = \"Connection: close\\r\\n\";\n\t\twrite(psock, t, strlen(t));\n\t}\n\n\tif (type == PXY_GET) {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", gethost, getport);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", gethost, getport);\n\t} else {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", host, port);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", host, port);\n\t}\n\n\twrite(psock, req, strlen(req));\n\n\tok = 0;\n\treply[0] = '\\0';\n\n\tfor (i=0; i<4096; i++) {\n\t\tint n;\n\t\treq[0] = req[1] = '\\0';\n\t\tn = read(psock, req, 1);\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(reply, req);\n\t\tif (strstr(reply, \"\\r\\n\\r\\n\")) {\n\t\t\tif (strstr(reply, \"HTTP/\") == reply) {\n\t\t\t\tchar *q = strchr(reply, ' ');\n\t\t\t\tif (q) {\n\t\t\t\t\tq++;\n\t\t\t\t\tif (q[0] == '2' && q[1] == '0' && q[2] == '0' && q[3] == ' ') {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type == PXY_GET) {\n\t\tchar *t1 = strstr(reply, \"VNC-IP-Port: \");\n\t\tchar *t2 = strstr(reply, \"VNC-Host-Port: \");\n\t\tchar *s, *newhost = NULL;\n\t\tint newport = 0;\n\t\tfprintf(stderr, \"%s\\n\", reply);\n\t\tif (t1) {\n\t\t\tt1 += strlen(\"VNC-IP-Port: \");\n\t\t\ts = strstr(t1, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t1);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t} else if (t2) {\n\t\t\tt2 += strlen(\"VNC-Host-Port: \");\n\t\t\ts = strstr(t2, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t2);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t}\n\t\tif (newhost && newport > 0) {\n\t\t\trfbLog(\"proxy GET reconnect to: %s:%d\\n\", newhost, newport);\n\t\t\tpxy_get_sock = connect_tcp(newhost, newport);\n\t\t}\n\t}\n\tfree(req);\n\n\treturn ok;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define PXY_SSH\t\t5",
            "#define PXY_SOCKS5\t4",
            "#define PXY_SOCKS\t3",
            "#define PXY_GET\t\t2"
          ],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "static int pxy_get_sock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define PXY_SSH\t\t5\n#define PXY_SOCKS5\t4\n#define PXY_SOCKS\t3\n#define PXY_GET\t\t2\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nstatic int pxy_get_sock;\n\nstatic int pconnect(int psock, char *host, int port, int type, char *http_path, char *gethost, int getport) {\n\tchar reply[4096];\n\tint i, ok, len;\n\tchar *req;\n\n\tpxy_get_sock = -1;\n\n\tif (type == PXY_SOCKS) {\n\t\treturn socks_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SOCKS5) {\n\t\treturn socks5_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SSH) {\n\t\treturn 1;\n\t}\n\n\tlen = strlen(\"CONNECT \") + strlen(host);\n\tif (type == PXY_GET) {\n\t\tlen += strlen(http_path) + strlen(gethost);\n\t\tlen += strlen(\"host=\") + 1 + strlen(\"port=\") + 1 + 1;\n\t}\n\tlen += 1 + 20 + strlen(\"HTTP/1.1\\r\\n\") + 1;\n\n\treq = (char *)malloc(len);\n\n\tif (type == PXY_GET) {\n\t\tint noquery = 0;\n\t\tchar *t = strstr(http_path, \"__END__\");\n\t\tif (t) {\n\t\t\tnoquery = 1;\n\t\t\t*t = '\\0';\n\t\t}\n\n\t\tif (noquery) {\n\t\t\tsprintf(req, \"GET %s HTTP/1.1\\r\\n\", http_path);\n\t\t} else {\n\t\t\tsprintf(req, \"GET %shost=%s&port=%d HTTP/1.1\\r\\n\", http_path, host, port);\n\t\t}\n\t} else {\n\t\tsprintf(req, \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\t}\n\trfbLog(\"http proxy: %s\", req);\n\twrite(psock, req, strlen(req));\n\n\tif (type == PXY_GET) {\n\t\tchar *t = \"Connection: close\\r\\n\";\n\t\twrite(psock, t, strlen(t));\n\t}\n\n\tif (type == PXY_GET) {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", gethost, getport);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", gethost, getport);\n\t} else {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", host, port);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", host, port);\n\t}\n\n\twrite(psock, req, strlen(req));\n\n\tok = 0;\n\treply[0] = '\\0';\n\n\tfor (i=0; i<4096; i++) {\n\t\tint n;\n\t\treq[0] = req[1] = '\\0';\n\t\tn = read(psock, req, 1);\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(reply, req);\n\t\tif (strstr(reply, \"\\r\\n\\r\\n\")) {\n\t\t\tif (strstr(reply, \"HTTP/\") == reply) {\n\t\t\t\tchar *q = strchr(reply, ' ');\n\t\t\t\tif (q) {\n\t\t\t\t\tq++;\n\t\t\t\t\tif (q[0] == '2' && q[1] == '0' && q[2] == '0' && q[3] == ' ') {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type == PXY_GET) {\n\t\tchar *t1 = strstr(reply, \"VNC-IP-Port: \");\n\t\tchar *t2 = strstr(reply, \"VNC-Host-Port: \");\n\t\tchar *s, *newhost = NULL;\n\t\tint newport = 0;\n\t\tfprintf(stderr, \"%s\\n\", reply);\n\t\tif (t1) {\n\t\t\tt1 += strlen(\"VNC-IP-Port: \");\n\t\t\ts = strstr(t1, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t1);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t} else if (t2) {\n\t\t\tt2 += strlen(\"VNC-Host-Port: \");\n\t\t\ts = strstr(t2, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t2);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t}\n\t\tif (newhost && newport > 0) {\n\t\t\trfbLog(\"proxy GET reconnect to: %s:%d\\n\", newhost, newport);\n\t\t\tpxy_get_sock = connect_tcp(newhost, newport);\n\t\t}\n\t}\n\tfree(req);\n\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"opened socket to proxy: %s:%d\\n\"",
            "pxy_h[0]",
            "pxy_p[0]"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "pxy_h[0]",
            "pxy_p[0]"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running: %s\\n\"",
            "cmd"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   exiting.\\n\""
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "cmd"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"ssh\""
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\"",
            "ssh",
            "pxy_p[0]",
            "sport",
            "pxy_h[1]",
            "pxy_p[1]",
            "pxy_h[0]"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\"",
            "ssh",
            "sport",
            "pxy_h[1]",
            "pxy_p[1]",
            "pxy_h[0]"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\"",
            "ssh",
            "pxy_p[0]",
            "sport",
            "host",
            "port",
            "pxy_h[0]"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\"",
            "ssh",
            "sport",
            "host",
            "port",
            "pxy_h[0]"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pxy_h[0]"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ssh"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSH\""
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSH\""
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_free_port",
          "args": [
            "7300",
            "8000"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_port6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "431-447",
          "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int find_free_port(int start, int end);",
            "int find_free_port6(int start, int end);",
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "hp"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "c+1"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "s"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "c",
            "\"/\""
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "hp",
            "\":\""
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "hp2",
            "\"%s:1\"",
            "hp"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(hp) + 5"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hp"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "hp",
            "\":\""
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"://\""
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"https://\""
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"://\""
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"http://\""
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"://\""
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ssh:// proxy must be the first one\\n\""
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"ssh://\""
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"://\""
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"socks5://\""
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"://\""
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"socks4://\""
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"://\""
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"socks://\""
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"proxy_connect[%d]: %s\\n\"",
            "n+1",
            "p"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "','"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "connect_proxy"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define PXY 3\n#define PXY_SSH\t\t5\n#define PXY_SOCKS5\t4\n#define PXY_SOCKS\t3\n#define PXY_GET\t\t2\n#define PXY_HTTP\t1\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\nstatic int action_match(char *action, int rc);\nstatic int pxy_get_sock;\n\nstatic int proxy_connect(char *host, int port) {\n\tchar *p, *q, *str;\n\tint i, n, pxy[PXY],pxy_p[PXY];\n\tint psock = -1;\n\tchar *pxy_h[PXY], *pxy_g[PXY];\n\n\tif (! connect_proxy) {\n\t\treturn -1;\n\t}\n\tstr = strdup(connect_proxy);\n\n\tfor (i=0; i<PXY; i++) {\n\t\tpxy[i] = 0;\n\t\tpxy_p[i] = 0;\n\t\tpxy_h[i] = NULL;\n\t\tpxy_g[i] = NULL;\n\t}\n\n\tn = 0;\n\tp = str;\n\twhile (p) {\n\t\tchar *hp, *c, *s = NULL;\n\n\t\tq = strchr(p, ',');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\tif (n==0) fprintf(stderr, \"\\n\");\n\t\trfbLog(\"proxy_connect[%d]: %s\\n\", n+1, p);\n\n\t\tpxy[n] = 0;\n\t\tpxy_p[n] = 0;\n\t\tpxy_h[n] = NULL;\n\t\tpxy_g[n] = NULL;\n\n\t\tif (strstr(p, \"socks://\") == p)\t{\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks4://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS;\n\t\t} else if (strstr(p, \"socks5://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SOCKS5;\n\t\t} else if (strstr(p, \"ssh://\") == p) {\n\t\t\tif (n != 0) {\n\t\t\t\trfbLog(\"ssh:// proxy must be the first one\\n\");\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_SSH;\n\t\t} else if (strstr(p, \"http://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else if (strstr(p, \"https://\") == p) {\n\t\t\thp = strstr(p, \"://\") + 3;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t} else {\n\t\t\thp = p;\n\t\t\tpxy[n] = PXY_HTTP;\n\t\t}\n\t\tc = strstr(hp, \":\");\n\t\tif (!c && pxy[n] == PXY_SSH) {\n\t\t\tchar *hp2 = (char *) malloc(strlen(hp) + 5);\n\t\t\tsprintf(hp2, \"%s:1\", hp);\n\t\t\thp = hp2;\n\t\t\tc = strstr(hp, \":\");\n\t\t}\n\t\tif (!c) {\n\t\t\tpxy[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tif (pxy[n] == PXY_HTTP) {\n\t\t\ts = strstr(c, \"/\");\n\t\t\tif (s) {\n\t\t\t\tpxy[n] = PXY_GET;\n\t\t\t\tpxy_g[n] = strdup(s);\n\t\t\t\t*s = '\\0';\n\t\t\t}\n\t\t}\n\t\tpxy_p[n] = atoi(c+1);\n\n\t\tif (pxy_p[n] <= 0) {\n\t\t\tpxy[n] = 0;\n\t\t\tpxy_p[n] = 0;\n\t\t\tif (q) {\n\t\t\t\t*q = ',';\n\t\t\t\tp = q + 1;\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t*c = '\\0';\n\t\tpxy_h[n] = strdup(hp);\n\n\t\tif (++n >= PXY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (q) {\n\t\t\t*q = ',';\n\t\t\tp = q + 1;\n\t\t} else {\n\t\t\tp = NULL;\n\t\t}\n\t}\n\tfree(str);\n\n\tif (!n) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\n\tif (pxy[0] == PXY_SSH) {\n\t\tint rc, len = 0;\n\t\tchar *cmd, *ssh;\n\t\tint sport = find_free_port(7300, 8000);\n\t\tif (getenv(\"SSH\")) {\n\t\t\tssh = getenv(\"SSH\");\n\t\t} else {\n\t\t\tssh = \"ssh\";\n\t\t}\n\t\tlen = 200 + strlen(ssh) + strlen(pxy_h[0]) + strlen(host);\n\t\tcmd = (char *) malloc(len);\n\t\tif (n == 1) {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, host, port, pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, host, port, pxy_h[0]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pxy_p[0] <= 1) {\n\t\t\t\tsprintf(cmd, \"%s -f       -L '%d:%s:%d' '%s' 'sleep 20'\", ssh,           sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s -f -p %d -L '%d:%s:%d' '%s' 'sleep 20'\", ssh, pxy_p[0], sport, pxy_h[1], pxy_p[1], pxy_h[0]);\n\t\t\t}\n\t\t}\n\t\tif (no_external_cmds || !cmd_ok(\"ssh\")) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\t\trfbLog(\"   exiting.\\n\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tclose_exec_fds();\n\t\tfprintf(stderr, \"\\n\");\n\t\trfbLog(\"running: %s\\n\", cmd);\n\t\trc = system(cmd);\n\t\tfree(cmd);\n\t\tif (rc != 0) {\n\t\t\tpsock = -1;\n\t\t\tgoto pxy_clean;\n\t\t}\n\t\tpsock = connect_tcp(\"localhost\", sport);\n\n\t} else {\n\t\tpsock = connect_tcp(pxy_h[0], pxy_p[0]);\n\t}\n\n\tif (psock < 0) {\n\t\tpsock = -1;\n\t\tgoto pxy_clean;\n\t}\n\trfbLog(\"opened socket to proxy: %s:%d\\n\", pxy_h[0], pxy_p[0]);\n\n\tif (n >= 2) {\n\t\tif (! pconnect(psock, pxy_h[1], pxy_p[1], pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\n\t\tif (n >= 3) {\n\t\t\tif (! pconnect(psock, pxy_h[2], pxy_p[2], pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\tif (! pconnect(psock, host, port, pxy[2], pxy_g[2], pxy_h[2], pxy_p[2])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t\t\n\t\t} else {\n\t\t\tif (! pconnect(psock, host, port, pxy[1], pxy_g[1], pxy_h[1], pxy_p[1])) {\n\t\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t\t}\n\t\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t\t}\n\t} else {\n\t\tif (! pconnect(psock, host, port, pxy[0], pxy_g[0], pxy_h[0], pxy_p[0])) {\n\t\t\tclose(psock); psock = -1; goto pxy_clean;\n\t\t}\n\t\tif (pxy_get_sock >= 0) {close(psock); psock = pxy_get_sock;}\n\t}\n\n\tpxy_clean:\n\tfor (i=0; i < PXY; i++) {\n\t\tif (pxy_h[i] != NULL) {\n\t\t\tfree(pxy_h[i]);\n\t\t}\n\t\tif (pxy_g[i] != NULL) {\n\t\t\tfree(pxy_g[i]);\n\t\t}\n\t}\n\n\treturn psock;\n}"
  },
  {
    "function_name": "pconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2206-2331",
    "snippet": "static int pconnect(int psock, char *host, int port, int type, char *http_path, char *gethost, int getport) {\n\tchar reply[4096];\n\tint i, ok, len;\n\tchar *req;\n\n\tpxy_get_sock = -1;\n\n\tif (type == PXY_SOCKS) {\n\t\treturn socks_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SOCKS5) {\n\t\treturn socks5_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SSH) {\n\t\treturn 1;\n\t}\n\n\tlen = strlen(\"CONNECT \") + strlen(host);\n\tif (type == PXY_GET) {\n\t\tlen += strlen(http_path) + strlen(gethost);\n\t\tlen += strlen(\"host=\") + 1 + strlen(\"port=\") + 1 + 1;\n\t}\n\tlen += 1 + 20 + strlen(\"HTTP/1.1\\r\\n\") + 1;\n\n\treq = (char *)malloc(len);\n\n\tif (type == PXY_GET) {\n\t\tint noquery = 0;\n\t\tchar *t = strstr(http_path, \"__END__\");\n\t\tif (t) {\n\t\t\tnoquery = 1;\n\t\t\t*t = '\\0';\n\t\t}\n\n\t\tif (noquery) {\n\t\t\tsprintf(req, \"GET %s HTTP/1.1\\r\\n\", http_path);\n\t\t} else {\n\t\t\tsprintf(req, \"GET %shost=%s&port=%d HTTP/1.1\\r\\n\", http_path, host, port);\n\t\t}\n\t} else {\n\t\tsprintf(req, \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\t}\n\trfbLog(\"http proxy: %s\", req);\n\twrite(psock, req, strlen(req));\n\n\tif (type == PXY_GET) {\n\t\tchar *t = \"Connection: close\\r\\n\";\n\t\twrite(psock, t, strlen(t));\n\t}\n\n\tif (type == PXY_GET) {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", gethost, getport);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", gethost, getport);\n\t} else {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", host, port);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", host, port);\n\t}\n\n\twrite(psock, req, strlen(req));\n\n\tok = 0;\n\treply[0] = '\\0';\n\n\tfor (i=0; i<4096; i++) {\n\t\tint n;\n\t\treq[0] = req[1] = '\\0';\n\t\tn = read(psock, req, 1);\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(reply, req);\n\t\tif (strstr(reply, \"\\r\\n\\r\\n\")) {\n\t\t\tif (strstr(reply, \"HTTP/\") == reply) {\n\t\t\t\tchar *q = strchr(reply, ' ');\n\t\t\t\tif (q) {\n\t\t\t\t\tq++;\n\t\t\t\t\tif (q[0] == '2' && q[1] == '0' && q[2] == '0' && q[3] == ' ') {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type == PXY_GET) {\n\t\tchar *t1 = strstr(reply, \"VNC-IP-Port: \");\n\t\tchar *t2 = strstr(reply, \"VNC-Host-Port: \");\n\t\tchar *s, *newhost = NULL;\n\t\tint newport = 0;\n\t\tfprintf(stderr, \"%s\\n\", reply);\n\t\tif (t1) {\n\t\t\tt1 += strlen(\"VNC-IP-Port: \");\n\t\t\ts = strstr(t1, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t1);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t} else if (t2) {\n\t\t\tt2 += strlen(\"VNC-Host-Port: \");\n\t\t\ts = strstr(t2, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t2);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t}\n\t\tif (newhost && newport > 0) {\n\t\t\trfbLog(\"proxy GET reconnect to: %s:%d\\n\", newhost, newport);\n\t\t\tpxy_get_sock = connect_tcp(newhost, newport);\n\t\t}\n\t}\n\tfree(req);\n\n\treturn ok;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define PXY_SSH\t\t5",
      "#define PXY_SOCKS5\t4",
      "#define PXY_SOCKS\t3",
      "#define PXY_GET\t\t2"
    ],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "static int pxy_get_sock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "req"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "newhost",
            "newport"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"proxy GET reconnect to: %s:%d\\n\"",
            "newhost",
            "newport"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s+1"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "t2"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t2",
            "\":\""
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"VNC-Host-Port: \""
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s+1"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "t1"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "t1",
            "\":\""
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"VNC-IP-Port: \""
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "reply"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "reply",
            "\"VNC-Host-Port: \""
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "reply",
            "\"VNC-IP-Port: \""
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "reply",
            "' '"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "reply",
            "\"HTTP/\""
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "reply",
            "\"\\r\\n\\r\\n\""
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "reply",
            "req"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "psock",
            "req",
            "1"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "psock",
            "req",
            "strlen(req)"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "req"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "req",
            "\"Host: %s:%d\\r\\n\\r\\n\"",
            "host",
            "port"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http proxy: %s\"",
            "req"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "req",
            "\"Host: %s:%d\\r\\n\"",
            "host",
            "port"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "req",
            "\"Host: %s:%d\\r\\n\\r\\n\"",
            "gethost",
            "getport"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http proxy: %s\"",
            "req"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "req",
            "\"Host: %s:%d\\r\\n\"",
            "gethost",
            "getport"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "t"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "req"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"http proxy: %s\"",
            "req"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "req",
            "\"CONNECT %s:%d HTTP/1.1\\r\\n\"",
            "host",
            "port"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "req",
            "\"GET %shost=%s&port=%d HTTP/1.1\\r\\n\"",
            "http_path",
            "host",
            "port"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "req",
            "\"GET %s HTTP/1.1\\r\\n\"",
            "http_path"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "http_path",
            "\"__END__\""
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"HTTP/1.1\\r\\n\""
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"port=\""
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"host=\""
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gethost"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "http_path"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"CONNECT \""
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socks5_proxy",
          "args": [
            "host",
            "port",
            "psock"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "socks5_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2011-2100",
          "snippet": "static int socks5_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[512];\n\tint len, n, i, j = 0;\n\n\tmemset(buf, 0, 512);\n\tmemset(reply, 0, 512);\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\n\twrite(sock, buf, 3);\n\n\tn = read(sock, buf, 2);\n\n\tif (n != 2) {\n\t\trfbLog(\"socks5_proxy: read error: %d\\n\", n);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\tif (buf[0] != 0x5 || buf[1] != 0x0) {\n\t\trfbLog(\"socks5_proxy: handshake error: %d %d\\n\", (int) buf[0], (int) buf[1]);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\tbuf[3] = 0x3;\n\n\tbuf[4] = (unsigned char) strlen(host);\n\tstrcat((char *) buf+5, host); \n\n\tlen = 5 + strlen(host);\n\n\tbuf[len]   = (unsigned char) (port >> 8);\n\tbuf[len+1] = (unsigned char) (port & 0xff);\n\n\twrite(sock, buf, len+2);\n\n\tfor (i=0; i<4; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (reply[3] == 0x1) {\n\t\tread(sock, reply+4, 4 + 2);\n\t} else if (reply[3] == 0x3) {\n\t\tn = read(sock, tmp, 1);\n\t\treply[4] = tmp[0];\n\t\tread(sock, reply+5, (int) reply[4] + 2);\n\t} else if (reply[3] == 0x4) {\n\t\tread(sock, reply+4, 16 + 2);\n\t}\n\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x5 && reply[1] == 0x0 && reply[2] == 0x0) {\n\t\trfbLog(\"SOCKS5 connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\treturn 1;\n\t} else {\n\t\trfbLog(\"SOCKS5 error to %s:%d sock=%d\\n\", host, port, sock);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\n\nstatic int socks5_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[512];\n\tint len, n, i, j = 0;\n\n\tmemset(buf, 0, 512);\n\tmemset(reply, 0, 512);\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\n\twrite(sock, buf, 3);\n\n\tn = read(sock, buf, 2);\n\n\tif (n != 2) {\n\t\trfbLog(\"socks5_proxy: read error: %d\\n\", n);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\tif (buf[0] != 0x5 || buf[1] != 0x0) {\n\t\trfbLog(\"socks5_proxy: handshake error: %d %d\\n\", (int) buf[0], (int) buf[1]);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\tbuf[3] = 0x3;\n\n\tbuf[4] = (unsigned char) strlen(host);\n\tstrcat((char *) buf+5, host); \n\n\tlen = 5 + strlen(host);\n\n\tbuf[len]   = (unsigned char) (port >> 8);\n\tbuf[len+1] = (unsigned char) (port & 0xff);\n\n\twrite(sock, buf, len+2);\n\n\tfor (i=0; i<4; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (reply[3] == 0x1) {\n\t\tread(sock, reply+4, 4 + 2);\n\t} else if (reply[3] == 0x3) {\n\t\tn = read(sock, tmp, 1);\n\t\treply[4] = tmp[0];\n\t\tread(sock, reply+5, (int) reply[4] + 2);\n\t} else if (reply[3] == 0x4) {\n\t\tread(sock, reply+4, 16 + 2);\n\t}\n\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x5 && reply[1] == 0x0 && reply[2] == 0x0) {\n\t\trfbLog(\"SOCKS5 connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\treturn 1;\n\t} else {\n\t\trfbLog(\"SOCKS5 error to %s:%d sock=%d\\n\", host, port, sock);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "socks_proxy",
          "args": [
            "host",
            "port",
            "psock"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "socks_proxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2102-2195",
          "snippet": "static int socks_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[16];\n\tint socks4a = 0, len, i, j = 0, d1, d2, d3, d4;\n\n\tmemset(buf, 0, 512);\n\n\tbuf[0] = 0x4;\n\tbuf[1] = 0x1;\n\tbuf[2] = (unsigned char) (port >> 8);\n\tbuf[3] = (unsigned char) (port & 0xff);\n\n\n\tif (strlen(host) > 256)  {\n\t\trfbLog(\"socks_proxy: hostname too long: %s\\n\", host);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\tbuf[4] = 127;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t} else if (sscanf(host, \"%d.%d.%d.%d\", &d1, &d2, &d3, &d4) == 4) {\n\t\tbuf[4] = (unsigned char) d1;\n\t\tbuf[5] = (unsigned char) d2;\n\t\tbuf[6] = (unsigned char) d3;\n\t\tbuf[7] = (unsigned char) d4;\n\t} else {\n\t\tbuf[4] = 0x0;\n\t\tbuf[5] = 0x0;\n\t\tbuf[6] = 0x0;\n\t\tbuf[7] = 0x3;\n\t\tsocks4a = 1;\n\t}\n\tlen = 8;\n\n\tstrcat((char *)buf+8, \"nobody\"); \n\tlen += strlen(\"nobody\") + 1;\n\n\tif (socks4a) {\n\t\tstrcat((char *) buf+8+strlen(\"nobody\") + 1, host);\n\t\tlen += strlen(host) + 1;\n\t}\n\n\twrite(sock, buf, len);\n\n\tfor (i=0; i<8; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x0 && reply[1] == 0x5a) {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\n\nstatic int socks_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[16];\n\tint socks4a = 0, len, i, j = 0, d1, d2, d3, d4;\n\n\tmemset(buf, 0, 512);\n\n\tbuf[0] = 0x4;\n\tbuf[1] = 0x1;\n\tbuf[2] = (unsigned char) (port >> 8);\n\tbuf[3] = (unsigned char) (port & 0xff);\n\n\n\tif (strlen(host) > 256)  {\n\t\trfbLog(\"socks_proxy: hostname too long: %s\\n\", host);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\tbuf[4] = 127;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t} else if (sscanf(host, \"%d.%d.%d.%d\", &d1, &d2, &d3, &d4) == 4) {\n\t\tbuf[4] = (unsigned char) d1;\n\t\tbuf[5] = (unsigned char) d2;\n\t\tbuf[6] = (unsigned char) d3;\n\t\tbuf[7] = (unsigned char) d4;\n\t} else {\n\t\tbuf[4] = 0x0;\n\t\tbuf[5] = 0x0;\n\t\tbuf[6] = 0x0;\n\t\tbuf[7] = 0x3;\n\t\tsocks4a = 1;\n\t}\n\tlen = 8;\n\n\tstrcat((char *)buf+8, \"nobody\"); \n\tlen += strlen(\"nobody\") + 1;\n\n\tif (socks4a) {\n\t\tstrcat((char *) buf+8+strlen(\"nobody\") + 1, host);\n\t\tlen += strlen(host) + 1;\n\t}\n\n\twrite(sock, buf, len);\n\n\tfor (i=0; i<8; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x0 && reply[1] == 0x5a) {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define PXY_SSH\t\t5\n#define PXY_SOCKS5\t4\n#define PXY_SOCKS\t3\n#define PXY_GET\t\t2\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nstatic int pxy_get_sock;\n\nstatic int pconnect(int psock, char *host, int port, int type, char *http_path, char *gethost, int getport) {\n\tchar reply[4096];\n\tint i, ok, len;\n\tchar *req;\n\n\tpxy_get_sock = -1;\n\n\tif (type == PXY_SOCKS) {\n\t\treturn socks_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SOCKS5) {\n\t\treturn socks5_proxy(host, port, psock);\n\t}\n\tif (type == PXY_SSH) {\n\t\treturn 1;\n\t}\n\n\tlen = strlen(\"CONNECT \") + strlen(host);\n\tif (type == PXY_GET) {\n\t\tlen += strlen(http_path) + strlen(gethost);\n\t\tlen += strlen(\"host=\") + 1 + strlen(\"port=\") + 1 + 1;\n\t}\n\tlen += 1 + 20 + strlen(\"HTTP/1.1\\r\\n\") + 1;\n\n\treq = (char *)malloc(len);\n\n\tif (type == PXY_GET) {\n\t\tint noquery = 0;\n\t\tchar *t = strstr(http_path, \"__END__\");\n\t\tif (t) {\n\t\t\tnoquery = 1;\n\t\t\t*t = '\\0';\n\t\t}\n\n\t\tif (noquery) {\n\t\t\tsprintf(req, \"GET %s HTTP/1.1\\r\\n\", http_path);\n\t\t} else {\n\t\t\tsprintf(req, \"GET %shost=%s&port=%d HTTP/1.1\\r\\n\", http_path, host, port);\n\t\t}\n\t} else {\n\t\tsprintf(req, \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\t}\n\trfbLog(\"http proxy: %s\", req);\n\twrite(psock, req, strlen(req));\n\n\tif (type == PXY_GET) {\n\t\tchar *t = \"Connection: close\\r\\n\";\n\t\twrite(psock, t, strlen(t));\n\t}\n\n\tif (type == PXY_GET) {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", gethost, getport);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", gethost, getport);\n\t} else {\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\", host, port);\n\t\trfbLog(\"http proxy: %s\", req);\n\t\tsprintf(req, \"Host: %s:%d\\r\\n\\r\\n\", host, port);\n\t}\n\n\twrite(psock, req, strlen(req));\n\n\tok = 0;\n\treply[0] = '\\0';\n\n\tfor (i=0; i<4096; i++) {\n\t\tint n;\n\t\treq[0] = req[1] = '\\0';\n\t\tn = read(psock, req, 1);\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(reply, req);\n\t\tif (strstr(reply, \"\\r\\n\\r\\n\")) {\n\t\t\tif (strstr(reply, \"HTTP/\") == reply) {\n\t\t\t\tchar *q = strchr(reply, ' ');\n\t\t\t\tif (q) {\n\t\t\t\t\tq++;\n\t\t\t\t\tif (q[0] == '2' && q[1] == '0' && q[2] == '0' && q[3] == ' ') {\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (type == PXY_GET) {\n\t\tchar *t1 = strstr(reply, \"VNC-IP-Port: \");\n\t\tchar *t2 = strstr(reply, \"VNC-Host-Port: \");\n\t\tchar *s, *newhost = NULL;\n\t\tint newport = 0;\n\t\tfprintf(stderr, \"%s\\n\", reply);\n\t\tif (t1) {\n\t\t\tt1 += strlen(\"VNC-IP-Port: \");\n\t\t\ts = strstr(t1, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t1);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t} else if (t2) {\n\t\t\tt2 += strlen(\"VNC-Host-Port: \");\n\t\t\ts = strstr(t2, \":\");\n\t\t\tif (s) {\n\t\t\t\t*s = '\\0';\n\t\t\t\tnewhost = strdup(t2);\n\t\t\t\tnewport = atoi(s+1);\n\t\t\t}\n\t\t}\n\t\tif (newhost && newport > 0) {\n\t\t\trfbLog(\"proxy GET reconnect to: %s:%d\\n\", newhost, newport);\n\t\t\tpxy_get_sock = connect_tcp(newhost, newport);\n\t\t}\n\t}\n\tfree(req);\n\n\treturn ok;\n}"
  },
  {
    "function_name": "socks_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2102-2195",
    "snippet": "static int socks_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[16];\n\tint socks4a = 0, len, i, j = 0, d1, d2, d3, d4;\n\n\tmemset(buf, 0, 512);\n\n\tbuf[0] = 0x4;\n\tbuf[1] = 0x1;\n\tbuf[2] = (unsigned char) (port >> 8);\n\tbuf[3] = (unsigned char) (port & 0xff);\n\n\n\tif (strlen(host) > 256)  {\n\t\trfbLog(\"socks_proxy: hostname too long: %s\\n\", host);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\tbuf[4] = 127;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t} else if (sscanf(host, \"%d.%d.%d.%d\", &d1, &d2, &d3, &d4) == 4) {\n\t\tbuf[4] = (unsigned char) d1;\n\t\tbuf[5] = (unsigned char) d2;\n\t\tbuf[6] = (unsigned char) d3;\n\t\tbuf[7] = (unsigned char) d4;\n\t} else {\n\t\tbuf[4] = 0x0;\n\t\tbuf[5] = 0x0;\n\t\tbuf[6] = 0x0;\n\t\tbuf[7] = 0x3;\n\t\tsocks4a = 1;\n\t}\n\tlen = 8;\n\n\tstrcat((char *)buf+8, \"nobody\"); \n\tlen += strlen(\"nobody\") + 1;\n\n\tif (socks4a) {\n\t\tstrcat((char *) buf+8+strlen(\"nobody\") + 1, host);\n\t\tlen += strlen(host) + 1;\n\t}\n\n\twrite(sock, buf, len);\n\n\tfor (i=0; i<8; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x0 && reply[1] == 0x5a) {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SOCKS4  error to %s:%d sock=%d\\n\"",
            "host",
            "port",
            "sock"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SOCKS4a error to %s:%d sock=%d\\n\"",
            "host",
            "port",
            "sock"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SOCKS4  connect OK to %s:%d sock=%d\\n\"",
            "host",
            "port",
            "sock"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SOCKS4a connect OK to %s:%d sock=%d\\n\"",
            "host",
            "port",
            "sock"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"r[%d]: %d\\n\"",
            "i",
            "(int) reply[i]"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"b[%d]: %d\\n\"",
            "i",
            "(int) buf[i]"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock",
            "tmp",
            "1"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "(char *) buf+8+strlen(\"nobody\") + 1",
            "host"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"nobody\""
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"nobody\""
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "(char *)buf+8",
            "\"nobody\""
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "host",
            "\"%d.%d.%d.%d\"",
            "&d1",
            "&d2",
            "&d3",
            "&d4"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "host",
            "\"127.0.0.1\""
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "host",
            "\"localhost\""
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"socks_proxy: hostname too long: %s\\n\"",
            "host"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "512"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\n\nstatic int socks_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[16];\n\tint socks4a = 0, len, i, j = 0, d1, d2, d3, d4;\n\n\tmemset(buf, 0, 512);\n\n\tbuf[0] = 0x4;\n\tbuf[1] = 0x1;\n\tbuf[2] = (unsigned char) (port >> 8);\n\tbuf[3] = (unsigned char) (port & 0xff);\n\n\n\tif (strlen(host) > 256)  {\n\t\trfbLog(\"socks_proxy: hostname too long: %s\\n\", host);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tif (!strcmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\")) {\n\t\tbuf[4] = 127;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t} else if (sscanf(host, \"%d.%d.%d.%d\", &d1, &d2, &d3, &d4) == 4) {\n\t\tbuf[4] = (unsigned char) d1;\n\t\tbuf[5] = (unsigned char) d2;\n\t\tbuf[6] = (unsigned char) d3;\n\t\tbuf[7] = (unsigned char) d4;\n\t} else {\n\t\tbuf[4] = 0x0;\n\t\tbuf[5] = 0x0;\n\t\tbuf[6] = 0x0;\n\t\tbuf[7] = 0x3;\n\t\tsocks4a = 1;\n\t}\n\tlen = 8;\n\n\tstrcat((char *)buf+8, \"nobody\"); \n\tlen += strlen(\"nobody\") + 1;\n\n\tif (socks4a) {\n\t\tstrcat((char *) buf+8+strlen(\"nobody\") + 1, host);\n\t\tlen += strlen(host) + 1;\n\t}\n\n\twrite(sock, buf, len);\n\n\tfor (i=0; i<8; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<8; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x0 && reply[1] == 0x5a) {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\tif (socks4a) {\n\t\t\trfbLog(\"SOCKS4a error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t} else {\n\t\t\trfbLog(\"SOCKS4  error to %s:%d sock=%d\\n\", host, port, sock);\n\t\t}\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "socks5_proxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "2011-2100",
    "snippet": "static int socks5_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[512];\n\tint len, n, i, j = 0;\n\n\tmemset(buf, 0, 512);\n\tmemset(reply, 0, 512);\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\n\twrite(sock, buf, 3);\n\n\tn = read(sock, buf, 2);\n\n\tif (n != 2) {\n\t\trfbLog(\"socks5_proxy: read error: %d\\n\", n);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\tif (buf[0] != 0x5 || buf[1] != 0x0) {\n\t\trfbLog(\"socks5_proxy: handshake error: %d %d\\n\", (int) buf[0], (int) buf[1]);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\tbuf[3] = 0x3;\n\n\tbuf[4] = (unsigned char) strlen(host);\n\tstrcat((char *) buf+5, host); \n\n\tlen = 5 + strlen(host);\n\n\tbuf[len]   = (unsigned char) (port >> 8);\n\tbuf[len+1] = (unsigned char) (port & 0xff);\n\n\twrite(sock, buf, len+2);\n\n\tfor (i=0; i<4; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (reply[3] == 0x1) {\n\t\tread(sock, reply+4, 4 + 2);\n\t} else if (reply[3] == 0x3) {\n\t\tn = read(sock, tmp, 1);\n\t\treply[4] = tmp[0];\n\t\tread(sock, reply+5, (int) reply[4] + 2);\n\t} else if (reply[3] == 0x4) {\n\t\tread(sock, reply+4, 16 + 2);\n\t}\n\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x5 && reply[1] == 0x0 && reply[2] == 0x0) {\n\t\trfbLog(\"SOCKS5 connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\treturn 1;\n\t} else {\n\t\trfbLog(\"SOCKS5 error to %s:%d sock=%d\\n\", host, port, sock);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SOCKS5 error to %s:%d sock=%d\\n\"",
            "host",
            "port",
            "sock"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SOCKS5 connect OK to %s:%d sock=%d\\n\"",
            "host",
            "port",
            "sock"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"r[%d]: %d\\n\"",
            "i",
            "(int) reply[i]"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"b[%d]: %d\\n\"",
            "i",
            "(int) buf[i]"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock",
            "reply+4",
            "16 + 2"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock",
            "buf",
            "len+2"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "(char *) buf+5",
            "host"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"socks5_proxy: handshake error: %d %d\\n\"",
            "(int) buf[0]",
            "(int) buf[1]"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"socks5_proxy: read error: %d\\n\"",
            "n"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "reply",
            "0",
            "512"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "512"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\n\nstatic int socks5_proxy(char *host, int port, int sock) {\n\tunsigned char buf[512], tmp[2];\n\tchar reply[512];\n\tint len, n, i, j = 0;\n\n\tmemset(buf, 0, 512);\n\tmemset(reply, 0, 512);\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\n\twrite(sock, buf, 3);\n\n\tn = read(sock, buf, 2);\n\n\tif (n != 2) {\n\t\trfbLog(\"socks5_proxy: read error: %d\\n\", n);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\tif (buf[0] != 0x5 || buf[1] != 0x0) {\n\t\trfbLog(\"socks5_proxy: handshake error: %d %d\\n\", (int) buf[0], (int) buf[1]);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n\n\tbuf[0] = 0x5;\n\tbuf[1] = 0x1;\n\tbuf[2] = 0x0;\n\tbuf[3] = 0x3;\n\n\tbuf[4] = (unsigned char) strlen(host);\n\tstrcat((char *) buf+5, host); \n\n\tlen = 5 + strlen(host);\n\n\tbuf[len]   = (unsigned char) (port >> 8);\n\tbuf[len+1] = (unsigned char) (port & 0xff);\n\n\twrite(sock, buf, len+2);\n\n\tfor (i=0; i<4; i++) {\n\t\tint n;\n\t\tn = read(sock, tmp, 1);\n\t\tj++;\n\t\tif (n < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t\tif (j > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\treply[i] = tmp[0];\n\t}\n\tif (reply[3] == 0x1) {\n\t\tread(sock, reply+4, 4 + 2);\n\t} else if (reply[3] == 0x3) {\n\t\tn = read(sock, tmp, 1);\n\t\treply[4] = tmp[0];\n\t\tread(sock, reply+5, (int) reply[4] + 2);\n\t} else if (reply[3] == 0x4) {\n\t\tread(sock, reply+4, 16 + 2);\n\t}\n\n\tif (0) {\n\t\tint i;\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"b[%d]: %d\\n\", i, (int) buf[i]);\n\t\t}\n\t\tfor (i=0; i<len+2; i++) {\n\t\t\tfprintf(stderr, \"r[%d]: %d\\n\", i, (int) reply[i]);\n\t\t}\n\t}\n\tif (reply[0] == 0x5 && reply[1] == 0x0 && reply[2] == 0x0) {\n\t\trfbLog(\"SOCKS5 connect OK to %s:%d sock=%d\\n\", host, port, sock);\n\t\treturn 1;\n\t} else {\n\t\trfbLog(\"SOCKS5 error to %s:%d sock=%d\\n\", host, port, sock);\n\t\tclose(sock);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "check_connect_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "1927-2009",
    "snippet": "static void check_connect_file(char *file) {\n\tFILE *in;\n\tchar line[VNC_CONNECT_MAX], host[VNC_CONNECT_MAX];\n\tstatic int first_warn = 1, truncate_ok = 1;\n\tstatic double last_time = 0.0, delay = 0.5; \n\tdouble now = dnow();\n\tstruct stat sbuf;\n\n\tif (last_time == 0.0) {\n\t\tif (!getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t/* skip first */\n\t\t\tlast_time = now;\n\t\t} else {\n\t\t\tdelay = 0.25;\n\t\t}\n\t}\n\tif (now - last_time < delay) {\n\t\t/* check only about once a second */\n\t\treturn;\n\t}\n\tlast_time = now;\n\n\tif (! truncate_ok) {\n\t\t/* check if permissions changed */\n\t\tif (access(file, W_OK) == 0) {\n\t\t\ttruncate_ok = 1;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat(file, &sbuf) == 0) {\n\t\t/* skip empty file directly */\n\t\tif (sbuf.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tin = fopen(file, \"r\");\n\tif (in == NULL) {\n\t\tif (first_warn) {\n\t\t\trfbLog(\"check_connect_file: fopen failure: %s\\n\", file);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfirst_warn = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fgets(line, VNC_CONNECT_MAX, in) != NULL) {\n\t\tif (sscanf(line, \"%s\", host) == 1) {\n\t\t\tif (strlen(host) > 0) {\n\t\t\t\tchar *str = strdup(host);\n\t\t\t\tif (strlen(str) > 38) {\n\t\t\t\t\tchar trim[100]; \n\t\t\t\t\ttrim[0] = '\\0';\n\t\t\t\t\tstrncat(trim, str, 38);\n\t\t\t\t\trfbLog(\"read connect file: %s ...\\n\",\n\t\t\t\t\t    trim);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"read connect file: %s\\n\", str);\n\t\t\t\t}\n\t\t\t\tif (!strcmp(str, \"cmd=stop\") &&\n\t\t\t\t    dnowx() < 3.0) {\n\t\t\t\t\trfbLog(\"ignoring stale cmd=stop\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tclient_connect = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(in);\n\n\t/* truncate file */\n\tin = fopen(file, \"w\");\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else {\n\t\t/* disable if we cannot truncate */\n\t\trfbLog(\"check_connect_file: could not truncate %s, \"\n\t\t   \"disabling checking.\\n\", file);\n\t\ttruncate_ok = 0;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "int cmd_ok(char *cmd);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);",
      "static void check_connect_file(char *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_connect_file: could not truncate %s, \"\n\t\t   \"disabling checking.\\n\"",
            "file"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"w\""
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ignoring stale cmd=stop\\n\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"cmd=stop\""
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read connect file: %s\\n\"",
            "str"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"read connect file: %s ...\\n\"",
            "trim"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "trim",
            "str",
            "38"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "host"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "host"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "line",
            "\"%s\"",
            "host"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "VNC_CONNECT_MAX",
            "in"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_connect_file: fopen failure: %s\\n\"",
            "file"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file",
            "&sbuf"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "file",
            "W_OK"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_APPSHARE_ACTIVE\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\nstatic void check_connect_file(char *file);\n\nstatic void check_connect_file(char *file) {\n\tFILE *in;\n\tchar line[VNC_CONNECT_MAX], host[VNC_CONNECT_MAX];\n\tstatic int first_warn = 1, truncate_ok = 1;\n\tstatic double last_time = 0.0, delay = 0.5; \n\tdouble now = dnow();\n\tstruct stat sbuf;\n\n\tif (last_time == 0.0) {\n\t\tif (!getenv(\"X11VNC_APPSHARE_ACTIVE\")) {\n\t\t\t/* skip first */\n\t\t\tlast_time = now;\n\t\t} else {\n\t\t\tdelay = 0.25;\n\t\t}\n\t}\n\tif (now - last_time < delay) {\n\t\t/* check only about once a second */\n\t\treturn;\n\t}\n\tlast_time = now;\n\n\tif (! truncate_ok) {\n\t\t/* check if permissions changed */\n\t\tif (access(file, W_OK) == 0) {\n\t\t\ttruncate_ok = 1;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat(file, &sbuf) == 0) {\n\t\t/* skip empty file directly */\n\t\tif (sbuf.st_size == 0) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tin = fopen(file, \"r\");\n\tif (in == NULL) {\n\t\tif (first_warn) {\n\t\t\trfbLog(\"check_connect_file: fopen failure: %s\\n\", file);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfirst_warn = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fgets(line, VNC_CONNECT_MAX, in) != NULL) {\n\t\tif (sscanf(line, \"%s\", host) == 1) {\n\t\t\tif (strlen(host) > 0) {\n\t\t\t\tchar *str = strdup(host);\n\t\t\t\tif (strlen(str) > 38) {\n\t\t\t\t\tchar trim[100]; \n\t\t\t\t\ttrim[0] = '\\0';\n\t\t\t\t\tstrncat(trim, str, 38);\n\t\t\t\t\trfbLog(\"read connect file: %s ...\\n\",\n\t\t\t\t\t    trim);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"read connect file: %s\\n\", str);\n\t\t\t\t}\n\t\t\t\tif (!strcmp(str, \"cmd=stop\") &&\n\t\t\t\t    dnowx() < 3.0) {\n\t\t\t\t\trfbLog(\"ignoring stale cmd=stop\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tclient_connect = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfclose(in);\n\n\t/* truncate file */\n\tin = fopen(file, \"w\");\n\tif (in != NULL) {\n\t\tfclose(in);\n\t} else {\n\t\t/* disable if we cannot truncate */\n\t\trfbLog(\"check_connect_file: could not truncate %s, \"\n\t\t   \"disabling checking.\\n\", file);\n\t\ttruncate_ok = 0;\n\t}\n}"
  },
  {
    "function_name": "check_unix_sock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "1860-1921",
    "snippet": "void check_unix_sock(long usec) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1;\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!unix_sock || unix_sock_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (unix_sock_fd >= 0) {\n\t\tFD_SET(unix_sock_fd, &fds);\n\t\tnmax = unix_sock_fd;\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (unix_sock_fd >= 0 && FD_ISSET(unix_sock_fd, &fds)) {\n\t\tcsock = accept_unix(unix_sock_fd);\n\t\tif (csock < 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_unix_sock: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\t/* rfbNewClient() will screw us with setsockopt TCP_NODELAY...\n\t\t   you need to comment out in libvncserver/rfbserver.c:\n\t\t\trfbLogPerror(\"setsockopt failed\");\n\t\t\tclose(sock);\n\t\t\treturn NULL;\n\t\t */\n\t\tcl = rfbNewClient(screen, csock);\n\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\tname = strdup(unix_sock);\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"unix sock client: %s\\n\", name);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void check_ipv6_listen(long usec);",
      "void check_unix_sock(long usec);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unix sock client: %s\\n\"",
            "name"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cl->host"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "unix_sock"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "csock"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbNewClient",
          "args": [
            "screen",
            "csock"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"check_unix_sock: fcntl\""
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "csock",
            "F_SETFL",
            "O_NONBLOCK"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept_unix",
          "args": [
            "unix_sock_fd"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "accept_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "698-714",
          "snippet": "int accept_unix(int s) {\n#if !defined(AF_UNIX) || !defined(LIBVNCSERVER_HAVE_SYS_SOCKET_H)\n\tif (s) {}\n\treturn -1;\n#else\n\tint fd;\n\tsocklen_t fromlen;\n\tstruct sockaddr_un fsaun;\n\n\tfd = accept(s, (struct sockaddr *)&fsaun, &fromlen);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"accept_unix: accept\");\n\t\treturn -1;\n\t}\n\treturn fd;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int accept_unix(int s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint accept_unix(int s);\n\nint accept_unix(int s) {\n#if !defined(AF_UNIX) || !defined(LIBVNCSERVER_HAVE_SYS_SOCKET_H)\n\tif (s) {}\n\treturn -1;\n#else\n\tint fd;\n\tsocklen_t fromlen;\n\tstruct sockaddr_un fsaun;\n\n\tfd = accept(s, (struct sockaddr *)&fsaun, &fromlen);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"accept_unix: accept\");\n\t\treturn -1;\n\t}\n\treturn fd;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "unix_sock_fd",
            "&fds"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "nmax+1",
            "&fds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "unix_sock_fd",
            "&fds"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid check_ipv6_listen(long usec);\nvoid check_unix_sock(long usec);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid check_unix_sock(long usec) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1;\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!unix_sock || unix_sock_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (unix_sock_fd >= 0) {\n\t\tFD_SET(unix_sock_fd, &fds);\n\t\tnmax = unix_sock_fd;\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (unix_sock_fd >= 0 && FD_ISSET(unix_sock_fd, &fds)) {\n\t\tcsock = accept_unix(unix_sock_fd);\n\t\tif (csock < 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_unix_sock: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\t/* rfbNewClient() will screw us with setsockopt TCP_NODELAY...\n\t\t   you need to comment out in libvncserver/rfbserver.c:\n\t\t\trfbLogPerror(\"setsockopt failed\");\n\t\t\tclose(sock);\n\t\t\treturn NULL;\n\t\t */\n\t\tcl = rfbNewClient(screen, csock);\n\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\tname = strdup(unix_sock);\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"unix sock client: %s\\n\", name);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_ipv6_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "1746-1858",
    "snippet": "void check_ipv6_listen(long usec) {\n#if X11VNC_IPV6\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1, one = 1;\n\tstruct sockaddr_in6 addr;\n\tsocklen_t addrlen = sizeof(addr);\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!ipv6_listen || noipv6) {\n\t\treturn;\n\t}\n\tif (ipv6_listen_fd < 0 && ipv6_http_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (ipv6_listen_fd >= 0) {\n\t\tFD_SET(ipv6_listen_fd, &fds);\n\t\tnmax = ipv6_listen_fd;\n\t}\n\tif (ipv6_http_fd >= 0 && screen->httpSock < 0) {\n\t\tFD_SET(ipv6_http_fd, &fds);\n\t\tif (ipv6_http_fd > nmax) {\n\t\t\tnmax = ipv6_http_fd;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (ipv6_listen_fd >= 0 && FD_ISSET(ipv6_listen_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_listen_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\tgoto err1;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tname = ipv6_getipaddr((struct sockaddr *) &addr, addrlen);\n\n\t\tipv6_client_ip_str = name;\n\t\tcl = rfbNewClient(screen, csock);\n\t\tipv6_client_ip_str = NULL;\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"ipv6 client: %s\\n\", name);\n\t\t}\n\t}\n\n\terr1:\n\n\tif (ipv6_http_fd >= 0 && FD_ISSET(ipv6_http_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_http_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\trfbLog(\"check_ipv6_listen: setting httpSock to %d\\n\", csock);\n\t\tscreen->httpSock = csock;\n\n\t\tif (screen->httpListenSock < 0) {\n\t\t\t/* this may not always work... */\n\t\t\tint save = screen->httpListenSock;\n\t\t\tscreen->httpListenSock = ipv6_http_fd;\t\n\t\t\trfbLog(\"check_ipv6_listen: no httpListenSock, calling rfbHttpCheckFds()\\n\");\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tscreen->httpListenSock = save;\t\n\t\t}\n\t}\n#endif\n\tif (usec) {}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void check_ipv6_listen(long usec);",
      "void check_unix_sock(long usec);",
      "int check_access(char *addr);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);",
      "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbHttpCheckFds",
          "args": [
            "screen"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_ipv6_listen: no httpListenSock, calling rfbHttpCheckFds()\\n\""
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_ipv6_listen: setting httpSock to %d\\n\"",
            "csock"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "csock"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"check_ipv6_listen: setsockopt\""
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "csock",
            "IPPROTO_TCP",
            "TCP_NODELAY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"check_ipv6_listen: fcntl\""
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "csock",
            "F_SETFL",
            "O_NONBLOCK"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"check_ipv6_listen: accept\""
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "ipv6_http_fd",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "ipv6_http_fd",
            "&fds"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ipv6 client: %s\\n\"",
            "name"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cl->host"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbNewClient",
          "args": [
            "screen",
            "csock"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_getipaddr",
          "args": [
            "(struct sockaddr *) &addr",
            "addrlen"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_getipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "525-536",
          "snippet": "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);",
            "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);\n\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"check_ipv6_listen: setsockopt\""
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "csock",
            "IPPROTO_TCP",
            "TCP_NODELAY",
            "(char *)&one",
            "sizeof(one)"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"check_ipv6_listen: fcntl\""
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "csock",
            "F_SETFL",
            "O_NONBLOCK"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"check_ipv6_listen: accept\""
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "ipv6_listen_fd",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "ipv6_listen_fd",
            "&fds"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "nmax+1",
            "&fds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "ipv6_http_fd",
            "&fds"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "ipv6_listen_fd",
            "&fds"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid check_ipv6_listen(long usec);\nvoid check_unix_sock(long usec);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\n\nvoid check_ipv6_listen(long usec) {\n#if X11VNC_IPV6\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, csock = -1, one = 1;\n\tstruct sockaddr_in6 addr;\n\tsocklen_t addrlen = sizeof(addr);\n\trfbClientPtr cl;\n\tint nmax = 0;\n\tchar *name;\n\n\tif (!ipv6_listen || noipv6) {\n\t\treturn;\n\t}\n\tif (ipv6_listen_fd < 0 && ipv6_http_fd < 0) {\n\t\treturn;\n\t}\n\n\tFD_ZERO(&fds);\n\tif (ipv6_listen_fd >= 0) {\n\t\tFD_SET(ipv6_listen_fd, &fds);\n\t\tnmax = ipv6_listen_fd;\n\t}\n\tif (ipv6_http_fd >= 0 && screen->httpSock < 0) {\n\t\tFD_SET(ipv6_http_fd, &fds);\n\t\tif (ipv6_http_fd > nmax) {\n\t\t\tnmax = ipv6_http_fd;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (ipv6_listen_fd >= 0 && FD_ISSET(ipv6_listen_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_listen_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\tgoto err1;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tname = ipv6_getipaddr((struct sockaddr *) &addr, addrlen);\n\n\t\tipv6_client_ip_str = name;\n\t\tcl = rfbNewClient(screen, csock);\n\t\tipv6_client_ip_str = NULL;\n\t\tif (cl == NULL) {\n\t\t\tclose(csock);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (cl->host) {\n\t\t\t\tfree(cl->host);\n\t\t\t}\n\t\t\tcl->host = name;\n\t\t\trfbLog(\"ipv6 client: %s\\n\", name);\n\t\t}\n\t}\n\n\terr1:\n\n\tif (ipv6_http_fd >= 0 && FD_ISSET(ipv6_http_fd, &fds)) {\n\n\t\tcsock = accept(ipv6_http_fd, (struct sockaddr *)&addr, &addrlen);\n\t\tif (csock < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: accept\");\n\t\t\treturn;\n\t\t}\n\t\tif (fcntl(csock, F_SETFL, O_NONBLOCK) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: fcntl\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\t\tif (setsockopt(csock, IPPROTO_TCP, TCP_NODELAY,\n\t\t    (char *)&one, sizeof(one)) < 0) {\n\t\t\trfbLogPerror(\"check_ipv6_listen: setsockopt\");\n\t\t\tclose(csock);\n\t\t\treturn;\n\t\t}\n\n\t\trfbLog(\"check_ipv6_listen: setting httpSock to %d\\n\", csock);\n\t\tscreen->httpSock = csock;\n\n\t\tif (screen->httpListenSock < 0) {\n\t\t\t/* this may not always work... */\n\t\t\tint save = screen->httpListenSock;\n\t\t\tscreen->httpListenSock = ipv6_http_fd;\t\n\t\t\trfbLog(\"check_ipv6_listen: no httpListenSock, calling rfbHttpCheckFds()\\n\");\n\t\t\trfbHttpCheckFds(screen);\n\t\t\tscreen->httpListenSock = save;\t\n\t\t}\n\t}\n#endif\n\tif (usec) {}\n}"
  },
  {
    "function_name": "accept_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "1592-1744",
    "snippet": "int accept_client(rfbClientPtr client) {\n\n\tchar xmessage[200], *cmd = NULL;\n\tchar *addr = client->host;\n\tchar *action = NULL;\n\n\tif (accept_cmd == NULL || *accept_cmd == '\\0') {\n\t\treturn 1;\t/* no command specified, so we accept */\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\tif (strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\t/* use our builtin popup button */\n\n\t\t/* (popup|popupkey|popupmouse)[+-X+-Y][:timeout] */\n\n\t\tint ret, timeout = 120;\n\t\tint x = -64000, y = -64000;\n\t\tchar *p, *mode;\n\t\tchar *userhost = ident_username(client);\n\n\t\t/* extract timeout */\n\t\tif ((p = strchr(accept_cmd, ':')) != NULL) {\n\t\t\tint in;\n\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\ttimeout = in;\n\t\t\t}\n\t\t}\n\t\t/* extract geometry */\n\t\tif ((p = strpbrk(accept_cmd, \"+-\")) != NULL) {\n\t\t\tugly_geom(p, &x, &y);\n\t\t}\n\n\t\t/* find mode: mouse, key, or both */\n\t\tif (strstr(accept_cmd, \"popupmouse\") == accept_cmd) {\n\t\t\tmode = \"mouse_only\";\n\t\t} else if (strstr(accept_cmd, \"popupkey\") == accept_cmd) {\n\t\t\tmode = \"key_only\";\n\t\t} else {\n\t\t\tmode = \"both\";\n\t\t}\n\n\t\tif (dpy == NULL && use_dpy && strstr(use_dpy, \"WAIT:\") ==\n\t\t    use_dpy) {\n\t\t\trfbLog(\"accept_client: warning allowing client under conditions:\\n\");\n\t\t\trfbLog(\"  -display WAIT:, dpy == NULL, -accept popup.\\n\");\n\t\t\trfbLog(\"   There will be another popup.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\trfbLog(\"accept_client: using builtin popup for: %s\\n\", addr);\n\t\tif ((ret = ugly_window(addr, userhost, x, y, timeout,\n\t\t    mode, 1))) {\n\t\t\tfree(userhost);\n\t\t\tif (ret == 2) {\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t}\n\t\t\trfbLog(\"accept_client: popup accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfree(userhost);\n\t\t\trfbLog(\"accept_client: popup rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(accept_cmd, \"xmessage\")) {\n\t\t/* make our own command using xmessage(1) */\n\n\t\tif (view_only) {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2 -center\"\n\t\t\t    \" 'x11vnc: accept connection from %s?'\", addr);\n\t\t} else {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2,\"\n\t\t\t    \"view-only:3 -center\" \" 'x11vnc: accept connection\"\n\t\t\t    \" from %s?'\", addr);\n\t\t\taction = \"yes:0,no:*,view:3\";\n\t\t}\n\t\tcmd = xmessage;\n\t\t\n\t} else {\n\t\t/* use the user supplied command: */\n\n\t\tcmd = accept_cmd;\n\n\t\t/* extract any action prefix:  yes:N,no:M,view:K */\n\t\tif (strstr(accept_cmd, \"yes:\") == accept_cmd) {\n\t\t\tchar *p;\n\t\t\tif ((p = strpbrk(accept_cmd, \" \\t\")) != NULL) {\n\t\t\t\tint i;\n\t\t\t\tcmd = p;\n\t\t\t\tp = accept_cmd;\n\t\t\t\tfor (i=0; i<200; i++) {\n\t\t\t\t\tif (*p == ' ' || *p == '\\t') {\n\t\t\t\t\t\txmessage[i] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\txmessage[i] = *p;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\txmessage[200-1] = '\\0';\n\t\t\t\taction = xmessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd) {\n\t\tint rc;\n\n\t\trfbLog(\"accept_client: using cmd for: %s\\n\", addr);\n\t\trc = run_user_command(cmd, client, \"accept\", NULL, 0, NULL);\n\n\t\tif (action) {\n\t\t\tint result;\n\n\t\t\tif (rc < 0) {\n\t\t\t\trfbLog(\"accept_client: cannot use negative \"\n\t\t\t\t    \"rc: %d, action %s\\n\", rc, action);\n\t\t\t\tresult = 2;\n\t\t\t} else {\n\t\t\t\tresult = action_match(action, rc);\n\t\t\t}\n\n\t\t\tif (result == 1) {\n\t\t\t\trc = 0;\n\t\t\t} else if (result == 2) {\n\t\t\t\trc = 1;\n\t\t\t} else if (result == 3) {\n\t\t\t\trc = 0;\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t} else {\n\t\t\t\trc = 1;\t/* NOTREACHED */\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\trfbLog(\"accept_client: accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"accept_client: rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\trfbLog(\"accept_client: no command, rejecting %s\\n\", addr);\n\t\treturn 0;\n\t}\n\n\t/* return 0; NOTREACHED */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "int cmd_ok(char *cmd);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "int check_access(char *addr);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);",
      "static void ugly_geom(char *p, int *x, int *y);",
      "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
      "static int action_match(char *action, int rc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: no command, rejecting %s\\n\"",
            "addr"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: rejected: %s\\n\"",
            "addr"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: accepted: %s\\n\"",
            "addr"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: viewonly: %s\\n\"",
            "addr"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "action_match",
          "args": [
            "action",
            "rc"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "action_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1472-1554",
          "snippet": "static int action_match(char *action, int rc) {\n\tchar *p, *q, *s = strdup(action);\n\tint cases[4], i, result;\n\tchar *labels[4];\n\n\tlabels[1] = \"yes\";\n\tlabels[2] = \"no\";\n\tlabels[3] = \"view\";\n\n\trfbLog(\"accept_client: process action line: %s\\n\",\n\t    action);\n\n\tfor (i=1; i <= 3; i++) {\n\t\tcases[i] = -2;\n\t}\n\n\tp = strtok(s, \",\");\n\twhile (p) {\n\t\tif ((q = strchr(p, ':')) != NULL) {\n\t\t\tint in, k = 1;\n\t\t\t*q = '\\0';\n\t\t\tq++;\n\t\t\tif (strstr(p, \"yes\") == p) {\n\t\t\t\tk = 1;\n\t\t\t} else if (strstr(p, \"no\") == p) {\n\t\t\t\tk = 2;\n\t\t\t} else if (strstr(p, \"view\") == p) {\n\t\t\t\tk = 3;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (*q == '*') {\n\t\t\t\tcases[k] = -1;\n\t\t\t} else if (sscanf(q, \"%d\", &in) == 1) {\n\t\t\t\tif (in < 0) {\n\t\t\t\t\trfbLogEnable(1);\n\t\t\t\t\trfbLog(\"invalid action line: %s\\n\",\n\t\t\t\t\t    action);\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tcases[k] = in;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\n\tresult = -1;\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] == -1) {\n\t\t\trfbLog(\"accept_client: default action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result == -1) {\n\t\trfbLog(\"accept_client: no default action\\n\");\n\t}\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] >= 0 && cases[i] == rc) {\n\t\t\trfbLog(\"accept_client: matched action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result < 0) {\n\t\trfbLog(\"no action match: %s rc=%d set to no\\n\", action, rc);\n\t\tresult = 2;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nstatic int action_match(char *action, int rc);\n\nstatic int action_match(char *action, int rc) {\n\tchar *p, *q, *s = strdup(action);\n\tint cases[4], i, result;\n\tchar *labels[4];\n\n\tlabels[1] = \"yes\";\n\tlabels[2] = \"no\";\n\tlabels[3] = \"view\";\n\n\trfbLog(\"accept_client: process action line: %s\\n\",\n\t    action);\n\n\tfor (i=1; i <= 3; i++) {\n\t\tcases[i] = -2;\n\t}\n\n\tp = strtok(s, \",\");\n\twhile (p) {\n\t\tif ((q = strchr(p, ':')) != NULL) {\n\t\t\tint in, k = 1;\n\t\t\t*q = '\\0';\n\t\t\tq++;\n\t\t\tif (strstr(p, \"yes\") == p) {\n\t\t\t\tk = 1;\n\t\t\t} else if (strstr(p, \"no\") == p) {\n\t\t\t\tk = 2;\n\t\t\t} else if (strstr(p, \"view\") == p) {\n\t\t\t\tk = 3;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (*q == '*') {\n\t\t\t\tcases[k] = -1;\n\t\t\t} else if (sscanf(q, \"%d\", &in) == 1) {\n\t\t\t\tif (in < 0) {\n\t\t\t\t\trfbLogEnable(1);\n\t\t\t\t\trfbLog(\"invalid action line: %s\\n\",\n\t\t\t\t\t    action);\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tcases[k] = in;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\n\tresult = -1;\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] == -1) {\n\t\t\trfbLog(\"accept_client: default action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result == -1) {\n\t\trfbLog(\"accept_client: no default action\\n\");\n\t}\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] >= 0 && cases[i] == rc) {\n\t\t\trfbLog(\"accept_client: matched action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result < 0) {\n\t\trfbLog(\"no action match: %s rc=%d set to no\\n\", action, rc);\n\t\tresult = 2;\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: cannot use negative \"\n\t\t\t\t    \"rc: %d, action %s\\n\"",
            "rc",
            "action"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "cmd",
            "client",
            "\"accept\"",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: using cmd for: %s\\n\"",
            "addr"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "accept_cmd",
            "\" \\t\""
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "accept_cmd",
            "\"yes:\""
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xmessage",
            "\"xmessage -buttons yes:0,no:2,\"\n\t\t\t    \"view-only:3 -center\" \" 'x11vnc: accept connection\"\n\t\t\t    \" from %s?'\"",
            "addr"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xmessage",
            "\"xmessage -buttons yes:0,no:2 -center\"\n\t\t\t    \" 'x11vnc: accept connection from %s?'\"",
            "addr"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "accept_cmd",
            "\"xmessage\""
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: popup rejected: %s\\n\"",
            "addr"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "userhost"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: popup accepted: %s\\n\"",
            "addr"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: viewonly: %s\\n\"",
            "addr"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugly_window",
          "args": [
            "addr",
            "userhost",
            "x",
            "y",
            "timeout",
            "mode",
            "1"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "ugly_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1147-1466",
          "snippet": "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept) {\n#if NO_X11\n\tif (!addr || !userhost || !X || !Y || !timeout || !mode || !accept) {}\n\tRAWFB_RET(0)\n\tnox11_exit(1);\n\treturn 0;\n#else\n\n#define t2x2_width 16\n#define t2x2_height 16\nstatic unsigned char t2x2_bits[] = {\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff,\n   0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33,\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33};\n\n\tWindow awin;\n\tGC gc;\n\tXSizeHints hints;\n\tXGCValues values;\n\tstatic XFontStruct *font_info = NULL;\n\tstatic Pixmap ico = 0;\n\tunsigned long valuemask = 0;\n\tstatic char dash_list[] = {20, 40};\n\tint list_length = sizeof(dash_list);\n\n\tAtom wm_protocols;\n\tAtom wm_delete_window;\n\n\tXEvent ev;\n\tlong evmask = ExposureMask | KeyPressMask | ButtonPressMask\n\t    | StructureNotifyMask;\n\tdouble waited = 0.0;\n\n\t/* strings and geometries y/n */\n\tKeyCode key_y, key_n, key_v;\n\tchar strh[100];\n\tchar stri[100];\n\tchar str1_b[] = \"To accept: press \\\"y\\\" or click the \\\"Yes\\\" button\";\n\tchar str2_b[] = \"To reject: press \\\"n\\\" or click the \\\"No\\\" button\";\n\tchar str3_b[] = \"View only: press \\\"v\\\" or click the \\\"View\\\" button\";\n\tchar str1_m[] = \"To accept: click the \\\"Yes\\\" button\";\n\tchar str2_m[] = \"To reject: click the \\\"No\\\" button\";\n\tchar str3_m[] = \"View only: click the \\\"View\\\" button\";\n\tchar str1_k[] = \"To accept: press \\\"y\\\"\";\n\tchar str2_k[] = \"To reject: press \\\"n\\\"\";\n\tchar str3_k[] = \"View only: press \\\"v\\\"\";\n\tchar *str1, *str2, *str3;\n\tchar str_y[] = \"Yes\";\n\tchar str_n[] = \"No\";\n\tchar str_v[] = \"View\";\n\tint x, y, w = 345, h = 175, ret = 0;\n\tint X_sh = 20, Y_sh = 30, dY = 20;\n\tint Ye_x = 20,  Ye_y = 0, Ye_w = 45, Ye_h = 20;\n\tint No_x = 75,  No_y = 0, No_w = 45, No_h = 20; \n\tint Vi_x = 130, Vi_y = 0, Vi_w = 45, Vi_h = 20; \n\tchar *sprop = \"new x11vnc client\";\n\n\tKeyCode key_o;\n\n\tRAWFB_RET(0)\n\n\tif (! accept) {\n\t\tsprintf(str_y, \"OK\");\n\t\tsprop = \"x11vnc client disconnected\";\n\t\th = 110;\n\t\tstr1 = \"\";\n\t\tstr2 = \"\";\n\t\tstr3 = \"\";\n\t} else if (!strcmp(mode, \"mouse_only\")) {\n\t\tstr1 = str1_m;\n\t\tstr2 = str2_m;\n\t\tstr3 = str3_m;\n\t} else if (!strcmp(mode, \"key_only\")) {\n\t\tstr1 = str1_k;\n\t\tstr2 = str2_k;\n\t\tstr3 = str3_k;\n\t\th -= dY;\n\t} else {\n\t\tstr1 = str1_b;\n\t\tstr2 = str2_b;\n\t\tstr3 = str3_b;\n\t}\n\tif (view_only) {\n\t\th -= dY;\n\t}\n\n\t/* XXX handle coff_x/coff_y? */\n\tif (X < -dpy_x) {\n\t\tx = (dpy_x - w)/2;\t/* large negative: center */\n\t\tif (x < 0) x = 0;\n\t} else if (X < 0) {\n\t\tx = dpy_x + X - w;\t/* from lower right */\n\t} else {\n\t\tx = X;\t\t\t/* from upper left */\n\t}\n\t\n\tif (Y < -dpy_y) {\n\t\ty = (dpy_y - h)/2;\n\t\tif (y < 0) y = 0;\n\t} else if (Y < 0) {\n\t\ty = dpy_y + Y - h;\n\t} else {\n\t\ty = Y;\n\t}\n\n\tX_LOCK;\n\n\tawin = XCreateSimpleWindow(dpy, window, x, y, w, h, 4,\n\t    BlackPixel(dpy, scr), WhitePixel(dpy, scr));\n\n\twm_protocols = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\twm_delete_window = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\tXSetWMProtocols(dpy, awin, &wm_delete_window, 1);\n\n\tif (! ico) {\n\t\tico = XCreateBitmapFromData(dpy, awin, (char *) t2x2_bits,\n\t\t    t2x2_width, t2x2_height);\n\t}\n\n\thints.flags = PPosition | PSize | PMinSize;\n\thints.x = x;\n\thints.y = y;\n\thints.width = w;\n\thints.height = h;\n\thints.min_width = w;\n\thints.min_height = h;\n\n\tXSetStandardProperties(dpy, awin, sprop, \"x11vnc query\", ico, NULL,\n\t    0, &hints);\n\n\tXSelectInput_wr(dpy, awin, evmask);\n\n\tif (! font_info && (font_info = XLoadQueryFont(dpy, \"fixed\")) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"ugly_window: cannot locate font fixed.\\n\");\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\n\tgc = XCreateGC(dpy, awin, valuemask, &values);\n\tXSetFont(dpy, gc, font_info->fid);\n\tXSetForeground(dpy, gc, BlackPixel(dpy, scr));\n\tXSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter);\n\tXSetDashes(dpy, gc, 0, dash_list, list_length);\n\n\tXMapWindow(dpy, awin);\n\tXFlush_wr(dpy);\n\n\tif (accept) {\n\t\tchar *ip = addr;\n\t\tchar *type = \"accept\";\n\t\tif (unixpw && strstr(userhost, \"UNIX:\") != userhost) {\n\t\t\ttype = \"UNIXPW\";\n\t\t\tif (openssl_last_ip) {\n\t\t\t\tip = openssl_last_ip;\n\t\t\t}\n\t\t}\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: %s connection from %s?\", type, ip);\n\t} else {\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: client disconnected from %s\", addr);\n\t}\n\tsnprintf(stri, sizeof stri, \"        (%s)\", userhost);\n\n\tkey_o = XKeysymToKeycode(dpy, XStringToKeysym(\"o\"));\n\tkey_y = XKeysymToKeycode(dpy, XStringToKeysym(\"y\"));\n\tkey_n = XKeysymToKeycode(dpy, XStringToKeysym(\"n\"));\n\tkey_v = XKeysymToKeycode(dpy, XStringToKeysym(\"v\"));\n\n\twhile (1) {\n\t\tint out = -1, x, y, tw, k;\n\n\t\tif (XCheckWindowEvent(dpy, awin, evmask, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else if (XCheckTypedEvent(dpy, ClientMessage, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else {\n\t\t\tint ms = 100;\t/* sleep a bit */\n\t\t\tusleep(ms * 1000);\n\t\t\twaited += ((double) ms)/1000.;\n\t\t\tif (timeout && (int) waited >= timeout) {\n\t\t\t\trfbLog(\"ugly_window: popup timed out after \"\n\t\t\t\t    \"%d seconds.\\n\", timeout);\n\t\t\t\tout = 0;\n\t\t\t\tev.type = 0;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch(ev.type) {\n\t\tcase Expose:\n\t\t\twhile (XCheckTypedEvent(dpy, Expose, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tk=0;\n\n\t\t\t/* instructions */\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    strh, strlen(strh));\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    stri, strlen(stri));\n\t\t\tif (accept) {\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str1, strlen(str1));\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str2, strlen(str2));\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t\t    str3, strlen(str3));\n\t\t\t  }\n\t\t\t}\n\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* buttons */\n\t\t\tYe_y = Y_sh+k*dY;\n\t\t\tNo_y = Y_sh+k*dY;\n\t\t\tVi_y = Y_sh+k*dY;\n\t\t\tXDrawRectangle(dpy, awin, gc, Ye_x, Ye_y, Ye_w, Ye_h);\n\n\t\t\tif (accept) {\n\t\t\t  XDrawRectangle(dpy, awin, gc, No_x, No_y, No_w, No_h);\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawRectangle(dpy, awin, gc, Vi_x, Vi_y,\n\t\t\t\t    Vi_w, Vi_h);\n\t\t\t  }\n\t\t\t}\n\n\t\t\ttw = XTextWidth(font_info, str_y, strlen(str_y));\n\t\t\ttw = (Ye_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, Ye_x+tw, Ye_y+Ye_h-5,\n\t\t\t    str_y, strlen(str_y));\n\n\t\t\tif (!accept) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw = XTextWidth(font_info, str_n, strlen(str_n));\n\t\t\ttw = (No_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, No_x+tw, No_y+No_h-5,\n\t\t\t    str_n, strlen(str_n));\n\n\t\t\tif (! view_only) {\n\t\t\t\ttw = XTextWidth(font_info, str_v,\n\t\t\t\t    strlen(str_v));\n\t\t\t\ttw = (Vi_w - tw)/2;\n\t\t\t\tif (tw < 0) tw = 1;\n\t\t\t\tXDrawString(dpy, awin, gc, Vi_x+tw,\n\t\t\t\t    Vi_y+Vi_h-5, str_v, strlen(str_v));\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ClientMessage:\n\t\t\tif (ev.xclient.message_type == wm_protocols &&\n\t\t\t    (Atom) ev.xclient.data.l[0] == wm_delete_window) {\n\t\t\t\tout = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ButtonPress:\n\t\t\tx = ev.xbutton.x;\n\t\t\ty = ev.xbutton.y;\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\t;\n\t\t\t} else if (x > Ye_x && x < Ye_x+Ye_w && y > Ye_y\n\t\t\t    && y < Ye_y+Ye_h) {\n\t\t\t\tout = 1;\n\t\t\t} else if (! accept) {\n\t\t\t\t;\n\t\t\t} else if (x > No_x && x < No_x+No_w && y > No_y\n\t\t\t    && y < No_y+No_h) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && x > Vi_x && x < Vi_x+Vi_w\n\t\t\t    && y > Vi_y && y < Vi_y+Ye_h) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KeyPress:\n\t\t\tif (!strcmp(mode, \"mouse_only\")) {\n\t\t\t\t;\n\t\t\t} else if (! accept) {\n\t\t\t\tif (ev.xkey.keycode == key_o) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t\tif (ev.xkey.keycode == key_y) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t} else if (ev.xkey.keycode == key_y) {\n\t\t\t\tout = 1;\n\t\t\t\t;\n\t\t\t} else if (ev.xkey.keycode == key_n) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && ev.xkey.keycode == key_v) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (out != -1) {\n\t\t\tret = out;\n\t\t\tXSelectInput_wr(dpy, awin, 0);\n\t\t\tXUnmapWindow(dpy, awin);\n\t\t\tXFree_wr(gc);\n\t\t\tXDestroyWindow(dpy, awin);\n\t\t\tXFlush_wr(dpy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\treturn ret;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define t2x2_height 16",
            "#define t2x2_width 16"
          ],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);",
            "static void ugly_geom(char *p, int *x, int *y);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define t2x2_height 16\n#define t2x2_width 16\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\n\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept) {\n#if NO_X11\n\tif (!addr || !userhost || !X || !Y || !timeout || !mode || !accept) {}\n\tRAWFB_RET(0)\n\tnox11_exit(1);\n\treturn 0;\n#else\n\n#define t2x2_width 16\n#define t2x2_height 16\nstatic unsigned char t2x2_bits[] = {\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff,\n   0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33,\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33};\n\n\tWindow awin;\n\tGC gc;\n\tXSizeHints hints;\n\tXGCValues values;\n\tstatic XFontStruct *font_info = NULL;\n\tstatic Pixmap ico = 0;\n\tunsigned long valuemask = 0;\n\tstatic char dash_list[] = {20, 40};\n\tint list_length = sizeof(dash_list);\n\n\tAtom wm_protocols;\n\tAtom wm_delete_window;\n\n\tXEvent ev;\n\tlong evmask = ExposureMask | KeyPressMask | ButtonPressMask\n\t    | StructureNotifyMask;\n\tdouble waited = 0.0;\n\n\t/* strings and geometries y/n */\n\tKeyCode key_y, key_n, key_v;\n\tchar strh[100];\n\tchar stri[100];\n\tchar str1_b[] = \"To accept: press \\\"y\\\" or click the \\\"Yes\\\" button\";\n\tchar str2_b[] = \"To reject: press \\\"n\\\" or click the \\\"No\\\" button\";\n\tchar str3_b[] = \"View only: press \\\"v\\\" or click the \\\"View\\\" button\";\n\tchar str1_m[] = \"To accept: click the \\\"Yes\\\" button\";\n\tchar str2_m[] = \"To reject: click the \\\"No\\\" button\";\n\tchar str3_m[] = \"View only: click the \\\"View\\\" button\";\n\tchar str1_k[] = \"To accept: press \\\"y\\\"\";\n\tchar str2_k[] = \"To reject: press \\\"n\\\"\";\n\tchar str3_k[] = \"View only: press \\\"v\\\"\";\n\tchar *str1, *str2, *str3;\n\tchar str_y[] = \"Yes\";\n\tchar str_n[] = \"No\";\n\tchar str_v[] = \"View\";\n\tint x, y, w = 345, h = 175, ret = 0;\n\tint X_sh = 20, Y_sh = 30, dY = 20;\n\tint Ye_x = 20,  Ye_y = 0, Ye_w = 45, Ye_h = 20;\n\tint No_x = 75,  No_y = 0, No_w = 45, No_h = 20; \n\tint Vi_x = 130, Vi_y = 0, Vi_w = 45, Vi_h = 20; \n\tchar *sprop = \"new x11vnc client\";\n\n\tKeyCode key_o;\n\n\tRAWFB_RET(0)\n\n\tif (! accept) {\n\t\tsprintf(str_y, \"OK\");\n\t\tsprop = \"x11vnc client disconnected\";\n\t\th = 110;\n\t\tstr1 = \"\";\n\t\tstr2 = \"\";\n\t\tstr3 = \"\";\n\t} else if (!strcmp(mode, \"mouse_only\")) {\n\t\tstr1 = str1_m;\n\t\tstr2 = str2_m;\n\t\tstr3 = str3_m;\n\t} else if (!strcmp(mode, \"key_only\")) {\n\t\tstr1 = str1_k;\n\t\tstr2 = str2_k;\n\t\tstr3 = str3_k;\n\t\th -= dY;\n\t} else {\n\t\tstr1 = str1_b;\n\t\tstr2 = str2_b;\n\t\tstr3 = str3_b;\n\t}\n\tif (view_only) {\n\t\th -= dY;\n\t}\n\n\t/* XXX handle coff_x/coff_y? */\n\tif (X < -dpy_x) {\n\t\tx = (dpy_x - w)/2;\t/* large negative: center */\n\t\tif (x < 0) x = 0;\n\t} else if (X < 0) {\n\t\tx = dpy_x + X - w;\t/* from lower right */\n\t} else {\n\t\tx = X;\t\t\t/* from upper left */\n\t}\n\t\n\tif (Y < -dpy_y) {\n\t\ty = (dpy_y - h)/2;\n\t\tif (y < 0) y = 0;\n\t} else if (Y < 0) {\n\t\ty = dpy_y + Y - h;\n\t} else {\n\t\ty = Y;\n\t}\n\n\tX_LOCK;\n\n\tawin = XCreateSimpleWindow(dpy, window, x, y, w, h, 4,\n\t    BlackPixel(dpy, scr), WhitePixel(dpy, scr));\n\n\twm_protocols = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\twm_delete_window = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\tXSetWMProtocols(dpy, awin, &wm_delete_window, 1);\n\n\tif (! ico) {\n\t\tico = XCreateBitmapFromData(dpy, awin, (char *) t2x2_bits,\n\t\t    t2x2_width, t2x2_height);\n\t}\n\n\thints.flags = PPosition | PSize | PMinSize;\n\thints.x = x;\n\thints.y = y;\n\thints.width = w;\n\thints.height = h;\n\thints.min_width = w;\n\thints.min_height = h;\n\n\tXSetStandardProperties(dpy, awin, sprop, \"x11vnc query\", ico, NULL,\n\t    0, &hints);\n\n\tXSelectInput_wr(dpy, awin, evmask);\n\n\tif (! font_info && (font_info = XLoadQueryFont(dpy, \"fixed\")) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"ugly_window: cannot locate font fixed.\\n\");\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\n\tgc = XCreateGC(dpy, awin, valuemask, &values);\n\tXSetFont(dpy, gc, font_info->fid);\n\tXSetForeground(dpy, gc, BlackPixel(dpy, scr));\n\tXSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter);\n\tXSetDashes(dpy, gc, 0, dash_list, list_length);\n\n\tXMapWindow(dpy, awin);\n\tXFlush_wr(dpy);\n\n\tif (accept) {\n\t\tchar *ip = addr;\n\t\tchar *type = \"accept\";\n\t\tif (unixpw && strstr(userhost, \"UNIX:\") != userhost) {\n\t\t\ttype = \"UNIXPW\";\n\t\t\tif (openssl_last_ip) {\n\t\t\t\tip = openssl_last_ip;\n\t\t\t}\n\t\t}\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: %s connection from %s?\", type, ip);\n\t} else {\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: client disconnected from %s\", addr);\n\t}\n\tsnprintf(stri, sizeof stri, \"        (%s)\", userhost);\n\n\tkey_o = XKeysymToKeycode(dpy, XStringToKeysym(\"o\"));\n\tkey_y = XKeysymToKeycode(dpy, XStringToKeysym(\"y\"));\n\tkey_n = XKeysymToKeycode(dpy, XStringToKeysym(\"n\"));\n\tkey_v = XKeysymToKeycode(dpy, XStringToKeysym(\"v\"));\n\n\twhile (1) {\n\t\tint out = -1, x, y, tw, k;\n\n\t\tif (XCheckWindowEvent(dpy, awin, evmask, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else if (XCheckTypedEvent(dpy, ClientMessage, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else {\n\t\t\tint ms = 100;\t/* sleep a bit */\n\t\t\tusleep(ms * 1000);\n\t\t\twaited += ((double) ms)/1000.;\n\t\t\tif (timeout && (int) waited >= timeout) {\n\t\t\t\trfbLog(\"ugly_window: popup timed out after \"\n\t\t\t\t    \"%d seconds.\\n\", timeout);\n\t\t\t\tout = 0;\n\t\t\t\tev.type = 0;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch(ev.type) {\n\t\tcase Expose:\n\t\t\twhile (XCheckTypedEvent(dpy, Expose, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tk=0;\n\n\t\t\t/* instructions */\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    strh, strlen(strh));\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    stri, strlen(stri));\n\t\t\tif (accept) {\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str1, strlen(str1));\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str2, strlen(str2));\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t\t    str3, strlen(str3));\n\t\t\t  }\n\t\t\t}\n\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* buttons */\n\t\t\tYe_y = Y_sh+k*dY;\n\t\t\tNo_y = Y_sh+k*dY;\n\t\t\tVi_y = Y_sh+k*dY;\n\t\t\tXDrawRectangle(dpy, awin, gc, Ye_x, Ye_y, Ye_w, Ye_h);\n\n\t\t\tif (accept) {\n\t\t\t  XDrawRectangle(dpy, awin, gc, No_x, No_y, No_w, No_h);\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawRectangle(dpy, awin, gc, Vi_x, Vi_y,\n\t\t\t\t    Vi_w, Vi_h);\n\t\t\t  }\n\t\t\t}\n\n\t\t\ttw = XTextWidth(font_info, str_y, strlen(str_y));\n\t\t\ttw = (Ye_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, Ye_x+tw, Ye_y+Ye_h-5,\n\t\t\t    str_y, strlen(str_y));\n\n\t\t\tif (!accept) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw = XTextWidth(font_info, str_n, strlen(str_n));\n\t\t\ttw = (No_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, No_x+tw, No_y+No_h-5,\n\t\t\t    str_n, strlen(str_n));\n\n\t\t\tif (! view_only) {\n\t\t\t\ttw = XTextWidth(font_info, str_v,\n\t\t\t\t    strlen(str_v));\n\t\t\t\ttw = (Vi_w - tw)/2;\n\t\t\t\tif (tw < 0) tw = 1;\n\t\t\t\tXDrawString(dpy, awin, gc, Vi_x+tw,\n\t\t\t\t    Vi_y+Vi_h-5, str_v, strlen(str_v));\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ClientMessage:\n\t\t\tif (ev.xclient.message_type == wm_protocols &&\n\t\t\t    (Atom) ev.xclient.data.l[0] == wm_delete_window) {\n\t\t\t\tout = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ButtonPress:\n\t\t\tx = ev.xbutton.x;\n\t\t\ty = ev.xbutton.y;\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\t;\n\t\t\t} else if (x > Ye_x && x < Ye_x+Ye_w && y > Ye_y\n\t\t\t    && y < Ye_y+Ye_h) {\n\t\t\t\tout = 1;\n\t\t\t} else if (! accept) {\n\t\t\t\t;\n\t\t\t} else if (x > No_x && x < No_x+No_w && y > No_y\n\t\t\t    && y < No_y+No_h) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && x > Vi_x && x < Vi_x+Vi_w\n\t\t\t    && y > Vi_y && y < Vi_y+Ye_h) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KeyPress:\n\t\t\tif (!strcmp(mode, \"mouse_only\")) {\n\t\t\t\t;\n\t\t\t} else if (! accept) {\n\t\t\t\tif (ev.xkey.keycode == key_o) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t\tif (ev.xkey.keycode == key_y) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t} else if (ev.xkey.keycode == key_y) {\n\t\t\t\tout = 1;\n\t\t\t\t;\n\t\t\t} else if (ev.xkey.keycode == key_n) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && ev.xkey.keycode == key_v) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (out != -1) {\n\t\t\tret = out;\n\t\t\tXSelectInput_wr(dpy, awin, 0);\n\t\t\tXUnmapWindow(dpy, awin);\n\t\t\tXFree_wr(gc);\n\t\t\tXDestroyWindow(dpy, awin);\n\t\t\tXFlush_wr(dpy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\treturn ret;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: using builtin popup for: %s\\n\"",
            "addr"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   There will be another popup.\\n\""
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  -display WAIT:, dpy == NULL, -accept popup.\\n\""
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: warning allowing client under conditions:\\n\""
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "use_dpy",
            "\"WAIT:\""
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "accept_cmd",
            "\"popupkey\""
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "accept_cmd",
            "\"popupmouse\""
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugly_geom",
          "args": [
            "p",
            "&x",
            "&y"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "ugly_geom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1556-1572",
          "snippet": "static void ugly_geom(char *p, int *x, int *y) {\n\tint x1, y1;\n\n\tif (sscanf(p, \"+%d+%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"+%d-%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = -y1;\n\t} else if (sscanf(p, \"-%d+%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"-%d-%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = -y1;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ugly_geom(char *p, int *x, int *y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void ugly_geom(char *p, int *x, int *y);\n\nstatic void ugly_geom(char *p, int *x, int *y) {\n\tint x1, y1;\n\n\tif (sscanf(p, \"+%d+%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"+%d-%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = -y1;\n\t} else if (sscanf(p, \"-%d+%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"-%d-%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = -y1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "accept_cmd",
            "\"+-\""
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p+1",
            "\"%d\"",
            "&in"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "accept_cmd",
            "':'"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ident_username",
          "args": [
            "client"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "ident_username",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "266-411",
          "snippet": "char *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "char *raw2host(char *raw, int len);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "char *ident_username(rfbClientPtr client);",
            "int accept_unix(int s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nchar *ident_username(rfbClientPtr client);\nint accept_unix(int s);\n\nchar *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "accept_cmd",
            "\"popup\""
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint accept_client(rfbClientPtr client) {\n\n\tchar xmessage[200], *cmd = NULL;\n\tchar *addr = client->host;\n\tchar *action = NULL;\n\n\tif (accept_cmd == NULL || *accept_cmd == '\\0') {\n\t\treturn 1;\t/* no command specified, so we accept */\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\tif (strstr(accept_cmd, \"popup\") == accept_cmd) {\n\t\t/* use our builtin popup button */\n\n\t\t/* (popup|popupkey|popupmouse)[+-X+-Y][:timeout] */\n\n\t\tint ret, timeout = 120;\n\t\tint x = -64000, y = -64000;\n\t\tchar *p, *mode;\n\t\tchar *userhost = ident_username(client);\n\n\t\t/* extract timeout */\n\t\tif ((p = strchr(accept_cmd, ':')) != NULL) {\n\t\t\tint in;\n\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\ttimeout = in;\n\t\t\t}\n\t\t}\n\t\t/* extract geometry */\n\t\tif ((p = strpbrk(accept_cmd, \"+-\")) != NULL) {\n\t\t\tugly_geom(p, &x, &y);\n\t\t}\n\n\t\t/* find mode: mouse, key, or both */\n\t\tif (strstr(accept_cmd, \"popupmouse\") == accept_cmd) {\n\t\t\tmode = \"mouse_only\";\n\t\t} else if (strstr(accept_cmd, \"popupkey\") == accept_cmd) {\n\t\t\tmode = \"key_only\";\n\t\t} else {\n\t\t\tmode = \"both\";\n\t\t}\n\n\t\tif (dpy == NULL && use_dpy && strstr(use_dpy, \"WAIT:\") ==\n\t\t    use_dpy) {\n\t\t\trfbLog(\"accept_client: warning allowing client under conditions:\\n\");\n\t\t\trfbLog(\"  -display WAIT:, dpy == NULL, -accept popup.\\n\");\n\t\t\trfbLog(\"   There will be another popup.\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\trfbLog(\"accept_client: using builtin popup for: %s\\n\", addr);\n\t\tif ((ret = ugly_window(addr, userhost, x, y, timeout,\n\t\t    mode, 1))) {\n\t\t\tfree(userhost);\n\t\t\tif (ret == 2) {\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t}\n\t\t\trfbLog(\"accept_client: popup accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfree(userhost);\n\t\t\trfbLog(\"accept_client: popup rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\n\t} else if (!strcmp(accept_cmd, \"xmessage\")) {\n\t\t/* make our own command using xmessage(1) */\n\n\t\tif (view_only) {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2 -center\"\n\t\t\t    \" 'x11vnc: accept connection from %s?'\", addr);\n\t\t} else {\n\t\t\tsprintf(xmessage, \"xmessage -buttons yes:0,no:2,\"\n\t\t\t    \"view-only:3 -center\" \" 'x11vnc: accept connection\"\n\t\t\t    \" from %s?'\", addr);\n\t\t\taction = \"yes:0,no:*,view:3\";\n\t\t}\n\t\tcmd = xmessage;\n\t\t\n\t} else {\n\t\t/* use the user supplied command: */\n\n\t\tcmd = accept_cmd;\n\n\t\t/* extract any action prefix:  yes:N,no:M,view:K */\n\t\tif (strstr(accept_cmd, \"yes:\") == accept_cmd) {\n\t\t\tchar *p;\n\t\t\tif ((p = strpbrk(accept_cmd, \" \\t\")) != NULL) {\n\t\t\t\tint i;\n\t\t\t\tcmd = p;\n\t\t\t\tp = accept_cmd;\n\t\t\t\tfor (i=0; i<200; i++) {\n\t\t\t\t\tif (*p == ' ' || *p == '\\t') {\n\t\t\t\t\t\txmessage[i] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\txmessage[i] = *p;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\txmessage[200-1] = '\\0';\n\t\t\t\taction = xmessage;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd) {\n\t\tint rc;\n\n\t\trfbLog(\"accept_client: using cmd for: %s\\n\", addr);\n\t\trc = run_user_command(cmd, client, \"accept\", NULL, 0, NULL);\n\n\t\tif (action) {\n\t\t\tint result;\n\n\t\t\tif (rc < 0) {\n\t\t\t\trfbLog(\"accept_client: cannot use negative \"\n\t\t\t\t    \"rc: %d, action %s\\n\", rc, action);\n\t\t\t\tresult = 2;\n\t\t\t} else {\n\t\t\t\tresult = action_match(action, rc);\n\t\t\t}\n\n\t\t\tif (result == 1) {\n\t\t\t\trc = 0;\n\t\t\t} else if (result == 2) {\n\t\t\t\trc = 1;\n\t\t\t} else if (result == 3) {\n\t\t\t\trc = 0;\n\t\t\t\trfbLog(\"accept_client: viewonly: %s\\n\", addr);\n\t\t\t\tclient->viewOnly = TRUE;\n\t\t\t} else {\n\t\t\t\trc = 1;\t/* NOTREACHED */\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\trfbLog(\"accept_client: accepted: %s\\n\", addr);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"accept_client: rejected: %s\\n\", addr);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\trfbLog(\"accept_client: no command, rejecting %s\\n\", addr);\n\t\treturn 0;\n\t}\n\n\t/* return 0; NOTREACHED */\n}"
  },
  {
    "function_name": "ugly_geom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "1556-1572",
    "snippet": "static void ugly_geom(char *p, int *x, int *y) {\n\tint x1, y1;\n\n\tif (sscanf(p, \"+%d+%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"+%d-%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = -y1;\n\t} else if (sscanf(p, \"-%d+%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"-%d-%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = -y1;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ugly_geom(char *p, int *x, int *y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"-%d-%d\"",
            "&x1",
            "&y1"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"-%d+%d\"",
            "&x1",
            "&y1"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"+%d-%d\"",
            "&x1",
            "&y1"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p",
            "\"+%d+%d\"",
            "&x1",
            "&y1"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void ugly_geom(char *p, int *x, int *y);\n\nstatic void ugly_geom(char *p, int *x, int *y) {\n\tint x1, y1;\n\n\tif (sscanf(p, \"+%d+%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"+%d-%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = -y1;\n\t} else if (sscanf(p, \"-%d+%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"-%d-%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = -y1;\n\t}\n}"
  },
  {
    "function_name": "action_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "1472-1554",
    "snippet": "static int action_match(char *action, int rc) {\n\tchar *p, *q, *s = strdup(action);\n\tint cases[4], i, result;\n\tchar *labels[4];\n\n\tlabels[1] = \"yes\";\n\tlabels[2] = \"no\";\n\tlabels[3] = \"view\";\n\n\trfbLog(\"accept_client: process action line: %s\\n\",\n\t    action);\n\n\tfor (i=1; i <= 3; i++) {\n\t\tcases[i] = -2;\n\t}\n\n\tp = strtok(s, \",\");\n\twhile (p) {\n\t\tif ((q = strchr(p, ':')) != NULL) {\n\t\t\tint in, k = 1;\n\t\t\t*q = '\\0';\n\t\t\tq++;\n\t\t\tif (strstr(p, \"yes\") == p) {\n\t\t\t\tk = 1;\n\t\t\t} else if (strstr(p, \"no\") == p) {\n\t\t\t\tk = 2;\n\t\t\t} else if (strstr(p, \"view\") == p) {\n\t\t\t\tk = 3;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (*q == '*') {\n\t\t\t\tcases[k] = -1;\n\t\t\t} else if (sscanf(q, \"%d\", &in) == 1) {\n\t\t\t\tif (in < 0) {\n\t\t\t\t\trfbLogEnable(1);\n\t\t\t\t\trfbLog(\"invalid action line: %s\\n\",\n\t\t\t\t\t    action);\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tcases[k] = in;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\n\tresult = -1;\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] == -1) {\n\t\t\trfbLog(\"accept_client: default action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result == -1) {\n\t\trfbLog(\"accept_client: no default action\\n\");\n\t}\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] >= 0 && cases[i] == rc) {\n\t\t\trfbLog(\"accept_client: matched action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result < 0) {\n\t\trfbLog(\"no action match: %s rc=%d set to no\\n\", action, rc);\n\t\tresult = 2;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "static int action_match(char *action, int rc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"no action match: %s rc=%d set to no\\n\"",
            "action",
            "rc"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: matched action is case=%d %s\\n\"",
            "i",
            "labels[i]"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: no default action\\n\""
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: default action is case=%d %s\\n\"",
            "i",
            "labels[i]"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid action line: %s\\n\"",
            "action"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid action line: %s\\n\"",
            "action"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid action line: %s\\n\"",
            "action"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"%d\"",
            "&in"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid action line: %s\\n\"",
            "action"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"view\""
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"no\""
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"yes\""
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "':'"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "s",
            "\",\""
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"accept_client: process action line: %s\\n\"",
            "action"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "action"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nstatic int action_match(char *action, int rc);\n\nstatic int action_match(char *action, int rc) {\n\tchar *p, *q, *s = strdup(action);\n\tint cases[4], i, result;\n\tchar *labels[4];\n\n\tlabels[1] = \"yes\";\n\tlabels[2] = \"no\";\n\tlabels[3] = \"view\";\n\n\trfbLog(\"accept_client: process action line: %s\\n\",\n\t    action);\n\n\tfor (i=1; i <= 3; i++) {\n\t\tcases[i] = -2;\n\t}\n\n\tp = strtok(s, \",\");\n\twhile (p) {\n\t\tif ((q = strchr(p, ':')) != NULL) {\n\t\t\tint in, k = 1;\n\t\t\t*q = '\\0';\n\t\t\tq++;\n\t\t\tif (strstr(p, \"yes\") == p) {\n\t\t\t\tk = 1;\n\t\t\t} else if (strstr(p, \"no\") == p) {\n\t\t\t\tk = 2;\n\t\t\t} else if (strstr(p, \"view\") == p) {\n\t\t\t\tk = 3;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\tif (*q == '*') {\n\t\t\t\tcases[k] = -1;\n\t\t\t} else if (sscanf(q, \"%d\", &in) == 1) {\n\t\t\t\tif (in < 0) {\n\t\t\t\t\trfbLogEnable(1);\n\t\t\t\t\trfbLog(\"invalid action line: %s\\n\",\n\t\t\t\t\t    action);\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t\tcases[k] = in;\n\t\t\t} else {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid action line: %s\\n\", action);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(s);\n\n\tresult = -1;\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] == -1) {\n\t\t\trfbLog(\"accept_client: default action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result == -1) {\n\t\trfbLog(\"accept_client: no default action\\n\");\n\t}\n\tfor (i=1; i <= 3; i++) {\n\t\tif (cases[i] >= 0 && cases[i] == rc) {\n\t\t\trfbLog(\"accept_client: matched action is case=%d %s\\n\",\n\t\t\t    i, labels[i]);\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result < 0) {\n\t\trfbLog(\"no action match: %s rc=%d set to no\\n\", action, rc);\n\t\tresult = 2;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "ugly_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "1147-1466",
    "snippet": "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept) {\n#if NO_X11\n\tif (!addr || !userhost || !X || !Y || !timeout || !mode || !accept) {}\n\tRAWFB_RET(0)\n\tnox11_exit(1);\n\treturn 0;\n#else\n\n#define t2x2_width 16\n#define t2x2_height 16\nstatic unsigned char t2x2_bits[] = {\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff,\n   0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33,\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33};\n\n\tWindow awin;\n\tGC gc;\n\tXSizeHints hints;\n\tXGCValues values;\n\tstatic XFontStruct *font_info = NULL;\n\tstatic Pixmap ico = 0;\n\tunsigned long valuemask = 0;\n\tstatic char dash_list[] = {20, 40};\n\tint list_length = sizeof(dash_list);\n\n\tAtom wm_protocols;\n\tAtom wm_delete_window;\n\n\tXEvent ev;\n\tlong evmask = ExposureMask | KeyPressMask | ButtonPressMask\n\t    | StructureNotifyMask;\n\tdouble waited = 0.0;\n\n\t/* strings and geometries y/n */\n\tKeyCode key_y, key_n, key_v;\n\tchar strh[100];\n\tchar stri[100];\n\tchar str1_b[] = \"To accept: press \\\"y\\\" or click the \\\"Yes\\\" button\";\n\tchar str2_b[] = \"To reject: press \\\"n\\\" or click the \\\"No\\\" button\";\n\tchar str3_b[] = \"View only: press \\\"v\\\" or click the \\\"View\\\" button\";\n\tchar str1_m[] = \"To accept: click the \\\"Yes\\\" button\";\n\tchar str2_m[] = \"To reject: click the \\\"No\\\" button\";\n\tchar str3_m[] = \"View only: click the \\\"View\\\" button\";\n\tchar str1_k[] = \"To accept: press \\\"y\\\"\";\n\tchar str2_k[] = \"To reject: press \\\"n\\\"\";\n\tchar str3_k[] = \"View only: press \\\"v\\\"\";\n\tchar *str1, *str2, *str3;\n\tchar str_y[] = \"Yes\";\n\tchar str_n[] = \"No\";\n\tchar str_v[] = \"View\";\n\tint x, y, w = 345, h = 175, ret = 0;\n\tint X_sh = 20, Y_sh = 30, dY = 20;\n\tint Ye_x = 20,  Ye_y = 0, Ye_w = 45, Ye_h = 20;\n\tint No_x = 75,  No_y = 0, No_w = 45, No_h = 20; \n\tint Vi_x = 130, Vi_y = 0, Vi_w = 45, Vi_h = 20; \n\tchar *sprop = \"new x11vnc client\";\n\n\tKeyCode key_o;\n\n\tRAWFB_RET(0)\n\n\tif (! accept) {\n\t\tsprintf(str_y, \"OK\");\n\t\tsprop = \"x11vnc client disconnected\";\n\t\th = 110;\n\t\tstr1 = \"\";\n\t\tstr2 = \"\";\n\t\tstr3 = \"\";\n\t} else if (!strcmp(mode, \"mouse_only\")) {\n\t\tstr1 = str1_m;\n\t\tstr2 = str2_m;\n\t\tstr3 = str3_m;\n\t} else if (!strcmp(mode, \"key_only\")) {\n\t\tstr1 = str1_k;\n\t\tstr2 = str2_k;\n\t\tstr3 = str3_k;\n\t\th -= dY;\n\t} else {\n\t\tstr1 = str1_b;\n\t\tstr2 = str2_b;\n\t\tstr3 = str3_b;\n\t}\n\tif (view_only) {\n\t\th -= dY;\n\t}\n\n\t/* XXX handle coff_x/coff_y? */\n\tif (X < -dpy_x) {\n\t\tx = (dpy_x - w)/2;\t/* large negative: center */\n\t\tif (x < 0) x = 0;\n\t} else if (X < 0) {\n\t\tx = dpy_x + X - w;\t/* from lower right */\n\t} else {\n\t\tx = X;\t\t\t/* from upper left */\n\t}\n\t\n\tif (Y < -dpy_y) {\n\t\ty = (dpy_y - h)/2;\n\t\tif (y < 0) y = 0;\n\t} else if (Y < 0) {\n\t\ty = dpy_y + Y - h;\n\t} else {\n\t\ty = Y;\n\t}\n\n\tX_LOCK;\n\n\tawin = XCreateSimpleWindow(dpy, window, x, y, w, h, 4,\n\t    BlackPixel(dpy, scr), WhitePixel(dpy, scr));\n\n\twm_protocols = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\twm_delete_window = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\tXSetWMProtocols(dpy, awin, &wm_delete_window, 1);\n\n\tif (! ico) {\n\t\tico = XCreateBitmapFromData(dpy, awin, (char *) t2x2_bits,\n\t\t    t2x2_width, t2x2_height);\n\t}\n\n\thints.flags = PPosition | PSize | PMinSize;\n\thints.x = x;\n\thints.y = y;\n\thints.width = w;\n\thints.height = h;\n\thints.min_width = w;\n\thints.min_height = h;\n\n\tXSetStandardProperties(dpy, awin, sprop, \"x11vnc query\", ico, NULL,\n\t    0, &hints);\n\n\tXSelectInput_wr(dpy, awin, evmask);\n\n\tif (! font_info && (font_info = XLoadQueryFont(dpy, \"fixed\")) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"ugly_window: cannot locate font fixed.\\n\");\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\n\tgc = XCreateGC(dpy, awin, valuemask, &values);\n\tXSetFont(dpy, gc, font_info->fid);\n\tXSetForeground(dpy, gc, BlackPixel(dpy, scr));\n\tXSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter);\n\tXSetDashes(dpy, gc, 0, dash_list, list_length);\n\n\tXMapWindow(dpy, awin);\n\tXFlush_wr(dpy);\n\n\tif (accept) {\n\t\tchar *ip = addr;\n\t\tchar *type = \"accept\";\n\t\tif (unixpw && strstr(userhost, \"UNIX:\") != userhost) {\n\t\t\ttype = \"UNIXPW\";\n\t\t\tif (openssl_last_ip) {\n\t\t\t\tip = openssl_last_ip;\n\t\t\t}\n\t\t}\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: %s connection from %s?\", type, ip);\n\t} else {\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: client disconnected from %s\", addr);\n\t}\n\tsnprintf(stri, sizeof stri, \"        (%s)\", userhost);\n\n\tkey_o = XKeysymToKeycode(dpy, XStringToKeysym(\"o\"));\n\tkey_y = XKeysymToKeycode(dpy, XStringToKeysym(\"y\"));\n\tkey_n = XKeysymToKeycode(dpy, XStringToKeysym(\"n\"));\n\tkey_v = XKeysymToKeycode(dpy, XStringToKeysym(\"v\"));\n\n\twhile (1) {\n\t\tint out = -1, x, y, tw, k;\n\n\t\tif (XCheckWindowEvent(dpy, awin, evmask, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else if (XCheckTypedEvent(dpy, ClientMessage, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else {\n\t\t\tint ms = 100;\t/* sleep a bit */\n\t\t\tusleep(ms * 1000);\n\t\t\twaited += ((double) ms)/1000.;\n\t\t\tif (timeout && (int) waited >= timeout) {\n\t\t\t\trfbLog(\"ugly_window: popup timed out after \"\n\t\t\t\t    \"%d seconds.\\n\", timeout);\n\t\t\t\tout = 0;\n\t\t\t\tev.type = 0;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch(ev.type) {\n\t\tcase Expose:\n\t\t\twhile (XCheckTypedEvent(dpy, Expose, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tk=0;\n\n\t\t\t/* instructions */\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    strh, strlen(strh));\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    stri, strlen(stri));\n\t\t\tif (accept) {\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str1, strlen(str1));\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str2, strlen(str2));\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t\t    str3, strlen(str3));\n\t\t\t  }\n\t\t\t}\n\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* buttons */\n\t\t\tYe_y = Y_sh+k*dY;\n\t\t\tNo_y = Y_sh+k*dY;\n\t\t\tVi_y = Y_sh+k*dY;\n\t\t\tXDrawRectangle(dpy, awin, gc, Ye_x, Ye_y, Ye_w, Ye_h);\n\n\t\t\tif (accept) {\n\t\t\t  XDrawRectangle(dpy, awin, gc, No_x, No_y, No_w, No_h);\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawRectangle(dpy, awin, gc, Vi_x, Vi_y,\n\t\t\t\t    Vi_w, Vi_h);\n\t\t\t  }\n\t\t\t}\n\n\t\t\ttw = XTextWidth(font_info, str_y, strlen(str_y));\n\t\t\ttw = (Ye_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, Ye_x+tw, Ye_y+Ye_h-5,\n\t\t\t    str_y, strlen(str_y));\n\n\t\t\tif (!accept) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw = XTextWidth(font_info, str_n, strlen(str_n));\n\t\t\ttw = (No_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, No_x+tw, No_y+No_h-5,\n\t\t\t    str_n, strlen(str_n));\n\n\t\t\tif (! view_only) {\n\t\t\t\ttw = XTextWidth(font_info, str_v,\n\t\t\t\t    strlen(str_v));\n\t\t\t\ttw = (Vi_w - tw)/2;\n\t\t\t\tif (tw < 0) tw = 1;\n\t\t\t\tXDrawString(dpy, awin, gc, Vi_x+tw,\n\t\t\t\t    Vi_y+Vi_h-5, str_v, strlen(str_v));\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ClientMessage:\n\t\t\tif (ev.xclient.message_type == wm_protocols &&\n\t\t\t    (Atom) ev.xclient.data.l[0] == wm_delete_window) {\n\t\t\t\tout = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ButtonPress:\n\t\t\tx = ev.xbutton.x;\n\t\t\ty = ev.xbutton.y;\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\t;\n\t\t\t} else if (x > Ye_x && x < Ye_x+Ye_w && y > Ye_y\n\t\t\t    && y < Ye_y+Ye_h) {\n\t\t\t\tout = 1;\n\t\t\t} else if (! accept) {\n\t\t\t\t;\n\t\t\t} else if (x > No_x && x < No_x+No_w && y > No_y\n\t\t\t    && y < No_y+No_h) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && x > Vi_x && x < Vi_x+Vi_w\n\t\t\t    && y > Vi_y && y < Vi_y+Ye_h) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KeyPress:\n\t\t\tif (!strcmp(mode, \"mouse_only\")) {\n\t\t\t\t;\n\t\t\t} else if (! accept) {\n\t\t\t\tif (ev.xkey.keycode == key_o) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t\tif (ev.xkey.keycode == key_y) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t} else if (ev.xkey.keycode == key_y) {\n\t\t\t\tout = 1;\n\t\t\t\t;\n\t\t\t} else if (ev.xkey.keycode == key_n) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && ev.xkey.keycode == key_v) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (out != -1) {\n\t\t\tret = out;\n\t\t\tXSelectInput_wr(dpy, awin, 0);\n\t\t\tXUnmapWindow(dpy, awin);\n\t\t\tXFree_wr(gc);\n\t\t\tXDestroyWindow(dpy, awin);\n\t\t\tXFlush_wr(dpy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\treturn ret;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define t2x2_height 16",
      "#define t2x2_width 16"
    ],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "int check_access(char *addr);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);",
      "static void ugly_geom(char *p, int *x, int *y);",
      "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "awin"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "gc"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XUnmapWindow",
          "args": [
            "dpy",
            "awin"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSelectInput_wr",
          "args": [
            "dpy",
            "awin",
            "0"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "XSelectInput_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1678-1697",
          "snippet": "int XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "int XSelectInput_wr(Display *display, Window w, long event_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nint XSelectInput_wr(Display *display, Window w, long event_mask);\n\nint XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"mouse_only\""
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"key_only\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "Vi_x+tw",
            "Vi_y+Vi_h-5",
            "str_v",
            "strlen(str_v)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_v"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTextWidth",
          "args": [
            "font_info",
            "str_v",
            "strlen(str_v)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_v"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "No_x+tw",
            "No_y+No_h-5",
            "str_n",
            "strlen(str_n)"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_n"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTextWidth",
          "args": [
            "font_info",
            "str_n",
            "strlen(str_n)"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_n"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "Ye_x+tw",
            "Ye_y+Ye_h-5",
            "str_y",
            "strlen(str_y)"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_y"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTextWidth",
          "args": [
            "font_info",
            "str_y",
            "strlen(str_y)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_y"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawRectangle",
          "args": [
            "dpy",
            "awin",
            "gc",
            "Vi_x",
            "Vi_y",
            "Vi_w",
            "Vi_h"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawRectangle",
          "args": [
            "dpy",
            "awin",
            "gc",
            "No_x",
            "No_y",
            "No_w",
            "No_h"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawRectangle",
          "args": [
            "dpy",
            "awin",
            "gc",
            "Ye_x",
            "Ye_y",
            "Ye_w",
            "Ye_h"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"key_only\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "X_sh",
            "Y_sh+(k++)*dY",
            "str3",
            "strlen(str3)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str3"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "X_sh",
            "Y_sh+(k++)*dY",
            "str2",
            "strlen(str2)"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str2"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "X_sh",
            "Y_sh+(k++)*dY",
            "str1",
            "strlen(str1)"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str1"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "X_sh",
            "Y_sh+(k++)*dY",
            "stri",
            "strlen(stri)"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "stri"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDrawString",
          "args": [
            "dpy",
            "awin",
            "gc",
            "X_sh",
            "Y_sh+(k++)*dY",
            "strh",
            "strlen(strh)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "strh"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "Expose",
            "&ev"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ugly_window: popup timed out after \"\n\t\t\t\t    \"%d seconds.\\n\"",
            "timeout"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "ms * 1000"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "ClientMessage",
            "&ev"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckWindowEvent",
          "args": [
            "dpy",
            "awin",
            "evmask",
            "&ev"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XKeysymToKeycode",
          "args": [
            "dpy",
            "XStringToKeysym(\"v\")"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "XKeysymToKeycode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2814-2817",
          "snippet": "KeyCode XKeysymToKeycode(Display *display, KeySym keysym) {\n\tif (!display || !keysym) {}\n\treturn NoSymbol;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "KeyCode XKeysymToKeycode(Display *display, KeySym keysym) {\n\tif (!display || !keysym) {}\n\treturn NoSymbol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XStringToKeysym",
          "args": [
            "\"v\""
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "XStringToKeysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "88-1446",
          "snippet": "KeySym XStringToKeysym(char *s) {\n#ifndef XK_0_nosuch\n\tif (!strcmp(s, \"VoidSymbol\")) return XK_VoidSymbol;\n#ifdef XK_MISCELLANY\n\tif (!strcmp(s, \"BackSpace\")) return XK_BackSpace;\n\tif (!strcmp(s, \"Tab\")) return XK_Tab;\n\tif (!strcmp(s, \"Linefeed\")) return XK_Linefeed;\n\tif (!strcmp(s, \"Clear\")) return XK_Clear;\n\tif (!strcmp(s, \"Return\")) return XK_Return;\n\tif (!strcmp(s, \"Pause\")) return XK_Pause;\n\tif (!strcmp(s, \"Scroll_Lock\")) return XK_Scroll_Lock;\n\tif (!strcmp(s, \"Sys_Req\")) return XK_Sys_Req;\n\tif (!strcmp(s, \"Escape\")) return XK_Escape;\n\tif (!strcmp(s, \"Delete\")) return XK_Delete;\n\tif (!strcmp(s, \"Multi_key\")) return XK_Multi_key;\n\tif (!strcmp(s, \"SingleCandidate\")) return XK_SingleCandidate;\n\tif (!strcmp(s, \"MultipleCandidate\")) return XK_MultipleCandidate;\n\tif (!strcmp(s, \"PreviousCandidate\")) return XK_PreviousCandidate;\n\tif (!strcmp(s, \"Kanji\")) return XK_Kanji;\n\tif (!strcmp(s, \"Muhenkan\")) return XK_Muhenkan;\n\tif (!strcmp(s, \"Henkan_Mode\")) return XK_Henkan_Mode;\n\tif (!strcmp(s, \"Henkan\")) return XK_Henkan;\n\tif (!strcmp(s, \"Romaji\")) return XK_Romaji;\n\tif (!strcmp(s, \"Hiragana\")) return XK_Hiragana;\n\tif (!strcmp(s, \"Katakana\")) return XK_Katakana;\n\tif (!strcmp(s, \"Hiragana_Katakana\")) return XK_Hiragana_Katakana;\n\tif (!strcmp(s, \"Zenkaku\")) return XK_Zenkaku;\n\tif (!strcmp(s, \"Hankaku\")) return XK_Hankaku;\n\tif (!strcmp(s, \"Zenkaku_Hankaku\")) return XK_Zenkaku_Hankaku;\n\tif (!strcmp(s, \"Touroku\")) return XK_Touroku;\n\tif (!strcmp(s, \"Massyo\")) return XK_Massyo;\n\tif (!strcmp(s, \"Kana_Lock\")) return XK_Kana_Lock;\n\tif (!strcmp(s, \"Kana_Shift\")) return XK_Kana_Shift;\n\tif (!strcmp(s, \"Eisu_Shift\")) return XK_Eisu_Shift;\n\tif (!strcmp(s, \"Eisu_toggle\")) return XK_Eisu_toggle;\n\tif (!strcmp(s, \"Zen_Koho\")) return XK_Zen_Koho;\n\tif (!strcmp(s, \"Mae_Koho\")) return XK_Mae_Koho;\n\tif (!strcmp(s, \"Home\")) return XK_Home;\n\tif (!strcmp(s, \"Left\")) return XK_Left;\n\tif (!strcmp(s, \"Up\")) return XK_Up;\n\tif (!strcmp(s, \"Right\")) return XK_Right;\n\tif (!strcmp(s, \"Down\")) return XK_Down;\n\tif (!strcmp(s, \"Prior\")) return XK_Prior;\n\tif (!strcmp(s, \"Page_Up\")) return XK_Page_Up;\n\tif (!strcmp(s, \"Next\")) return XK_Next;\n\tif (!strcmp(s, \"Page_Down\")) return XK_Page_Down;\n\tif (!strcmp(s, \"End\")) return XK_End;\n\tif (!strcmp(s, \"Begin\")) return XK_Begin;\n\tif (!strcmp(s, \"Select\")) return XK_Select;\n\tif (!strcmp(s, \"Print\")) return XK_Print;\n\tif (!strcmp(s, \"Execute\")) return XK_Execute;\n\tif (!strcmp(s, \"Insert\")) return XK_Insert;\n\tif (!strcmp(s, \"Undo\")) return XK_Undo;\n\tif (!strcmp(s, \"Redo\")) return XK_Redo;\n\tif (!strcmp(s, \"Menu\")) return XK_Menu;\n\tif (!strcmp(s, \"Find\")) return XK_Find;\n\tif (!strcmp(s, \"Cancel\")) return XK_Cancel;\n\tif (!strcmp(s, \"Help\")) return XK_Help;\n\tif (!strcmp(s, \"Break\")) return XK_Break;\n\tif (!strcmp(s, \"Mode_switch\")) return XK_Mode_switch;\n\tif (!strcmp(s, \"script_switch\")) return XK_script_switch;\n\tif (!strcmp(s, \"Num_Lock\")) return XK_Num_Lock;\n\tif (!strcmp(s, \"KP_Space\")) return XK_KP_Space;\n\tif (!strcmp(s, \"KP_Tab\")) return XK_KP_Tab;\n\tif (!strcmp(s, \"KP_Enter\")) return XK_KP_Enter;\n\tif (!strcmp(s, \"KP_F1\")) return XK_KP_F1;\n\tif (!strcmp(s, \"KP_F2\")) return XK_KP_F2;\n\tif (!strcmp(s, \"KP_F3\")) return XK_KP_F3;\n\tif (!strcmp(s, \"KP_F4\")) return XK_KP_F4;\n\tif (!strcmp(s, \"KP_Home\")) return XK_KP_Home;\n\tif (!strcmp(s, \"KP_Left\")) return XK_KP_Left;\n\tif (!strcmp(s, \"KP_Up\")) return XK_KP_Up;\n\tif (!strcmp(s, \"KP_Right\")) return XK_KP_Right;\n\tif (!strcmp(s, \"KP_Down\")) return XK_KP_Down;\n\tif (!strcmp(s, \"KP_Prior\")) return XK_KP_Prior;\n\tif (!strcmp(s, \"KP_Page_Up\")) return XK_KP_Page_Up;\n\tif (!strcmp(s, \"KP_Next\")) return XK_KP_Next;\n\tif (!strcmp(s, \"KP_Page_Down\")) return XK_KP_Page_Down;\n\tif (!strcmp(s, \"KP_End\")) return XK_KP_End;\n\tif (!strcmp(s, \"KP_Begin\")) return XK_KP_Begin;\n\tif (!strcmp(s, \"KP_Insert\")) return XK_KP_Insert;\n\tif (!strcmp(s, \"KP_Delete\")) return XK_KP_Delete;\n\tif (!strcmp(s, \"KP_Equal\")) return XK_KP_Equal;\n\tif (!strcmp(s, \"KP_Multiply\")) return XK_KP_Multiply;\n\tif (!strcmp(s, \"KP_Add\")) return XK_KP_Add;\n\tif (!strcmp(s, \"KP_Separator\")) return XK_KP_Separator;\n\tif (!strcmp(s, \"KP_Subtract\")) return XK_KP_Subtract;\n\tif (!strcmp(s, \"KP_Decimal\")) return XK_KP_Decimal;\n\tif (!strcmp(s, \"KP_Divide\")) return XK_KP_Divide;\n\tif (!strcmp(s, \"KP_0\")) return XK_KP_0;\n\tif (!strcmp(s, \"KP_1\")) return XK_KP_1;\n\tif (!strcmp(s, \"KP_2\")) return XK_KP_2;\n\tif (!strcmp(s, \"KP_3\")) return XK_KP_3;\n\tif (!strcmp(s, \"KP_4\")) return XK_KP_4;\n\tif (!strcmp(s, \"KP_5\")) return XK_KP_5;\n\tif (!strcmp(s, \"KP_6\")) return XK_KP_6;\n\tif (!strcmp(s, \"KP_7\")) return XK_KP_7;\n\tif (!strcmp(s, \"KP_8\")) return XK_KP_8;\n\tif (!strcmp(s, \"KP_9\")) return XK_KP_9;\n\tif (!strcmp(s, \"F1\")) return XK_F1;\n\tif (!strcmp(s, \"F2\")) return XK_F2;\n\tif (!strcmp(s, \"F3\")) return XK_F3;\n\tif (!strcmp(s, \"F4\")) return XK_F4;\n\tif (!strcmp(s, \"F5\")) return XK_F5;\n\tif (!strcmp(s, \"F6\")) return XK_F6;\n\tif (!strcmp(s, \"F7\")) return XK_F7;\n\tif (!strcmp(s, \"F8\")) return XK_F8;\n\tif (!strcmp(s, \"F9\")) return XK_F9;\n\tif (!strcmp(s, \"F10\")) return XK_F10;\n\tif (!strcmp(s, \"F11\")) return XK_F11;\n\tif (!strcmp(s, \"L1\")) return XK_L1;\n\tif (!strcmp(s, \"F12\")) return XK_F12;\n\tif (!strcmp(s, \"L2\")) return XK_L2;\n\tif (!strcmp(s, \"F13\")) return XK_F13;\n\tif (!strcmp(s, \"L3\")) return XK_L3;\n\tif (!strcmp(s, \"F14\")) return XK_F14;\n\tif (!strcmp(s, \"L4\")) return XK_L4;\n\tif (!strcmp(s, \"F15\")) return XK_F15;\n\tif (!strcmp(s, \"L5\")) return XK_L5;\n\tif (!strcmp(s, \"F16\")) return XK_F16;\n\tif (!strcmp(s, \"L6\")) return XK_L6;\n\tif (!strcmp(s, \"F17\")) return XK_F17;\n\tif (!strcmp(s, \"L7\")) return XK_L7;\n\tif (!strcmp(s, \"F18\")) return XK_F18;\n\tif (!strcmp(s, \"L8\")) return XK_L8;\n\tif (!strcmp(s, \"F19\")) return XK_F19;\n\tif (!strcmp(s, \"L9\")) return XK_L9;\n\tif (!strcmp(s, \"F20\")) return XK_F20;\n\tif (!strcmp(s, \"L10\")) return XK_L10;\n\tif (!strcmp(s, \"F21\")) return XK_F21;\n\tif (!strcmp(s, \"R1\")) return XK_R1;\n\tif (!strcmp(s, \"F22\")) return XK_F22;\n\tif (!strcmp(s, \"R2\")) return XK_R2;\n\tif (!strcmp(s, \"F23\")) return XK_F23;\n\tif (!strcmp(s, \"R3\")) return XK_R3;\n\tif (!strcmp(s, \"F24\")) return XK_F24;\n\tif (!strcmp(s, \"R4\")) return XK_R4;\n\tif (!strcmp(s, \"F25\")) return XK_F25;\n\tif (!strcmp(s, \"R5\")) return XK_R5;\n\tif (!strcmp(s, \"F26\")) return XK_F26;\n\tif (!strcmp(s, \"R6\")) return XK_R6;\n\tif (!strcmp(s, \"F27\")) return XK_F27;\n\tif (!strcmp(s, \"R7\")) return XK_R7;\n\tif (!strcmp(s, \"F28\")) return XK_F28;\n\tif (!strcmp(s, \"R8\")) return XK_R8;\n\tif (!strcmp(s, \"F29\")) return XK_F29;\n\tif (!strcmp(s, \"R9\")) return XK_R9;\n\tif (!strcmp(s, \"F30\")) return XK_F30;\n\tif (!strcmp(s, \"R10\")) return XK_R10;\n\tif (!strcmp(s, \"F31\")) return XK_F31;\n\tif (!strcmp(s, \"R11\")) return XK_R11;\n\tif (!strcmp(s, \"F32\")) return XK_F32;\n\tif (!strcmp(s, \"R12\")) return XK_R12;\n\tif (!strcmp(s, \"F33\")) return XK_F33;\n\tif (!strcmp(s, \"R13\")) return XK_R13;\n\tif (!strcmp(s, \"F34\")) return XK_F34;\n\tif (!strcmp(s, \"R14\")) return XK_R14;\n\tif (!strcmp(s, \"F35\")) return XK_F35;\n\tif (!strcmp(s, \"R15\")) return XK_R15;\n\tif (!strcmp(s, \"Shift_L\")) return XK_Shift_L;\n\tif (!strcmp(s, \"Shift_R\")) return XK_Shift_R;\n\tif (!strcmp(s, \"Control_L\")) return XK_Control_L;\n\tif (!strcmp(s, \"Control_R\")) return XK_Control_R;\n\tif (!strcmp(s, \"Caps_Lock\")) return XK_Caps_Lock;\n\tif (!strcmp(s, \"Shift_Lock\")) return XK_Shift_Lock;\n\tif (!strcmp(s, \"Meta_L\")) return XK_Meta_L;\n\tif (!strcmp(s, \"Meta_R\")) return XK_Meta_R;\n\tif (!strcmp(s, \"Alt_L\")) return XK_Alt_L;\n\tif (!strcmp(s, \"Alt_R\")) return XK_Alt_R;\n\tif (!strcmp(s, \"Super_L\")) return XK_Super_L;\n\tif (!strcmp(s, \"Super_R\")) return XK_Super_R;\n\tif (!strcmp(s, \"Hyper_L\")) return XK_Hyper_L;\n\tif (!strcmp(s, \"Hyper_R\")) return XK_Hyper_R;\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (!strcmp(s, \"ISO_Lock\")) return XK_ISO_Lock;\n\tif (!strcmp(s, \"ISO_Level2_Latch\")) return XK_ISO_Level2_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Shift\")) return XK_ISO_Level3_Shift;\n\tif (!strcmp(s, \"ISO_Level3_Latch\")) return XK_ISO_Level3_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Lock\")) return XK_ISO_Level3_Lock;\n\tif (!strcmp(s, \"ISO_Group_Shift\")) return XK_ISO_Group_Shift;\n\tif (!strcmp(s, \"ISO_Group_Latch\")) return XK_ISO_Group_Latch;\n\tif (!strcmp(s, \"ISO_Group_Lock\")) return XK_ISO_Group_Lock;\n\tif (!strcmp(s, \"ISO_Next_Group\")) return XK_ISO_Next_Group;\n\tif (!strcmp(s, \"ISO_Next_Group_Lock\")) return XK_ISO_Next_Group_Lock;\n\tif (!strcmp(s, \"ISO_Prev_Group\")) return XK_ISO_Prev_Group;\n\tif (!strcmp(s, \"ISO_Prev_Group_Lock\")) return XK_ISO_Prev_Group_Lock;\n\tif (!strcmp(s, \"ISO_First_Group\")) return XK_ISO_First_Group;\n\tif (!strcmp(s, \"ISO_First_Group_Lock\")) return XK_ISO_First_Group_Lock;\n\tif (!strcmp(s, \"ISO_Last_Group\")) return XK_ISO_Last_Group;\n\tif (!strcmp(s, \"ISO_Last_Group_Lock\")) return XK_ISO_Last_Group_Lock;\n\tif (!strcmp(s, \"ISO_Left_Tab\")) return XK_ISO_Left_Tab;\n\tif (!strcmp(s, \"ISO_Move_Line_Up\")) return XK_ISO_Move_Line_Up;\n\tif (!strcmp(s, \"ISO_Move_Line_Down\")) return XK_ISO_Move_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Line_Up\")) return XK_ISO_Partial_Line_Up;\n\tif (!strcmp(s, \"ISO_Partial_Line_Down\")) return XK_ISO_Partial_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Space_Left\")) return XK_ISO_Partial_Space_Left;\n\tif (!strcmp(s, \"ISO_Partial_Space_Right\")) return XK_ISO_Partial_Space_Right;\n\tif (!strcmp(s, \"ISO_Set_Margin_Left\")) return XK_ISO_Set_Margin_Left;\n\tif (!strcmp(s, \"ISO_Set_Margin_Right\")) return XK_ISO_Set_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Margin_Left\")) return XK_ISO_Release_Margin_Left;\n\tif (!strcmp(s, \"ISO_Release_Margin_Right\")) return XK_ISO_Release_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Both_Margins\")) return XK_ISO_Release_Both_Margins;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Left\")) return XK_ISO_Fast_Cursor_Left;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Right\")) return XK_ISO_Fast_Cursor_Right;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Up\")) return XK_ISO_Fast_Cursor_Up;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Down\")) return XK_ISO_Fast_Cursor_Down;\n\tif (!strcmp(s, \"ISO_Continuous_Underline\")) return XK_ISO_Continuous_Underline;\n\tif (!strcmp(s, \"ISO_Discontinuous_Underline\")) return XK_ISO_Discontinuous_Underline;\n\tif (!strcmp(s, \"ISO_Emphasize\")) return XK_ISO_Emphasize;\n\tif (!strcmp(s, \"ISO_Center_Object\")) return XK_ISO_Center_Object;\n\tif (!strcmp(s, \"ISO_Enter\")) return XK_ISO_Enter;\n\tif (!strcmp(s, \"dead_grave\")) return XK_dead_grave;\n\tif (!strcmp(s, \"dead_acute\")) return XK_dead_acute;\n\tif (!strcmp(s, \"dead_circumflex\")) return XK_dead_circumflex;\n\tif (!strcmp(s, \"dead_tilde\")) return XK_dead_tilde;\n\tif (!strcmp(s, \"dead_macron\")) return XK_dead_macron;\n\tif (!strcmp(s, \"dead_breve\")) return XK_dead_breve;\n\tif (!strcmp(s, \"dead_abovedot\")) return XK_dead_abovedot;\n\tif (!strcmp(s, \"dead_diaeresis\")) return XK_dead_diaeresis;\n\tif (!strcmp(s, \"dead_abovering\")) return XK_dead_abovering;\n\tif (!strcmp(s, \"dead_doubleacute\")) return XK_dead_doubleacute;\n\tif (!strcmp(s, \"dead_caron\")) return XK_dead_caron;\n\tif (!strcmp(s, \"dead_cedilla\")) return XK_dead_cedilla;\n\tif (!strcmp(s, \"dead_ogonek\")) return XK_dead_ogonek;\n\tif (!strcmp(s, \"dead_iota\")) return XK_dead_iota;\n\tif (!strcmp(s, \"dead_voiced_sound\")) return XK_dead_voiced_sound;\n\tif (!strcmp(s, \"dead_semivoiced_sound\")) return XK_dead_semivoiced_sound;\n\tif (!strcmp(s, \"dead_belowdot\")) return XK_dead_belowdot;\n\tif (!strcmp(s, \"First_Virtual_Screen\")) return XK_First_Virtual_Screen;\n\tif (!strcmp(s, \"Prev_Virtual_Screen\")) return XK_Prev_Virtual_Screen;\n\tif (!strcmp(s, \"Next_Virtual_Screen\")) return XK_Next_Virtual_Screen;\n\tif (!strcmp(s, \"Last_Virtual_Screen\")) return XK_Last_Virtual_Screen;\n\tif (!strcmp(s, \"Terminate_Server\")) return XK_Terminate_Server;\n\tif (!strcmp(s, \"AccessX_Enable\")) return XK_AccessX_Enable;\n\tif (!strcmp(s, \"AccessX_Feedback_Enable\")) return XK_AccessX_Feedback_Enable;\n\tif (!strcmp(s, \"RepeatKeys_Enable\")) return XK_RepeatKeys_Enable;\n\tif (!strcmp(s, \"SlowKeys_Enable\")) return XK_SlowKeys_Enable;\n\tif (!strcmp(s, \"BounceKeys_Enable\")) return XK_BounceKeys_Enable;\n\tif (!strcmp(s, \"StickyKeys_Enable\")) return XK_StickyKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Enable\")) return XK_MouseKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Accel_Enable\")) return XK_MouseKeys_Accel_Enable;\n\tif (!strcmp(s, \"Overlay1_Enable\")) return XK_Overlay1_Enable;\n\tif (!strcmp(s, \"Overlay2_Enable\")) return XK_Overlay2_Enable;\n\tif (!strcmp(s, \"AudibleBell_Enable\")) return XK_AudibleBell_Enable;\n\tif (!strcmp(s, \"Pointer_Left\")) return XK_Pointer_Left;\n\tif (!strcmp(s, \"Pointer_Right\")) return XK_Pointer_Right;\n\tif (!strcmp(s, \"Pointer_Up\")) return XK_Pointer_Up;\n\tif (!strcmp(s, \"Pointer_Down\")) return XK_Pointer_Down;\n\tif (!strcmp(s, \"Pointer_UpLeft\")) return XK_Pointer_UpLeft;\n\tif (!strcmp(s, \"Pointer_UpRight\")) return XK_Pointer_UpRight;\n\tif (!strcmp(s, \"Pointer_DownLeft\")) return XK_Pointer_DownLeft;\n\tif (!strcmp(s, \"Pointer_DownRight\")) return XK_Pointer_DownRight;\n\tif (!strcmp(s, \"Pointer_Button_Dflt\")) return XK_Pointer_Button_Dflt;\n\tif (!strcmp(s, \"Pointer_Button1\")) return XK_Pointer_Button1;\n\tif (!strcmp(s, \"Pointer_Button2\")) return XK_Pointer_Button2;\n\tif (!strcmp(s, \"Pointer_Button3\")) return XK_Pointer_Button3;\n\tif (!strcmp(s, \"Pointer_Button4\")) return XK_Pointer_Button4;\n\tif (!strcmp(s, \"Pointer_Button5\")) return XK_Pointer_Button5;\n\tif (!strcmp(s, \"Pointer_DblClick_Dflt\")) return XK_Pointer_DblClick_Dflt;\n\tif (!strcmp(s, \"Pointer_DblClick1\")) return XK_Pointer_DblClick1;\n\tif (!strcmp(s, \"Pointer_DblClick2\")) return XK_Pointer_DblClick2;\n\tif (!strcmp(s, \"Pointer_DblClick3\")) return XK_Pointer_DblClick3;\n\tif (!strcmp(s, \"Pointer_DblClick4\")) return XK_Pointer_DblClick4;\n\tif (!strcmp(s, \"Pointer_DblClick5\")) return XK_Pointer_DblClick5;\n\tif (!strcmp(s, \"Pointer_Drag_Dflt\")) return XK_Pointer_Drag_Dflt;\n\tif (!strcmp(s, \"Pointer_Drag1\")) return XK_Pointer_Drag1;\n\tif (!strcmp(s, \"Pointer_Drag2\")) return XK_Pointer_Drag2;\n\tif (!strcmp(s, \"Pointer_Drag3\")) return XK_Pointer_Drag3;\n\tif (!strcmp(s, \"Pointer_Drag4\")) return XK_Pointer_Drag4;\n\tif (!strcmp(s, \"Pointer_Drag5\")) return XK_Pointer_Drag5;\n\tif (!strcmp(s, \"Pointer_EnableKeys\")) return XK_Pointer_EnableKeys;\n\tif (!strcmp(s, \"Pointer_Accelerate\")) return XK_Pointer_Accelerate;\n\tif (!strcmp(s, \"Pointer_DfltBtnNext\")) return XK_Pointer_DfltBtnNext;\n\tif (!strcmp(s, \"Pointer_DfltBtnPrev\")) return XK_Pointer_DfltBtnPrev;\n#endif\n#ifdef XK_3270\n\tif (!strcmp(s, \"3270_Duplicate\")) return XK_3270_Duplicate;\n\tif (!strcmp(s, \"3270_FieldMark\")) return XK_3270_FieldMark;\n\tif (!strcmp(s, \"3270_Right2\")) return XK_3270_Right2;\n\tif (!strcmp(s, \"3270_Left2\")) return XK_3270_Left2;\n\tif (!strcmp(s, \"3270_BackTab\")) return XK_3270_BackTab;\n\tif (!strcmp(s, \"3270_EraseEOF\")) return XK_3270_EraseEOF;\n\tif (!strcmp(s, \"3270_EraseInput\")) return XK_3270_EraseInput;\n\tif (!strcmp(s, \"3270_Reset\")) return XK_3270_Reset;\n\tif (!strcmp(s, \"3270_Quit\")) return XK_3270_Quit;\n\tif (!strcmp(s, \"3270_PA1\")) return XK_3270_PA1;\n\tif (!strcmp(s, \"3270_PA2\")) return XK_3270_PA2;\n\tif (!strcmp(s, \"3270_PA3\")) return XK_3270_PA3;\n\tif (!strcmp(s, \"3270_Test\")) return XK_3270_Test;\n\tif (!strcmp(s, \"3270_Attn\")) return XK_3270_Attn;\n\tif (!strcmp(s, \"3270_CursorBlink\")) return XK_3270_CursorBlink;\n\tif (!strcmp(s, \"3270_AltCursor\")) return XK_3270_AltCursor;\n\tif (!strcmp(s, \"3270_KeyClick\")) return XK_3270_KeyClick;\n\tif (!strcmp(s, \"3270_Jump\")) return XK_3270_Jump;\n\tif (!strcmp(s, \"3270_Ident\")) return XK_3270_Ident;\n\tif (!strcmp(s, \"3270_Rule\")) return XK_3270_Rule;\n\tif (!strcmp(s, \"3270_Copy\")) return XK_3270_Copy;\n\tif (!strcmp(s, \"3270_Play\")) return XK_3270_Play;\n\tif (!strcmp(s, \"3270_Setup\")) return XK_3270_Setup;\n\tif (!strcmp(s, \"3270_Record\")) return XK_3270_Record;\n\tif (!strcmp(s, \"3270_ChangeScreen\")) return XK_3270_ChangeScreen;\n\tif (!strcmp(s, \"3270_DeleteWord\")) return XK_3270_DeleteWord;\n\tif (!strcmp(s, \"3270_ExSelect\")) return XK_3270_ExSelect;\n\tif (!strcmp(s, \"3270_CursorSelect\")) return XK_3270_CursorSelect;\n\tif (!strcmp(s, \"3270_PrintScreen\")) return XK_3270_PrintScreen;\n\tif (!strcmp(s, \"3270_Enter\")) return XK_3270_Enter;\n#endif\n#ifdef XK_LATIN1\n\tif (!strcmp(s, \"space\")) return XK_space;\n\tif (!strcmp(s, \"exclam\")) return XK_exclam;\n\tif (!strcmp(s, \"quotedbl\")) return XK_quotedbl;\n\tif (!strcmp(s, \"numbersign\")) return XK_numbersign;\n\tif (!strcmp(s, \"dollar\")) return XK_dollar;\n\tif (!strcmp(s, \"percent\")) return XK_percent;\n\tif (!strcmp(s, \"ampersand\")) return XK_ampersand;\n\tif (!strcmp(s, \"apostrophe\")) return XK_apostrophe;\n\tif (!strcmp(s, \"quoteright\")) return XK_quoteright;\n\tif (!strcmp(s, \"parenleft\")) return XK_parenleft;\n\tif (!strcmp(s, \"parenright\")) return XK_parenright;\n\tif (!strcmp(s, \"asterisk\")) return XK_asterisk;\n\tif (!strcmp(s, \"plus\")) return XK_plus;\n\tif (!strcmp(s, \"comma\")) return XK_comma;\n\tif (!strcmp(s, \"minus\")) return XK_minus;\n\tif (!strcmp(s, \"period\")) return XK_period;\n\tif (!strcmp(s, \"slash\")) return XK_slash;\n\tif (!strcmp(s, \"0\")) return XK_0;\n\tif (!strcmp(s, \"1\")) return XK_1;\n\tif (!strcmp(s, \"2\")) return XK_2;\n\tif (!strcmp(s, \"3\")) return XK_3;\n\tif (!strcmp(s, \"4\")) return XK_4;\n\tif (!strcmp(s, \"5\")) return XK_5;\n\tif (!strcmp(s, \"6\")) return XK_6;\n\tif (!strcmp(s, \"7\")) return XK_7;\n\tif (!strcmp(s, \"8\")) return XK_8;\n\tif (!strcmp(s, \"9\")) return XK_9;\n\tif (!strcmp(s, \"colon\")) return XK_colon;\n\tif (!strcmp(s, \"semicolon\")) return XK_semicolon;\n\tif (!strcmp(s, \"less\")) return XK_less;\n\tif (!strcmp(s, \"equal\")) return XK_equal;\n\tif (!strcmp(s, \"greater\")) return XK_greater;\n\tif (!strcmp(s, \"question\")) return XK_question;\n\tif (!strcmp(s, \"at\")) return XK_at;\n\tif (!strcmp(s, \"A\")) return XK_A;\n\tif (!strcmp(s, \"B\")) return XK_B;\n\tif (!strcmp(s, \"C\")) return XK_C;\n\tif (!strcmp(s, \"D\")) return XK_D;\n\tif (!strcmp(s, \"E\")) return XK_E;\n\tif (!strcmp(s, \"F\")) return XK_F;\n\tif (!strcmp(s, \"G\")) return XK_G;\n\tif (!strcmp(s, \"H\")) return XK_H;\n\tif (!strcmp(s, \"I\")) return XK_I;\n\tif (!strcmp(s, \"J\")) return XK_J;\n\tif (!strcmp(s, \"K\")) return XK_K;\n\tif (!strcmp(s, \"L\")) return XK_L;\n\tif (!strcmp(s, \"M\")) return XK_M;\n\tif (!strcmp(s, \"N\")) return XK_N;\n\tif (!strcmp(s, \"O\")) return XK_O;\n\tif (!strcmp(s, \"P\")) return XK_P;\n\tif (!strcmp(s, \"Q\")) return XK_Q;\n\tif (!strcmp(s, \"R\")) return XK_R;\n\tif (!strcmp(s, \"S\")) return XK_S;\n\tif (!strcmp(s, \"T\")) return XK_T;\n\tif (!strcmp(s, \"U\")) return XK_U;\n\tif (!strcmp(s, \"V\")) return XK_V;\n\tif (!strcmp(s, \"W\")) return XK_W;\n\tif (!strcmp(s, \"X\")) return XK_X;\n\tif (!strcmp(s, \"Y\")) return XK_Y;\n\tif (!strcmp(s, \"Z\")) return XK_Z;\n\tif (!strcmp(s, \"bracketleft\")) return XK_bracketleft;\n\tif (!strcmp(s, \"backslash\")) return XK_backslash;\n\tif (!strcmp(s, \"bracketright\")) return XK_bracketright;\n\tif (!strcmp(s, \"asciicircum\")) return XK_asciicircum;\n\tif (!strcmp(s, \"underscore\")) return XK_underscore;\n\tif (!strcmp(s, \"grave\")) return XK_grave;\n\tif (!strcmp(s, \"quoteleft\")) return XK_quoteleft;\n\tif (!strcmp(s, \"a\")) return XK_a;\n\tif (!strcmp(s, \"b\")) return XK_b;\n\tif (!strcmp(s, \"c\")) return XK_c;\n\tif (!strcmp(s, \"d\")) return XK_d;\n\tif (!strcmp(s, \"e\")) return XK_e;\n\tif (!strcmp(s, \"f\")) return XK_f;\n\tif (!strcmp(s, \"g\")) return XK_g;\n\tif (!strcmp(s, \"h\")) return XK_h;\n\tif (!strcmp(s, \"i\")) return XK_i;\n\tif (!strcmp(s, \"j\")) return XK_j;\n\tif (!strcmp(s, \"k\")) return XK_k;\n\tif (!strcmp(s, \"l\")) return XK_l;\n\tif (!strcmp(s, \"m\")) return XK_m;\n\tif (!strcmp(s, \"n\")) return XK_n;\n\tif (!strcmp(s, \"o\")) return XK_o;\n\tif (!strcmp(s, \"p\")) return XK_p;\n\tif (!strcmp(s, \"q\")) return XK_q;\n\tif (!strcmp(s, \"r\")) return XK_r;\n\tif (!strcmp(s, \"s\")) return XK_s;\n\tif (!strcmp(s, \"t\")) return XK_t;\n\tif (!strcmp(s, \"u\")) return XK_u;\n\tif (!strcmp(s, \"v\")) return XK_v;\n\tif (!strcmp(s, \"w\")) return XK_w;\n\tif (!strcmp(s, \"x\")) return XK_x;\n\tif (!strcmp(s, \"y\")) return XK_y;\n\tif (!strcmp(s, \"z\")) return XK_z;\n\tif (!strcmp(s, \"braceleft\")) return XK_braceleft;\n\tif (!strcmp(s, \"bar\")) return XK_bar;\n\tif (!strcmp(s, \"braceright\")) return XK_braceright;\n\tif (!strcmp(s, \"asciitilde\")) return XK_asciitilde;\n\tif (!strcmp(s, \"nobreakspace\")) return XK_nobreakspace;\n\tif (!strcmp(s, \"exclamdown\")) return XK_exclamdown;\n\tif (!strcmp(s, \"cent\")) return XK_cent;\n\tif (!strcmp(s, \"sterling\")) return XK_sterling;\n\tif (!strcmp(s, \"currency\")) return XK_currency;\n\tif (!strcmp(s, \"yen\")) return XK_yen;\n\tif (!strcmp(s, \"brokenbar\")) return XK_brokenbar;\n\tif (!strcmp(s, \"section\")) return XK_section;\n\tif (!strcmp(s, \"diaeresis\")) return XK_diaeresis;\n\tif (!strcmp(s, \"copyright\")) return XK_copyright;\n\tif (!strcmp(s, \"ordfeminine\")) return XK_ordfeminine;\n\tif (!strcmp(s, \"guillemotleft\")) return XK_guillemotleft;\n\tif (!strcmp(s, \"notsign\")) return XK_notsign;\n\tif (!strcmp(s, \"hyphen\")) return XK_hyphen;\n\tif (!strcmp(s, \"registered\")) return XK_registered;\n\tif (!strcmp(s, \"macron\")) return XK_macron;\n\tif (!strcmp(s, \"degree\")) return XK_degree;\n\tif (!strcmp(s, \"plusminus\")) return XK_plusminus;\n\tif (!strcmp(s, \"twosuperior\")) return XK_twosuperior;\n\tif (!strcmp(s, \"threesuperior\")) return XK_threesuperior;\n\tif (!strcmp(s, \"acute\")) return XK_acute;\n\tif (!strcmp(s, \"mu\")) return XK_mu;\n\tif (!strcmp(s, \"paragraph\")) return XK_paragraph;\n\tif (!strcmp(s, \"periodcentered\")) return XK_periodcentered;\n\tif (!strcmp(s, \"cedilla\")) return XK_cedilla;\n\tif (!strcmp(s, \"onesuperior\")) return XK_onesuperior;\n\tif (!strcmp(s, \"masculine\")) return XK_masculine;\n\tif (!strcmp(s, \"guillemotright\")) return XK_guillemotright;\n\tif (!strcmp(s, \"onequarter\")) return XK_onequarter;\n\tif (!strcmp(s, \"onehalf\")) return XK_onehalf;\n\tif (!strcmp(s, \"threequarters\")) return XK_threequarters;\n\tif (!strcmp(s, \"questiondown\")) return XK_questiondown;\n\tif (!strcmp(s, \"Agrave\")) return XK_Agrave;\n\tif (!strcmp(s, \"Aacute\")) return XK_Aacute;\n\tif (!strcmp(s, \"Acircumflex\")) return XK_Acircumflex;\n\tif (!strcmp(s, \"Atilde\")) return XK_Atilde;\n\tif (!strcmp(s, \"Adiaeresis\")) return XK_Adiaeresis;\n\tif (!strcmp(s, \"Aring\")) return XK_Aring;\n\tif (!strcmp(s, \"AE\")) return XK_AE;\n\tif (!strcmp(s, \"Ccedilla\")) return XK_Ccedilla;\n\tif (!strcmp(s, \"Egrave\")) return XK_Egrave;\n\tif (!strcmp(s, \"Eacute\")) return XK_Eacute;\n\tif (!strcmp(s, \"Ecircumflex\")) return XK_Ecircumflex;\n\tif (!strcmp(s, \"Ediaeresis\")) return XK_Ediaeresis;\n\tif (!strcmp(s, \"Igrave\")) return XK_Igrave;\n\tif (!strcmp(s, \"Iacute\")) return XK_Iacute;\n\tif (!strcmp(s, \"Icircumflex\")) return XK_Icircumflex;\n\tif (!strcmp(s, \"Idiaeresis\")) return XK_Idiaeresis;\n\tif (!strcmp(s, \"ETH\")) return XK_ETH;\n\tif (!strcmp(s, \"Eth\")) return XK_Eth;\n\tif (!strcmp(s, \"Ntilde\")) return XK_Ntilde;\n\tif (!strcmp(s, \"Ograve\")) return XK_Ograve;\n\tif (!strcmp(s, \"Oacute\")) return XK_Oacute;\n\tif (!strcmp(s, \"Ocircumflex\")) return XK_Ocircumflex;\n\tif (!strcmp(s, \"Otilde\")) return XK_Otilde;\n\tif (!strcmp(s, \"Odiaeresis\")) return XK_Odiaeresis;\n\tif (!strcmp(s, \"multiply\")) return XK_multiply;\n\tif (!strcmp(s, \"Ooblique\")) return XK_Ooblique;\n\tif (!strcmp(s, \"Ugrave\")) return XK_Ugrave;\n\tif (!strcmp(s, \"Uacute\")) return XK_Uacute;\n\tif (!strcmp(s, \"Ucircumflex\")) return XK_Ucircumflex;\n\tif (!strcmp(s, \"Udiaeresis\")) return XK_Udiaeresis;\n\tif (!strcmp(s, \"Yacute\")) return XK_Yacute;\n\tif (!strcmp(s, \"THORN\")) return XK_THORN;\n\tif (!strcmp(s, \"Thorn\")) return XK_Thorn;\n\tif (!strcmp(s, \"ssharp\")) return XK_ssharp;\n\tif (!strcmp(s, \"agrave\")) return XK_agrave;\n\tif (!strcmp(s, \"aacute\")) return XK_aacute;\n\tif (!strcmp(s, \"acircumflex\")) return XK_acircumflex;\n\tif (!strcmp(s, \"atilde\")) return XK_atilde;\n\tif (!strcmp(s, \"adiaeresis\")) return XK_adiaeresis;\n\tif (!strcmp(s, \"aring\")) return XK_aring;\n\tif (!strcmp(s, \"ae\")) return XK_ae;\n\tif (!strcmp(s, \"ccedilla\")) return XK_ccedilla;\n\tif (!strcmp(s, \"egrave\")) return XK_egrave;\n\tif (!strcmp(s, \"eacute\")) return XK_eacute;\n\tif (!strcmp(s, \"ecircumflex\")) return XK_ecircumflex;\n\tif (!strcmp(s, \"ediaeresis\")) return XK_ediaeresis;\n\tif (!strcmp(s, \"igrave\")) return XK_igrave;\n\tif (!strcmp(s, \"iacute\")) return XK_iacute;\n\tif (!strcmp(s, \"icircumflex\")) return XK_icircumflex;\n\tif (!strcmp(s, \"idiaeresis\")) return XK_idiaeresis;\n\tif (!strcmp(s, \"eth\")) return XK_eth;\n\tif (!strcmp(s, \"ntilde\")) return XK_ntilde;\n\tif (!strcmp(s, \"ograve\")) return XK_ograve;\n\tif (!strcmp(s, \"oacute\")) return XK_oacute;\n\tif (!strcmp(s, \"ocircumflex\")) return XK_ocircumflex;\n\tif (!strcmp(s, \"otilde\")) return XK_otilde;\n\tif (!strcmp(s, \"odiaeresis\")) return XK_odiaeresis;\n\tif (!strcmp(s, \"division\")) return XK_division;\n\tif (!strcmp(s, \"oslash\")) return XK_oslash;\n\tif (!strcmp(s, \"ugrave\")) return XK_ugrave;\n\tif (!strcmp(s, \"uacute\")) return XK_uacute;\n\tif (!strcmp(s, \"ucircumflex\")) return XK_ucircumflex;\n\tif (!strcmp(s, \"udiaeresis\")) return XK_udiaeresis;\n\tif (!strcmp(s, \"yacute\")) return XK_yacute;\n\tif (!strcmp(s, \"thorn\")) return XK_thorn;\n\tif (!strcmp(s, \"ydiaeresis\")) return XK_ydiaeresis;\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (!strcmp(s, \"Aogonek\")) return XK_Aogonek;\n\tif (!strcmp(s, \"breve\")) return XK_breve;\n\tif (!strcmp(s, \"Lstroke\")) return XK_Lstroke;\n\tif (!strcmp(s, \"Lcaron\")) return XK_Lcaron;\n\tif (!strcmp(s, \"Sacute\")) return XK_Sacute;\n\tif (!strcmp(s, \"Scaron\")) return XK_Scaron;\n\tif (!strcmp(s, \"Scedilla\")) return XK_Scedilla;\n\tif (!strcmp(s, \"Tcaron\")) return XK_Tcaron;\n\tif (!strcmp(s, \"Zacute\")) return XK_Zacute;\n\tif (!strcmp(s, \"Zcaron\")) return XK_Zcaron;\n\tif (!strcmp(s, \"Zabovedot\")) return XK_Zabovedot;\n\tif (!strcmp(s, \"aogonek\")) return XK_aogonek;\n\tif (!strcmp(s, \"ogonek\")) return XK_ogonek;\n\tif (!strcmp(s, \"lstroke\")) return XK_lstroke;\n\tif (!strcmp(s, \"lcaron\")) return XK_lcaron;\n\tif (!strcmp(s, \"sacute\")) return XK_sacute;\n\tif (!strcmp(s, \"caron\")) return XK_caron;\n\tif (!strcmp(s, \"scaron\")) return XK_scaron;\n\tif (!strcmp(s, \"scedilla\")) return XK_scedilla;\n\tif (!strcmp(s, \"tcaron\")) return XK_tcaron;\n\tif (!strcmp(s, \"zacute\")) return XK_zacute;\n\tif (!strcmp(s, \"doubleacute\")) return XK_doubleacute;\n\tif (!strcmp(s, \"zcaron\")) return XK_zcaron;\n\tif (!strcmp(s, \"zabovedot\")) return XK_zabovedot;\n\tif (!strcmp(s, \"Racute\")) return XK_Racute;\n\tif (!strcmp(s, \"Abreve\")) return XK_Abreve;\n\tif (!strcmp(s, \"Lacute\")) return XK_Lacute;\n\tif (!strcmp(s, \"Cacute\")) return XK_Cacute;\n\tif (!strcmp(s, \"Ccaron\")) return XK_Ccaron;\n\tif (!strcmp(s, \"Eogonek\")) return XK_Eogonek;\n\tif (!strcmp(s, \"Ecaron\")) return XK_Ecaron;\n\tif (!strcmp(s, \"Dcaron\")) return XK_Dcaron;\n\tif (!strcmp(s, \"Dstroke\")) return XK_Dstroke;\n\tif (!strcmp(s, \"Nacute\")) return XK_Nacute;\n\tif (!strcmp(s, \"Ncaron\")) return XK_Ncaron;\n\tif (!strcmp(s, \"Odoubleacute\")) return XK_Odoubleacute;\n\tif (!strcmp(s, \"Rcaron\")) return XK_Rcaron;\n\tif (!strcmp(s, \"Uring\")) return XK_Uring;\n\tif (!strcmp(s, \"Udoubleacute\")) return XK_Udoubleacute;\n\tif (!strcmp(s, \"Tcedilla\")) return XK_Tcedilla;\n\tif (!strcmp(s, \"racute\")) return XK_racute;\n\tif (!strcmp(s, \"abreve\")) return XK_abreve;\n\tif (!strcmp(s, \"lacute\")) return XK_lacute;\n\tif (!strcmp(s, \"cacute\")) return XK_cacute;\n\tif (!strcmp(s, \"ccaron\")) return XK_ccaron;\n\tif (!strcmp(s, \"eogonek\")) return XK_eogonek;\n\tif (!strcmp(s, \"ecaron\")) return XK_ecaron;\n\tif (!strcmp(s, \"dcaron\")) return XK_dcaron;\n\tif (!strcmp(s, \"dstroke\")) return XK_dstroke;\n\tif (!strcmp(s, \"nacute\")) return XK_nacute;\n\tif (!strcmp(s, \"ncaron\")) return XK_ncaron;\n\tif (!strcmp(s, \"odoubleacute\")) return XK_odoubleacute;\n\tif (!strcmp(s, \"udoubleacute\")) return XK_udoubleacute;\n\tif (!strcmp(s, \"rcaron\")) return XK_rcaron;\n\tif (!strcmp(s, \"uring\")) return XK_uring;\n\tif (!strcmp(s, \"tcedilla\")) return XK_tcedilla;\n\tif (!strcmp(s, \"abovedot\")) return XK_abovedot;\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (!strcmp(s, \"Hstroke\")) return XK_Hstroke;\n\tif (!strcmp(s, \"Hcircumflex\")) return XK_Hcircumflex;\n\tif (!strcmp(s, \"Iabovedot\")) return XK_Iabovedot;\n\tif (!strcmp(s, \"Gbreve\")) return XK_Gbreve;\n\tif (!strcmp(s, \"Jcircumflex\")) return XK_Jcircumflex;\n\tif (!strcmp(s, \"hstroke\")) return XK_hstroke;\n\tif (!strcmp(s, \"hcircumflex\")) return XK_hcircumflex;\n\tif (!strcmp(s, \"idotless\")) return XK_idotless;\n\tif (!strcmp(s, \"gbreve\")) return XK_gbreve;\n\tif (!strcmp(s, \"jcircumflex\")) return XK_jcircumflex;\n\tif (!strcmp(s, \"Cabovedot\")) return XK_Cabovedot;\n\tif (!strcmp(s, \"Ccircumflex\")) return XK_Ccircumflex;\n\tif (!strcmp(s, \"Gabovedot\")) return XK_Gabovedot;\n\tif (!strcmp(s, \"Gcircumflex\")) return XK_Gcircumflex;\n\tif (!strcmp(s, \"Ubreve\")) return XK_Ubreve;\n\tif (!strcmp(s, \"Scircumflex\")) return XK_Scircumflex;\n\tif (!strcmp(s, \"cabovedot\")) return XK_cabovedot;\n\tif (!strcmp(s, \"ccircumflex\")) return XK_ccircumflex;\n\tif (!strcmp(s, \"gabovedot\")) return XK_gabovedot;\n\tif (!strcmp(s, \"gcircumflex\")) return XK_gcircumflex;\n\tif (!strcmp(s, \"ubreve\")) return XK_ubreve;\n\tif (!strcmp(s, \"scircumflex\")) return XK_scircumflex;\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (!strcmp(s, \"kra\")) return XK_kra;\n\tif (!strcmp(s, \"kappa\")) return XK_kappa;\n\tif (!strcmp(s, \"Rcedilla\")) return XK_Rcedilla;\n\tif (!strcmp(s, \"Itilde\")) return XK_Itilde;\n\tif (!strcmp(s, \"Lcedilla\")) return XK_Lcedilla;\n\tif (!strcmp(s, \"Emacron\")) return XK_Emacron;\n\tif (!strcmp(s, \"Gcedilla\")) return XK_Gcedilla;\n\tif (!strcmp(s, \"Tslash\")) return XK_Tslash;\n\tif (!strcmp(s, \"rcedilla\")) return XK_rcedilla;\n\tif (!strcmp(s, \"itilde\")) return XK_itilde;\n\tif (!strcmp(s, \"lcedilla\")) return XK_lcedilla;\n\tif (!strcmp(s, \"emacron\")) return XK_emacron;\n\tif (!strcmp(s, \"gcedilla\")) return XK_gcedilla;\n\tif (!strcmp(s, \"tslash\")) return XK_tslash;\n\tif (!strcmp(s, \"ENG\")) return XK_ENG;\n\tif (!strcmp(s, \"eng\")) return XK_eng;\n\tif (!strcmp(s, \"Amacron\")) return XK_Amacron;\n\tif (!strcmp(s, \"Iogonek\")) return XK_Iogonek;\n\tif (!strcmp(s, \"Eabovedot\")) return XK_Eabovedot;\n\tif (!strcmp(s, \"Imacron\")) return XK_Imacron;\n\tif (!strcmp(s, \"Ncedilla\")) return XK_Ncedilla;\n\tif (!strcmp(s, \"Omacron\")) return XK_Omacron;\n\tif (!strcmp(s, \"Kcedilla\")) return XK_Kcedilla;\n\tif (!strcmp(s, \"Uogonek\")) return XK_Uogonek;\n\tif (!strcmp(s, \"Utilde\")) return XK_Utilde;\n\tif (!strcmp(s, \"Umacron\")) return XK_Umacron;\n\tif (!strcmp(s, \"amacron\")) return XK_amacron;\n\tif (!strcmp(s, \"iogonek\")) return XK_iogonek;\n\tif (!strcmp(s, \"eabovedot\")) return XK_eabovedot;\n\tif (!strcmp(s, \"imacron\")) return XK_imacron;\n\tif (!strcmp(s, \"ncedilla\")) return XK_ncedilla;\n\tif (!strcmp(s, \"omacron\")) return XK_omacron;\n\tif (!strcmp(s, \"kcedilla\")) return XK_kcedilla;\n\tif (!strcmp(s, \"uogonek\")) return XK_uogonek;\n\tif (!strcmp(s, \"utilde\")) return XK_utilde;\n\tif (!strcmp(s, \"umacron\")) return XK_umacron;\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (!strcmp(s, \"overline\")) return XK_overline;\n\tif (!strcmp(s, \"kana_fullstop\")) return XK_kana_fullstop;\n\tif (!strcmp(s, \"kana_openingbracket\")) return XK_kana_openingbracket;\n\tif (!strcmp(s, \"kana_closingbracket\")) return XK_kana_closingbracket;\n\tif (!strcmp(s, \"kana_comma\")) return XK_kana_comma;\n\tif (!strcmp(s, \"kana_conjunctive\")) return XK_kana_conjunctive;\n\tif (!strcmp(s, \"kana_middledot\")) return XK_kana_middledot;\n\tif (!strcmp(s, \"kana_WO\")) return XK_kana_WO;\n\tif (!strcmp(s, \"kana_a\")) return XK_kana_a;\n\tif (!strcmp(s, \"kana_i\")) return XK_kana_i;\n\tif (!strcmp(s, \"kana_u\")) return XK_kana_u;\n\tif (!strcmp(s, \"kana_e\")) return XK_kana_e;\n\tif (!strcmp(s, \"kana_o\")) return XK_kana_o;\n\tif (!strcmp(s, \"kana_ya\")) return XK_kana_ya;\n\tif (!strcmp(s, \"kana_yu\")) return XK_kana_yu;\n\tif (!strcmp(s, \"kana_yo\")) return XK_kana_yo;\n\tif (!strcmp(s, \"kana_tsu\")) return XK_kana_tsu;\n\tif (!strcmp(s, \"kana_tu\")) return XK_kana_tu;\n\tif (!strcmp(s, \"prolongedsound\")) return XK_prolongedsound;\n\tif (!strcmp(s, \"kana_A\")) return XK_kana_A;\n\tif (!strcmp(s, \"kana_I\")) return XK_kana_I;\n\tif (!strcmp(s, \"kana_U\")) return XK_kana_U;\n\tif (!strcmp(s, \"kana_E\")) return XK_kana_E;\n\tif (!strcmp(s, \"kana_O\")) return XK_kana_O;\n\tif (!strcmp(s, \"kana_KA\")) return XK_kana_KA;\n\tif (!strcmp(s, \"kana_KI\")) return XK_kana_KI;\n\tif (!strcmp(s, \"kana_KU\")) return XK_kana_KU;\n\tif (!strcmp(s, \"kana_KE\")) return XK_kana_KE;\n\tif (!strcmp(s, \"kana_KO\")) return XK_kana_KO;\n\tif (!strcmp(s, \"kana_SA\")) return XK_kana_SA;\n\tif (!strcmp(s, \"kana_SHI\")) return XK_kana_SHI;\n\tif (!strcmp(s, \"kana_SU\")) return XK_kana_SU;\n\tif (!strcmp(s, \"kana_SE\")) return XK_kana_SE;\n\tif (!strcmp(s, \"kana_SO\")) return XK_kana_SO;\n\tif (!strcmp(s, \"kana_TA\")) return XK_kana_TA;\n\tif (!strcmp(s, \"kana_CHI\")) return XK_kana_CHI;\n\tif (!strcmp(s, \"kana_TI\")) return XK_kana_TI;\n\tif (!strcmp(s, \"kana_TSU\")) return XK_kana_TSU;\n\tif (!strcmp(s, \"kana_TU\")) return XK_kana_TU;\n\tif (!strcmp(s, \"kana_TE\")) return XK_kana_TE;\n\tif (!strcmp(s, \"kana_TO\")) return XK_kana_TO;\n\tif (!strcmp(s, \"kana_NA\")) return XK_kana_NA;\n\tif (!strcmp(s, \"kana_NI\")) return XK_kana_NI;\n\tif (!strcmp(s, \"kana_NU\")) return XK_kana_NU;\n\tif (!strcmp(s, \"kana_NE\")) return XK_kana_NE;\n\tif (!strcmp(s, \"kana_NO\")) return XK_kana_NO;\n\tif (!strcmp(s, \"kana_HA\")) return XK_kana_HA;\n\tif (!strcmp(s, \"kana_HI\")) return XK_kana_HI;\n\tif (!strcmp(s, \"kana_FU\")) return XK_kana_FU;\n\tif (!strcmp(s, \"kana_HU\")) return XK_kana_HU;\n\tif (!strcmp(s, \"kana_HE\")) return XK_kana_HE;\n\tif (!strcmp(s, \"kana_HO\")) return XK_kana_HO;\n\tif (!strcmp(s, \"kana_MA\")) return XK_kana_MA;\n\tif (!strcmp(s, \"kana_MI\")) return XK_kana_MI;\n\tif (!strcmp(s, \"kana_MU\")) return XK_kana_MU;\n\tif (!strcmp(s, \"kana_ME\")) return XK_kana_ME;\n\tif (!strcmp(s, \"kana_MO\")) return XK_kana_MO;\n\tif (!strcmp(s, \"kana_YA\")) return XK_kana_YA;\n\tif (!strcmp(s, \"kana_YU\")) return XK_kana_YU;\n\tif (!strcmp(s, \"kana_YO\")) return XK_kana_YO;\n\tif (!strcmp(s, \"kana_RA\")) return XK_kana_RA;\n\tif (!strcmp(s, \"kana_RI\")) return XK_kana_RI;\n\tif (!strcmp(s, \"kana_RU\")) return XK_kana_RU;\n\tif (!strcmp(s, \"kana_RE\")) return XK_kana_RE;\n\tif (!strcmp(s, \"kana_RO\")) return XK_kana_RO;\n\tif (!strcmp(s, \"kana_WA\")) return XK_kana_WA;\n\tif (!strcmp(s, \"kana_N\")) return XK_kana_N;\n\tif (!strcmp(s, \"voicedsound\")) return XK_voicedsound;\n\tif (!strcmp(s, \"semivoicedsound\")) return XK_semivoicedsound;\n\tif (!strcmp(s, \"kana_switch\")) return XK_kana_switch;\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (!strcmp(s, \"Arabic_comma\")) return XK_Arabic_comma;\n\tif (!strcmp(s, \"Arabic_semicolon\")) return XK_Arabic_semicolon;\n\tif (!strcmp(s, \"Arabic_question_mark\")) return XK_Arabic_question_mark;\n\tif (!strcmp(s, \"Arabic_hamza\")) return XK_Arabic_hamza;\n\tif (!strcmp(s, \"Arabic_maddaonalef\")) return XK_Arabic_maddaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonalef\")) return XK_Arabic_hamzaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonwaw\")) return XK_Arabic_hamzaonwaw;\n\tif (!strcmp(s, \"Arabic_hamzaunderalef\")) return XK_Arabic_hamzaunderalef;\n\tif (!strcmp(s, \"Arabic_hamzaonyeh\")) return XK_Arabic_hamzaonyeh;\n\tif (!strcmp(s, \"Arabic_alef\")) return XK_Arabic_alef;\n\tif (!strcmp(s, \"Arabic_beh\")) return XK_Arabic_beh;\n\tif (!strcmp(s, \"Arabic_tehmarbuta\")) return XK_Arabic_tehmarbuta;\n\tif (!strcmp(s, \"Arabic_teh\")) return XK_Arabic_teh;\n\tif (!strcmp(s, \"Arabic_theh\")) return XK_Arabic_theh;\n\tif (!strcmp(s, \"Arabic_jeem\")) return XK_Arabic_jeem;\n\tif (!strcmp(s, \"Arabic_hah\")) return XK_Arabic_hah;\n\tif (!strcmp(s, \"Arabic_khah\")) return XK_Arabic_khah;\n\tif (!strcmp(s, \"Arabic_dal\")) return XK_Arabic_dal;\n\tif (!strcmp(s, \"Arabic_thal\")) return XK_Arabic_thal;\n\tif (!strcmp(s, \"Arabic_ra\")) return XK_Arabic_ra;\n\tif (!strcmp(s, \"Arabic_zain\")) return XK_Arabic_zain;\n\tif (!strcmp(s, \"Arabic_seen\")) return XK_Arabic_seen;\n\tif (!strcmp(s, \"Arabic_sheen\")) return XK_Arabic_sheen;\n\tif (!strcmp(s, \"Arabic_sad\")) return XK_Arabic_sad;\n\tif (!strcmp(s, \"Arabic_dad\")) return XK_Arabic_dad;\n\tif (!strcmp(s, \"Arabic_tah\")) return XK_Arabic_tah;\n\tif (!strcmp(s, \"Arabic_zah\")) return XK_Arabic_zah;\n\tif (!strcmp(s, \"Arabic_ain\")) return XK_Arabic_ain;\n\tif (!strcmp(s, \"Arabic_ghain\")) return XK_Arabic_ghain;\n\tif (!strcmp(s, \"Arabic_tatweel\")) return XK_Arabic_tatweel;\n\tif (!strcmp(s, \"Arabic_feh\")) return XK_Arabic_feh;\n\tif (!strcmp(s, \"Arabic_qaf\")) return XK_Arabic_qaf;\n\tif (!strcmp(s, \"Arabic_kaf\")) return XK_Arabic_kaf;\n\tif (!strcmp(s, \"Arabic_lam\")) return XK_Arabic_lam;\n\tif (!strcmp(s, \"Arabic_meem\")) return XK_Arabic_meem;\n\tif (!strcmp(s, \"Arabic_noon\")) return XK_Arabic_noon;\n\tif (!strcmp(s, \"Arabic_ha\")) return XK_Arabic_ha;\n\tif (!strcmp(s, \"Arabic_heh\")) return XK_Arabic_heh;\n\tif (!strcmp(s, \"Arabic_waw\")) return XK_Arabic_waw;\n\tif (!strcmp(s, \"Arabic_alefmaksura\")) return XK_Arabic_alefmaksura;\n\tif (!strcmp(s, \"Arabic_yeh\")) return XK_Arabic_yeh;\n\tif (!strcmp(s, \"Arabic_fathatan\")) return XK_Arabic_fathatan;\n\tif (!strcmp(s, \"Arabic_dammatan\")) return XK_Arabic_dammatan;\n\tif (!strcmp(s, \"Arabic_kasratan\")) return XK_Arabic_kasratan;\n\tif (!strcmp(s, \"Arabic_fatha\")) return XK_Arabic_fatha;\n\tif (!strcmp(s, \"Arabic_damma\")) return XK_Arabic_damma;\n\tif (!strcmp(s, \"Arabic_kasra\")) return XK_Arabic_kasra;\n\tif (!strcmp(s, \"Arabic_shadda\")) return XK_Arabic_shadda;\n\tif (!strcmp(s, \"Arabic_sukun\")) return XK_Arabic_sukun;\n\tif (!strcmp(s, \"Arabic_switch\")) return XK_Arabic_switch;\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (!strcmp(s, \"Serbian_dje\")) return XK_Serbian_dje;\n\tif (!strcmp(s, \"Macedonia_gje\")) return XK_Macedonia_gje;\n\tif (!strcmp(s, \"Cyrillic_io\")) return XK_Cyrillic_io;\n\tif (!strcmp(s, \"Ukrainian_ie\")) return XK_Ukrainian_ie;\n\tif (!strcmp(s, \"Ukranian_je\")) return XK_Ukranian_je;\n\tif (!strcmp(s, \"Macedonia_dse\")) return XK_Macedonia_dse;\n\tif (!strcmp(s, \"Ukrainian_i\")) return XK_Ukrainian_i;\n\tif (!strcmp(s, \"Ukranian_i\")) return XK_Ukranian_i;\n\tif (!strcmp(s, \"Ukrainian_yi\")) return XK_Ukrainian_yi;\n\tif (!strcmp(s, \"Ukranian_yi\")) return XK_Ukranian_yi;\n\tif (!strcmp(s, \"Cyrillic_je\")) return XK_Cyrillic_je;\n\tif (!strcmp(s, \"Serbian_je\")) return XK_Serbian_je;\n\tif (!strcmp(s, \"Cyrillic_lje\")) return XK_Cyrillic_lje;\n\tif (!strcmp(s, \"Serbian_lje\")) return XK_Serbian_lje;\n\tif (!strcmp(s, \"Cyrillic_nje\")) return XK_Cyrillic_nje;\n\tif (!strcmp(s, \"Serbian_nje\")) return XK_Serbian_nje;\n\tif (!strcmp(s, \"Serbian_tshe\")) return XK_Serbian_tshe;\n\tif (!strcmp(s, \"Macedonia_kje\")) return XK_Macedonia_kje;\n\tif (!strcmp(s, \"Byelorussian_shortu\")) return XK_Byelorussian_shortu;\n\tif (!strcmp(s, \"Cyrillic_dzhe\")) return XK_Cyrillic_dzhe;\n\tif (!strcmp(s, \"Serbian_dze\")) return XK_Serbian_dze;\n\tif (!strcmp(s, \"numerosign\")) return XK_numerosign;\n\tif (!strcmp(s, \"Serbian_DJE\")) return XK_Serbian_DJE;\n\tif (!strcmp(s, \"Macedonia_GJE\")) return XK_Macedonia_GJE;\n\tif (!strcmp(s, \"Cyrillic_IO\")) return XK_Cyrillic_IO;\n\tif (!strcmp(s, \"Ukrainian_IE\")) return XK_Ukrainian_IE;\n\tif (!strcmp(s, \"Ukranian_JE\")) return XK_Ukranian_JE;\n\tif (!strcmp(s, \"Macedonia_DSE\")) return XK_Macedonia_DSE;\n\tif (!strcmp(s, \"Ukrainian_I\")) return XK_Ukrainian_I;\n\tif (!strcmp(s, \"Ukranian_I\")) return XK_Ukranian_I;\n\tif (!strcmp(s, \"Ukrainian_YI\")) return XK_Ukrainian_YI;\n\tif (!strcmp(s, \"Ukranian_YI\")) return XK_Ukranian_YI;\n\tif (!strcmp(s, \"Cyrillic_JE\")) return XK_Cyrillic_JE;\n\tif (!strcmp(s, \"Serbian_JE\")) return XK_Serbian_JE;\n\tif (!strcmp(s, \"Cyrillic_LJE\")) return XK_Cyrillic_LJE;\n\tif (!strcmp(s, \"Serbian_LJE\")) return XK_Serbian_LJE;\n\tif (!strcmp(s, \"Cyrillic_NJE\")) return XK_Cyrillic_NJE;\n\tif (!strcmp(s, \"Serbian_NJE\")) return XK_Serbian_NJE;\n\tif (!strcmp(s, \"Serbian_TSHE\")) return XK_Serbian_TSHE;\n\tif (!strcmp(s, \"Macedonia_KJE\")) return XK_Macedonia_KJE;\n\tif (!strcmp(s, \"Byelorussian_SHORTU\")) return XK_Byelorussian_SHORTU;\n\tif (!strcmp(s, \"Cyrillic_DZHE\")) return XK_Cyrillic_DZHE;\n\tif (!strcmp(s, \"Serbian_DZE\")) return XK_Serbian_DZE;\n\tif (!strcmp(s, \"Cyrillic_yu\")) return XK_Cyrillic_yu;\n\tif (!strcmp(s, \"Cyrillic_a\")) return XK_Cyrillic_a;\n\tif (!strcmp(s, \"Cyrillic_be\")) return XK_Cyrillic_be;\n\tif (!strcmp(s, \"Cyrillic_tse\")) return XK_Cyrillic_tse;\n\tif (!strcmp(s, \"Cyrillic_de\")) return XK_Cyrillic_de;\n\tif (!strcmp(s, \"Cyrillic_ie\")) return XK_Cyrillic_ie;\n\tif (!strcmp(s, \"Cyrillic_ef\")) return XK_Cyrillic_ef;\n\tif (!strcmp(s, \"Cyrillic_ghe\")) return XK_Cyrillic_ghe;\n\tif (!strcmp(s, \"Cyrillic_ha\")) return XK_Cyrillic_ha;\n\tif (!strcmp(s, \"Cyrillic_i\")) return XK_Cyrillic_i;\n\tif (!strcmp(s, \"Cyrillic_shorti\")) return XK_Cyrillic_shorti;\n\tif (!strcmp(s, \"Cyrillic_ka\")) return XK_Cyrillic_ka;\n\tif (!strcmp(s, \"Cyrillic_el\")) return XK_Cyrillic_el;\n\tif (!strcmp(s, \"Cyrillic_em\")) return XK_Cyrillic_em;\n\tif (!strcmp(s, \"Cyrillic_en\")) return XK_Cyrillic_en;\n\tif (!strcmp(s, \"Cyrillic_o\")) return XK_Cyrillic_o;\n\tif (!strcmp(s, \"Cyrillic_pe\")) return XK_Cyrillic_pe;\n\tif (!strcmp(s, \"Cyrillic_ya\")) return XK_Cyrillic_ya;\n\tif (!strcmp(s, \"Cyrillic_er\")) return XK_Cyrillic_er;\n\tif (!strcmp(s, \"Cyrillic_es\")) return XK_Cyrillic_es;\n\tif (!strcmp(s, \"Cyrillic_te\")) return XK_Cyrillic_te;\n\tif (!strcmp(s, \"Cyrillic_u\")) return XK_Cyrillic_u;\n\tif (!strcmp(s, \"Cyrillic_zhe\")) return XK_Cyrillic_zhe;\n\tif (!strcmp(s, \"Cyrillic_ve\")) return XK_Cyrillic_ve;\n\tif (!strcmp(s, \"Cyrillic_softsign\")) return XK_Cyrillic_softsign;\n\tif (!strcmp(s, \"Cyrillic_yeru\")) return XK_Cyrillic_yeru;\n\tif (!strcmp(s, \"Cyrillic_ze\")) return XK_Cyrillic_ze;\n\tif (!strcmp(s, \"Cyrillic_sha\")) return XK_Cyrillic_sha;\n\tif (!strcmp(s, \"Cyrillic_e\")) return XK_Cyrillic_e;\n\tif (!strcmp(s, \"Cyrillic_shcha\")) return XK_Cyrillic_shcha;\n\tif (!strcmp(s, \"Cyrillic_che\")) return XK_Cyrillic_che;\n\tif (!strcmp(s, \"Cyrillic_hardsign\")) return XK_Cyrillic_hardsign;\n\tif (!strcmp(s, \"Cyrillic_YU\")) return XK_Cyrillic_YU;\n\tif (!strcmp(s, \"Cyrillic_A\")) return XK_Cyrillic_A;\n\tif (!strcmp(s, \"Cyrillic_BE\")) return XK_Cyrillic_BE;\n\tif (!strcmp(s, \"Cyrillic_TSE\")) return XK_Cyrillic_TSE;\n\tif (!strcmp(s, \"Cyrillic_DE\")) return XK_Cyrillic_DE;\n\tif (!strcmp(s, \"Cyrillic_IE\")) return XK_Cyrillic_IE;\n\tif (!strcmp(s, \"Cyrillic_EF\")) return XK_Cyrillic_EF;\n\tif (!strcmp(s, \"Cyrillic_GHE\")) return XK_Cyrillic_GHE;\n\tif (!strcmp(s, \"Cyrillic_HA\")) return XK_Cyrillic_HA;\n\tif (!strcmp(s, \"Cyrillic_I\")) return XK_Cyrillic_I;\n\tif (!strcmp(s, \"Cyrillic_SHORTI\")) return XK_Cyrillic_SHORTI;\n\tif (!strcmp(s, \"Cyrillic_KA\")) return XK_Cyrillic_KA;\n\tif (!strcmp(s, \"Cyrillic_EL\")) return XK_Cyrillic_EL;\n\tif (!strcmp(s, \"Cyrillic_EM\")) return XK_Cyrillic_EM;\n\tif (!strcmp(s, \"Cyrillic_EN\")) return XK_Cyrillic_EN;\n\tif (!strcmp(s, \"Cyrillic_O\")) return XK_Cyrillic_O;\n\tif (!strcmp(s, \"Cyrillic_PE\")) return XK_Cyrillic_PE;\n\tif (!strcmp(s, \"Cyrillic_YA\")) return XK_Cyrillic_YA;\n\tif (!strcmp(s, \"Cyrillic_ER\")) return XK_Cyrillic_ER;\n\tif (!strcmp(s, \"Cyrillic_ES\")) return XK_Cyrillic_ES;\n\tif (!strcmp(s, \"Cyrillic_TE\")) return XK_Cyrillic_TE;\n\tif (!strcmp(s, \"Cyrillic_U\")) return XK_Cyrillic_U;\n\tif (!strcmp(s, \"Cyrillic_ZHE\")) return XK_Cyrillic_ZHE;\n\tif (!strcmp(s, \"Cyrillic_VE\")) return XK_Cyrillic_VE;\n\tif (!strcmp(s, \"Cyrillic_SOFTSIGN\")) return XK_Cyrillic_SOFTSIGN;\n\tif (!strcmp(s, \"Cyrillic_YERU\")) return XK_Cyrillic_YERU;\n\tif (!strcmp(s, \"Cyrillic_ZE\")) return XK_Cyrillic_ZE;\n\tif (!strcmp(s, \"Cyrillic_SHA\")) return XK_Cyrillic_SHA;\n\tif (!strcmp(s, \"Cyrillic_E\")) return XK_Cyrillic_E;\n\tif (!strcmp(s, \"Cyrillic_SHCHA\")) return XK_Cyrillic_SHCHA;\n\tif (!strcmp(s, \"Cyrillic_CHE\")) return XK_Cyrillic_CHE;\n\tif (!strcmp(s, \"Cyrillic_HARDSIGN\")) return XK_Cyrillic_HARDSIGN;\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (!strcmp(s, \"Greek_ALPHAaccent\")) return XK_Greek_ALPHAaccent;\n\tif (!strcmp(s, \"Greek_EPSILONaccent\")) return XK_Greek_EPSILONaccent;\n\tif (!strcmp(s, \"Greek_ETAaccent\")) return XK_Greek_ETAaccent;\n\tif (!strcmp(s, \"Greek_IOTAaccent\")) return XK_Greek_IOTAaccent;\n\tif (!strcmp(s, \"Greek_IOTAdieresis\")) return XK_Greek_IOTAdieresis;\n\tif (!strcmp(s, \"Greek_OMICRONaccent\")) return XK_Greek_OMICRONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONaccent\")) return XK_Greek_UPSILONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONdieresis\")) return XK_Greek_UPSILONdieresis;\n\tif (!strcmp(s, \"Greek_OMEGAaccent\")) return XK_Greek_OMEGAaccent;\n\tif (!strcmp(s, \"Greek_accentdieresis\")) return XK_Greek_accentdieresis;\n\tif (!strcmp(s, \"Greek_horizbar\")) return XK_Greek_horizbar;\n\tif (!strcmp(s, \"Greek_alphaaccent\")) return XK_Greek_alphaaccent;\n\tif (!strcmp(s, \"Greek_epsilonaccent\")) return XK_Greek_epsilonaccent;\n\tif (!strcmp(s, \"Greek_etaaccent\")) return XK_Greek_etaaccent;\n\tif (!strcmp(s, \"Greek_iotaaccent\")) return XK_Greek_iotaaccent;\n\tif (!strcmp(s, \"Greek_iotadieresis\")) return XK_Greek_iotadieresis;\n\tif (!strcmp(s, \"Greek_iotaaccentdieresis\")) return XK_Greek_iotaaccentdieresis;\n\tif (!strcmp(s, \"Greek_omicronaccent\")) return XK_Greek_omicronaccent;\n\tif (!strcmp(s, \"Greek_upsilonaccent\")) return XK_Greek_upsilonaccent;\n\tif (!strcmp(s, \"Greek_upsilondieresis\")) return XK_Greek_upsilondieresis;\n\tif (!strcmp(s, \"Greek_upsilonaccentdieresis\")) return XK_Greek_upsilonaccentdieresis;\n\tif (!strcmp(s, \"Greek_omegaaccent\")) return XK_Greek_omegaaccent;\n\tif (!strcmp(s, \"Greek_ALPHA\")) return XK_Greek_ALPHA;\n\tif (!strcmp(s, \"Greek_BETA\")) return XK_Greek_BETA;\n\tif (!strcmp(s, \"Greek_GAMMA\")) return XK_Greek_GAMMA;\n\tif (!strcmp(s, \"Greek_DELTA\")) return XK_Greek_DELTA;\n\tif (!strcmp(s, \"Greek_EPSILON\")) return XK_Greek_EPSILON;\n\tif (!strcmp(s, \"Greek_ZETA\")) return XK_Greek_ZETA;\n\tif (!strcmp(s, \"Greek_ETA\")) return XK_Greek_ETA;\n\tif (!strcmp(s, \"Greek_THETA\")) return XK_Greek_THETA;\n\tif (!strcmp(s, \"Greek_IOTA\")) return XK_Greek_IOTA;\n\tif (!strcmp(s, \"Greek_KAPPA\")) return XK_Greek_KAPPA;\n\tif (!strcmp(s, \"Greek_LAMDA\")) return XK_Greek_LAMDA;\n\tif (!strcmp(s, \"Greek_LAMBDA\")) return XK_Greek_LAMBDA;\n\tif (!strcmp(s, \"Greek_MU\")) return XK_Greek_MU;\n\tif (!strcmp(s, \"Greek_NU\")) return XK_Greek_NU;\n\tif (!strcmp(s, \"Greek_XI\")) return XK_Greek_XI;\n\tif (!strcmp(s, \"Greek_OMICRON\")) return XK_Greek_OMICRON;\n\tif (!strcmp(s, \"Greek_PI\")) return XK_Greek_PI;\n\tif (!strcmp(s, \"Greek_RHO\")) return XK_Greek_RHO;\n\tif (!strcmp(s, \"Greek_SIGMA\")) return XK_Greek_SIGMA;\n\tif (!strcmp(s, \"Greek_TAU\")) return XK_Greek_TAU;\n\tif (!strcmp(s, \"Greek_UPSILON\")) return XK_Greek_UPSILON;\n\tif (!strcmp(s, \"Greek_PHI\")) return XK_Greek_PHI;\n\tif (!strcmp(s, \"Greek_CHI\")) return XK_Greek_CHI;\n\tif (!strcmp(s, \"Greek_PSI\")) return XK_Greek_PSI;\n\tif (!strcmp(s, \"Greek_OMEGA\")) return XK_Greek_OMEGA;\n\tif (!strcmp(s, \"Greek_alpha\")) return XK_Greek_alpha;\n\tif (!strcmp(s, \"Greek_beta\")) return XK_Greek_beta;\n\tif (!strcmp(s, \"Greek_gamma\")) return XK_Greek_gamma;\n\tif (!strcmp(s, \"Greek_delta\")) return XK_Greek_delta;\n\tif (!strcmp(s, \"Greek_epsilon\")) return XK_Greek_epsilon;\n\tif (!strcmp(s, \"Greek_zeta\")) return XK_Greek_zeta;\n\tif (!strcmp(s, \"Greek_eta\")) return XK_Greek_eta;\n\tif (!strcmp(s, \"Greek_theta\")) return XK_Greek_theta;\n\tif (!strcmp(s, \"Greek_iota\")) return XK_Greek_iota;\n\tif (!strcmp(s, \"Greek_kappa\")) return XK_Greek_kappa;\n\tif (!strcmp(s, \"Greek_lamda\")) return XK_Greek_lamda;\n\tif (!strcmp(s, \"Greek_lambda\")) return XK_Greek_lambda;\n\tif (!strcmp(s, \"Greek_mu\")) return XK_Greek_mu;\n\tif (!strcmp(s, \"Greek_nu\")) return XK_Greek_nu;\n\tif (!strcmp(s, \"Greek_xi\")) return XK_Greek_xi;\n\tif (!strcmp(s, \"Greek_omicron\")) return XK_Greek_omicron;\n\tif (!strcmp(s, \"Greek_pi\")) return XK_Greek_pi;\n\tif (!strcmp(s, \"Greek_rho\")) return XK_Greek_rho;\n\tif (!strcmp(s, \"Greek_sigma\")) return XK_Greek_sigma;\n\tif (!strcmp(s, \"Greek_finalsmallsigma\")) return XK_Greek_finalsmallsigma;\n\tif (!strcmp(s, \"Greek_tau\")) return XK_Greek_tau;\n\tif (!strcmp(s, \"Greek_upsilon\")) return XK_Greek_upsilon;\n\tif (!strcmp(s, \"Greek_phi\")) return XK_Greek_phi;\n\tif (!strcmp(s, \"Greek_chi\")) return XK_Greek_chi;\n\tif (!strcmp(s, \"Greek_psi\")) return XK_Greek_psi;\n\tif (!strcmp(s, \"Greek_omega\")) return XK_Greek_omega;\n\tif (!strcmp(s, \"Greek_switch\")) return XK_Greek_switch;\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (!strcmp(s, \"leftradical\")) return XK_leftradical;\n\tif (!strcmp(s, \"topleftradical\")) return XK_topleftradical;\n\tif (!strcmp(s, \"horizconnector\")) return XK_horizconnector;\n\tif (!strcmp(s, \"topintegral\")) return XK_topintegral;\n\tif (!strcmp(s, \"botintegral\")) return XK_botintegral;\n\tif (!strcmp(s, \"vertconnector\")) return XK_vertconnector;\n\tif (!strcmp(s, \"topleftsqbracket\")) return XK_topleftsqbracket;\n\tif (!strcmp(s, \"botleftsqbracket\")) return XK_botleftsqbracket;\n\tif (!strcmp(s, \"toprightsqbracket\")) return XK_toprightsqbracket;\n\tif (!strcmp(s, \"botrightsqbracket\")) return XK_botrightsqbracket;\n\tif (!strcmp(s, \"topleftparens\")) return XK_topleftparens;\n\tif (!strcmp(s, \"botleftparens\")) return XK_botleftparens;\n\tif (!strcmp(s, \"toprightparens\")) return XK_toprightparens;\n\tif (!strcmp(s, \"botrightparens\")) return XK_botrightparens;\n\tif (!strcmp(s, \"leftmiddlecurlybrace\")) return XK_leftmiddlecurlybrace;\n\tif (!strcmp(s, \"rightmiddlecurlybrace\")) return XK_rightmiddlecurlybrace;\n\tif (!strcmp(s, \"topleftsummation\")) return XK_topleftsummation;\n\tif (!strcmp(s, \"botleftsummation\")) return XK_botleftsummation;\n\tif (!strcmp(s, \"topvertsummationconnector\")) return XK_topvertsummationconnector;\n\tif (!strcmp(s, \"botvertsummationconnector\")) return XK_botvertsummationconnector;\n\tif (!strcmp(s, \"toprightsummation\")) return XK_toprightsummation;\n\tif (!strcmp(s, \"botrightsummation\")) return XK_botrightsummation;\n\tif (!strcmp(s, \"rightmiddlesummation\")) return XK_rightmiddlesummation;\n\tif (!strcmp(s, \"lessthanequal\")) return XK_lessthanequal;\n\tif (!strcmp(s, \"notequal\")) return XK_notequal;\n\tif (!strcmp(s, \"greaterthanequal\")) return XK_greaterthanequal;\n\tif (!strcmp(s, \"integral\")) return XK_integral;\n\tif (!strcmp(s, \"therefore\")) return XK_therefore;\n\tif (!strcmp(s, \"variation\")) return XK_variation;\n\tif (!strcmp(s, \"infinity\")) return XK_infinity;\n\tif (!strcmp(s, \"nabla\")) return XK_nabla;\n\tif (!strcmp(s, \"approximate\")) return XK_approximate;\n\tif (!strcmp(s, \"similarequal\")) return XK_similarequal;\n\tif (!strcmp(s, \"ifonlyif\")) return XK_ifonlyif;\n\tif (!strcmp(s, \"implies\")) return XK_implies;\n\tif (!strcmp(s, \"identical\")) return XK_identical;\n\tif (!strcmp(s, \"radical\")) return XK_radical;\n\tif (!strcmp(s, \"includedin\")) return XK_includedin;\n\tif (!strcmp(s, \"includes\")) return XK_includes;\n\tif (!strcmp(s, \"intersection\")) return XK_intersection;\n\tif (!strcmp(s, \"union\")) return XK_union;\n\tif (!strcmp(s, \"logicaland\")) return XK_logicaland;\n\tif (!strcmp(s, \"logicalor\")) return XK_logicalor;\n\tif (!strcmp(s, \"partialderivative\")) return XK_partialderivative;\n\tif (!strcmp(s, \"function\")) return XK_function;\n\tif (!strcmp(s, \"leftarrow\")) return XK_leftarrow;\n\tif (!strcmp(s, \"uparrow\")) return XK_uparrow;\n\tif (!strcmp(s, \"rightarrow\")) return XK_rightarrow;\n\tif (!strcmp(s, \"downarrow\")) return XK_downarrow;\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (!strcmp(s, \"blank\")) return XK_blank;\n\tif (!strcmp(s, \"soliddiamond\")) return XK_soliddiamond;\n\tif (!strcmp(s, \"checkerboard\")) return XK_checkerboard;\n\tif (!strcmp(s, \"ht\")) return XK_ht;\n\tif (!strcmp(s, \"ff\")) return XK_ff;\n\tif (!strcmp(s, \"cr\")) return XK_cr;\n\tif (!strcmp(s, \"lf\")) return XK_lf;\n\tif (!strcmp(s, \"nl\")) return XK_nl;\n\tif (!strcmp(s, \"vt\")) return XK_vt;\n\tif (!strcmp(s, \"lowrightcorner\")) return XK_lowrightcorner;\n\tif (!strcmp(s, \"uprightcorner\")) return XK_uprightcorner;\n\tif (!strcmp(s, \"upleftcorner\")) return XK_upleftcorner;\n\tif (!strcmp(s, \"lowleftcorner\")) return XK_lowleftcorner;\n\tif (!strcmp(s, \"crossinglines\")) return XK_crossinglines;\n\tif (!strcmp(s, \"horizlinescan1\")) return XK_horizlinescan1;\n\tif (!strcmp(s, \"horizlinescan3\")) return XK_horizlinescan3;\n\tif (!strcmp(s, \"horizlinescan5\")) return XK_horizlinescan5;\n\tif (!strcmp(s, \"horizlinescan7\")) return XK_horizlinescan7;\n\tif (!strcmp(s, \"horizlinescan9\")) return XK_horizlinescan9;\n\tif (!strcmp(s, \"leftt\")) return XK_leftt;\n\tif (!strcmp(s, \"rightt\")) return XK_rightt;\n\tif (!strcmp(s, \"bott\")) return XK_bott;\n\tif (!strcmp(s, \"topt\")) return XK_topt;\n\tif (!strcmp(s, \"vertbar\")) return XK_vertbar;\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (!strcmp(s, \"emspace\")) return XK_emspace;\n\tif (!strcmp(s, \"enspace\")) return XK_enspace;\n\tif (!strcmp(s, \"em3space\")) return XK_em3space;\n\tif (!strcmp(s, \"em4space\")) return XK_em4space;\n\tif (!strcmp(s, \"digitspace\")) return XK_digitspace;\n\tif (!strcmp(s, \"punctspace\")) return XK_punctspace;\n\tif (!strcmp(s, \"thinspace\")) return XK_thinspace;\n\tif (!strcmp(s, \"hairspace\")) return XK_hairspace;\n\tif (!strcmp(s, \"emdash\")) return XK_emdash;\n\tif (!strcmp(s, \"endash\")) return XK_endash;\n\tif (!strcmp(s, \"signifblank\")) return XK_signifblank;\n\tif (!strcmp(s, \"ellipsis\")) return XK_ellipsis;\n\tif (!strcmp(s, \"doubbaselinedot\")) return XK_doubbaselinedot;\n\tif (!strcmp(s, \"onethird\")) return XK_onethird;\n\tif (!strcmp(s, \"twothirds\")) return XK_twothirds;\n\tif (!strcmp(s, \"onefifth\")) return XK_onefifth;\n\tif (!strcmp(s, \"twofifths\")) return XK_twofifths;\n\tif (!strcmp(s, \"threefifths\")) return XK_threefifths;\n\tif (!strcmp(s, \"fourfifths\")) return XK_fourfifths;\n\tif (!strcmp(s, \"onesixth\")) return XK_onesixth;\n\tif (!strcmp(s, \"fivesixths\")) return XK_fivesixths;\n\tif (!strcmp(s, \"careof\")) return XK_careof;\n\tif (!strcmp(s, \"figdash\")) return XK_figdash;\n\tif (!strcmp(s, \"leftanglebracket\")) return XK_leftanglebracket;\n\tif (!strcmp(s, \"decimalpoint\")) return XK_decimalpoint;\n\tif (!strcmp(s, \"rightanglebracket\")) return XK_rightanglebracket;\n\tif (!strcmp(s, \"marker\")) return XK_marker;\n\tif (!strcmp(s, \"oneeighth\")) return XK_oneeighth;\n\tif (!strcmp(s, \"threeeighths\")) return XK_threeeighths;\n\tif (!strcmp(s, \"fiveeighths\")) return XK_fiveeighths;\n\tif (!strcmp(s, \"seveneighths\")) return XK_seveneighths;\n\tif (!strcmp(s, \"trademark\")) return XK_trademark;\n\tif (!strcmp(s, \"signaturemark\")) return XK_signaturemark;\n\tif (!strcmp(s, \"trademarkincircle\")) return XK_trademarkincircle;\n\tif (!strcmp(s, \"leftopentriangle\")) return XK_leftopentriangle;\n\tif (!strcmp(s, \"rightopentriangle\")) return XK_rightopentriangle;\n\tif (!strcmp(s, \"emopencircle\")) return XK_emopencircle;\n\tif (!strcmp(s, \"emopenrectangle\")) return XK_emopenrectangle;\n\tif (!strcmp(s, \"leftsinglequotemark\")) return XK_leftsinglequotemark;\n\tif (!strcmp(s, \"rightsinglequotemark\")) return XK_rightsinglequotemark;\n\tif (!strcmp(s, \"leftdoublequotemark\")) return XK_leftdoublequotemark;\n\tif (!strcmp(s, \"rightdoublequotemark\")) return XK_rightdoublequotemark;\n\tif (!strcmp(s, \"prescription\")) return XK_prescription;\n\tif (!strcmp(s, \"minutes\")) return XK_minutes;\n\tif (!strcmp(s, \"seconds\")) return XK_seconds;\n\tif (!strcmp(s, \"latincross\")) return XK_latincross;\n\tif (!strcmp(s, \"hexagram\")) return XK_hexagram;\n\tif (!strcmp(s, \"filledrectbullet\")) return XK_filledrectbullet;\n\tif (!strcmp(s, \"filledlefttribullet\")) return XK_filledlefttribullet;\n\tif (!strcmp(s, \"filledrighttribullet\")) return XK_filledrighttribullet;\n\tif (!strcmp(s, \"emfilledcircle\")) return XK_emfilledcircle;\n\tif (!strcmp(s, \"emfilledrect\")) return XK_emfilledrect;\n\tif (!strcmp(s, \"enopencircbullet\")) return XK_enopencircbullet;\n\tif (!strcmp(s, \"enopensquarebullet\")) return XK_enopensquarebullet;\n\tif (!strcmp(s, \"openrectbullet\")) return XK_openrectbullet;\n\tif (!strcmp(s, \"opentribulletup\")) return XK_opentribulletup;\n\tif (!strcmp(s, \"opentribulletdown\")) return XK_opentribulletdown;\n\tif (!strcmp(s, \"openstar\")) return XK_openstar;\n\tif (!strcmp(s, \"enfilledcircbullet\")) return XK_enfilledcircbullet;\n\tif (!strcmp(s, \"enfilledsqbullet\")) return XK_enfilledsqbullet;\n\tif (!strcmp(s, \"filledtribulletup\")) return XK_filledtribulletup;\n\tif (!strcmp(s, \"filledtribulletdown\")) return XK_filledtribulletdown;\n\tif (!strcmp(s, \"leftpointer\")) return XK_leftpointer;\n\tif (!strcmp(s, \"rightpointer\")) return XK_rightpointer;\n\tif (!strcmp(s, \"club\")) return XK_club;\n\tif (!strcmp(s, \"diamond\")) return XK_diamond;\n\tif (!strcmp(s, \"heart\")) return XK_heart;\n\tif (!strcmp(s, \"maltesecross\")) return XK_maltesecross;\n\tif (!strcmp(s, \"dagger\")) return XK_dagger;\n\tif (!strcmp(s, \"doubledagger\")) return XK_doubledagger;\n\tif (!strcmp(s, \"checkmark\")) return XK_checkmark;\n\tif (!strcmp(s, \"ballotcross\")) return XK_ballotcross;\n\tif (!strcmp(s, \"musicalsharp\")) return XK_musicalsharp;\n\tif (!strcmp(s, \"musicalflat\")) return XK_musicalflat;\n\tif (!strcmp(s, \"malesymbol\")) return XK_malesymbol;\n\tif (!strcmp(s, \"femalesymbol\")) return XK_femalesymbol;\n\tif (!strcmp(s, \"telephone\")) return XK_telephone;\n\tif (!strcmp(s, \"telephonerecorder\")) return XK_telephonerecorder;\n\tif (!strcmp(s, \"phonographcopyright\")) return XK_phonographcopyright;\n\tif (!strcmp(s, \"caret\")) return XK_caret;\n\tif (!strcmp(s, \"singlelowquotemark\")) return XK_singlelowquotemark;\n\tif (!strcmp(s, \"doublelowquotemark\")) return XK_doublelowquotemark;\n\tif (!strcmp(s, \"cursor\")) return XK_cursor;\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (!strcmp(s, \"leftcaret\")) return XK_leftcaret;\n\tif (!strcmp(s, \"rightcaret\")) return XK_rightcaret;\n\tif (!strcmp(s, \"downcaret\")) return XK_downcaret;\n\tif (!strcmp(s, \"upcaret\")) return XK_upcaret;\n\tif (!strcmp(s, \"overbar\")) return XK_overbar;\n\tif (!strcmp(s, \"downtack\")) return XK_downtack;\n\tif (!strcmp(s, \"upshoe\")) return XK_upshoe;\n\tif (!strcmp(s, \"downstile\")) return XK_downstile;\n\tif (!strcmp(s, \"underbar\")) return XK_underbar;\n\tif (!strcmp(s, \"jot\")) return XK_jot;\n\tif (!strcmp(s, \"quad\")) return XK_quad;\n\tif (!strcmp(s, \"uptack\")) return XK_uptack;\n\tif (!strcmp(s, \"circle\")) return XK_circle;\n\tif (!strcmp(s, \"upstile\")) return XK_upstile;\n\tif (!strcmp(s, \"downshoe\")) return XK_downshoe;\n\tif (!strcmp(s, \"rightshoe\")) return XK_rightshoe;\n\tif (!strcmp(s, \"leftshoe\")) return XK_leftshoe;\n\tif (!strcmp(s, \"lefttack\")) return XK_lefttack;\n\tif (!strcmp(s, \"righttack\")) return XK_righttack;\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (!strcmp(s, \"hebrew_doublelowline\")) return XK_hebrew_doublelowline;\n\tif (!strcmp(s, \"hebrew_aleph\")) return XK_hebrew_aleph;\n\tif (!strcmp(s, \"hebrew_bet\")) return XK_hebrew_bet;\n\tif (!strcmp(s, \"hebrew_beth\")) return XK_hebrew_beth;\n\tif (!strcmp(s, \"hebrew_gimel\")) return XK_hebrew_gimel;\n\tif (!strcmp(s, \"hebrew_gimmel\")) return XK_hebrew_gimmel;\n\tif (!strcmp(s, \"hebrew_dalet\")) return XK_hebrew_dalet;\n\tif (!strcmp(s, \"hebrew_daleth\")) return XK_hebrew_daleth;\n\tif (!strcmp(s, \"hebrew_he\")) return XK_hebrew_he;\n\tif (!strcmp(s, \"hebrew_waw\")) return XK_hebrew_waw;\n\tif (!strcmp(s, \"hebrew_zain\")) return XK_hebrew_zain;\n\tif (!strcmp(s, \"hebrew_zayin\")) return XK_hebrew_zayin;\n\tif (!strcmp(s, \"hebrew_chet\")) return XK_hebrew_chet;\n\tif (!strcmp(s, \"hebrew_het\")) return XK_hebrew_het;\n\tif (!strcmp(s, \"hebrew_tet\")) return XK_hebrew_tet;\n\tif (!strcmp(s, \"hebrew_teth\")) return XK_hebrew_teth;\n\tif (!strcmp(s, \"hebrew_yod\")) return XK_hebrew_yod;\n\tif (!strcmp(s, \"hebrew_finalkaph\")) return XK_hebrew_finalkaph;\n\tif (!strcmp(s, \"hebrew_kaph\")) return XK_hebrew_kaph;\n\tif (!strcmp(s, \"hebrew_lamed\")) return XK_hebrew_lamed;\n\tif (!strcmp(s, \"hebrew_finalmem\")) return XK_hebrew_finalmem;\n\tif (!strcmp(s, \"hebrew_mem\")) return XK_hebrew_mem;\n\tif (!strcmp(s, \"hebrew_finalnun\")) return XK_hebrew_finalnun;\n\tif (!strcmp(s, \"hebrew_nun\")) return XK_hebrew_nun;\n\tif (!strcmp(s, \"hebrew_samech\")) return XK_hebrew_samech;\n\tif (!strcmp(s, \"hebrew_samekh\")) return XK_hebrew_samekh;\n\tif (!strcmp(s, \"hebrew_ayin\")) return XK_hebrew_ayin;\n\tif (!strcmp(s, \"hebrew_finalpe\")) return XK_hebrew_finalpe;\n\tif (!strcmp(s, \"hebrew_pe\")) return XK_hebrew_pe;\n\tif (!strcmp(s, \"hebrew_finalzade\")) return XK_hebrew_finalzade;\n\tif (!strcmp(s, \"hebrew_finalzadi\")) return XK_hebrew_finalzadi;\n\tif (!strcmp(s, \"hebrew_zade\")) return XK_hebrew_zade;\n\tif (!strcmp(s, \"hebrew_zadi\")) return XK_hebrew_zadi;\n\tif (!strcmp(s, \"hebrew_qoph\")) return XK_hebrew_qoph;\n\tif (!strcmp(s, \"hebrew_kuf\")) return XK_hebrew_kuf;\n\tif (!strcmp(s, \"hebrew_resh\")) return XK_hebrew_resh;\n\tif (!strcmp(s, \"hebrew_shin\")) return XK_hebrew_shin;\n\tif (!strcmp(s, \"hebrew_taw\")) return XK_hebrew_taw;\n\tif (!strcmp(s, \"hebrew_taf\")) return XK_hebrew_taf;\n\tif (!strcmp(s, \"Hebrew_switch\")) return XK_Hebrew_switch;\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (!strcmp(s, \"Thai_kokai\")) return XK_Thai_kokai;\n\tif (!strcmp(s, \"Thai_khokhai\")) return XK_Thai_khokhai;\n\tif (!strcmp(s, \"Thai_khokhuat\")) return XK_Thai_khokhuat;\n\tif (!strcmp(s, \"Thai_khokhwai\")) return XK_Thai_khokhwai;\n\tif (!strcmp(s, \"Thai_khokhon\")) return XK_Thai_khokhon;\n\tif (!strcmp(s, \"Thai_khorakhang\")) return XK_Thai_khorakhang;\n\tif (!strcmp(s, \"Thai_ngongu\")) return XK_Thai_ngongu;\n\tif (!strcmp(s, \"Thai_chochan\")) return XK_Thai_chochan;\n\tif (!strcmp(s, \"Thai_choching\")) return XK_Thai_choching;\n\tif (!strcmp(s, \"Thai_chochang\")) return XK_Thai_chochang;\n\tif (!strcmp(s, \"Thai_soso\")) return XK_Thai_soso;\n\tif (!strcmp(s, \"Thai_chochoe\")) return XK_Thai_chochoe;\n\tif (!strcmp(s, \"Thai_yoying\")) return XK_Thai_yoying;\n\tif (!strcmp(s, \"Thai_dochada\")) return XK_Thai_dochada;\n\tif (!strcmp(s, \"Thai_topatak\")) return XK_Thai_topatak;\n\tif (!strcmp(s, \"Thai_thothan\")) return XK_Thai_thothan;\n\tif (!strcmp(s, \"Thai_thonangmontho\")) return XK_Thai_thonangmontho;\n\tif (!strcmp(s, \"Thai_thophuthao\")) return XK_Thai_thophuthao;\n\tif (!strcmp(s, \"Thai_nonen\")) return XK_Thai_nonen;\n\tif (!strcmp(s, \"Thai_dodek\")) return XK_Thai_dodek;\n\tif (!strcmp(s, \"Thai_totao\")) return XK_Thai_totao;\n\tif (!strcmp(s, \"Thai_thothung\")) return XK_Thai_thothung;\n\tif (!strcmp(s, \"Thai_thothahan\")) return XK_Thai_thothahan;\n\tif (!strcmp(s, \"Thai_thothong\")) return XK_Thai_thothong;\n\tif (!strcmp(s, \"Thai_nonu\")) return XK_Thai_nonu;\n\tif (!strcmp(s, \"Thai_bobaimai\")) return XK_Thai_bobaimai;\n\tif (!strcmp(s, \"Thai_popla\")) return XK_Thai_popla;\n\tif (!strcmp(s, \"Thai_phophung\")) return XK_Thai_phophung;\n\tif (!strcmp(s, \"Thai_fofa\")) return XK_Thai_fofa;\n\tif (!strcmp(s, \"Thai_phophan\")) return XK_Thai_phophan;\n\tif (!strcmp(s, \"Thai_fofan\")) return XK_Thai_fofan;\n\tif (!strcmp(s, \"Thai_phosamphao\")) return XK_Thai_phosamphao;\n\tif (!strcmp(s, \"Thai_moma\")) return XK_Thai_moma;\n\tif (!strcmp(s, \"Thai_yoyak\")) return XK_Thai_yoyak;\n\tif (!strcmp(s, \"Thai_rorua\")) return XK_Thai_rorua;\n\tif (!strcmp(s, \"Thai_ru\")) return XK_Thai_ru;\n\tif (!strcmp(s, \"Thai_loling\")) return XK_Thai_loling;\n\tif (!strcmp(s, \"Thai_lu\")) return XK_Thai_lu;\n\tif (!strcmp(s, \"Thai_wowaen\")) return XK_Thai_wowaen;\n\tif (!strcmp(s, \"Thai_sosala\")) return XK_Thai_sosala;\n\tif (!strcmp(s, \"Thai_sorusi\")) return XK_Thai_sorusi;\n\tif (!strcmp(s, \"Thai_sosua\")) return XK_Thai_sosua;\n\tif (!strcmp(s, \"Thai_hohip\")) return XK_Thai_hohip;\n\tif (!strcmp(s, \"Thai_lochula\")) return XK_Thai_lochula;\n\tif (!strcmp(s, \"Thai_oang\")) return XK_Thai_oang;\n\tif (!strcmp(s, \"Thai_honokhuk\")) return XK_Thai_honokhuk;\n\tif (!strcmp(s, \"Thai_paiyannoi\")) return XK_Thai_paiyannoi;\n\tif (!strcmp(s, \"Thai_saraa\")) return XK_Thai_saraa;\n\tif (!strcmp(s, \"Thai_maihanakat\")) return XK_Thai_maihanakat;\n\tif (!strcmp(s, \"Thai_saraaa\")) return XK_Thai_saraaa;\n\tif (!strcmp(s, \"Thai_saraam\")) return XK_Thai_saraam;\n\tif (!strcmp(s, \"Thai_sarai\")) return XK_Thai_sarai;\n\tif (!strcmp(s, \"Thai_saraii\")) return XK_Thai_saraii;\n\tif (!strcmp(s, \"Thai_saraue\")) return XK_Thai_saraue;\n\tif (!strcmp(s, \"Thai_sarauee\")) return XK_Thai_sarauee;\n\tif (!strcmp(s, \"Thai_sarau\")) return XK_Thai_sarau;\n\tif (!strcmp(s, \"Thai_sarauu\")) return XK_Thai_sarauu;\n\tif (!strcmp(s, \"Thai_phinthu\")) return XK_Thai_phinthu;\n\tif (!strcmp(s, \"Thai_maihanakat_maitho\")) return XK_Thai_maihanakat_maitho;\n\tif (!strcmp(s, \"Thai_baht\")) return XK_Thai_baht;\n\tif (!strcmp(s, \"Thai_sarae\")) return XK_Thai_sarae;\n\tif (!strcmp(s, \"Thai_saraae\")) return XK_Thai_saraae;\n\tif (!strcmp(s, \"Thai_sarao\")) return XK_Thai_sarao;\n\tif (!strcmp(s, \"Thai_saraaimaimuan\")) return XK_Thai_saraaimaimuan;\n\tif (!strcmp(s, \"Thai_saraaimaimalai\")) return XK_Thai_saraaimaimalai;\n\tif (!strcmp(s, \"Thai_lakkhangyao\")) return XK_Thai_lakkhangyao;\n\tif (!strcmp(s, \"Thai_maiyamok\")) return XK_Thai_maiyamok;\n\tif (!strcmp(s, \"Thai_maitaikhu\")) return XK_Thai_maitaikhu;\n\tif (!strcmp(s, \"Thai_maiek\")) return XK_Thai_maiek;\n\tif (!strcmp(s, \"Thai_maitho\")) return XK_Thai_maitho;\n\tif (!strcmp(s, \"Thai_maitri\")) return XK_Thai_maitri;\n\tif (!strcmp(s, \"Thai_maichattawa\")) return XK_Thai_maichattawa;\n\tif (!strcmp(s, \"Thai_thanthakhat\")) return XK_Thai_thanthakhat;\n\tif (!strcmp(s, \"Thai_nikhahit\")) return XK_Thai_nikhahit;\n\tif (!strcmp(s, \"Thai_leksun\")) return XK_Thai_leksun;\n\tif (!strcmp(s, \"Thai_leknung\")) return XK_Thai_leknung;\n\tif (!strcmp(s, \"Thai_leksong\")) return XK_Thai_leksong;\n\tif (!strcmp(s, \"Thai_leksam\")) return XK_Thai_leksam;\n\tif (!strcmp(s, \"Thai_leksi\")) return XK_Thai_leksi;\n\tif (!strcmp(s, \"Thai_lekha\")) return XK_Thai_lekha;\n\tif (!strcmp(s, \"Thai_lekhok\")) return XK_Thai_lekhok;\n\tif (!strcmp(s, \"Thai_lekchet\")) return XK_Thai_lekchet;\n\tif (!strcmp(s, \"Thai_lekpaet\")) return XK_Thai_lekpaet;\n\tif (!strcmp(s, \"Thai_lekkao\")) return XK_Thai_lekkao;\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (!strcmp(s, \"Hangul\")) return XK_Hangul;\n\tif (!strcmp(s, \"Hangul_Start\")) return XK_Hangul_Start;\n\tif (!strcmp(s, \"Hangul_End\")) return XK_Hangul_End;\n\tif (!strcmp(s, \"Hangul_Hanja\")) return XK_Hangul_Hanja;\n\tif (!strcmp(s, \"Hangul_Jamo\")) return XK_Hangul_Jamo;\n\tif (!strcmp(s, \"Hangul_Romaja\")) return XK_Hangul_Romaja;\n\tif (!strcmp(s, \"Hangul_Codeinput\")) return XK_Hangul_Codeinput;\n\tif (!strcmp(s, \"Hangul_Jeonja\")) return XK_Hangul_Jeonja;\n\tif (!strcmp(s, \"Hangul_Banja\")) return XK_Hangul_Banja;\n\tif (!strcmp(s, \"Hangul_PreHanja\")) return XK_Hangul_PreHanja;\n\tif (!strcmp(s, \"Hangul_PostHanja\")) return XK_Hangul_PostHanja;\n\tif (!strcmp(s, \"Hangul_SingleCandidate\")) return XK_Hangul_SingleCandidate;\n\tif (!strcmp(s, \"Hangul_MultipleCandidate\")) return XK_Hangul_MultipleCandidate;\n\tif (!strcmp(s, \"Hangul_PreviousCandidate\")) return XK_Hangul_PreviousCandidate;\n\tif (!strcmp(s, \"Hangul_Special\")) return XK_Hangul_Special;\n\tif (!strcmp(s, \"Hangul_switch\")) return XK_Hangul_switch;\n\tif (!strcmp(s, \"Hangul_Kiyeog\")) return XK_Hangul_Kiyeog;\n\tif (!strcmp(s, \"Hangul_SsangKiyeog\")) return XK_Hangul_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_KiyeogSios\")) return XK_Hangul_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_Nieun\")) return XK_Hangul_Nieun;\n\tif (!strcmp(s, \"Hangul_NieunJieuj\")) return XK_Hangul_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_NieunHieuh\")) return XK_Hangul_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_Dikeud\")) return XK_Hangul_Dikeud;\n\tif (!strcmp(s, \"Hangul_SsangDikeud\")) return XK_Hangul_SsangDikeud;\n\tif (!strcmp(s, \"Hangul_Rieul\")) return XK_Hangul_Rieul;\n\tif (!strcmp(s, \"Hangul_RieulKiyeog\")) return XK_Hangul_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_RieulMieum\")) return XK_Hangul_RieulMieum;\n\tif (!strcmp(s, \"Hangul_RieulPieub\")) return XK_Hangul_RieulPieub;\n\tif (!strcmp(s, \"Hangul_RieulSios\")) return XK_Hangul_RieulSios;\n\tif (!strcmp(s, \"Hangul_RieulTieut\")) return XK_Hangul_RieulTieut;\n\tif (!strcmp(s, \"Hangul_RieulPhieuf\")) return XK_Hangul_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_RieulHieuh\")) return XK_Hangul_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_Mieum\")) return XK_Hangul_Mieum;\n\tif (!strcmp(s, \"Hangul_Pieub\")) return XK_Hangul_Pieub;\n\tif (!strcmp(s, \"Hangul_SsangPieub\")) return XK_Hangul_SsangPieub;\n\tif (!strcmp(s, \"Hangul_PieubSios\")) return XK_Hangul_PieubSios;\n\tif (!strcmp(s, \"Hangul_Sios\")) return XK_Hangul_Sios;\n\tif (!strcmp(s, \"Hangul_SsangSios\")) return XK_Hangul_SsangSios;\n\tif (!strcmp(s, \"Hangul_Ieung\")) return XK_Hangul_Ieung;\n\tif (!strcmp(s, \"Hangul_Jieuj\")) return XK_Hangul_Jieuj;\n\tif (!strcmp(s, \"Hangul_SsangJieuj\")) return XK_Hangul_SsangJieuj;\n\tif (!strcmp(s, \"Hangul_Cieuc\")) return XK_Hangul_Cieuc;\n\tif (!strcmp(s, \"Hangul_Khieuq\")) return XK_Hangul_Khieuq;\n\tif (!strcmp(s, \"Hangul_Tieut\")) return XK_Hangul_Tieut;\n\tif (!strcmp(s, \"Hangul_Phieuf\")) return XK_Hangul_Phieuf;\n\tif (!strcmp(s, \"Hangul_Hieuh\")) return XK_Hangul_Hieuh;\n\tif (!strcmp(s, \"Hangul_A\")) return XK_Hangul_A;\n\tif (!strcmp(s, \"Hangul_AE\")) return XK_Hangul_AE;\n\tif (!strcmp(s, \"Hangul_YA\")) return XK_Hangul_YA;\n\tif (!strcmp(s, \"Hangul_YAE\")) return XK_Hangul_YAE;\n\tif (!strcmp(s, \"Hangul_EO\")) return XK_Hangul_EO;\n\tif (!strcmp(s, \"Hangul_E\")) return XK_Hangul_E;\n\tif (!strcmp(s, \"Hangul_YEO\")) return XK_Hangul_YEO;\n\tif (!strcmp(s, \"Hangul_YE\")) return XK_Hangul_YE;\n\tif (!strcmp(s, \"Hangul_O\")) return XK_Hangul_O;\n\tif (!strcmp(s, \"Hangul_WA\")) return XK_Hangul_WA;\n\tif (!strcmp(s, \"Hangul_WAE\")) return XK_Hangul_WAE;\n\tif (!strcmp(s, \"Hangul_OE\")) return XK_Hangul_OE;\n\tif (!strcmp(s, \"Hangul_YO\")) return XK_Hangul_YO;\n\tif (!strcmp(s, \"Hangul_U\")) return XK_Hangul_U;\n\tif (!strcmp(s, \"Hangul_WEO\")) return XK_Hangul_WEO;\n\tif (!strcmp(s, \"Hangul_WE\")) return XK_Hangul_WE;\n\tif (!strcmp(s, \"Hangul_WI\")) return XK_Hangul_WI;\n\tif (!strcmp(s, \"Hangul_YU\")) return XK_Hangul_YU;\n\tif (!strcmp(s, \"Hangul_EU\")) return XK_Hangul_EU;\n\tif (!strcmp(s, \"Hangul_YI\")) return XK_Hangul_YI;\n\tif (!strcmp(s, \"Hangul_I\")) return XK_Hangul_I;\n\tif (!strcmp(s, \"Hangul_J_Kiyeog\")) return XK_Hangul_J_Kiyeog;\n\tif (!strcmp(s, \"Hangul_J_SsangKiyeog\")) return XK_Hangul_J_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_J_KiyeogSios\")) return XK_Hangul_J_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_J_Nieun\")) return XK_Hangul_J_Nieun;\n\tif (!strcmp(s, \"Hangul_J_NieunJieuj\")) return XK_Hangul_J_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_J_NieunHieuh\")) return XK_Hangul_J_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_J_Dikeud\")) return XK_Hangul_J_Dikeud;\n\tif (!strcmp(s, \"Hangul_J_Rieul\")) return XK_Hangul_J_Rieul;\n\tif (!strcmp(s, \"Hangul_J_RieulKiyeog\")) return XK_Hangul_J_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_J_RieulMieum\")) return XK_Hangul_J_RieulMieum;\n\tif (!strcmp(s, \"Hangul_J_RieulPieub\")) return XK_Hangul_J_RieulPieub;\n\tif (!strcmp(s, \"Hangul_J_RieulSios\")) return XK_Hangul_J_RieulSios;\n\tif (!strcmp(s, \"Hangul_J_RieulTieut\")) return XK_Hangul_J_RieulTieut;\n\tif (!strcmp(s, \"Hangul_J_RieulPhieuf\")) return XK_Hangul_J_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_J_RieulHieuh\")) return XK_Hangul_J_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_J_Mieum\")) return XK_Hangul_J_Mieum;\n\tif (!strcmp(s, \"Hangul_J_Pieub\")) return XK_Hangul_J_Pieub;\n\tif (!strcmp(s, \"Hangul_J_PieubSios\")) return XK_Hangul_J_PieubSios;\n\tif (!strcmp(s, \"Hangul_J_Sios\")) return XK_Hangul_J_Sios;\n\tif (!strcmp(s, \"Hangul_J_SsangSios\")) return XK_Hangul_J_SsangSios;\n\tif (!strcmp(s, \"Hangul_J_Ieung\")) return XK_Hangul_J_Ieung;\n\tif (!strcmp(s, \"Hangul_J_Jieuj\")) return XK_Hangul_J_Jieuj;\n\tif (!strcmp(s, \"Hangul_J_Cieuc\")) return XK_Hangul_J_Cieuc;\n\tif (!strcmp(s, \"Hangul_J_Khieuq\")) return XK_Hangul_J_Khieuq;\n\tif (!strcmp(s, \"Hangul_J_Tieut\")) return XK_Hangul_J_Tieut;\n\tif (!strcmp(s, \"Hangul_J_Phieuf\")) return XK_Hangul_J_Phieuf;\n\tif (!strcmp(s, \"Hangul_J_Hieuh\")) return XK_Hangul_J_Hieuh;\n\tif (!strcmp(s, \"Hangul_RieulYeorinHieuh\")) return XK_Hangul_RieulYeorinHieuh;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumMieum\")) return XK_Hangul_SunkyeongeumMieum;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPieub\")) return XK_Hangul_SunkyeongeumPieub;\n\tif (!strcmp(s, \"Hangul_PanSios\")) return XK_Hangul_PanSios;\n\tif (!strcmp(s, \"Hangul_KkogjiDalrinIeung\")) return XK_Hangul_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPhieuf\")) return XK_Hangul_SunkyeongeumPhieuf;\n\tif (!strcmp(s, \"Hangul_YeorinHieuh\")) return XK_Hangul_YeorinHieuh;\n\tif (!strcmp(s, \"Hangul_AraeA\")) return XK_Hangul_AraeA;\n\tif (!strcmp(s, \"Hangul_AraeAE\")) return XK_Hangul_AraeAE;\n\tif (!strcmp(s, \"Hangul_J_PanSios\")) return XK_Hangul_J_PanSios;\n\tif (!strcmp(s, \"Hangul_J_KkogjiDalrinIeung\")) return XK_Hangul_J_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_J_YeorinHieuh\")) return XK_Hangul_J_YeorinHieuh;\n\tif (!strcmp(s, \"Korean_Won\")) return XK_Korean_Won;\n#endif /* XK_KOREAN */\n\tif (!strcmp(s, \"EuroSign\")) return XK_EuroSign;\n#endif\n\treturn NoSymbol;\t\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "KeySym XStringToKeysym(char *s) {\n#ifndef XK_0_nosuch\n\tif (!strcmp(s, \"VoidSymbol\")) return XK_VoidSymbol;\n#ifdef XK_MISCELLANY\n\tif (!strcmp(s, \"BackSpace\")) return XK_BackSpace;\n\tif (!strcmp(s, \"Tab\")) return XK_Tab;\n\tif (!strcmp(s, \"Linefeed\")) return XK_Linefeed;\n\tif (!strcmp(s, \"Clear\")) return XK_Clear;\n\tif (!strcmp(s, \"Return\")) return XK_Return;\n\tif (!strcmp(s, \"Pause\")) return XK_Pause;\n\tif (!strcmp(s, \"Scroll_Lock\")) return XK_Scroll_Lock;\n\tif (!strcmp(s, \"Sys_Req\")) return XK_Sys_Req;\n\tif (!strcmp(s, \"Escape\")) return XK_Escape;\n\tif (!strcmp(s, \"Delete\")) return XK_Delete;\n\tif (!strcmp(s, \"Multi_key\")) return XK_Multi_key;\n\tif (!strcmp(s, \"SingleCandidate\")) return XK_SingleCandidate;\n\tif (!strcmp(s, \"MultipleCandidate\")) return XK_MultipleCandidate;\n\tif (!strcmp(s, \"PreviousCandidate\")) return XK_PreviousCandidate;\n\tif (!strcmp(s, \"Kanji\")) return XK_Kanji;\n\tif (!strcmp(s, \"Muhenkan\")) return XK_Muhenkan;\n\tif (!strcmp(s, \"Henkan_Mode\")) return XK_Henkan_Mode;\n\tif (!strcmp(s, \"Henkan\")) return XK_Henkan;\n\tif (!strcmp(s, \"Romaji\")) return XK_Romaji;\n\tif (!strcmp(s, \"Hiragana\")) return XK_Hiragana;\n\tif (!strcmp(s, \"Katakana\")) return XK_Katakana;\n\tif (!strcmp(s, \"Hiragana_Katakana\")) return XK_Hiragana_Katakana;\n\tif (!strcmp(s, \"Zenkaku\")) return XK_Zenkaku;\n\tif (!strcmp(s, \"Hankaku\")) return XK_Hankaku;\n\tif (!strcmp(s, \"Zenkaku_Hankaku\")) return XK_Zenkaku_Hankaku;\n\tif (!strcmp(s, \"Touroku\")) return XK_Touroku;\n\tif (!strcmp(s, \"Massyo\")) return XK_Massyo;\n\tif (!strcmp(s, \"Kana_Lock\")) return XK_Kana_Lock;\n\tif (!strcmp(s, \"Kana_Shift\")) return XK_Kana_Shift;\n\tif (!strcmp(s, \"Eisu_Shift\")) return XK_Eisu_Shift;\n\tif (!strcmp(s, \"Eisu_toggle\")) return XK_Eisu_toggle;\n\tif (!strcmp(s, \"Zen_Koho\")) return XK_Zen_Koho;\n\tif (!strcmp(s, \"Mae_Koho\")) return XK_Mae_Koho;\n\tif (!strcmp(s, \"Home\")) return XK_Home;\n\tif (!strcmp(s, \"Left\")) return XK_Left;\n\tif (!strcmp(s, \"Up\")) return XK_Up;\n\tif (!strcmp(s, \"Right\")) return XK_Right;\n\tif (!strcmp(s, \"Down\")) return XK_Down;\n\tif (!strcmp(s, \"Prior\")) return XK_Prior;\n\tif (!strcmp(s, \"Page_Up\")) return XK_Page_Up;\n\tif (!strcmp(s, \"Next\")) return XK_Next;\n\tif (!strcmp(s, \"Page_Down\")) return XK_Page_Down;\n\tif (!strcmp(s, \"End\")) return XK_End;\n\tif (!strcmp(s, \"Begin\")) return XK_Begin;\n\tif (!strcmp(s, \"Select\")) return XK_Select;\n\tif (!strcmp(s, \"Print\")) return XK_Print;\n\tif (!strcmp(s, \"Execute\")) return XK_Execute;\n\tif (!strcmp(s, \"Insert\")) return XK_Insert;\n\tif (!strcmp(s, \"Undo\")) return XK_Undo;\n\tif (!strcmp(s, \"Redo\")) return XK_Redo;\n\tif (!strcmp(s, \"Menu\")) return XK_Menu;\n\tif (!strcmp(s, \"Find\")) return XK_Find;\n\tif (!strcmp(s, \"Cancel\")) return XK_Cancel;\n\tif (!strcmp(s, \"Help\")) return XK_Help;\n\tif (!strcmp(s, \"Break\")) return XK_Break;\n\tif (!strcmp(s, \"Mode_switch\")) return XK_Mode_switch;\n\tif (!strcmp(s, \"script_switch\")) return XK_script_switch;\n\tif (!strcmp(s, \"Num_Lock\")) return XK_Num_Lock;\n\tif (!strcmp(s, \"KP_Space\")) return XK_KP_Space;\n\tif (!strcmp(s, \"KP_Tab\")) return XK_KP_Tab;\n\tif (!strcmp(s, \"KP_Enter\")) return XK_KP_Enter;\n\tif (!strcmp(s, \"KP_F1\")) return XK_KP_F1;\n\tif (!strcmp(s, \"KP_F2\")) return XK_KP_F2;\n\tif (!strcmp(s, \"KP_F3\")) return XK_KP_F3;\n\tif (!strcmp(s, \"KP_F4\")) return XK_KP_F4;\n\tif (!strcmp(s, \"KP_Home\")) return XK_KP_Home;\n\tif (!strcmp(s, \"KP_Left\")) return XK_KP_Left;\n\tif (!strcmp(s, \"KP_Up\")) return XK_KP_Up;\n\tif (!strcmp(s, \"KP_Right\")) return XK_KP_Right;\n\tif (!strcmp(s, \"KP_Down\")) return XK_KP_Down;\n\tif (!strcmp(s, \"KP_Prior\")) return XK_KP_Prior;\n\tif (!strcmp(s, \"KP_Page_Up\")) return XK_KP_Page_Up;\n\tif (!strcmp(s, \"KP_Next\")) return XK_KP_Next;\n\tif (!strcmp(s, \"KP_Page_Down\")) return XK_KP_Page_Down;\n\tif (!strcmp(s, \"KP_End\")) return XK_KP_End;\n\tif (!strcmp(s, \"KP_Begin\")) return XK_KP_Begin;\n\tif (!strcmp(s, \"KP_Insert\")) return XK_KP_Insert;\n\tif (!strcmp(s, \"KP_Delete\")) return XK_KP_Delete;\n\tif (!strcmp(s, \"KP_Equal\")) return XK_KP_Equal;\n\tif (!strcmp(s, \"KP_Multiply\")) return XK_KP_Multiply;\n\tif (!strcmp(s, \"KP_Add\")) return XK_KP_Add;\n\tif (!strcmp(s, \"KP_Separator\")) return XK_KP_Separator;\n\tif (!strcmp(s, \"KP_Subtract\")) return XK_KP_Subtract;\n\tif (!strcmp(s, \"KP_Decimal\")) return XK_KP_Decimal;\n\tif (!strcmp(s, \"KP_Divide\")) return XK_KP_Divide;\n\tif (!strcmp(s, \"KP_0\")) return XK_KP_0;\n\tif (!strcmp(s, \"KP_1\")) return XK_KP_1;\n\tif (!strcmp(s, \"KP_2\")) return XK_KP_2;\n\tif (!strcmp(s, \"KP_3\")) return XK_KP_3;\n\tif (!strcmp(s, \"KP_4\")) return XK_KP_4;\n\tif (!strcmp(s, \"KP_5\")) return XK_KP_5;\n\tif (!strcmp(s, \"KP_6\")) return XK_KP_6;\n\tif (!strcmp(s, \"KP_7\")) return XK_KP_7;\n\tif (!strcmp(s, \"KP_8\")) return XK_KP_8;\n\tif (!strcmp(s, \"KP_9\")) return XK_KP_9;\n\tif (!strcmp(s, \"F1\")) return XK_F1;\n\tif (!strcmp(s, \"F2\")) return XK_F2;\n\tif (!strcmp(s, \"F3\")) return XK_F3;\n\tif (!strcmp(s, \"F4\")) return XK_F4;\n\tif (!strcmp(s, \"F5\")) return XK_F5;\n\tif (!strcmp(s, \"F6\")) return XK_F6;\n\tif (!strcmp(s, \"F7\")) return XK_F7;\n\tif (!strcmp(s, \"F8\")) return XK_F8;\n\tif (!strcmp(s, \"F9\")) return XK_F9;\n\tif (!strcmp(s, \"F10\")) return XK_F10;\n\tif (!strcmp(s, \"F11\")) return XK_F11;\n\tif (!strcmp(s, \"L1\")) return XK_L1;\n\tif (!strcmp(s, \"F12\")) return XK_F12;\n\tif (!strcmp(s, \"L2\")) return XK_L2;\n\tif (!strcmp(s, \"F13\")) return XK_F13;\n\tif (!strcmp(s, \"L3\")) return XK_L3;\n\tif (!strcmp(s, \"F14\")) return XK_F14;\n\tif (!strcmp(s, \"L4\")) return XK_L4;\n\tif (!strcmp(s, \"F15\")) return XK_F15;\n\tif (!strcmp(s, \"L5\")) return XK_L5;\n\tif (!strcmp(s, \"F16\")) return XK_F16;\n\tif (!strcmp(s, \"L6\")) return XK_L6;\n\tif (!strcmp(s, \"F17\")) return XK_F17;\n\tif (!strcmp(s, \"L7\")) return XK_L7;\n\tif (!strcmp(s, \"F18\")) return XK_F18;\n\tif (!strcmp(s, \"L8\")) return XK_L8;\n\tif (!strcmp(s, \"F19\")) return XK_F19;\n\tif (!strcmp(s, \"L9\")) return XK_L9;\n\tif (!strcmp(s, \"F20\")) return XK_F20;\n\tif (!strcmp(s, \"L10\")) return XK_L10;\n\tif (!strcmp(s, \"F21\")) return XK_F21;\n\tif (!strcmp(s, \"R1\")) return XK_R1;\n\tif (!strcmp(s, \"F22\")) return XK_F22;\n\tif (!strcmp(s, \"R2\")) return XK_R2;\n\tif (!strcmp(s, \"F23\")) return XK_F23;\n\tif (!strcmp(s, \"R3\")) return XK_R3;\n\tif (!strcmp(s, \"F24\")) return XK_F24;\n\tif (!strcmp(s, \"R4\")) return XK_R4;\n\tif (!strcmp(s, \"F25\")) return XK_F25;\n\tif (!strcmp(s, \"R5\")) return XK_R5;\n\tif (!strcmp(s, \"F26\")) return XK_F26;\n\tif (!strcmp(s, \"R6\")) return XK_R6;\n\tif (!strcmp(s, \"F27\")) return XK_F27;\n\tif (!strcmp(s, \"R7\")) return XK_R7;\n\tif (!strcmp(s, \"F28\")) return XK_F28;\n\tif (!strcmp(s, \"R8\")) return XK_R8;\n\tif (!strcmp(s, \"F29\")) return XK_F29;\n\tif (!strcmp(s, \"R9\")) return XK_R9;\n\tif (!strcmp(s, \"F30\")) return XK_F30;\n\tif (!strcmp(s, \"R10\")) return XK_R10;\n\tif (!strcmp(s, \"F31\")) return XK_F31;\n\tif (!strcmp(s, \"R11\")) return XK_R11;\n\tif (!strcmp(s, \"F32\")) return XK_F32;\n\tif (!strcmp(s, \"R12\")) return XK_R12;\n\tif (!strcmp(s, \"F33\")) return XK_F33;\n\tif (!strcmp(s, \"R13\")) return XK_R13;\n\tif (!strcmp(s, \"F34\")) return XK_F34;\n\tif (!strcmp(s, \"R14\")) return XK_R14;\n\tif (!strcmp(s, \"F35\")) return XK_F35;\n\tif (!strcmp(s, \"R15\")) return XK_R15;\n\tif (!strcmp(s, \"Shift_L\")) return XK_Shift_L;\n\tif (!strcmp(s, \"Shift_R\")) return XK_Shift_R;\n\tif (!strcmp(s, \"Control_L\")) return XK_Control_L;\n\tif (!strcmp(s, \"Control_R\")) return XK_Control_R;\n\tif (!strcmp(s, \"Caps_Lock\")) return XK_Caps_Lock;\n\tif (!strcmp(s, \"Shift_Lock\")) return XK_Shift_Lock;\n\tif (!strcmp(s, \"Meta_L\")) return XK_Meta_L;\n\tif (!strcmp(s, \"Meta_R\")) return XK_Meta_R;\n\tif (!strcmp(s, \"Alt_L\")) return XK_Alt_L;\n\tif (!strcmp(s, \"Alt_R\")) return XK_Alt_R;\n\tif (!strcmp(s, \"Super_L\")) return XK_Super_L;\n\tif (!strcmp(s, \"Super_R\")) return XK_Super_R;\n\tif (!strcmp(s, \"Hyper_L\")) return XK_Hyper_L;\n\tif (!strcmp(s, \"Hyper_R\")) return XK_Hyper_R;\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (!strcmp(s, \"ISO_Lock\")) return XK_ISO_Lock;\n\tif (!strcmp(s, \"ISO_Level2_Latch\")) return XK_ISO_Level2_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Shift\")) return XK_ISO_Level3_Shift;\n\tif (!strcmp(s, \"ISO_Level3_Latch\")) return XK_ISO_Level3_Latch;\n\tif (!strcmp(s, \"ISO_Level3_Lock\")) return XK_ISO_Level3_Lock;\n\tif (!strcmp(s, \"ISO_Group_Shift\")) return XK_ISO_Group_Shift;\n\tif (!strcmp(s, \"ISO_Group_Latch\")) return XK_ISO_Group_Latch;\n\tif (!strcmp(s, \"ISO_Group_Lock\")) return XK_ISO_Group_Lock;\n\tif (!strcmp(s, \"ISO_Next_Group\")) return XK_ISO_Next_Group;\n\tif (!strcmp(s, \"ISO_Next_Group_Lock\")) return XK_ISO_Next_Group_Lock;\n\tif (!strcmp(s, \"ISO_Prev_Group\")) return XK_ISO_Prev_Group;\n\tif (!strcmp(s, \"ISO_Prev_Group_Lock\")) return XK_ISO_Prev_Group_Lock;\n\tif (!strcmp(s, \"ISO_First_Group\")) return XK_ISO_First_Group;\n\tif (!strcmp(s, \"ISO_First_Group_Lock\")) return XK_ISO_First_Group_Lock;\n\tif (!strcmp(s, \"ISO_Last_Group\")) return XK_ISO_Last_Group;\n\tif (!strcmp(s, \"ISO_Last_Group_Lock\")) return XK_ISO_Last_Group_Lock;\n\tif (!strcmp(s, \"ISO_Left_Tab\")) return XK_ISO_Left_Tab;\n\tif (!strcmp(s, \"ISO_Move_Line_Up\")) return XK_ISO_Move_Line_Up;\n\tif (!strcmp(s, \"ISO_Move_Line_Down\")) return XK_ISO_Move_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Line_Up\")) return XK_ISO_Partial_Line_Up;\n\tif (!strcmp(s, \"ISO_Partial_Line_Down\")) return XK_ISO_Partial_Line_Down;\n\tif (!strcmp(s, \"ISO_Partial_Space_Left\")) return XK_ISO_Partial_Space_Left;\n\tif (!strcmp(s, \"ISO_Partial_Space_Right\")) return XK_ISO_Partial_Space_Right;\n\tif (!strcmp(s, \"ISO_Set_Margin_Left\")) return XK_ISO_Set_Margin_Left;\n\tif (!strcmp(s, \"ISO_Set_Margin_Right\")) return XK_ISO_Set_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Margin_Left\")) return XK_ISO_Release_Margin_Left;\n\tif (!strcmp(s, \"ISO_Release_Margin_Right\")) return XK_ISO_Release_Margin_Right;\n\tif (!strcmp(s, \"ISO_Release_Both_Margins\")) return XK_ISO_Release_Both_Margins;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Left\")) return XK_ISO_Fast_Cursor_Left;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Right\")) return XK_ISO_Fast_Cursor_Right;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Up\")) return XK_ISO_Fast_Cursor_Up;\n\tif (!strcmp(s, \"ISO_Fast_Cursor_Down\")) return XK_ISO_Fast_Cursor_Down;\n\tif (!strcmp(s, \"ISO_Continuous_Underline\")) return XK_ISO_Continuous_Underline;\n\tif (!strcmp(s, \"ISO_Discontinuous_Underline\")) return XK_ISO_Discontinuous_Underline;\n\tif (!strcmp(s, \"ISO_Emphasize\")) return XK_ISO_Emphasize;\n\tif (!strcmp(s, \"ISO_Center_Object\")) return XK_ISO_Center_Object;\n\tif (!strcmp(s, \"ISO_Enter\")) return XK_ISO_Enter;\n\tif (!strcmp(s, \"dead_grave\")) return XK_dead_grave;\n\tif (!strcmp(s, \"dead_acute\")) return XK_dead_acute;\n\tif (!strcmp(s, \"dead_circumflex\")) return XK_dead_circumflex;\n\tif (!strcmp(s, \"dead_tilde\")) return XK_dead_tilde;\n\tif (!strcmp(s, \"dead_macron\")) return XK_dead_macron;\n\tif (!strcmp(s, \"dead_breve\")) return XK_dead_breve;\n\tif (!strcmp(s, \"dead_abovedot\")) return XK_dead_abovedot;\n\tif (!strcmp(s, \"dead_diaeresis\")) return XK_dead_diaeresis;\n\tif (!strcmp(s, \"dead_abovering\")) return XK_dead_abovering;\n\tif (!strcmp(s, \"dead_doubleacute\")) return XK_dead_doubleacute;\n\tif (!strcmp(s, \"dead_caron\")) return XK_dead_caron;\n\tif (!strcmp(s, \"dead_cedilla\")) return XK_dead_cedilla;\n\tif (!strcmp(s, \"dead_ogonek\")) return XK_dead_ogonek;\n\tif (!strcmp(s, \"dead_iota\")) return XK_dead_iota;\n\tif (!strcmp(s, \"dead_voiced_sound\")) return XK_dead_voiced_sound;\n\tif (!strcmp(s, \"dead_semivoiced_sound\")) return XK_dead_semivoiced_sound;\n\tif (!strcmp(s, \"dead_belowdot\")) return XK_dead_belowdot;\n\tif (!strcmp(s, \"First_Virtual_Screen\")) return XK_First_Virtual_Screen;\n\tif (!strcmp(s, \"Prev_Virtual_Screen\")) return XK_Prev_Virtual_Screen;\n\tif (!strcmp(s, \"Next_Virtual_Screen\")) return XK_Next_Virtual_Screen;\n\tif (!strcmp(s, \"Last_Virtual_Screen\")) return XK_Last_Virtual_Screen;\n\tif (!strcmp(s, \"Terminate_Server\")) return XK_Terminate_Server;\n\tif (!strcmp(s, \"AccessX_Enable\")) return XK_AccessX_Enable;\n\tif (!strcmp(s, \"AccessX_Feedback_Enable\")) return XK_AccessX_Feedback_Enable;\n\tif (!strcmp(s, \"RepeatKeys_Enable\")) return XK_RepeatKeys_Enable;\n\tif (!strcmp(s, \"SlowKeys_Enable\")) return XK_SlowKeys_Enable;\n\tif (!strcmp(s, \"BounceKeys_Enable\")) return XK_BounceKeys_Enable;\n\tif (!strcmp(s, \"StickyKeys_Enable\")) return XK_StickyKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Enable\")) return XK_MouseKeys_Enable;\n\tif (!strcmp(s, \"MouseKeys_Accel_Enable\")) return XK_MouseKeys_Accel_Enable;\n\tif (!strcmp(s, \"Overlay1_Enable\")) return XK_Overlay1_Enable;\n\tif (!strcmp(s, \"Overlay2_Enable\")) return XK_Overlay2_Enable;\n\tif (!strcmp(s, \"AudibleBell_Enable\")) return XK_AudibleBell_Enable;\n\tif (!strcmp(s, \"Pointer_Left\")) return XK_Pointer_Left;\n\tif (!strcmp(s, \"Pointer_Right\")) return XK_Pointer_Right;\n\tif (!strcmp(s, \"Pointer_Up\")) return XK_Pointer_Up;\n\tif (!strcmp(s, \"Pointer_Down\")) return XK_Pointer_Down;\n\tif (!strcmp(s, \"Pointer_UpLeft\")) return XK_Pointer_UpLeft;\n\tif (!strcmp(s, \"Pointer_UpRight\")) return XK_Pointer_UpRight;\n\tif (!strcmp(s, \"Pointer_DownLeft\")) return XK_Pointer_DownLeft;\n\tif (!strcmp(s, \"Pointer_DownRight\")) return XK_Pointer_DownRight;\n\tif (!strcmp(s, \"Pointer_Button_Dflt\")) return XK_Pointer_Button_Dflt;\n\tif (!strcmp(s, \"Pointer_Button1\")) return XK_Pointer_Button1;\n\tif (!strcmp(s, \"Pointer_Button2\")) return XK_Pointer_Button2;\n\tif (!strcmp(s, \"Pointer_Button3\")) return XK_Pointer_Button3;\n\tif (!strcmp(s, \"Pointer_Button4\")) return XK_Pointer_Button4;\n\tif (!strcmp(s, \"Pointer_Button5\")) return XK_Pointer_Button5;\n\tif (!strcmp(s, \"Pointer_DblClick_Dflt\")) return XK_Pointer_DblClick_Dflt;\n\tif (!strcmp(s, \"Pointer_DblClick1\")) return XK_Pointer_DblClick1;\n\tif (!strcmp(s, \"Pointer_DblClick2\")) return XK_Pointer_DblClick2;\n\tif (!strcmp(s, \"Pointer_DblClick3\")) return XK_Pointer_DblClick3;\n\tif (!strcmp(s, \"Pointer_DblClick4\")) return XK_Pointer_DblClick4;\n\tif (!strcmp(s, \"Pointer_DblClick5\")) return XK_Pointer_DblClick5;\n\tif (!strcmp(s, \"Pointer_Drag_Dflt\")) return XK_Pointer_Drag_Dflt;\n\tif (!strcmp(s, \"Pointer_Drag1\")) return XK_Pointer_Drag1;\n\tif (!strcmp(s, \"Pointer_Drag2\")) return XK_Pointer_Drag2;\n\tif (!strcmp(s, \"Pointer_Drag3\")) return XK_Pointer_Drag3;\n\tif (!strcmp(s, \"Pointer_Drag4\")) return XK_Pointer_Drag4;\n\tif (!strcmp(s, \"Pointer_Drag5\")) return XK_Pointer_Drag5;\n\tif (!strcmp(s, \"Pointer_EnableKeys\")) return XK_Pointer_EnableKeys;\n\tif (!strcmp(s, \"Pointer_Accelerate\")) return XK_Pointer_Accelerate;\n\tif (!strcmp(s, \"Pointer_DfltBtnNext\")) return XK_Pointer_DfltBtnNext;\n\tif (!strcmp(s, \"Pointer_DfltBtnPrev\")) return XK_Pointer_DfltBtnPrev;\n#endif\n#ifdef XK_3270\n\tif (!strcmp(s, \"3270_Duplicate\")) return XK_3270_Duplicate;\n\tif (!strcmp(s, \"3270_FieldMark\")) return XK_3270_FieldMark;\n\tif (!strcmp(s, \"3270_Right2\")) return XK_3270_Right2;\n\tif (!strcmp(s, \"3270_Left2\")) return XK_3270_Left2;\n\tif (!strcmp(s, \"3270_BackTab\")) return XK_3270_BackTab;\n\tif (!strcmp(s, \"3270_EraseEOF\")) return XK_3270_EraseEOF;\n\tif (!strcmp(s, \"3270_EraseInput\")) return XK_3270_EraseInput;\n\tif (!strcmp(s, \"3270_Reset\")) return XK_3270_Reset;\n\tif (!strcmp(s, \"3270_Quit\")) return XK_3270_Quit;\n\tif (!strcmp(s, \"3270_PA1\")) return XK_3270_PA1;\n\tif (!strcmp(s, \"3270_PA2\")) return XK_3270_PA2;\n\tif (!strcmp(s, \"3270_PA3\")) return XK_3270_PA3;\n\tif (!strcmp(s, \"3270_Test\")) return XK_3270_Test;\n\tif (!strcmp(s, \"3270_Attn\")) return XK_3270_Attn;\n\tif (!strcmp(s, \"3270_CursorBlink\")) return XK_3270_CursorBlink;\n\tif (!strcmp(s, \"3270_AltCursor\")) return XK_3270_AltCursor;\n\tif (!strcmp(s, \"3270_KeyClick\")) return XK_3270_KeyClick;\n\tif (!strcmp(s, \"3270_Jump\")) return XK_3270_Jump;\n\tif (!strcmp(s, \"3270_Ident\")) return XK_3270_Ident;\n\tif (!strcmp(s, \"3270_Rule\")) return XK_3270_Rule;\n\tif (!strcmp(s, \"3270_Copy\")) return XK_3270_Copy;\n\tif (!strcmp(s, \"3270_Play\")) return XK_3270_Play;\n\tif (!strcmp(s, \"3270_Setup\")) return XK_3270_Setup;\n\tif (!strcmp(s, \"3270_Record\")) return XK_3270_Record;\n\tif (!strcmp(s, \"3270_ChangeScreen\")) return XK_3270_ChangeScreen;\n\tif (!strcmp(s, \"3270_DeleteWord\")) return XK_3270_DeleteWord;\n\tif (!strcmp(s, \"3270_ExSelect\")) return XK_3270_ExSelect;\n\tif (!strcmp(s, \"3270_CursorSelect\")) return XK_3270_CursorSelect;\n\tif (!strcmp(s, \"3270_PrintScreen\")) return XK_3270_PrintScreen;\n\tif (!strcmp(s, \"3270_Enter\")) return XK_3270_Enter;\n#endif\n#ifdef XK_LATIN1\n\tif (!strcmp(s, \"space\")) return XK_space;\n\tif (!strcmp(s, \"exclam\")) return XK_exclam;\n\tif (!strcmp(s, \"quotedbl\")) return XK_quotedbl;\n\tif (!strcmp(s, \"numbersign\")) return XK_numbersign;\n\tif (!strcmp(s, \"dollar\")) return XK_dollar;\n\tif (!strcmp(s, \"percent\")) return XK_percent;\n\tif (!strcmp(s, \"ampersand\")) return XK_ampersand;\n\tif (!strcmp(s, \"apostrophe\")) return XK_apostrophe;\n\tif (!strcmp(s, \"quoteright\")) return XK_quoteright;\n\tif (!strcmp(s, \"parenleft\")) return XK_parenleft;\n\tif (!strcmp(s, \"parenright\")) return XK_parenright;\n\tif (!strcmp(s, \"asterisk\")) return XK_asterisk;\n\tif (!strcmp(s, \"plus\")) return XK_plus;\n\tif (!strcmp(s, \"comma\")) return XK_comma;\n\tif (!strcmp(s, \"minus\")) return XK_minus;\n\tif (!strcmp(s, \"period\")) return XK_period;\n\tif (!strcmp(s, \"slash\")) return XK_slash;\n\tif (!strcmp(s, \"0\")) return XK_0;\n\tif (!strcmp(s, \"1\")) return XK_1;\n\tif (!strcmp(s, \"2\")) return XK_2;\n\tif (!strcmp(s, \"3\")) return XK_3;\n\tif (!strcmp(s, \"4\")) return XK_4;\n\tif (!strcmp(s, \"5\")) return XK_5;\n\tif (!strcmp(s, \"6\")) return XK_6;\n\tif (!strcmp(s, \"7\")) return XK_7;\n\tif (!strcmp(s, \"8\")) return XK_8;\n\tif (!strcmp(s, \"9\")) return XK_9;\n\tif (!strcmp(s, \"colon\")) return XK_colon;\n\tif (!strcmp(s, \"semicolon\")) return XK_semicolon;\n\tif (!strcmp(s, \"less\")) return XK_less;\n\tif (!strcmp(s, \"equal\")) return XK_equal;\n\tif (!strcmp(s, \"greater\")) return XK_greater;\n\tif (!strcmp(s, \"question\")) return XK_question;\n\tif (!strcmp(s, \"at\")) return XK_at;\n\tif (!strcmp(s, \"A\")) return XK_A;\n\tif (!strcmp(s, \"B\")) return XK_B;\n\tif (!strcmp(s, \"C\")) return XK_C;\n\tif (!strcmp(s, \"D\")) return XK_D;\n\tif (!strcmp(s, \"E\")) return XK_E;\n\tif (!strcmp(s, \"F\")) return XK_F;\n\tif (!strcmp(s, \"G\")) return XK_G;\n\tif (!strcmp(s, \"H\")) return XK_H;\n\tif (!strcmp(s, \"I\")) return XK_I;\n\tif (!strcmp(s, \"J\")) return XK_J;\n\tif (!strcmp(s, \"K\")) return XK_K;\n\tif (!strcmp(s, \"L\")) return XK_L;\n\tif (!strcmp(s, \"M\")) return XK_M;\n\tif (!strcmp(s, \"N\")) return XK_N;\n\tif (!strcmp(s, \"O\")) return XK_O;\n\tif (!strcmp(s, \"P\")) return XK_P;\n\tif (!strcmp(s, \"Q\")) return XK_Q;\n\tif (!strcmp(s, \"R\")) return XK_R;\n\tif (!strcmp(s, \"S\")) return XK_S;\n\tif (!strcmp(s, \"T\")) return XK_T;\n\tif (!strcmp(s, \"U\")) return XK_U;\n\tif (!strcmp(s, \"V\")) return XK_V;\n\tif (!strcmp(s, \"W\")) return XK_W;\n\tif (!strcmp(s, \"X\")) return XK_X;\n\tif (!strcmp(s, \"Y\")) return XK_Y;\n\tif (!strcmp(s, \"Z\")) return XK_Z;\n\tif (!strcmp(s, \"bracketleft\")) return XK_bracketleft;\n\tif (!strcmp(s, \"backslash\")) return XK_backslash;\n\tif (!strcmp(s, \"bracketright\")) return XK_bracketright;\n\tif (!strcmp(s, \"asciicircum\")) return XK_asciicircum;\n\tif (!strcmp(s, \"underscore\")) return XK_underscore;\n\tif (!strcmp(s, \"grave\")) return XK_grave;\n\tif (!strcmp(s, \"quoteleft\")) return XK_quoteleft;\n\tif (!strcmp(s, \"a\")) return XK_a;\n\tif (!strcmp(s, \"b\")) return XK_b;\n\tif (!strcmp(s, \"c\")) return XK_c;\n\tif (!strcmp(s, \"d\")) return XK_d;\n\tif (!strcmp(s, \"e\")) return XK_e;\n\tif (!strcmp(s, \"f\")) return XK_f;\n\tif (!strcmp(s, \"g\")) return XK_g;\n\tif (!strcmp(s, \"h\")) return XK_h;\n\tif (!strcmp(s, \"i\")) return XK_i;\n\tif (!strcmp(s, \"j\")) return XK_j;\n\tif (!strcmp(s, \"k\")) return XK_k;\n\tif (!strcmp(s, \"l\")) return XK_l;\n\tif (!strcmp(s, \"m\")) return XK_m;\n\tif (!strcmp(s, \"n\")) return XK_n;\n\tif (!strcmp(s, \"o\")) return XK_o;\n\tif (!strcmp(s, \"p\")) return XK_p;\n\tif (!strcmp(s, \"q\")) return XK_q;\n\tif (!strcmp(s, \"r\")) return XK_r;\n\tif (!strcmp(s, \"s\")) return XK_s;\n\tif (!strcmp(s, \"t\")) return XK_t;\n\tif (!strcmp(s, \"u\")) return XK_u;\n\tif (!strcmp(s, \"v\")) return XK_v;\n\tif (!strcmp(s, \"w\")) return XK_w;\n\tif (!strcmp(s, \"x\")) return XK_x;\n\tif (!strcmp(s, \"y\")) return XK_y;\n\tif (!strcmp(s, \"z\")) return XK_z;\n\tif (!strcmp(s, \"braceleft\")) return XK_braceleft;\n\tif (!strcmp(s, \"bar\")) return XK_bar;\n\tif (!strcmp(s, \"braceright\")) return XK_braceright;\n\tif (!strcmp(s, \"asciitilde\")) return XK_asciitilde;\n\tif (!strcmp(s, \"nobreakspace\")) return XK_nobreakspace;\n\tif (!strcmp(s, \"exclamdown\")) return XK_exclamdown;\n\tif (!strcmp(s, \"cent\")) return XK_cent;\n\tif (!strcmp(s, \"sterling\")) return XK_sterling;\n\tif (!strcmp(s, \"currency\")) return XK_currency;\n\tif (!strcmp(s, \"yen\")) return XK_yen;\n\tif (!strcmp(s, \"brokenbar\")) return XK_brokenbar;\n\tif (!strcmp(s, \"section\")) return XK_section;\n\tif (!strcmp(s, \"diaeresis\")) return XK_diaeresis;\n\tif (!strcmp(s, \"copyright\")) return XK_copyright;\n\tif (!strcmp(s, \"ordfeminine\")) return XK_ordfeminine;\n\tif (!strcmp(s, \"guillemotleft\")) return XK_guillemotleft;\n\tif (!strcmp(s, \"notsign\")) return XK_notsign;\n\tif (!strcmp(s, \"hyphen\")) return XK_hyphen;\n\tif (!strcmp(s, \"registered\")) return XK_registered;\n\tif (!strcmp(s, \"macron\")) return XK_macron;\n\tif (!strcmp(s, \"degree\")) return XK_degree;\n\tif (!strcmp(s, \"plusminus\")) return XK_plusminus;\n\tif (!strcmp(s, \"twosuperior\")) return XK_twosuperior;\n\tif (!strcmp(s, \"threesuperior\")) return XK_threesuperior;\n\tif (!strcmp(s, \"acute\")) return XK_acute;\n\tif (!strcmp(s, \"mu\")) return XK_mu;\n\tif (!strcmp(s, \"paragraph\")) return XK_paragraph;\n\tif (!strcmp(s, \"periodcentered\")) return XK_periodcentered;\n\tif (!strcmp(s, \"cedilla\")) return XK_cedilla;\n\tif (!strcmp(s, \"onesuperior\")) return XK_onesuperior;\n\tif (!strcmp(s, \"masculine\")) return XK_masculine;\n\tif (!strcmp(s, \"guillemotright\")) return XK_guillemotright;\n\tif (!strcmp(s, \"onequarter\")) return XK_onequarter;\n\tif (!strcmp(s, \"onehalf\")) return XK_onehalf;\n\tif (!strcmp(s, \"threequarters\")) return XK_threequarters;\n\tif (!strcmp(s, \"questiondown\")) return XK_questiondown;\n\tif (!strcmp(s, \"Agrave\")) return XK_Agrave;\n\tif (!strcmp(s, \"Aacute\")) return XK_Aacute;\n\tif (!strcmp(s, \"Acircumflex\")) return XK_Acircumflex;\n\tif (!strcmp(s, \"Atilde\")) return XK_Atilde;\n\tif (!strcmp(s, \"Adiaeresis\")) return XK_Adiaeresis;\n\tif (!strcmp(s, \"Aring\")) return XK_Aring;\n\tif (!strcmp(s, \"AE\")) return XK_AE;\n\tif (!strcmp(s, \"Ccedilla\")) return XK_Ccedilla;\n\tif (!strcmp(s, \"Egrave\")) return XK_Egrave;\n\tif (!strcmp(s, \"Eacute\")) return XK_Eacute;\n\tif (!strcmp(s, \"Ecircumflex\")) return XK_Ecircumflex;\n\tif (!strcmp(s, \"Ediaeresis\")) return XK_Ediaeresis;\n\tif (!strcmp(s, \"Igrave\")) return XK_Igrave;\n\tif (!strcmp(s, \"Iacute\")) return XK_Iacute;\n\tif (!strcmp(s, \"Icircumflex\")) return XK_Icircumflex;\n\tif (!strcmp(s, \"Idiaeresis\")) return XK_Idiaeresis;\n\tif (!strcmp(s, \"ETH\")) return XK_ETH;\n\tif (!strcmp(s, \"Eth\")) return XK_Eth;\n\tif (!strcmp(s, \"Ntilde\")) return XK_Ntilde;\n\tif (!strcmp(s, \"Ograve\")) return XK_Ograve;\n\tif (!strcmp(s, \"Oacute\")) return XK_Oacute;\n\tif (!strcmp(s, \"Ocircumflex\")) return XK_Ocircumflex;\n\tif (!strcmp(s, \"Otilde\")) return XK_Otilde;\n\tif (!strcmp(s, \"Odiaeresis\")) return XK_Odiaeresis;\n\tif (!strcmp(s, \"multiply\")) return XK_multiply;\n\tif (!strcmp(s, \"Ooblique\")) return XK_Ooblique;\n\tif (!strcmp(s, \"Ugrave\")) return XK_Ugrave;\n\tif (!strcmp(s, \"Uacute\")) return XK_Uacute;\n\tif (!strcmp(s, \"Ucircumflex\")) return XK_Ucircumflex;\n\tif (!strcmp(s, \"Udiaeresis\")) return XK_Udiaeresis;\n\tif (!strcmp(s, \"Yacute\")) return XK_Yacute;\n\tif (!strcmp(s, \"THORN\")) return XK_THORN;\n\tif (!strcmp(s, \"Thorn\")) return XK_Thorn;\n\tif (!strcmp(s, \"ssharp\")) return XK_ssharp;\n\tif (!strcmp(s, \"agrave\")) return XK_agrave;\n\tif (!strcmp(s, \"aacute\")) return XK_aacute;\n\tif (!strcmp(s, \"acircumflex\")) return XK_acircumflex;\n\tif (!strcmp(s, \"atilde\")) return XK_atilde;\n\tif (!strcmp(s, \"adiaeresis\")) return XK_adiaeresis;\n\tif (!strcmp(s, \"aring\")) return XK_aring;\n\tif (!strcmp(s, \"ae\")) return XK_ae;\n\tif (!strcmp(s, \"ccedilla\")) return XK_ccedilla;\n\tif (!strcmp(s, \"egrave\")) return XK_egrave;\n\tif (!strcmp(s, \"eacute\")) return XK_eacute;\n\tif (!strcmp(s, \"ecircumflex\")) return XK_ecircumflex;\n\tif (!strcmp(s, \"ediaeresis\")) return XK_ediaeresis;\n\tif (!strcmp(s, \"igrave\")) return XK_igrave;\n\tif (!strcmp(s, \"iacute\")) return XK_iacute;\n\tif (!strcmp(s, \"icircumflex\")) return XK_icircumflex;\n\tif (!strcmp(s, \"idiaeresis\")) return XK_idiaeresis;\n\tif (!strcmp(s, \"eth\")) return XK_eth;\n\tif (!strcmp(s, \"ntilde\")) return XK_ntilde;\n\tif (!strcmp(s, \"ograve\")) return XK_ograve;\n\tif (!strcmp(s, \"oacute\")) return XK_oacute;\n\tif (!strcmp(s, \"ocircumflex\")) return XK_ocircumflex;\n\tif (!strcmp(s, \"otilde\")) return XK_otilde;\n\tif (!strcmp(s, \"odiaeresis\")) return XK_odiaeresis;\n\tif (!strcmp(s, \"division\")) return XK_division;\n\tif (!strcmp(s, \"oslash\")) return XK_oslash;\n\tif (!strcmp(s, \"ugrave\")) return XK_ugrave;\n\tif (!strcmp(s, \"uacute\")) return XK_uacute;\n\tif (!strcmp(s, \"ucircumflex\")) return XK_ucircumflex;\n\tif (!strcmp(s, \"udiaeresis\")) return XK_udiaeresis;\n\tif (!strcmp(s, \"yacute\")) return XK_yacute;\n\tif (!strcmp(s, \"thorn\")) return XK_thorn;\n\tif (!strcmp(s, \"ydiaeresis\")) return XK_ydiaeresis;\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (!strcmp(s, \"Aogonek\")) return XK_Aogonek;\n\tif (!strcmp(s, \"breve\")) return XK_breve;\n\tif (!strcmp(s, \"Lstroke\")) return XK_Lstroke;\n\tif (!strcmp(s, \"Lcaron\")) return XK_Lcaron;\n\tif (!strcmp(s, \"Sacute\")) return XK_Sacute;\n\tif (!strcmp(s, \"Scaron\")) return XK_Scaron;\n\tif (!strcmp(s, \"Scedilla\")) return XK_Scedilla;\n\tif (!strcmp(s, \"Tcaron\")) return XK_Tcaron;\n\tif (!strcmp(s, \"Zacute\")) return XK_Zacute;\n\tif (!strcmp(s, \"Zcaron\")) return XK_Zcaron;\n\tif (!strcmp(s, \"Zabovedot\")) return XK_Zabovedot;\n\tif (!strcmp(s, \"aogonek\")) return XK_aogonek;\n\tif (!strcmp(s, \"ogonek\")) return XK_ogonek;\n\tif (!strcmp(s, \"lstroke\")) return XK_lstroke;\n\tif (!strcmp(s, \"lcaron\")) return XK_lcaron;\n\tif (!strcmp(s, \"sacute\")) return XK_sacute;\n\tif (!strcmp(s, \"caron\")) return XK_caron;\n\tif (!strcmp(s, \"scaron\")) return XK_scaron;\n\tif (!strcmp(s, \"scedilla\")) return XK_scedilla;\n\tif (!strcmp(s, \"tcaron\")) return XK_tcaron;\n\tif (!strcmp(s, \"zacute\")) return XK_zacute;\n\tif (!strcmp(s, \"doubleacute\")) return XK_doubleacute;\n\tif (!strcmp(s, \"zcaron\")) return XK_zcaron;\n\tif (!strcmp(s, \"zabovedot\")) return XK_zabovedot;\n\tif (!strcmp(s, \"Racute\")) return XK_Racute;\n\tif (!strcmp(s, \"Abreve\")) return XK_Abreve;\n\tif (!strcmp(s, \"Lacute\")) return XK_Lacute;\n\tif (!strcmp(s, \"Cacute\")) return XK_Cacute;\n\tif (!strcmp(s, \"Ccaron\")) return XK_Ccaron;\n\tif (!strcmp(s, \"Eogonek\")) return XK_Eogonek;\n\tif (!strcmp(s, \"Ecaron\")) return XK_Ecaron;\n\tif (!strcmp(s, \"Dcaron\")) return XK_Dcaron;\n\tif (!strcmp(s, \"Dstroke\")) return XK_Dstroke;\n\tif (!strcmp(s, \"Nacute\")) return XK_Nacute;\n\tif (!strcmp(s, \"Ncaron\")) return XK_Ncaron;\n\tif (!strcmp(s, \"Odoubleacute\")) return XK_Odoubleacute;\n\tif (!strcmp(s, \"Rcaron\")) return XK_Rcaron;\n\tif (!strcmp(s, \"Uring\")) return XK_Uring;\n\tif (!strcmp(s, \"Udoubleacute\")) return XK_Udoubleacute;\n\tif (!strcmp(s, \"Tcedilla\")) return XK_Tcedilla;\n\tif (!strcmp(s, \"racute\")) return XK_racute;\n\tif (!strcmp(s, \"abreve\")) return XK_abreve;\n\tif (!strcmp(s, \"lacute\")) return XK_lacute;\n\tif (!strcmp(s, \"cacute\")) return XK_cacute;\n\tif (!strcmp(s, \"ccaron\")) return XK_ccaron;\n\tif (!strcmp(s, \"eogonek\")) return XK_eogonek;\n\tif (!strcmp(s, \"ecaron\")) return XK_ecaron;\n\tif (!strcmp(s, \"dcaron\")) return XK_dcaron;\n\tif (!strcmp(s, \"dstroke\")) return XK_dstroke;\n\tif (!strcmp(s, \"nacute\")) return XK_nacute;\n\tif (!strcmp(s, \"ncaron\")) return XK_ncaron;\n\tif (!strcmp(s, \"odoubleacute\")) return XK_odoubleacute;\n\tif (!strcmp(s, \"udoubleacute\")) return XK_udoubleacute;\n\tif (!strcmp(s, \"rcaron\")) return XK_rcaron;\n\tif (!strcmp(s, \"uring\")) return XK_uring;\n\tif (!strcmp(s, \"tcedilla\")) return XK_tcedilla;\n\tif (!strcmp(s, \"abovedot\")) return XK_abovedot;\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (!strcmp(s, \"Hstroke\")) return XK_Hstroke;\n\tif (!strcmp(s, \"Hcircumflex\")) return XK_Hcircumflex;\n\tif (!strcmp(s, \"Iabovedot\")) return XK_Iabovedot;\n\tif (!strcmp(s, \"Gbreve\")) return XK_Gbreve;\n\tif (!strcmp(s, \"Jcircumflex\")) return XK_Jcircumflex;\n\tif (!strcmp(s, \"hstroke\")) return XK_hstroke;\n\tif (!strcmp(s, \"hcircumflex\")) return XK_hcircumflex;\n\tif (!strcmp(s, \"idotless\")) return XK_idotless;\n\tif (!strcmp(s, \"gbreve\")) return XK_gbreve;\n\tif (!strcmp(s, \"jcircumflex\")) return XK_jcircumflex;\n\tif (!strcmp(s, \"Cabovedot\")) return XK_Cabovedot;\n\tif (!strcmp(s, \"Ccircumflex\")) return XK_Ccircumflex;\n\tif (!strcmp(s, \"Gabovedot\")) return XK_Gabovedot;\n\tif (!strcmp(s, \"Gcircumflex\")) return XK_Gcircumflex;\n\tif (!strcmp(s, \"Ubreve\")) return XK_Ubreve;\n\tif (!strcmp(s, \"Scircumflex\")) return XK_Scircumflex;\n\tif (!strcmp(s, \"cabovedot\")) return XK_cabovedot;\n\tif (!strcmp(s, \"ccircumflex\")) return XK_ccircumflex;\n\tif (!strcmp(s, \"gabovedot\")) return XK_gabovedot;\n\tif (!strcmp(s, \"gcircumflex\")) return XK_gcircumflex;\n\tif (!strcmp(s, \"ubreve\")) return XK_ubreve;\n\tif (!strcmp(s, \"scircumflex\")) return XK_scircumflex;\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (!strcmp(s, \"kra\")) return XK_kra;\n\tif (!strcmp(s, \"kappa\")) return XK_kappa;\n\tif (!strcmp(s, \"Rcedilla\")) return XK_Rcedilla;\n\tif (!strcmp(s, \"Itilde\")) return XK_Itilde;\n\tif (!strcmp(s, \"Lcedilla\")) return XK_Lcedilla;\n\tif (!strcmp(s, \"Emacron\")) return XK_Emacron;\n\tif (!strcmp(s, \"Gcedilla\")) return XK_Gcedilla;\n\tif (!strcmp(s, \"Tslash\")) return XK_Tslash;\n\tif (!strcmp(s, \"rcedilla\")) return XK_rcedilla;\n\tif (!strcmp(s, \"itilde\")) return XK_itilde;\n\tif (!strcmp(s, \"lcedilla\")) return XK_lcedilla;\n\tif (!strcmp(s, \"emacron\")) return XK_emacron;\n\tif (!strcmp(s, \"gcedilla\")) return XK_gcedilla;\n\tif (!strcmp(s, \"tslash\")) return XK_tslash;\n\tif (!strcmp(s, \"ENG\")) return XK_ENG;\n\tif (!strcmp(s, \"eng\")) return XK_eng;\n\tif (!strcmp(s, \"Amacron\")) return XK_Amacron;\n\tif (!strcmp(s, \"Iogonek\")) return XK_Iogonek;\n\tif (!strcmp(s, \"Eabovedot\")) return XK_Eabovedot;\n\tif (!strcmp(s, \"Imacron\")) return XK_Imacron;\n\tif (!strcmp(s, \"Ncedilla\")) return XK_Ncedilla;\n\tif (!strcmp(s, \"Omacron\")) return XK_Omacron;\n\tif (!strcmp(s, \"Kcedilla\")) return XK_Kcedilla;\n\tif (!strcmp(s, \"Uogonek\")) return XK_Uogonek;\n\tif (!strcmp(s, \"Utilde\")) return XK_Utilde;\n\tif (!strcmp(s, \"Umacron\")) return XK_Umacron;\n\tif (!strcmp(s, \"amacron\")) return XK_amacron;\n\tif (!strcmp(s, \"iogonek\")) return XK_iogonek;\n\tif (!strcmp(s, \"eabovedot\")) return XK_eabovedot;\n\tif (!strcmp(s, \"imacron\")) return XK_imacron;\n\tif (!strcmp(s, \"ncedilla\")) return XK_ncedilla;\n\tif (!strcmp(s, \"omacron\")) return XK_omacron;\n\tif (!strcmp(s, \"kcedilla\")) return XK_kcedilla;\n\tif (!strcmp(s, \"uogonek\")) return XK_uogonek;\n\tif (!strcmp(s, \"utilde\")) return XK_utilde;\n\tif (!strcmp(s, \"umacron\")) return XK_umacron;\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (!strcmp(s, \"overline\")) return XK_overline;\n\tif (!strcmp(s, \"kana_fullstop\")) return XK_kana_fullstop;\n\tif (!strcmp(s, \"kana_openingbracket\")) return XK_kana_openingbracket;\n\tif (!strcmp(s, \"kana_closingbracket\")) return XK_kana_closingbracket;\n\tif (!strcmp(s, \"kana_comma\")) return XK_kana_comma;\n\tif (!strcmp(s, \"kana_conjunctive\")) return XK_kana_conjunctive;\n\tif (!strcmp(s, \"kana_middledot\")) return XK_kana_middledot;\n\tif (!strcmp(s, \"kana_WO\")) return XK_kana_WO;\n\tif (!strcmp(s, \"kana_a\")) return XK_kana_a;\n\tif (!strcmp(s, \"kana_i\")) return XK_kana_i;\n\tif (!strcmp(s, \"kana_u\")) return XK_kana_u;\n\tif (!strcmp(s, \"kana_e\")) return XK_kana_e;\n\tif (!strcmp(s, \"kana_o\")) return XK_kana_o;\n\tif (!strcmp(s, \"kana_ya\")) return XK_kana_ya;\n\tif (!strcmp(s, \"kana_yu\")) return XK_kana_yu;\n\tif (!strcmp(s, \"kana_yo\")) return XK_kana_yo;\n\tif (!strcmp(s, \"kana_tsu\")) return XK_kana_tsu;\n\tif (!strcmp(s, \"kana_tu\")) return XK_kana_tu;\n\tif (!strcmp(s, \"prolongedsound\")) return XK_prolongedsound;\n\tif (!strcmp(s, \"kana_A\")) return XK_kana_A;\n\tif (!strcmp(s, \"kana_I\")) return XK_kana_I;\n\tif (!strcmp(s, \"kana_U\")) return XK_kana_U;\n\tif (!strcmp(s, \"kana_E\")) return XK_kana_E;\n\tif (!strcmp(s, \"kana_O\")) return XK_kana_O;\n\tif (!strcmp(s, \"kana_KA\")) return XK_kana_KA;\n\tif (!strcmp(s, \"kana_KI\")) return XK_kana_KI;\n\tif (!strcmp(s, \"kana_KU\")) return XK_kana_KU;\n\tif (!strcmp(s, \"kana_KE\")) return XK_kana_KE;\n\tif (!strcmp(s, \"kana_KO\")) return XK_kana_KO;\n\tif (!strcmp(s, \"kana_SA\")) return XK_kana_SA;\n\tif (!strcmp(s, \"kana_SHI\")) return XK_kana_SHI;\n\tif (!strcmp(s, \"kana_SU\")) return XK_kana_SU;\n\tif (!strcmp(s, \"kana_SE\")) return XK_kana_SE;\n\tif (!strcmp(s, \"kana_SO\")) return XK_kana_SO;\n\tif (!strcmp(s, \"kana_TA\")) return XK_kana_TA;\n\tif (!strcmp(s, \"kana_CHI\")) return XK_kana_CHI;\n\tif (!strcmp(s, \"kana_TI\")) return XK_kana_TI;\n\tif (!strcmp(s, \"kana_TSU\")) return XK_kana_TSU;\n\tif (!strcmp(s, \"kana_TU\")) return XK_kana_TU;\n\tif (!strcmp(s, \"kana_TE\")) return XK_kana_TE;\n\tif (!strcmp(s, \"kana_TO\")) return XK_kana_TO;\n\tif (!strcmp(s, \"kana_NA\")) return XK_kana_NA;\n\tif (!strcmp(s, \"kana_NI\")) return XK_kana_NI;\n\tif (!strcmp(s, \"kana_NU\")) return XK_kana_NU;\n\tif (!strcmp(s, \"kana_NE\")) return XK_kana_NE;\n\tif (!strcmp(s, \"kana_NO\")) return XK_kana_NO;\n\tif (!strcmp(s, \"kana_HA\")) return XK_kana_HA;\n\tif (!strcmp(s, \"kana_HI\")) return XK_kana_HI;\n\tif (!strcmp(s, \"kana_FU\")) return XK_kana_FU;\n\tif (!strcmp(s, \"kana_HU\")) return XK_kana_HU;\n\tif (!strcmp(s, \"kana_HE\")) return XK_kana_HE;\n\tif (!strcmp(s, \"kana_HO\")) return XK_kana_HO;\n\tif (!strcmp(s, \"kana_MA\")) return XK_kana_MA;\n\tif (!strcmp(s, \"kana_MI\")) return XK_kana_MI;\n\tif (!strcmp(s, \"kana_MU\")) return XK_kana_MU;\n\tif (!strcmp(s, \"kana_ME\")) return XK_kana_ME;\n\tif (!strcmp(s, \"kana_MO\")) return XK_kana_MO;\n\tif (!strcmp(s, \"kana_YA\")) return XK_kana_YA;\n\tif (!strcmp(s, \"kana_YU\")) return XK_kana_YU;\n\tif (!strcmp(s, \"kana_YO\")) return XK_kana_YO;\n\tif (!strcmp(s, \"kana_RA\")) return XK_kana_RA;\n\tif (!strcmp(s, \"kana_RI\")) return XK_kana_RI;\n\tif (!strcmp(s, \"kana_RU\")) return XK_kana_RU;\n\tif (!strcmp(s, \"kana_RE\")) return XK_kana_RE;\n\tif (!strcmp(s, \"kana_RO\")) return XK_kana_RO;\n\tif (!strcmp(s, \"kana_WA\")) return XK_kana_WA;\n\tif (!strcmp(s, \"kana_N\")) return XK_kana_N;\n\tif (!strcmp(s, \"voicedsound\")) return XK_voicedsound;\n\tif (!strcmp(s, \"semivoicedsound\")) return XK_semivoicedsound;\n\tif (!strcmp(s, \"kana_switch\")) return XK_kana_switch;\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (!strcmp(s, \"Arabic_comma\")) return XK_Arabic_comma;\n\tif (!strcmp(s, \"Arabic_semicolon\")) return XK_Arabic_semicolon;\n\tif (!strcmp(s, \"Arabic_question_mark\")) return XK_Arabic_question_mark;\n\tif (!strcmp(s, \"Arabic_hamza\")) return XK_Arabic_hamza;\n\tif (!strcmp(s, \"Arabic_maddaonalef\")) return XK_Arabic_maddaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonalef\")) return XK_Arabic_hamzaonalef;\n\tif (!strcmp(s, \"Arabic_hamzaonwaw\")) return XK_Arabic_hamzaonwaw;\n\tif (!strcmp(s, \"Arabic_hamzaunderalef\")) return XK_Arabic_hamzaunderalef;\n\tif (!strcmp(s, \"Arabic_hamzaonyeh\")) return XK_Arabic_hamzaonyeh;\n\tif (!strcmp(s, \"Arabic_alef\")) return XK_Arabic_alef;\n\tif (!strcmp(s, \"Arabic_beh\")) return XK_Arabic_beh;\n\tif (!strcmp(s, \"Arabic_tehmarbuta\")) return XK_Arabic_tehmarbuta;\n\tif (!strcmp(s, \"Arabic_teh\")) return XK_Arabic_teh;\n\tif (!strcmp(s, \"Arabic_theh\")) return XK_Arabic_theh;\n\tif (!strcmp(s, \"Arabic_jeem\")) return XK_Arabic_jeem;\n\tif (!strcmp(s, \"Arabic_hah\")) return XK_Arabic_hah;\n\tif (!strcmp(s, \"Arabic_khah\")) return XK_Arabic_khah;\n\tif (!strcmp(s, \"Arabic_dal\")) return XK_Arabic_dal;\n\tif (!strcmp(s, \"Arabic_thal\")) return XK_Arabic_thal;\n\tif (!strcmp(s, \"Arabic_ra\")) return XK_Arabic_ra;\n\tif (!strcmp(s, \"Arabic_zain\")) return XK_Arabic_zain;\n\tif (!strcmp(s, \"Arabic_seen\")) return XK_Arabic_seen;\n\tif (!strcmp(s, \"Arabic_sheen\")) return XK_Arabic_sheen;\n\tif (!strcmp(s, \"Arabic_sad\")) return XK_Arabic_sad;\n\tif (!strcmp(s, \"Arabic_dad\")) return XK_Arabic_dad;\n\tif (!strcmp(s, \"Arabic_tah\")) return XK_Arabic_tah;\n\tif (!strcmp(s, \"Arabic_zah\")) return XK_Arabic_zah;\n\tif (!strcmp(s, \"Arabic_ain\")) return XK_Arabic_ain;\n\tif (!strcmp(s, \"Arabic_ghain\")) return XK_Arabic_ghain;\n\tif (!strcmp(s, \"Arabic_tatweel\")) return XK_Arabic_tatweel;\n\tif (!strcmp(s, \"Arabic_feh\")) return XK_Arabic_feh;\n\tif (!strcmp(s, \"Arabic_qaf\")) return XK_Arabic_qaf;\n\tif (!strcmp(s, \"Arabic_kaf\")) return XK_Arabic_kaf;\n\tif (!strcmp(s, \"Arabic_lam\")) return XK_Arabic_lam;\n\tif (!strcmp(s, \"Arabic_meem\")) return XK_Arabic_meem;\n\tif (!strcmp(s, \"Arabic_noon\")) return XK_Arabic_noon;\n\tif (!strcmp(s, \"Arabic_ha\")) return XK_Arabic_ha;\n\tif (!strcmp(s, \"Arabic_heh\")) return XK_Arabic_heh;\n\tif (!strcmp(s, \"Arabic_waw\")) return XK_Arabic_waw;\n\tif (!strcmp(s, \"Arabic_alefmaksura\")) return XK_Arabic_alefmaksura;\n\tif (!strcmp(s, \"Arabic_yeh\")) return XK_Arabic_yeh;\n\tif (!strcmp(s, \"Arabic_fathatan\")) return XK_Arabic_fathatan;\n\tif (!strcmp(s, \"Arabic_dammatan\")) return XK_Arabic_dammatan;\n\tif (!strcmp(s, \"Arabic_kasratan\")) return XK_Arabic_kasratan;\n\tif (!strcmp(s, \"Arabic_fatha\")) return XK_Arabic_fatha;\n\tif (!strcmp(s, \"Arabic_damma\")) return XK_Arabic_damma;\n\tif (!strcmp(s, \"Arabic_kasra\")) return XK_Arabic_kasra;\n\tif (!strcmp(s, \"Arabic_shadda\")) return XK_Arabic_shadda;\n\tif (!strcmp(s, \"Arabic_sukun\")) return XK_Arabic_sukun;\n\tif (!strcmp(s, \"Arabic_switch\")) return XK_Arabic_switch;\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (!strcmp(s, \"Serbian_dje\")) return XK_Serbian_dje;\n\tif (!strcmp(s, \"Macedonia_gje\")) return XK_Macedonia_gje;\n\tif (!strcmp(s, \"Cyrillic_io\")) return XK_Cyrillic_io;\n\tif (!strcmp(s, \"Ukrainian_ie\")) return XK_Ukrainian_ie;\n\tif (!strcmp(s, \"Ukranian_je\")) return XK_Ukranian_je;\n\tif (!strcmp(s, \"Macedonia_dse\")) return XK_Macedonia_dse;\n\tif (!strcmp(s, \"Ukrainian_i\")) return XK_Ukrainian_i;\n\tif (!strcmp(s, \"Ukranian_i\")) return XK_Ukranian_i;\n\tif (!strcmp(s, \"Ukrainian_yi\")) return XK_Ukrainian_yi;\n\tif (!strcmp(s, \"Ukranian_yi\")) return XK_Ukranian_yi;\n\tif (!strcmp(s, \"Cyrillic_je\")) return XK_Cyrillic_je;\n\tif (!strcmp(s, \"Serbian_je\")) return XK_Serbian_je;\n\tif (!strcmp(s, \"Cyrillic_lje\")) return XK_Cyrillic_lje;\n\tif (!strcmp(s, \"Serbian_lje\")) return XK_Serbian_lje;\n\tif (!strcmp(s, \"Cyrillic_nje\")) return XK_Cyrillic_nje;\n\tif (!strcmp(s, \"Serbian_nje\")) return XK_Serbian_nje;\n\tif (!strcmp(s, \"Serbian_tshe\")) return XK_Serbian_tshe;\n\tif (!strcmp(s, \"Macedonia_kje\")) return XK_Macedonia_kje;\n\tif (!strcmp(s, \"Byelorussian_shortu\")) return XK_Byelorussian_shortu;\n\tif (!strcmp(s, \"Cyrillic_dzhe\")) return XK_Cyrillic_dzhe;\n\tif (!strcmp(s, \"Serbian_dze\")) return XK_Serbian_dze;\n\tif (!strcmp(s, \"numerosign\")) return XK_numerosign;\n\tif (!strcmp(s, \"Serbian_DJE\")) return XK_Serbian_DJE;\n\tif (!strcmp(s, \"Macedonia_GJE\")) return XK_Macedonia_GJE;\n\tif (!strcmp(s, \"Cyrillic_IO\")) return XK_Cyrillic_IO;\n\tif (!strcmp(s, \"Ukrainian_IE\")) return XK_Ukrainian_IE;\n\tif (!strcmp(s, \"Ukranian_JE\")) return XK_Ukranian_JE;\n\tif (!strcmp(s, \"Macedonia_DSE\")) return XK_Macedonia_DSE;\n\tif (!strcmp(s, \"Ukrainian_I\")) return XK_Ukrainian_I;\n\tif (!strcmp(s, \"Ukranian_I\")) return XK_Ukranian_I;\n\tif (!strcmp(s, \"Ukrainian_YI\")) return XK_Ukrainian_YI;\n\tif (!strcmp(s, \"Ukranian_YI\")) return XK_Ukranian_YI;\n\tif (!strcmp(s, \"Cyrillic_JE\")) return XK_Cyrillic_JE;\n\tif (!strcmp(s, \"Serbian_JE\")) return XK_Serbian_JE;\n\tif (!strcmp(s, \"Cyrillic_LJE\")) return XK_Cyrillic_LJE;\n\tif (!strcmp(s, \"Serbian_LJE\")) return XK_Serbian_LJE;\n\tif (!strcmp(s, \"Cyrillic_NJE\")) return XK_Cyrillic_NJE;\n\tif (!strcmp(s, \"Serbian_NJE\")) return XK_Serbian_NJE;\n\tif (!strcmp(s, \"Serbian_TSHE\")) return XK_Serbian_TSHE;\n\tif (!strcmp(s, \"Macedonia_KJE\")) return XK_Macedonia_KJE;\n\tif (!strcmp(s, \"Byelorussian_SHORTU\")) return XK_Byelorussian_SHORTU;\n\tif (!strcmp(s, \"Cyrillic_DZHE\")) return XK_Cyrillic_DZHE;\n\tif (!strcmp(s, \"Serbian_DZE\")) return XK_Serbian_DZE;\n\tif (!strcmp(s, \"Cyrillic_yu\")) return XK_Cyrillic_yu;\n\tif (!strcmp(s, \"Cyrillic_a\")) return XK_Cyrillic_a;\n\tif (!strcmp(s, \"Cyrillic_be\")) return XK_Cyrillic_be;\n\tif (!strcmp(s, \"Cyrillic_tse\")) return XK_Cyrillic_tse;\n\tif (!strcmp(s, \"Cyrillic_de\")) return XK_Cyrillic_de;\n\tif (!strcmp(s, \"Cyrillic_ie\")) return XK_Cyrillic_ie;\n\tif (!strcmp(s, \"Cyrillic_ef\")) return XK_Cyrillic_ef;\n\tif (!strcmp(s, \"Cyrillic_ghe\")) return XK_Cyrillic_ghe;\n\tif (!strcmp(s, \"Cyrillic_ha\")) return XK_Cyrillic_ha;\n\tif (!strcmp(s, \"Cyrillic_i\")) return XK_Cyrillic_i;\n\tif (!strcmp(s, \"Cyrillic_shorti\")) return XK_Cyrillic_shorti;\n\tif (!strcmp(s, \"Cyrillic_ka\")) return XK_Cyrillic_ka;\n\tif (!strcmp(s, \"Cyrillic_el\")) return XK_Cyrillic_el;\n\tif (!strcmp(s, \"Cyrillic_em\")) return XK_Cyrillic_em;\n\tif (!strcmp(s, \"Cyrillic_en\")) return XK_Cyrillic_en;\n\tif (!strcmp(s, \"Cyrillic_o\")) return XK_Cyrillic_o;\n\tif (!strcmp(s, \"Cyrillic_pe\")) return XK_Cyrillic_pe;\n\tif (!strcmp(s, \"Cyrillic_ya\")) return XK_Cyrillic_ya;\n\tif (!strcmp(s, \"Cyrillic_er\")) return XK_Cyrillic_er;\n\tif (!strcmp(s, \"Cyrillic_es\")) return XK_Cyrillic_es;\n\tif (!strcmp(s, \"Cyrillic_te\")) return XK_Cyrillic_te;\n\tif (!strcmp(s, \"Cyrillic_u\")) return XK_Cyrillic_u;\n\tif (!strcmp(s, \"Cyrillic_zhe\")) return XK_Cyrillic_zhe;\n\tif (!strcmp(s, \"Cyrillic_ve\")) return XK_Cyrillic_ve;\n\tif (!strcmp(s, \"Cyrillic_softsign\")) return XK_Cyrillic_softsign;\n\tif (!strcmp(s, \"Cyrillic_yeru\")) return XK_Cyrillic_yeru;\n\tif (!strcmp(s, \"Cyrillic_ze\")) return XK_Cyrillic_ze;\n\tif (!strcmp(s, \"Cyrillic_sha\")) return XK_Cyrillic_sha;\n\tif (!strcmp(s, \"Cyrillic_e\")) return XK_Cyrillic_e;\n\tif (!strcmp(s, \"Cyrillic_shcha\")) return XK_Cyrillic_shcha;\n\tif (!strcmp(s, \"Cyrillic_che\")) return XK_Cyrillic_che;\n\tif (!strcmp(s, \"Cyrillic_hardsign\")) return XK_Cyrillic_hardsign;\n\tif (!strcmp(s, \"Cyrillic_YU\")) return XK_Cyrillic_YU;\n\tif (!strcmp(s, \"Cyrillic_A\")) return XK_Cyrillic_A;\n\tif (!strcmp(s, \"Cyrillic_BE\")) return XK_Cyrillic_BE;\n\tif (!strcmp(s, \"Cyrillic_TSE\")) return XK_Cyrillic_TSE;\n\tif (!strcmp(s, \"Cyrillic_DE\")) return XK_Cyrillic_DE;\n\tif (!strcmp(s, \"Cyrillic_IE\")) return XK_Cyrillic_IE;\n\tif (!strcmp(s, \"Cyrillic_EF\")) return XK_Cyrillic_EF;\n\tif (!strcmp(s, \"Cyrillic_GHE\")) return XK_Cyrillic_GHE;\n\tif (!strcmp(s, \"Cyrillic_HA\")) return XK_Cyrillic_HA;\n\tif (!strcmp(s, \"Cyrillic_I\")) return XK_Cyrillic_I;\n\tif (!strcmp(s, \"Cyrillic_SHORTI\")) return XK_Cyrillic_SHORTI;\n\tif (!strcmp(s, \"Cyrillic_KA\")) return XK_Cyrillic_KA;\n\tif (!strcmp(s, \"Cyrillic_EL\")) return XK_Cyrillic_EL;\n\tif (!strcmp(s, \"Cyrillic_EM\")) return XK_Cyrillic_EM;\n\tif (!strcmp(s, \"Cyrillic_EN\")) return XK_Cyrillic_EN;\n\tif (!strcmp(s, \"Cyrillic_O\")) return XK_Cyrillic_O;\n\tif (!strcmp(s, \"Cyrillic_PE\")) return XK_Cyrillic_PE;\n\tif (!strcmp(s, \"Cyrillic_YA\")) return XK_Cyrillic_YA;\n\tif (!strcmp(s, \"Cyrillic_ER\")) return XK_Cyrillic_ER;\n\tif (!strcmp(s, \"Cyrillic_ES\")) return XK_Cyrillic_ES;\n\tif (!strcmp(s, \"Cyrillic_TE\")) return XK_Cyrillic_TE;\n\tif (!strcmp(s, \"Cyrillic_U\")) return XK_Cyrillic_U;\n\tif (!strcmp(s, \"Cyrillic_ZHE\")) return XK_Cyrillic_ZHE;\n\tif (!strcmp(s, \"Cyrillic_VE\")) return XK_Cyrillic_VE;\n\tif (!strcmp(s, \"Cyrillic_SOFTSIGN\")) return XK_Cyrillic_SOFTSIGN;\n\tif (!strcmp(s, \"Cyrillic_YERU\")) return XK_Cyrillic_YERU;\n\tif (!strcmp(s, \"Cyrillic_ZE\")) return XK_Cyrillic_ZE;\n\tif (!strcmp(s, \"Cyrillic_SHA\")) return XK_Cyrillic_SHA;\n\tif (!strcmp(s, \"Cyrillic_E\")) return XK_Cyrillic_E;\n\tif (!strcmp(s, \"Cyrillic_SHCHA\")) return XK_Cyrillic_SHCHA;\n\tif (!strcmp(s, \"Cyrillic_CHE\")) return XK_Cyrillic_CHE;\n\tif (!strcmp(s, \"Cyrillic_HARDSIGN\")) return XK_Cyrillic_HARDSIGN;\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (!strcmp(s, \"Greek_ALPHAaccent\")) return XK_Greek_ALPHAaccent;\n\tif (!strcmp(s, \"Greek_EPSILONaccent\")) return XK_Greek_EPSILONaccent;\n\tif (!strcmp(s, \"Greek_ETAaccent\")) return XK_Greek_ETAaccent;\n\tif (!strcmp(s, \"Greek_IOTAaccent\")) return XK_Greek_IOTAaccent;\n\tif (!strcmp(s, \"Greek_IOTAdieresis\")) return XK_Greek_IOTAdieresis;\n\tif (!strcmp(s, \"Greek_OMICRONaccent\")) return XK_Greek_OMICRONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONaccent\")) return XK_Greek_UPSILONaccent;\n\tif (!strcmp(s, \"Greek_UPSILONdieresis\")) return XK_Greek_UPSILONdieresis;\n\tif (!strcmp(s, \"Greek_OMEGAaccent\")) return XK_Greek_OMEGAaccent;\n\tif (!strcmp(s, \"Greek_accentdieresis\")) return XK_Greek_accentdieresis;\n\tif (!strcmp(s, \"Greek_horizbar\")) return XK_Greek_horizbar;\n\tif (!strcmp(s, \"Greek_alphaaccent\")) return XK_Greek_alphaaccent;\n\tif (!strcmp(s, \"Greek_epsilonaccent\")) return XK_Greek_epsilonaccent;\n\tif (!strcmp(s, \"Greek_etaaccent\")) return XK_Greek_etaaccent;\n\tif (!strcmp(s, \"Greek_iotaaccent\")) return XK_Greek_iotaaccent;\n\tif (!strcmp(s, \"Greek_iotadieresis\")) return XK_Greek_iotadieresis;\n\tif (!strcmp(s, \"Greek_iotaaccentdieresis\")) return XK_Greek_iotaaccentdieresis;\n\tif (!strcmp(s, \"Greek_omicronaccent\")) return XK_Greek_omicronaccent;\n\tif (!strcmp(s, \"Greek_upsilonaccent\")) return XK_Greek_upsilonaccent;\n\tif (!strcmp(s, \"Greek_upsilondieresis\")) return XK_Greek_upsilondieresis;\n\tif (!strcmp(s, \"Greek_upsilonaccentdieresis\")) return XK_Greek_upsilonaccentdieresis;\n\tif (!strcmp(s, \"Greek_omegaaccent\")) return XK_Greek_omegaaccent;\n\tif (!strcmp(s, \"Greek_ALPHA\")) return XK_Greek_ALPHA;\n\tif (!strcmp(s, \"Greek_BETA\")) return XK_Greek_BETA;\n\tif (!strcmp(s, \"Greek_GAMMA\")) return XK_Greek_GAMMA;\n\tif (!strcmp(s, \"Greek_DELTA\")) return XK_Greek_DELTA;\n\tif (!strcmp(s, \"Greek_EPSILON\")) return XK_Greek_EPSILON;\n\tif (!strcmp(s, \"Greek_ZETA\")) return XK_Greek_ZETA;\n\tif (!strcmp(s, \"Greek_ETA\")) return XK_Greek_ETA;\n\tif (!strcmp(s, \"Greek_THETA\")) return XK_Greek_THETA;\n\tif (!strcmp(s, \"Greek_IOTA\")) return XK_Greek_IOTA;\n\tif (!strcmp(s, \"Greek_KAPPA\")) return XK_Greek_KAPPA;\n\tif (!strcmp(s, \"Greek_LAMDA\")) return XK_Greek_LAMDA;\n\tif (!strcmp(s, \"Greek_LAMBDA\")) return XK_Greek_LAMBDA;\n\tif (!strcmp(s, \"Greek_MU\")) return XK_Greek_MU;\n\tif (!strcmp(s, \"Greek_NU\")) return XK_Greek_NU;\n\tif (!strcmp(s, \"Greek_XI\")) return XK_Greek_XI;\n\tif (!strcmp(s, \"Greek_OMICRON\")) return XK_Greek_OMICRON;\n\tif (!strcmp(s, \"Greek_PI\")) return XK_Greek_PI;\n\tif (!strcmp(s, \"Greek_RHO\")) return XK_Greek_RHO;\n\tif (!strcmp(s, \"Greek_SIGMA\")) return XK_Greek_SIGMA;\n\tif (!strcmp(s, \"Greek_TAU\")) return XK_Greek_TAU;\n\tif (!strcmp(s, \"Greek_UPSILON\")) return XK_Greek_UPSILON;\n\tif (!strcmp(s, \"Greek_PHI\")) return XK_Greek_PHI;\n\tif (!strcmp(s, \"Greek_CHI\")) return XK_Greek_CHI;\n\tif (!strcmp(s, \"Greek_PSI\")) return XK_Greek_PSI;\n\tif (!strcmp(s, \"Greek_OMEGA\")) return XK_Greek_OMEGA;\n\tif (!strcmp(s, \"Greek_alpha\")) return XK_Greek_alpha;\n\tif (!strcmp(s, \"Greek_beta\")) return XK_Greek_beta;\n\tif (!strcmp(s, \"Greek_gamma\")) return XK_Greek_gamma;\n\tif (!strcmp(s, \"Greek_delta\")) return XK_Greek_delta;\n\tif (!strcmp(s, \"Greek_epsilon\")) return XK_Greek_epsilon;\n\tif (!strcmp(s, \"Greek_zeta\")) return XK_Greek_zeta;\n\tif (!strcmp(s, \"Greek_eta\")) return XK_Greek_eta;\n\tif (!strcmp(s, \"Greek_theta\")) return XK_Greek_theta;\n\tif (!strcmp(s, \"Greek_iota\")) return XK_Greek_iota;\n\tif (!strcmp(s, \"Greek_kappa\")) return XK_Greek_kappa;\n\tif (!strcmp(s, \"Greek_lamda\")) return XK_Greek_lamda;\n\tif (!strcmp(s, \"Greek_lambda\")) return XK_Greek_lambda;\n\tif (!strcmp(s, \"Greek_mu\")) return XK_Greek_mu;\n\tif (!strcmp(s, \"Greek_nu\")) return XK_Greek_nu;\n\tif (!strcmp(s, \"Greek_xi\")) return XK_Greek_xi;\n\tif (!strcmp(s, \"Greek_omicron\")) return XK_Greek_omicron;\n\tif (!strcmp(s, \"Greek_pi\")) return XK_Greek_pi;\n\tif (!strcmp(s, \"Greek_rho\")) return XK_Greek_rho;\n\tif (!strcmp(s, \"Greek_sigma\")) return XK_Greek_sigma;\n\tif (!strcmp(s, \"Greek_finalsmallsigma\")) return XK_Greek_finalsmallsigma;\n\tif (!strcmp(s, \"Greek_tau\")) return XK_Greek_tau;\n\tif (!strcmp(s, \"Greek_upsilon\")) return XK_Greek_upsilon;\n\tif (!strcmp(s, \"Greek_phi\")) return XK_Greek_phi;\n\tif (!strcmp(s, \"Greek_chi\")) return XK_Greek_chi;\n\tif (!strcmp(s, \"Greek_psi\")) return XK_Greek_psi;\n\tif (!strcmp(s, \"Greek_omega\")) return XK_Greek_omega;\n\tif (!strcmp(s, \"Greek_switch\")) return XK_Greek_switch;\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (!strcmp(s, \"leftradical\")) return XK_leftradical;\n\tif (!strcmp(s, \"topleftradical\")) return XK_topleftradical;\n\tif (!strcmp(s, \"horizconnector\")) return XK_horizconnector;\n\tif (!strcmp(s, \"topintegral\")) return XK_topintegral;\n\tif (!strcmp(s, \"botintegral\")) return XK_botintegral;\n\tif (!strcmp(s, \"vertconnector\")) return XK_vertconnector;\n\tif (!strcmp(s, \"topleftsqbracket\")) return XK_topleftsqbracket;\n\tif (!strcmp(s, \"botleftsqbracket\")) return XK_botleftsqbracket;\n\tif (!strcmp(s, \"toprightsqbracket\")) return XK_toprightsqbracket;\n\tif (!strcmp(s, \"botrightsqbracket\")) return XK_botrightsqbracket;\n\tif (!strcmp(s, \"topleftparens\")) return XK_topleftparens;\n\tif (!strcmp(s, \"botleftparens\")) return XK_botleftparens;\n\tif (!strcmp(s, \"toprightparens\")) return XK_toprightparens;\n\tif (!strcmp(s, \"botrightparens\")) return XK_botrightparens;\n\tif (!strcmp(s, \"leftmiddlecurlybrace\")) return XK_leftmiddlecurlybrace;\n\tif (!strcmp(s, \"rightmiddlecurlybrace\")) return XK_rightmiddlecurlybrace;\n\tif (!strcmp(s, \"topleftsummation\")) return XK_topleftsummation;\n\tif (!strcmp(s, \"botleftsummation\")) return XK_botleftsummation;\n\tif (!strcmp(s, \"topvertsummationconnector\")) return XK_topvertsummationconnector;\n\tif (!strcmp(s, \"botvertsummationconnector\")) return XK_botvertsummationconnector;\n\tif (!strcmp(s, \"toprightsummation\")) return XK_toprightsummation;\n\tif (!strcmp(s, \"botrightsummation\")) return XK_botrightsummation;\n\tif (!strcmp(s, \"rightmiddlesummation\")) return XK_rightmiddlesummation;\n\tif (!strcmp(s, \"lessthanequal\")) return XK_lessthanequal;\n\tif (!strcmp(s, \"notequal\")) return XK_notequal;\n\tif (!strcmp(s, \"greaterthanequal\")) return XK_greaterthanequal;\n\tif (!strcmp(s, \"integral\")) return XK_integral;\n\tif (!strcmp(s, \"therefore\")) return XK_therefore;\n\tif (!strcmp(s, \"variation\")) return XK_variation;\n\tif (!strcmp(s, \"infinity\")) return XK_infinity;\n\tif (!strcmp(s, \"nabla\")) return XK_nabla;\n\tif (!strcmp(s, \"approximate\")) return XK_approximate;\n\tif (!strcmp(s, \"similarequal\")) return XK_similarequal;\n\tif (!strcmp(s, \"ifonlyif\")) return XK_ifonlyif;\n\tif (!strcmp(s, \"implies\")) return XK_implies;\n\tif (!strcmp(s, \"identical\")) return XK_identical;\n\tif (!strcmp(s, \"radical\")) return XK_radical;\n\tif (!strcmp(s, \"includedin\")) return XK_includedin;\n\tif (!strcmp(s, \"includes\")) return XK_includes;\n\tif (!strcmp(s, \"intersection\")) return XK_intersection;\n\tif (!strcmp(s, \"union\")) return XK_union;\n\tif (!strcmp(s, \"logicaland\")) return XK_logicaland;\n\tif (!strcmp(s, \"logicalor\")) return XK_logicalor;\n\tif (!strcmp(s, \"partialderivative\")) return XK_partialderivative;\n\tif (!strcmp(s, \"function\")) return XK_function;\n\tif (!strcmp(s, \"leftarrow\")) return XK_leftarrow;\n\tif (!strcmp(s, \"uparrow\")) return XK_uparrow;\n\tif (!strcmp(s, \"rightarrow\")) return XK_rightarrow;\n\tif (!strcmp(s, \"downarrow\")) return XK_downarrow;\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (!strcmp(s, \"blank\")) return XK_blank;\n\tif (!strcmp(s, \"soliddiamond\")) return XK_soliddiamond;\n\tif (!strcmp(s, \"checkerboard\")) return XK_checkerboard;\n\tif (!strcmp(s, \"ht\")) return XK_ht;\n\tif (!strcmp(s, \"ff\")) return XK_ff;\n\tif (!strcmp(s, \"cr\")) return XK_cr;\n\tif (!strcmp(s, \"lf\")) return XK_lf;\n\tif (!strcmp(s, \"nl\")) return XK_nl;\n\tif (!strcmp(s, \"vt\")) return XK_vt;\n\tif (!strcmp(s, \"lowrightcorner\")) return XK_lowrightcorner;\n\tif (!strcmp(s, \"uprightcorner\")) return XK_uprightcorner;\n\tif (!strcmp(s, \"upleftcorner\")) return XK_upleftcorner;\n\tif (!strcmp(s, \"lowleftcorner\")) return XK_lowleftcorner;\n\tif (!strcmp(s, \"crossinglines\")) return XK_crossinglines;\n\tif (!strcmp(s, \"horizlinescan1\")) return XK_horizlinescan1;\n\tif (!strcmp(s, \"horizlinescan3\")) return XK_horizlinescan3;\n\tif (!strcmp(s, \"horizlinescan5\")) return XK_horizlinescan5;\n\tif (!strcmp(s, \"horizlinescan7\")) return XK_horizlinescan7;\n\tif (!strcmp(s, \"horizlinescan9\")) return XK_horizlinescan9;\n\tif (!strcmp(s, \"leftt\")) return XK_leftt;\n\tif (!strcmp(s, \"rightt\")) return XK_rightt;\n\tif (!strcmp(s, \"bott\")) return XK_bott;\n\tif (!strcmp(s, \"topt\")) return XK_topt;\n\tif (!strcmp(s, \"vertbar\")) return XK_vertbar;\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (!strcmp(s, \"emspace\")) return XK_emspace;\n\tif (!strcmp(s, \"enspace\")) return XK_enspace;\n\tif (!strcmp(s, \"em3space\")) return XK_em3space;\n\tif (!strcmp(s, \"em4space\")) return XK_em4space;\n\tif (!strcmp(s, \"digitspace\")) return XK_digitspace;\n\tif (!strcmp(s, \"punctspace\")) return XK_punctspace;\n\tif (!strcmp(s, \"thinspace\")) return XK_thinspace;\n\tif (!strcmp(s, \"hairspace\")) return XK_hairspace;\n\tif (!strcmp(s, \"emdash\")) return XK_emdash;\n\tif (!strcmp(s, \"endash\")) return XK_endash;\n\tif (!strcmp(s, \"signifblank\")) return XK_signifblank;\n\tif (!strcmp(s, \"ellipsis\")) return XK_ellipsis;\n\tif (!strcmp(s, \"doubbaselinedot\")) return XK_doubbaselinedot;\n\tif (!strcmp(s, \"onethird\")) return XK_onethird;\n\tif (!strcmp(s, \"twothirds\")) return XK_twothirds;\n\tif (!strcmp(s, \"onefifth\")) return XK_onefifth;\n\tif (!strcmp(s, \"twofifths\")) return XK_twofifths;\n\tif (!strcmp(s, \"threefifths\")) return XK_threefifths;\n\tif (!strcmp(s, \"fourfifths\")) return XK_fourfifths;\n\tif (!strcmp(s, \"onesixth\")) return XK_onesixth;\n\tif (!strcmp(s, \"fivesixths\")) return XK_fivesixths;\n\tif (!strcmp(s, \"careof\")) return XK_careof;\n\tif (!strcmp(s, \"figdash\")) return XK_figdash;\n\tif (!strcmp(s, \"leftanglebracket\")) return XK_leftanglebracket;\n\tif (!strcmp(s, \"decimalpoint\")) return XK_decimalpoint;\n\tif (!strcmp(s, \"rightanglebracket\")) return XK_rightanglebracket;\n\tif (!strcmp(s, \"marker\")) return XK_marker;\n\tif (!strcmp(s, \"oneeighth\")) return XK_oneeighth;\n\tif (!strcmp(s, \"threeeighths\")) return XK_threeeighths;\n\tif (!strcmp(s, \"fiveeighths\")) return XK_fiveeighths;\n\tif (!strcmp(s, \"seveneighths\")) return XK_seveneighths;\n\tif (!strcmp(s, \"trademark\")) return XK_trademark;\n\tif (!strcmp(s, \"signaturemark\")) return XK_signaturemark;\n\tif (!strcmp(s, \"trademarkincircle\")) return XK_trademarkincircle;\n\tif (!strcmp(s, \"leftopentriangle\")) return XK_leftopentriangle;\n\tif (!strcmp(s, \"rightopentriangle\")) return XK_rightopentriangle;\n\tif (!strcmp(s, \"emopencircle\")) return XK_emopencircle;\n\tif (!strcmp(s, \"emopenrectangle\")) return XK_emopenrectangle;\n\tif (!strcmp(s, \"leftsinglequotemark\")) return XK_leftsinglequotemark;\n\tif (!strcmp(s, \"rightsinglequotemark\")) return XK_rightsinglequotemark;\n\tif (!strcmp(s, \"leftdoublequotemark\")) return XK_leftdoublequotemark;\n\tif (!strcmp(s, \"rightdoublequotemark\")) return XK_rightdoublequotemark;\n\tif (!strcmp(s, \"prescription\")) return XK_prescription;\n\tif (!strcmp(s, \"minutes\")) return XK_minutes;\n\tif (!strcmp(s, \"seconds\")) return XK_seconds;\n\tif (!strcmp(s, \"latincross\")) return XK_latincross;\n\tif (!strcmp(s, \"hexagram\")) return XK_hexagram;\n\tif (!strcmp(s, \"filledrectbullet\")) return XK_filledrectbullet;\n\tif (!strcmp(s, \"filledlefttribullet\")) return XK_filledlefttribullet;\n\tif (!strcmp(s, \"filledrighttribullet\")) return XK_filledrighttribullet;\n\tif (!strcmp(s, \"emfilledcircle\")) return XK_emfilledcircle;\n\tif (!strcmp(s, \"emfilledrect\")) return XK_emfilledrect;\n\tif (!strcmp(s, \"enopencircbullet\")) return XK_enopencircbullet;\n\tif (!strcmp(s, \"enopensquarebullet\")) return XK_enopensquarebullet;\n\tif (!strcmp(s, \"openrectbullet\")) return XK_openrectbullet;\n\tif (!strcmp(s, \"opentribulletup\")) return XK_opentribulletup;\n\tif (!strcmp(s, \"opentribulletdown\")) return XK_opentribulletdown;\n\tif (!strcmp(s, \"openstar\")) return XK_openstar;\n\tif (!strcmp(s, \"enfilledcircbullet\")) return XK_enfilledcircbullet;\n\tif (!strcmp(s, \"enfilledsqbullet\")) return XK_enfilledsqbullet;\n\tif (!strcmp(s, \"filledtribulletup\")) return XK_filledtribulletup;\n\tif (!strcmp(s, \"filledtribulletdown\")) return XK_filledtribulletdown;\n\tif (!strcmp(s, \"leftpointer\")) return XK_leftpointer;\n\tif (!strcmp(s, \"rightpointer\")) return XK_rightpointer;\n\tif (!strcmp(s, \"club\")) return XK_club;\n\tif (!strcmp(s, \"diamond\")) return XK_diamond;\n\tif (!strcmp(s, \"heart\")) return XK_heart;\n\tif (!strcmp(s, \"maltesecross\")) return XK_maltesecross;\n\tif (!strcmp(s, \"dagger\")) return XK_dagger;\n\tif (!strcmp(s, \"doubledagger\")) return XK_doubledagger;\n\tif (!strcmp(s, \"checkmark\")) return XK_checkmark;\n\tif (!strcmp(s, \"ballotcross\")) return XK_ballotcross;\n\tif (!strcmp(s, \"musicalsharp\")) return XK_musicalsharp;\n\tif (!strcmp(s, \"musicalflat\")) return XK_musicalflat;\n\tif (!strcmp(s, \"malesymbol\")) return XK_malesymbol;\n\tif (!strcmp(s, \"femalesymbol\")) return XK_femalesymbol;\n\tif (!strcmp(s, \"telephone\")) return XK_telephone;\n\tif (!strcmp(s, \"telephonerecorder\")) return XK_telephonerecorder;\n\tif (!strcmp(s, \"phonographcopyright\")) return XK_phonographcopyright;\n\tif (!strcmp(s, \"caret\")) return XK_caret;\n\tif (!strcmp(s, \"singlelowquotemark\")) return XK_singlelowquotemark;\n\tif (!strcmp(s, \"doublelowquotemark\")) return XK_doublelowquotemark;\n\tif (!strcmp(s, \"cursor\")) return XK_cursor;\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (!strcmp(s, \"leftcaret\")) return XK_leftcaret;\n\tif (!strcmp(s, \"rightcaret\")) return XK_rightcaret;\n\tif (!strcmp(s, \"downcaret\")) return XK_downcaret;\n\tif (!strcmp(s, \"upcaret\")) return XK_upcaret;\n\tif (!strcmp(s, \"overbar\")) return XK_overbar;\n\tif (!strcmp(s, \"downtack\")) return XK_downtack;\n\tif (!strcmp(s, \"upshoe\")) return XK_upshoe;\n\tif (!strcmp(s, \"downstile\")) return XK_downstile;\n\tif (!strcmp(s, \"underbar\")) return XK_underbar;\n\tif (!strcmp(s, \"jot\")) return XK_jot;\n\tif (!strcmp(s, \"quad\")) return XK_quad;\n\tif (!strcmp(s, \"uptack\")) return XK_uptack;\n\tif (!strcmp(s, \"circle\")) return XK_circle;\n\tif (!strcmp(s, \"upstile\")) return XK_upstile;\n\tif (!strcmp(s, \"downshoe\")) return XK_downshoe;\n\tif (!strcmp(s, \"rightshoe\")) return XK_rightshoe;\n\tif (!strcmp(s, \"leftshoe\")) return XK_leftshoe;\n\tif (!strcmp(s, \"lefttack\")) return XK_lefttack;\n\tif (!strcmp(s, \"righttack\")) return XK_righttack;\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (!strcmp(s, \"hebrew_doublelowline\")) return XK_hebrew_doublelowline;\n\tif (!strcmp(s, \"hebrew_aleph\")) return XK_hebrew_aleph;\n\tif (!strcmp(s, \"hebrew_bet\")) return XK_hebrew_bet;\n\tif (!strcmp(s, \"hebrew_beth\")) return XK_hebrew_beth;\n\tif (!strcmp(s, \"hebrew_gimel\")) return XK_hebrew_gimel;\n\tif (!strcmp(s, \"hebrew_gimmel\")) return XK_hebrew_gimmel;\n\tif (!strcmp(s, \"hebrew_dalet\")) return XK_hebrew_dalet;\n\tif (!strcmp(s, \"hebrew_daleth\")) return XK_hebrew_daleth;\n\tif (!strcmp(s, \"hebrew_he\")) return XK_hebrew_he;\n\tif (!strcmp(s, \"hebrew_waw\")) return XK_hebrew_waw;\n\tif (!strcmp(s, \"hebrew_zain\")) return XK_hebrew_zain;\n\tif (!strcmp(s, \"hebrew_zayin\")) return XK_hebrew_zayin;\n\tif (!strcmp(s, \"hebrew_chet\")) return XK_hebrew_chet;\n\tif (!strcmp(s, \"hebrew_het\")) return XK_hebrew_het;\n\tif (!strcmp(s, \"hebrew_tet\")) return XK_hebrew_tet;\n\tif (!strcmp(s, \"hebrew_teth\")) return XK_hebrew_teth;\n\tif (!strcmp(s, \"hebrew_yod\")) return XK_hebrew_yod;\n\tif (!strcmp(s, \"hebrew_finalkaph\")) return XK_hebrew_finalkaph;\n\tif (!strcmp(s, \"hebrew_kaph\")) return XK_hebrew_kaph;\n\tif (!strcmp(s, \"hebrew_lamed\")) return XK_hebrew_lamed;\n\tif (!strcmp(s, \"hebrew_finalmem\")) return XK_hebrew_finalmem;\n\tif (!strcmp(s, \"hebrew_mem\")) return XK_hebrew_mem;\n\tif (!strcmp(s, \"hebrew_finalnun\")) return XK_hebrew_finalnun;\n\tif (!strcmp(s, \"hebrew_nun\")) return XK_hebrew_nun;\n\tif (!strcmp(s, \"hebrew_samech\")) return XK_hebrew_samech;\n\tif (!strcmp(s, \"hebrew_samekh\")) return XK_hebrew_samekh;\n\tif (!strcmp(s, \"hebrew_ayin\")) return XK_hebrew_ayin;\n\tif (!strcmp(s, \"hebrew_finalpe\")) return XK_hebrew_finalpe;\n\tif (!strcmp(s, \"hebrew_pe\")) return XK_hebrew_pe;\n\tif (!strcmp(s, \"hebrew_finalzade\")) return XK_hebrew_finalzade;\n\tif (!strcmp(s, \"hebrew_finalzadi\")) return XK_hebrew_finalzadi;\n\tif (!strcmp(s, \"hebrew_zade\")) return XK_hebrew_zade;\n\tif (!strcmp(s, \"hebrew_zadi\")) return XK_hebrew_zadi;\n\tif (!strcmp(s, \"hebrew_qoph\")) return XK_hebrew_qoph;\n\tif (!strcmp(s, \"hebrew_kuf\")) return XK_hebrew_kuf;\n\tif (!strcmp(s, \"hebrew_resh\")) return XK_hebrew_resh;\n\tif (!strcmp(s, \"hebrew_shin\")) return XK_hebrew_shin;\n\tif (!strcmp(s, \"hebrew_taw\")) return XK_hebrew_taw;\n\tif (!strcmp(s, \"hebrew_taf\")) return XK_hebrew_taf;\n\tif (!strcmp(s, \"Hebrew_switch\")) return XK_Hebrew_switch;\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (!strcmp(s, \"Thai_kokai\")) return XK_Thai_kokai;\n\tif (!strcmp(s, \"Thai_khokhai\")) return XK_Thai_khokhai;\n\tif (!strcmp(s, \"Thai_khokhuat\")) return XK_Thai_khokhuat;\n\tif (!strcmp(s, \"Thai_khokhwai\")) return XK_Thai_khokhwai;\n\tif (!strcmp(s, \"Thai_khokhon\")) return XK_Thai_khokhon;\n\tif (!strcmp(s, \"Thai_khorakhang\")) return XK_Thai_khorakhang;\n\tif (!strcmp(s, \"Thai_ngongu\")) return XK_Thai_ngongu;\n\tif (!strcmp(s, \"Thai_chochan\")) return XK_Thai_chochan;\n\tif (!strcmp(s, \"Thai_choching\")) return XK_Thai_choching;\n\tif (!strcmp(s, \"Thai_chochang\")) return XK_Thai_chochang;\n\tif (!strcmp(s, \"Thai_soso\")) return XK_Thai_soso;\n\tif (!strcmp(s, \"Thai_chochoe\")) return XK_Thai_chochoe;\n\tif (!strcmp(s, \"Thai_yoying\")) return XK_Thai_yoying;\n\tif (!strcmp(s, \"Thai_dochada\")) return XK_Thai_dochada;\n\tif (!strcmp(s, \"Thai_topatak\")) return XK_Thai_topatak;\n\tif (!strcmp(s, \"Thai_thothan\")) return XK_Thai_thothan;\n\tif (!strcmp(s, \"Thai_thonangmontho\")) return XK_Thai_thonangmontho;\n\tif (!strcmp(s, \"Thai_thophuthao\")) return XK_Thai_thophuthao;\n\tif (!strcmp(s, \"Thai_nonen\")) return XK_Thai_nonen;\n\tif (!strcmp(s, \"Thai_dodek\")) return XK_Thai_dodek;\n\tif (!strcmp(s, \"Thai_totao\")) return XK_Thai_totao;\n\tif (!strcmp(s, \"Thai_thothung\")) return XK_Thai_thothung;\n\tif (!strcmp(s, \"Thai_thothahan\")) return XK_Thai_thothahan;\n\tif (!strcmp(s, \"Thai_thothong\")) return XK_Thai_thothong;\n\tif (!strcmp(s, \"Thai_nonu\")) return XK_Thai_nonu;\n\tif (!strcmp(s, \"Thai_bobaimai\")) return XK_Thai_bobaimai;\n\tif (!strcmp(s, \"Thai_popla\")) return XK_Thai_popla;\n\tif (!strcmp(s, \"Thai_phophung\")) return XK_Thai_phophung;\n\tif (!strcmp(s, \"Thai_fofa\")) return XK_Thai_fofa;\n\tif (!strcmp(s, \"Thai_phophan\")) return XK_Thai_phophan;\n\tif (!strcmp(s, \"Thai_fofan\")) return XK_Thai_fofan;\n\tif (!strcmp(s, \"Thai_phosamphao\")) return XK_Thai_phosamphao;\n\tif (!strcmp(s, \"Thai_moma\")) return XK_Thai_moma;\n\tif (!strcmp(s, \"Thai_yoyak\")) return XK_Thai_yoyak;\n\tif (!strcmp(s, \"Thai_rorua\")) return XK_Thai_rorua;\n\tif (!strcmp(s, \"Thai_ru\")) return XK_Thai_ru;\n\tif (!strcmp(s, \"Thai_loling\")) return XK_Thai_loling;\n\tif (!strcmp(s, \"Thai_lu\")) return XK_Thai_lu;\n\tif (!strcmp(s, \"Thai_wowaen\")) return XK_Thai_wowaen;\n\tif (!strcmp(s, \"Thai_sosala\")) return XK_Thai_sosala;\n\tif (!strcmp(s, \"Thai_sorusi\")) return XK_Thai_sorusi;\n\tif (!strcmp(s, \"Thai_sosua\")) return XK_Thai_sosua;\n\tif (!strcmp(s, \"Thai_hohip\")) return XK_Thai_hohip;\n\tif (!strcmp(s, \"Thai_lochula\")) return XK_Thai_lochula;\n\tif (!strcmp(s, \"Thai_oang\")) return XK_Thai_oang;\n\tif (!strcmp(s, \"Thai_honokhuk\")) return XK_Thai_honokhuk;\n\tif (!strcmp(s, \"Thai_paiyannoi\")) return XK_Thai_paiyannoi;\n\tif (!strcmp(s, \"Thai_saraa\")) return XK_Thai_saraa;\n\tif (!strcmp(s, \"Thai_maihanakat\")) return XK_Thai_maihanakat;\n\tif (!strcmp(s, \"Thai_saraaa\")) return XK_Thai_saraaa;\n\tif (!strcmp(s, \"Thai_saraam\")) return XK_Thai_saraam;\n\tif (!strcmp(s, \"Thai_sarai\")) return XK_Thai_sarai;\n\tif (!strcmp(s, \"Thai_saraii\")) return XK_Thai_saraii;\n\tif (!strcmp(s, \"Thai_saraue\")) return XK_Thai_saraue;\n\tif (!strcmp(s, \"Thai_sarauee\")) return XK_Thai_sarauee;\n\tif (!strcmp(s, \"Thai_sarau\")) return XK_Thai_sarau;\n\tif (!strcmp(s, \"Thai_sarauu\")) return XK_Thai_sarauu;\n\tif (!strcmp(s, \"Thai_phinthu\")) return XK_Thai_phinthu;\n\tif (!strcmp(s, \"Thai_maihanakat_maitho\")) return XK_Thai_maihanakat_maitho;\n\tif (!strcmp(s, \"Thai_baht\")) return XK_Thai_baht;\n\tif (!strcmp(s, \"Thai_sarae\")) return XK_Thai_sarae;\n\tif (!strcmp(s, \"Thai_saraae\")) return XK_Thai_saraae;\n\tif (!strcmp(s, \"Thai_sarao\")) return XK_Thai_sarao;\n\tif (!strcmp(s, \"Thai_saraaimaimuan\")) return XK_Thai_saraaimaimuan;\n\tif (!strcmp(s, \"Thai_saraaimaimalai\")) return XK_Thai_saraaimaimalai;\n\tif (!strcmp(s, \"Thai_lakkhangyao\")) return XK_Thai_lakkhangyao;\n\tif (!strcmp(s, \"Thai_maiyamok\")) return XK_Thai_maiyamok;\n\tif (!strcmp(s, \"Thai_maitaikhu\")) return XK_Thai_maitaikhu;\n\tif (!strcmp(s, \"Thai_maiek\")) return XK_Thai_maiek;\n\tif (!strcmp(s, \"Thai_maitho\")) return XK_Thai_maitho;\n\tif (!strcmp(s, \"Thai_maitri\")) return XK_Thai_maitri;\n\tif (!strcmp(s, \"Thai_maichattawa\")) return XK_Thai_maichattawa;\n\tif (!strcmp(s, \"Thai_thanthakhat\")) return XK_Thai_thanthakhat;\n\tif (!strcmp(s, \"Thai_nikhahit\")) return XK_Thai_nikhahit;\n\tif (!strcmp(s, \"Thai_leksun\")) return XK_Thai_leksun;\n\tif (!strcmp(s, \"Thai_leknung\")) return XK_Thai_leknung;\n\tif (!strcmp(s, \"Thai_leksong\")) return XK_Thai_leksong;\n\tif (!strcmp(s, \"Thai_leksam\")) return XK_Thai_leksam;\n\tif (!strcmp(s, \"Thai_leksi\")) return XK_Thai_leksi;\n\tif (!strcmp(s, \"Thai_lekha\")) return XK_Thai_lekha;\n\tif (!strcmp(s, \"Thai_lekhok\")) return XK_Thai_lekhok;\n\tif (!strcmp(s, \"Thai_lekchet\")) return XK_Thai_lekchet;\n\tif (!strcmp(s, \"Thai_lekpaet\")) return XK_Thai_lekpaet;\n\tif (!strcmp(s, \"Thai_lekkao\")) return XK_Thai_lekkao;\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (!strcmp(s, \"Hangul\")) return XK_Hangul;\n\tif (!strcmp(s, \"Hangul_Start\")) return XK_Hangul_Start;\n\tif (!strcmp(s, \"Hangul_End\")) return XK_Hangul_End;\n\tif (!strcmp(s, \"Hangul_Hanja\")) return XK_Hangul_Hanja;\n\tif (!strcmp(s, \"Hangul_Jamo\")) return XK_Hangul_Jamo;\n\tif (!strcmp(s, \"Hangul_Romaja\")) return XK_Hangul_Romaja;\n\tif (!strcmp(s, \"Hangul_Codeinput\")) return XK_Hangul_Codeinput;\n\tif (!strcmp(s, \"Hangul_Jeonja\")) return XK_Hangul_Jeonja;\n\tif (!strcmp(s, \"Hangul_Banja\")) return XK_Hangul_Banja;\n\tif (!strcmp(s, \"Hangul_PreHanja\")) return XK_Hangul_PreHanja;\n\tif (!strcmp(s, \"Hangul_PostHanja\")) return XK_Hangul_PostHanja;\n\tif (!strcmp(s, \"Hangul_SingleCandidate\")) return XK_Hangul_SingleCandidate;\n\tif (!strcmp(s, \"Hangul_MultipleCandidate\")) return XK_Hangul_MultipleCandidate;\n\tif (!strcmp(s, \"Hangul_PreviousCandidate\")) return XK_Hangul_PreviousCandidate;\n\tif (!strcmp(s, \"Hangul_Special\")) return XK_Hangul_Special;\n\tif (!strcmp(s, \"Hangul_switch\")) return XK_Hangul_switch;\n\tif (!strcmp(s, \"Hangul_Kiyeog\")) return XK_Hangul_Kiyeog;\n\tif (!strcmp(s, \"Hangul_SsangKiyeog\")) return XK_Hangul_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_KiyeogSios\")) return XK_Hangul_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_Nieun\")) return XK_Hangul_Nieun;\n\tif (!strcmp(s, \"Hangul_NieunJieuj\")) return XK_Hangul_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_NieunHieuh\")) return XK_Hangul_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_Dikeud\")) return XK_Hangul_Dikeud;\n\tif (!strcmp(s, \"Hangul_SsangDikeud\")) return XK_Hangul_SsangDikeud;\n\tif (!strcmp(s, \"Hangul_Rieul\")) return XK_Hangul_Rieul;\n\tif (!strcmp(s, \"Hangul_RieulKiyeog\")) return XK_Hangul_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_RieulMieum\")) return XK_Hangul_RieulMieum;\n\tif (!strcmp(s, \"Hangul_RieulPieub\")) return XK_Hangul_RieulPieub;\n\tif (!strcmp(s, \"Hangul_RieulSios\")) return XK_Hangul_RieulSios;\n\tif (!strcmp(s, \"Hangul_RieulTieut\")) return XK_Hangul_RieulTieut;\n\tif (!strcmp(s, \"Hangul_RieulPhieuf\")) return XK_Hangul_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_RieulHieuh\")) return XK_Hangul_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_Mieum\")) return XK_Hangul_Mieum;\n\tif (!strcmp(s, \"Hangul_Pieub\")) return XK_Hangul_Pieub;\n\tif (!strcmp(s, \"Hangul_SsangPieub\")) return XK_Hangul_SsangPieub;\n\tif (!strcmp(s, \"Hangul_PieubSios\")) return XK_Hangul_PieubSios;\n\tif (!strcmp(s, \"Hangul_Sios\")) return XK_Hangul_Sios;\n\tif (!strcmp(s, \"Hangul_SsangSios\")) return XK_Hangul_SsangSios;\n\tif (!strcmp(s, \"Hangul_Ieung\")) return XK_Hangul_Ieung;\n\tif (!strcmp(s, \"Hangul_Jieuj\")) return XK_Hangul_Jieuj;\n\tif (!strcmp(s, \"Hangul_SsangJieuj\")) return XK_Hangul_SsangJieuj;\n\tif (!strcmp(s, \"Hangul_Cieuc\")) return XK_Hangul_Cieuc;\n\tif (!strcmp(s, \"Hangul_Khieuq\")) return XK_Hangul_Khieuq;\n\tif (!strcmp(s, \"Hangul_Tieut\")) return XK_Hangul_Tieut;\n\tif (!strcmp(s, \"Hangul_Phieuf\")) return XK_Hangul_Phieuf;\n\tif (!strcmp(s, \"Hangul_Hieuh\")) return XK_Hangul_Hieuh;\n\tif (!strcmp(s, \"Hangul_A\")) return XK_Hangul_A;\n\tif (!strcmp(s, \"Hangul_AE\")) return XK_Hangul_AE;\n\tif (!strcmp(s, \"Hangul_YA\")) return XK_Hangul_YA;\n\tif (!strcmp(s, \"Hangul_YAE\")) return XK_Hangul_YAE;\n\tif (!strcmp(s, \"Hangul_EO\")) return XK_Hangul_EO;\n\tif (!strcmp(s, \"Hangul_E\")) return XK_Hangul_E;\n\tif (!strcmp(s, \"Hangul_YEO\")) return XK_Hangul_YEO;\n\tif (!strcmp(s, \"Hangul_YE\")) return XK_Hangul_YE;\n\tif (!strcmp(s, \"Hangul_O\")) return XK_Hangul_O;\n\tif (!strcmp(s, \"Hangul_WA\")) return XK_Hangul_WA;\n\tif (!strcmp(s, \"Hangul_WAE\")) return XK_Hangul_WAE;\n\tif (!strcmp(s, \"Hangul_OE\")) return XK_Hangul_OE;\n\tif (!strcmp(s, \"Hangul_YO\")) return XK_Hangul_YO;\n\tif (!strcmp(s, \"Hangul_U\")) return XK_Hangul_U;\n\tif (!strcmp(s, \"Hangul_WEO\")) return XK_Hangul_WEO;\n\tif (!strcmp(s, \"Hangul_WE\")) return XK_Hangul_WE;\n\tif (!strcmp(s, \"Hangul_WI\")) return XK_Hangul_WI;\n\tif (!strcmp(s, \"Hangul_YU\")) return XK_Hangul_YU;\n\tif (!strcmp(s, \"Hangul_EU\")) return XK_Hangul_EU;\n\tif (!strcmp(s, \"Hangul_YI\")) return XK_Hangul_YI;\n\tif (!strcmp(s, \"Hangul_I\")) return XK_Hangul_I;\n\tif (!strcmp(s, \"Hangul_J_Kiyeog\")) return XK_Hangul_J_Kiyeog;\n\tif (!strcmp(s, \"Hangul_J_SsangKiyeog\")) return XK_Hangul_J_SsangKiyeog;\n\tif (!strcmp(s, \"Hangul_J_KiyeogSios\")) return XK_Hangul_J_KiyeogSios;\n\tif (!strcmp(s, \"Hangul_J_Nieun\")) return XK_Hangul_J_Nieun;\n\tif (!strcmp(s, \"Hangul_J_NieunJieuj\")) return XK_Hangul_J_NieunJieuj;\n\tif (!strcmp(s, \"Hangul_J_NieunHieuh\")) return XK_Hangul_J_NieunHieuh;\n\tif (!strcmp(s, \"Hangul_J_Dikeud\")) return XK_Hangul_J_Dikeud;\n\tif (!strcmp(s, \"Hangul_J_Rieul\")) return XK_Hangul_J_Rieul;\n\tif (!strcmp(s, \"Hangul_J_RieulKiyeog\")) return XK_Hangul_J_RieulKiyeog;\n\tif (!strcmp(s, \"Hangul_J_RieulMieum\")) return XK_Hangul_J_RieulMieum;\n\tif (!strcmp(s, \"Hangul_J_RieulPieub\")) return XK_Hangul_J_RieulPieub;\n\tif (!strcmp(s, \"Hangul_J_RieulSios\")) return XK_Hangul_J_RieulSios;\n\tif (!strcmp(s, \"Hangul_J_RieulTieut\")) return XK_Hangul_J_RieulTieut;\n\tif (!strcmp(s, \"Hangul_J_RieulPhieuf\")) return XK_Hangul_J_RieulPhieuf;\n\tif (!strcmp(s, \"Hangul_J_RieulHieuh\")) return XK_Hangul_J_RieulHieuh;\n\tif (!strcmp(s, \"Hangul_J_Mieum\")) return XK_Hangul_J_Mieum;\n\tif (!strcmp(s, \"Hangul_J_Pieub\")) return XK_Hangul_J_Pieub;\n\tif (!strcmp(s, \"Hangul_J_PieubSios\")) return XK_Hangul_J_PieubSios;\n\tif (!strcmp(s, \"Hangul_J_Sios\")) return XK_Hangul_J_Sios;\n\tif (!strcmp(s, \"Hangul_J_SsangSios\")) return XK_Hangul_J_SsangSios;\n\tif (!strcmp(s, \"Hangul_J_Ieung\")) return XK_Hangul_J_Ieung;\n\tif (!strcmp(s, \"Hangul_J_Jieuj\")) return XK_Hangul_J_Jieuj;\n\tif (!strcmp(s, \"Hangul_J_Cieuc\")) return XK_Hangul_J_Cieuc;\n\tif (!strcmp(s, \"Hangul_J_Khieuq\")) return XK_Hangul_J_Khieuq;\n\tif (!strcmp(s, \"Hangul_J_Tieut\")) return XK_Hangul_J_Tieut;\n\tif (!strcmp(s, \"Hangul_J_Phieuf\")) return XK_Hangul_J_Phieuf;\n\tif (!strcmp(s, \"Hangul_J_Hieuh\")) return XK_Hangul_J_Hieuh;\n\tif (!strcmp(s, \"Hangul_RieulYeorinHieuh\")) return XK_Hangul_RieulYeorinHieuh;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumMieum\")) return XK_Hangul_SunkyeongeumMieum;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPieub\")) return XK_Hangul_SunkyeongeumPieub;\n\tif (!strcmp(s, \"Hangul_PanSios\")) return XK_Hangul_PanSios;\n\tif (!strcmp(s, \"Hangul_KkogjiDalrinIeung\")) return XK_Hangul_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_SunkyeongeumPhieuf\")) return XK_Hangul_SunkyeongeumPhieuf;\n\tif (!strcmp(s, \"Hangul_YeorinHieuh\")) return XK_Hangul_YeorinHieuh;\n\tif (!strcmp(s, \"Hangul_AraeA\")) return XK_Hangul_AraeA;\n\tif (!strcmp(s, \"Hangul_AraeAE\")) return XK_Hangul_AraeAE;\n\tif (!strcmp(s, \"Hangul_J_PanSios\")) return XK_Hangul_J_PanSios;\n\tif (!strcmp(s, \"Hangul_J_KkogjiDalrinIeung\")) return XK_Hangul_J_KkogjiDalrinIeung;\n\tif (!strcmp(s, \"Hangul_J_YeorinHieuh\")) return XK_Hangul_J_YeorinHieuh;\n\tif (!strcmp(s, \"Korean_Won\")) return XK_Korean_Won;\n#endif /* XK_KOREAN */\n\tif (!strcmp(s, \"EuroSign\")) return XK_EuroSign;\n#endif\n\treturn NoSymbol;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "stri",
            "sizeof stri",
            "\"        (%s)\"",
            "userhost"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strh",
            "sizeof strh",
            "\"x11vnc: client disconnected from %s\"",
            "addr"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strh",
            "sizeof strh",
            "\"x11vnc: %s connection from %s?\"",
            "type",
            "ip"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "userhost",
            "\"UNIX:\""
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "awin"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetDashes",
          "args": [
            "dpy",
            "gc",
            "0",
            "dash_list",
            "list_length"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetLineAttributes",
          "args": [
            "dpy",
            "gc",
            "1",
            "LineSolid",
            "CapButt",
            "JoinMiter"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetForeground",
          "args": [
            "dpy",
            "gc",
            "BlackPixel(dpy, scr)"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetFont",
          "args": [
            "dpy",
            "gc",
            "font_info->fid"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateGC",
          "args": [
            "dpy",
            "awin",
            "valuemask",
            "&values"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ugly_window: cannot locate font fixed.\\n\""
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLoadQueryFont",
          "args": [
            "dpy",
            "\"fixed\""
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetStandardProperties",
          "args": [
            "dpy",
            "awin",
            "sprop",
            "\"x11vnc query\"",
            "ico",
            "NULL",
            "0",
            "&hints"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateBitmapFromData",
          "args": [
            "dpy",
            "awin",
            "(char *) t2x2_bits",
            "t2x2_width",
            "t2x2_height"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetWMProtocols",
          "args": [
            "dpy",
            "awin",
            "&wm_delete_window",
            "1"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"WM_DELETE_WINDOW\"",
            "False"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"WM_PROTOCOLS\"",
            "False"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateSimpleWindow",
          "args": [
            "dpy",
            "window",
            "x",
            "y",
            "w",
            "h",
            "4",
            "BlackPixel(dpy, scr)",
            "WhitePixel(dpy, scr)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WhitePixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"key_only\""
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"mouse_only\""
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str_y",
            "\"OK\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nox11_exit",
          "args": [
            "1"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "nox11_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1711-1718",
          "snippet": "void nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid nox11_exit(int rc) {\n#if NO_X11\n\trfbLog(\"This x11vnc was not built with X11 support.\\n\");\n\tclean_up_exit(rc);\n#else\n\tif (0) {rc = 0;}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define t2x2_height 16\n#define t2x2_width 16\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\n\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept) {\n#if NO_X11\n\tif (!addr || !userhost || !X || !Y || !timeout || !mode || !accept) {}\n\tRAWFB_RET(0)\n\tnox11_exit(1);\n\treturn 0;\n#else\n\n#define t2x2_width 16\n#define t2x2_height 16\nstatic unsigned char t2x2_bits[] = {\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff,\n   0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33,\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33};\n\n\tWindow awin;\n\tGC gc;\n\tXSizeHints hints;\n\tXGCValues values;\n\tstatic XFontStruct *font_info = NULL;\n\tstatic Pixmap ico = 0;\n\tunsigned long valuemask = 0;\n\tstatic char dash_list[] = {20, 40};\n\tint list_length = sizeof(dash_list);\n\n\tAtom wm_protocols;\n\tAtom wm_delete_window;\n\n\tXEvent ev;\n\tlong evmask = ExposureMask | KeyPressMask | ButtonPressMask\n\t    | StructureNotifyMask;\n\tdouble waited = 0.0;\n\n\t/* strings and geometries y/n */\n\tKeyCode key_y, key_n, key_v;\n\tchar strh[100];\n\tchar stri[100];\n\tchar str1_b[] = \"To accept: press \\\"y\\\" or click the \\\"Yes\\\" button\";\n\tchar str2_b[] = \"To reject: press \\\"n\\\" or click the \\\"No\\\" button\";\n\tchar str3_b[] = \"View only: press \\\"v\\\" or click the \\\"View\\\" button\";\n\tchar str1_m[] = \"To accept: click the \\\"Yes\\\" button\";\n\tchar str2_m[] = \"To reject: click the \\\"No\\\" button\";\n\tchar str3_m[] = \"View only: click the \\\"View\\\" button\";\n\tchar str1_k[] = \"To accept: press \\\"y\\\"\";\n\tchar str2_k[] = \"To reject: press \\\"n\\\"\";\n\tchar str3_k[] = \"View only: press \\\"v\\\"\";\n\tchar *str1, *str2, *str3;\n\tchar str_y[] = \"Yes\";\n\tchar str_n[] = \"No\";\n\tchar str_v[] = \"View\";\n\tint x, y, w = 345, h = 175, ret = 0;\n\tint X_sh = 20, Y_sh = 30, dY = 20;\n\tint Ye_x = 20,  Ye_y = 0, Ye_w = 45, Ye_h = 20;\n\tint No_x = 75,  No_y = 0, No_w = 45, No_h = 20; \n\tint Vi_x = 130, Vi_y = 0, Vi_w = 45, Vi_h = 20; \n\tchar *sprop = \"new x11vnc client\";\n\n\tKeyCode key_o;\n\n\tRAWFB_RET(0)\n\n\tif (! accept) {\n\t\tsprintf(str_y, \"OK\");\n\t\tsprop = \"x11vnc client disconnected\";\n\t\th = 110;\n\t\tstr1 = \"\";\n\t\tstr2 = \"\";\n\t\tstr3 = \"\";\n\t} else if (!strcmp(mode, \"mouse_only\")) {\n\t\tstr1 = str1_m;\n\t\tstr2 = str2_m;\n\t\tstr3 = str3_m;\n\t} else if (!strcmp(mode, \"key_only\")) {\n\t\tstr1 = str1_k;\n\t\tstr2 = str2_k;\n\t\tstr3 = str3_k;\n\t\th -= dY;\n\t} else {\n\t\tstr1 = str1_b;\n\t\tstr2 = str2_b;\n\t\tstr3 = str3_b;\n\t}\n\tif (view_only) {\n\t\th -= dY;\n\t}\n\n\t/* XXX handle coff_x/coff_y? */\n\tif (X < -dpy_x) {\n\t\tx = (dpy_x - w)/2;\t/* large negative: center */\n\t\tif (x < 0) x = 0;\n\t} else if (X < 0) {\n\t\tx = dpy_x + X - w;\t/* from lower right */\n\t} else {\n\t\tx = X;\t\t\t/* from upper left */\n\t}\n\t\n\tif (Y < -dpy_y) {\n\t\ty = (dpy_y - h)/2;\n\t\tif (y < 0) y = 0;\n\t} else if (Y < 0) {\n\t\ty = dpy_y + Y - h;\n\t} else {\n\t\ty = Y;\n\t}\n\n\tX_LOCK;\n\n\tawin = XCreateSimpleWindow(dpy, window, x, y, w, h, 4,\n\t    BlackPixel(dpy, scr), WhitePixel(dpy, scr));\n\n\twm_protocols = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\twm_delete_window = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\tXSetWMProtocols(dpy, awin, &wm_delete_window, 1);\n\n\tif (! ico) {\n\t\tico = XCreateBitmapFromData(dpy, awin, (char *) t2x2_bits,\n\t\t    t2x2_width, t2x2_height);\n\t}\n\n\thints.flags = PPosition | PSize | PMinSize;\n\thints.x = x;\n\thints.y = y;\n\thints.width = w;\n\thints.height = h;\n\thints.min_width = w;\n\thints.min_height = h;\n\n\tXSetStandardProperties(dpy, awin, sprop, \"x11vnc query\", ico, NULL,\n\t    0, &hints);\n\n\tXSelectInput_wr(dpy, awin, evmask);\n\n\tif (! font_info && (font_info = XLoadQueryFont(dpy, \"fixed\")) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"ugly_window: cannot locate font fixed.\\n\");\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\n\tgc = XCreateGC(dpy, awin, valuemask, &values);\n\tXSetFont(dpy, gc, font_info->fid);\n\tXSetForeground(dpy, gc, BlackPixel(dpy, scr));\n\tXSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter);\n\tXSetDashes(dpy, gc, 0, dash_list, list_length);\n\n\tXMapWindow(dpy, awin);\n\tXFlush_wr(dpy);\n\n\tif (accept) {\n\t\tchar *ip = addr;\n\t\tchar *type = \"accept\";\n\t\tif (unixpw && strstr(userhost, \"UNIX:\") != userhost) {\n\t\t\ttype = \"UNIXPW\";\n\t\t\tif (openssl_last_ip) {\n\t\t\t\tip = openssl_last_ip;\n\t\t\t}\n\t\t}\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: %s connection from %s?\", type, ip);\n\t} else {\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: client disconnected from %s\", addr);\n\t}\n\tsnprintf(stri, sizeof stri, \"        (%s)\", userhost);\n\n\tkey_o = XKeysymToKeycode(dpy, XStringToKeysym(\"o\"));\n\tkey_y = XKeysymToKeycode(dpy, XStringToKeysym(\"y\"));\n\tkey_n = XKeysymToKeycode(dpy, XStringToKeysym(\"n\"));\n\tkey_v = XKeysymToKeycode(dpy, XStringToKeysym(\"v\"));\n\n\twhile (1) {\n\t\tint out = -1, x, y, tw, k;\n\n\t\tif (XCheckWindowEvent(dpy, awin, evmask, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else if (XCheckTypedEvent(dpy, ClientMessage, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else {\n\t\t\tint ms = 100;\t/* sleep a bit */\n\t\t\tusleep(ms * 1000);\n\t\t\twaited += ((double) ms)/1000.;\n\t\t\tif (timeout && (int) waited >= timeout) {\n\t\t\t\trfbLog(\"ugly_window: popup timed out after \"\n\t\t\t\t    \"%d seconds.\\n\", timeout);\n\t\t\t\tout = 0;\n\t\t\t\tev.type = 0;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch(ev.type) {\n\t\tcase Expose:\n\t\t\twhile (XCheckTypedEvent(dpy, Expose, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tk=0;\n\n\t\t\t/* instructions */\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    strh, strlen(strh));\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    stri, strlen(stri));\n\t\t\tif (accept) {\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str1, strlen(str1));\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str2, strlen(str2));\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t\t    str3, strlen(str3));\n\t\t\t  }\n\t\t\t}\n\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* buttons */\n\t\t\tYe_y = Y_sh+k*dY;\n\t\t\tNo_y = Y_sh+k*dY;\n\t\t\tVi_y = Y_sh+k*dY;\n\t\t\tXDrawRectangle(dpy, awin, gc, Ye_x, Ye_y, Ye_w, Ye_h);\n\n\t\t\tif (accept) {\n\t\t\t  XDrawRectangle(dpy, awin, gc, No_x, No_y, No_w, No_h);\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawRectangle(dpy, awin, gc, Vi_x, Vi_y,\n\t\t\t\t    Vi_w, Vi_h);\n\t\t\t  }\n\t\t\t}\n\n\t\t\ttw = XTextWidth(font_info, str_y, strlen(str_y));\n\t\t\ttw = (Ye_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, Ye_x+tw, Ye_y+Ye_h-5,\n\t\t\t    str_y, strlen(str_y));\n\n\t\t\tif (!accept) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw = XTextWidth(font_info, str_n, strlen(str_n));\n\t\t\ttw = (No_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, No_x+tw, No_y+No_h-5,\n\t\t\t    str_n, strlen(str_n));\n\n\t\t\tif (! view_only) {\n\t\t\t\ttw = XTextWidth(font_info, str_v,\n\t\t\t\t    strlen(str_v));\n\t\t\t\ttw = (Vi_w - tw)/2;\n\t\t\t\tif (tw < 0) tw = 1;\n\t\t\t\tXDrawString(dpy, awin, gc, Vi_x+tw,\n\t\t\t\t    Vi_y+Vi_h-5, str_v, strlen(str_v));\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ClientMessage:\n\t\t\tif (ev.xclient.message_type == wm_protocols &&\n\t\t\t    (Atom) ev.xclient.data.l[0] == wm_delete_window) {\n\t\t\t\tout = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ButtonPress:\n\t\t\tx = ev.xbutton.x;\n\t\t\ty = ev.xbutton.y;\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\t;\n\t\t\t} else if (x > Ye_x && x < Ye_x+Ye_w && y > Ye_y\n\t\t\t    && y < Ye_y+Ye_h) {\n\t\t\t\tout = 1;\n\t\t\t} else if (! accept) {\n\t\t\t\t;\n\t\t\t} else if (x > No_x && x < No_x+No_w && y > No_y\n\t\t\t    && y < No_y+No_h) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && x > Vi_x && x < Vi_x+Vi_w\n\t\t\t    && y > Vi_y && y < Vi_y+Ye_h) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KeyPress:\n\t\t\tif (!strcmp(mode, \"mouse_only\")) {\n\t\t\t\t;\n\t\t\t} else if (! accept) {\n\t\t\t\tif (ev.xkey.keycode == key_o) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t\tif (ev.xkey.keycode == key_y) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t} else if (ev.xkey.keycode == key_y) {\n\t\t\t\tout = 1;\n\t\t\t\t;\n\t\t\t} else if (ev.xkey.keycode == key_n) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && ev.xkey.keycode == key_v) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (out != -1) {\n\t\t\tret = out;\n\t\t\tXSelectInput_wr(dpy, awin, 0);\n\t\t\tXUnmapWindow(dpy, awin);\n\t\t\tXFree_wr(gc);\n\t\t\tXDestroyWindow(dpy, awin);\n\t\t\tXFlush_wr(dpy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\treturn ret;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "check_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "969-1141",
    "snippet": "int check_access(char *addr) {\n\tint allowed = 0;\n\tint ssl = 0;\n\tchar *p, *list;\n\n\tif (use_openssl || use_stunnel) {\n\t\tssl = 1;\n\t}\n\tif (deny_all) {\n\t\trfbLog(\"check_access: new connections are currently \"\n\t\t    \"blocked.\\n\");\n\t\treturn 0;\n\t}\n\tif (addr == NULL || *addr == '\\0') {\n\t\trfbLog(\"check_access: denying empty host IP address string.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (allow_list == NULL) {\n\t\t/* set to \"\" to possibly append allow_once */\n\t\tallow_list = strdup(\"\");\n\t}\n\tif (*allow_list == '\\0' && allow_once == NULL) {\n\t\t/* no constraints, accept it */\n\t\treturn 1;\n\t}\n\n\tif (strchr(allow_list, '/')) {\n\t\t/* a file of IP addresess or prefixes */\n\t\tint len, len2 = 0;\n\t\tstruct stat sbuf;\n\t\tFILE *in;\n\t\tchar line[1024], *q;\n\n\t\tif (stat(allow_list, &sbuf) != 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: failure stating file: %s\\n\",\n\t\t\t    allow_list);\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tlen = sbuf.st_size + 1;\t/* 1 more for '\\0' at end */\n\t\tif (allow_once) {\n\t\t\tlen2 = strlen(allow_once) + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen2 = strlen(\"127.0.0.1\") + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\t\n\t\tin = fopen(allow_list, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: cannot open: %s\\n\", allow_list);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif ( (q = strchr(line, '#')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strlen(list) + strlen(line) >=\n\t\t\t    (size_t) (len - len2)) {\n\t\t\t\t/* file grew since our stat() */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcat(list, line);\n\t\t}\n\t\tfclose(in);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, allow_once);\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t} else {\n\t\tint len = strlen(allow_list) + 1;\n\t\tif (allow_once) {\n\t\t\tlen += strlen(allow_once) + 1;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen += strlen(\"127.0.0.1\") + 1;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\tstrcat(list, allow_list);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, allow_once);\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t}\n\t}\n\n\tif (allow_once) {\n\t\tfree(allow_once);\n\t\tallow_once = NULL;\n\t}\n\t\n\tp = strtok(list, \", \\t\\n\\r\");\n\twhile (p) {\n\t\tchar *chk, *q, *r = NULL;\n\t\tif (*p == '\\0') {\n\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\tcontinue;\t\n\t\t}\n\t\tif (ipv6_ip(p)) {\n\t\t\tchk = p;\n\t\t} else if (! dotted_ip(p, 1)) {\n\t\t\tr = host2ip(p);\n\t\t\tif (r == NULL || *r == '\\0') {\n\t\t\t\trfbLog(\"check_access: bad lookup \\\"%s\\\"\\n\", p);\n\t\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"check_access: lookup %s -> %s\\n\", p, r);\n\t\t\tchk = r;\n\t\t} else {\n\t\t\tchk = p;\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_ACCESS\")) fprintf(stderr, \"chk: %s  part: %s  addr: %s\\n\", chk, p, addr);\n\n\t\tq = strstr(addr, chk);\n\t\tif (ipv6_ip(addr)) {\n\t\t\tif (!strcmp(chk, \"localhost\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"::1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"127.0.0.1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\t/* this if for host2ip(\"localhost\") */\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (q == addr) {\n\t\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (chk[strlen(chk)-1] != '.') {\n\t\t\tif (!strcmp(addr, chk)) {\n\t\t\t\tif (chk != p) {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s=%s\\n\", addr, chk, p);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s\\n\", addr, chk);\n\t\t\t\t}\n\t\t\t\tallowed = 1;\n\t\t\t} else if(!strcmp(chk, \"localhost\") && !strcmp(addr, \"127.0.0.1\")) {\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (q == addr) {\n\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\tallowed = 1;\n\t\t}\n\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\tif (r) {\n\t\t\tfree(r);\n\t\t}\n\t\tif (allowed) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(list);\n\treturn allowed;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "int accept_client(rfbClientPtr client);",
      "int check_access(char *addr);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);",
      "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
      "static void check_connect_file(char *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "list"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\", \\t\\n\\r\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: client %s matches pattern %s\\n\"",
            "addr",
            "chk"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "addr",
            "\"127.0.0.1\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "chk",
            "\"localhost\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: client %s \" \"matches host %s\\n\"",
            "addr",
            "chk"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: client %s \" \"matches host %s=%s\\n\"",
            "addr",
            "chk",
            "p"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "addr",
            "chk"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chk"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: client %s matches pattern %s\\n\"",
            "addr",
            "chk"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: client addr %s is local.\\n\"",
            "addr"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "addr",
            "\"::1\""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "chk",
            "\"127.0.0.1\""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: client addr %s is local.\\n\"",
            "addr"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "addr",
            "\"::1\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "chk",
            "\"::1\""
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: client addr %s is local.\\n\"",
            "addr"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "addr",
            "\"::1\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "chk",
            "\"localhost\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_ip",
          "args": [
            "addr"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "138-173",
          "snippet": "int ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nint ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "addr",
            "chk"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"chk: %s  part: %s  addr: %s\\n\"",
            "chk",
            "p",
            "addr"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_ACCESS\""
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: lookup %s -> %s\\n\"",
            "p",
            "r"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\", \\t\\n\\r\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: bad lookup \\\"%s\\\"\\n\"",
            "p"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host2ip",
          "args": [
            "p"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "host2ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "68-86",
          "snippet": "char *host2ip(char *host) {\n\tstruct hostent *hp;\n\tstruct sockaddr_in addr;\n\tchar *str;\n\n\tif (! host_lookup) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyname(host);\n\tif (!hp) {\n\t\treturn NULL;\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr =  *(unsigned long *)hp->h_addr;\n\tstr = strdup(inet_ntoa(addr.sin_addr));\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nchar *host2ip(char *host) {\n\tstruct hostent *hp;\n\tstruct sockaddr_in addr;\n\tchar *str;\n\n\tif (! host_lookup) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyname(host);\n\tif (!hp) {\n\t\treturn NULL;\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr =  *(unsigned long *)hp->h_addr;\n\tstr = strdup(inet_ntoa(addr.sin_addr));\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dotted_ip",
          "args": [
            "p",
            "1"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "dotted_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "175-204",
          "snippet": "int dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "char *raw2host(char *raw, int len);",
            "int ipv6_ip(char *host);",
            "int dotted_ip(char *host, int partial);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint dotted_ip(char *host, int partial);\n\nint dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\", \\t\\n\\r\""
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "list",
            "\", \\t\\n\\r\""
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\"127.0.0.1\""
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\",\""
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "allow_once"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\",\""
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "allow_list"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "allow_once"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "allow_list"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\"\\n\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\"127.0.0.1\""
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\"\\n\""
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\"\\n\""
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "allow_once"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\"\\n\""
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "line"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'#'"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "in"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: cannot open: %s\\n\"",
            "allow_list"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "allow_list",
            "\"r\""
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "allow_once"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"stat\""
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: failure stating file: %s\\n\"",
            "allow_list"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "allow_list",
            "&sbuf"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "allow_list",
            "'/'"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: denying empty host IP address string.\\n\""
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_access: new connections are currently \"\n\t\t    \"blocked.\\n\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic void check_connect_file(char *file);\n\nint check_access(char *addr) {\n\tint allowed = 0;\n\tint ssl = 0;\n\tchar *p, *list;\n\n\tif (use_openssl || use_stunnel) {\n\t\tssl = 1;\n\t}\n\tif (deny_all) {\n\t\trfbLog(\"check_access: new connections are currently \"\n\t\t    \"blocked.\\n\");\n\t\treturn 0;\n\t}\n\tif (addr == NULL || *addr == '\\0') {\n\t\trfbLog(\"check_access: denying empty host IP address string.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (allow_list == NULL) {\n\t\t/* set to \"\" to possibly append allow_once */\n\t\tallow_list = strdup(\"\");\n\t}\n\tif (*allow_list == '\\0' && allow_once == NULL) {\n\t\t/* no constraints, accept it */\n\t\treturn 1;\n\t}\n\n\tif (strchr(allow_list, '/')) {\n\t\t/* a file of IP addresess or prefixes */\n\t\tint len, len2 = 0;\n\t\tstruct stat sbuf;\n\t\tFILE *in;\n\t\tchar line[1024], *q;\n\n\t\tif (stat(allow_list, &sbuf) != 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: failure stating file: %s\\n\",\n\t\t\t    allow_list);\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tlen = sbuf.st_size + 1;\t/* 1 more for '\\0' at end */\n\t\tif (allow_once) {\n\t\t\tlen2 = strlen(allow_once) + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen2 = strlen(\"127.0.0.1\") + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\t\n\t\tin = fopen(allow_list, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: cannot open: %s\\n\", allow_list);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif ( (q = strchr(line, '#')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strlen(list) + strlen(line) >=\n\t\t\t    (size_t) (len - len2)) {\n\t\t\t\t/* file grew since our stat() */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcat(list, line);\n\t\t}\n\t\tfclose(in);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, allow_once);\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t} else {\n\t\tint len = strlen(allow_list) + 1;\n\t\tif (allow_once) {\n\t\t\tlen += strlen(allow_once) + 1;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen += strlen(\"127.0.0.1\") + 1;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\tstrcat(list, allow_list);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, allow_once);\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t}\n\t}\n\n\tif (allow_once) {\n\t\tfree(allow_once);\n\t\tallow_once = NULL;\n\t}\n\t\n\tp = strtok(list, \", \\t\\n\\r\");\n\twhile (p) {\n\t\tchar *chk, *q, *r = NULL;\n\t\tif (*p == '\\0') {\n\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\tcontinue;\t\n\t\t}\n\t\tif (ipv6_ip(p)) {\n\t\t\tchk = p;\n\t\t} else if (! dotted_ip(p, 1)) {\n\t\t\tr = host2ip(p);\n\t\t\tif (r == NULL || *r == '\\0') {\n\t\t\t\trfbLog(\"check_access: bad lookup \\\"%s\\\"\\n\", p);\n\t\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"check_access: lookup %s -> %s\\n\", p, r);\n\t\t\tchk = r;\n\t\t} else {\n\t\t\tchk = p;\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_ACCESS\")) fprintf(stderr, \"chk: %s  part: %s  addr: %s\\n\", chk, p, addr);\n\n\t\tq = strstr(addr, chk);\n\t\tif (ipv6_ip(addr)) {\n\t\t\tif (!strcmp(chk, \"localhost\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"::1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"127.0.0.1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\t/* this if for host2ip(\"localhost\") */\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (q == addr) {\n\t\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (chk[strlen(chk)-1] != '.') {\n\t\t\tif (!strcmp(addr, chk)) {\n\t\t\t\tif (chk != p) {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s=%s\\n\", addr, chk, p);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s\\n\", addr, chk);\n\t\t\t\t}\n\t\t\t\tallowed = 1;\n\t\t\t} else if(!strcmp(chk, \"localhost\") && !strcmp(addr, \"127.0.0.1\")) {\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (q == addr) {\n\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\tallowed = 1;\n\t\t}\n\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\tif (r) {\n\t\t\tfree(r);\n\t\t}\n\t\tif (allowed) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(list);\n\treturn allowed;\n}"
  },
  {
    "function_name": "client_gone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "811-963",
    "snippet": "void client_gone(rfbClientPtr client) {\n\tClientData *cd = NULL;\n\n\tCLIENT_LOCK;\n\n\tclient_count--;\n\tif (client_count < 0) client_count = 0;\n\n\tspeeds_net_rate_measured = 0;\n\tspeeds_net_latency_measured = 0;\n\n\trfbLog(\"client_count: %d\\n\", client_count);\n\tlast_client_gone = dnow();\n\n\tif (unixpw_in_progress && unixpw_client) {\n\t\tif (client == unixpw_client) {\n\t\t\tunixpw_in_progress = 0;\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\t\t\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 3\\n\");\n\t\t\t\trfbRegisterTightVNCFileTransferExtension();\n#endif\n\t\t\t}\n\t\t\tunixpw_client = NULL;\n\t\t\tcopy_screen();\n\t\t}\n\t}\n\n\n\tif (no_autorepeat && client_count == 0) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg && client_count == 0) {\n\t\tsolid_bg(1);\n\t}\n\tif ((ncache || ncache0) && client_count == 0) {\n\t\tkde_no_animate(1);\n\t}\n\tif (client->clientData) {\n\t\tcd = (ClientData *) client->clientData;\n\t\tif (cd->ssl_helper_pid > 0) {\n\t\t\tint status;\n\t\t\trfbLog(\"sending SIGTERM to ssl_helper_pid: %d\\n\",\n\t\t\t    cd->ssl_helper_pid);\n\t\t\tkill(cd->ssl_helper_pid, SIGTERM);\n\t\t\tusleep(200*1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\t\t\twaitpid(cd->ssl_helper_pid, &status, WNOHANG); \n#endif\n\t\t\tssl_helper_pid(cd->ssl_helper_pid, -1);\t/* delete */\n\t\t}\n\t}\n\tif (gone_cmd && *gone_cmd != '\\0') {\n\t\tif (strstr(gone_cmd, \"popup\") == gone_cmd) {\n\t\t\tint x = -64000, y = -64000, timeout = 120;\n\t\t\tchar *userhost = ident_username(client);\n\t\t\tchar *addr, *p, *mode;\n\n\t\t\t/* extract timeout */\n\t\t\tif ((p = strchr(gone_cmd, ':')) != NULL) {\n\t\t\t\tint in;\n\t\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\t\ttimeout = in;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* extract geometry */\n\t\t\tif ((p = strpbrk(gone_cmd, \"+-\")) != NULL) {\n\t\t\t\tugly_geom(p, &x, &y);\n\t\t\t}\n\n\t\t\t/* find mode: mouse, key, or both */\n\t\t\tif (strstr(gone_cmd, \"popupmouse\") == gone_cmd) {\n\t\t\t\tmode = \"mouse_only\";\n\t\t\t} else if (strstr(gone_cmd, \"popupkey\") == gone_cmd) {\n\t\t\t\tmode = \"key_only\";\n\t\t\t} else {\n\t\t\t\tmode = \"both\";\n\t\t\t}\n\n\t\t\taddr = client->host;\n\n\t\t\tugly_window(addr, userhost, x, y, timeout, mode, 0);\n\n\t\t\tfree(userhost);\n\t\t} else {\n\t\t\trfbLog(\"client_gone: using cmd: %s\\n\", client->host);\n\t\t\trun_user_command(gone_cmd, client, \"gone\", NULL, 0, NULL);\n\t\t}\n\t}\n\n\t/* remove clients XInput2 master device */\n        if(use_multipointer) \n\t  if(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"removed XInput2 MD for client %s.\\n\", client->host);\n\n\tfree_client_data(client);\n\n\tif (inetd && client == inetd_client) {\n\t\trfbLog(\"inetd viewer exited.\\n\");\n\t\tif (gui_pid > 0) {\n\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\tkill(gui_pid, SIGTERM);\n\t\t}\n\t\tclean_up_exit(0);\n\t}\n\n\tif (connect_once) {\n\t\t/*\n\t\t * This non-exit is done for a bad passwd to be consistent\n\t\t * with our RFB_CLIENT_REFUSE behavior in new_client()  (i.e.\n\t\t * we disconnect after 1 successful connection).\n\t\t */\n\t\tif ((client->state == RFB_PROTOCOL_VERSION ||\n\t\t     client->state == RFB_SECURITY_TYPE ||\n\t\t     client->state == RFB_AUTHENTICATION ||\n\t\t     client->state == RFB_INITIALISATION) && accepted_client) {\n\t\t\trfbLog(\"connect_once: invalid password or early \"\n\t\t\t   \"disconnect.  %d\\n\", client->state);\n\t\t\trfbLog(\"connect_once: waiting for next connection.\\n\"); \n\t\t\taccepted_client--;\n\t\t\tif (accepted_client < 0) {\n\t\t\t\taccepted_client = 0;\n\t\t\t}\n\t\t\tCLIENT_UNLOCK;\n\t\t\tif (connect_or_exit) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (shared && client_count > 0)  {\n\t\t\trfbLog(\"connect_once: other shared clients still \"\n\t\t\t    \"connected, not exiting.\\n\");\n\t\t\tCLIENT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\trfbLog(\"viewer exited.\\n\");\n\t\tif ((client_connect || connect_or_exit) && gui_pid > 0) {\n\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\tkill(gui_pid, SIGTERM);\n\t\t}\n\t\tCLIENT_UNLOCK;\n\t\tclean_up_exit(0);\n\t}\n#ifdef MACOSX\n\tif (macosx_console && client_count == 0) {\n\t\tmacosxCG_refresh_callback_off();\n\t}\n#endif\n\tCLIENT_UNLOCK;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "rfbClientPtr inetd_client = NULL;",
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "int cmd_ok(char *cmd);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "int check_access(char *addr);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);",
      "static void ugly_geom(char *p, int *x, int *y);",
      "static int accepted_client = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxCG_refresh_callback_off",
          "args": [],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_refresh_callback_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "125-131",
          "snippet": "void macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "0"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "gui_pid",
            "SIGTERM"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"killing gui_pid %d\\n\"",
            "gui_pid"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"viewer exited.\\n\""
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_once: other shared clients still \"\n\t\t\t    \"connected, not exiting.\\n\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_once: waiting for next connection.\\n\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"connect_once: invalid password or early \"\n\t\t\t   \"disconnect.  %d\\n\"",
            "client->state"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"killing gui_pid %d\\n\"",
            "gui_pid"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"inetd viewer exited.\\n\""
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_client_data",
          "args": [
            "client"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"removed XInput2 MD for client %s.\\n\"",
            "client->host"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "removeMD",
          "args": [
            "dpy",
            "cd->ptr_id"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "removeMD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xi2_devices.c",
          "lines": "114-155",
          "snippet": "int removeMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n  int found = 0, res = 0;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n\n  if(dev_id < 0)\n    return 0;\n\n  X_LOCK;\n\n  /* see if this device exists */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = 0; i < num_devices; ++i)\n    if(devinfo[i].deviceid == dev_id)\n      found = 1;\n  XIFreeDeviceInfo(devinfo);\n\n  if(found) {\n    XIRemoveMasterInfo r;\n\n    /* we need to unset client pointer */\n    XISetClientPointer(dpy, None, dev_id);\n    XSync(dpy, False);\n  \n    /* actually remove device pair */\n    r.type = XIRemoveMaster;\n    r.deviceid = dev_id;\n    r.return_mode = XIFloating;\n\n    res = XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&r, 1) == Success ? 1 : 0;\n    XSync(dpy, False);\n  }\n\n  X_UNLOCK;\n\n  return res;\n#endif\n}",
          "includes": [
            "#include <cairo.h>",
            "#include <X11/Xcursor/Xcursor.h>",
            "#include \"xi2_devices.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"cursor.h\"",
            "#include \"x11vnc.h\"",
            "#include <X11/keysym.h>",
            "#include <X11/Xproto.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cairo.h>\n#include <X11/Xcursor/Xcursor.h>\n#include \"xi2_devices.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"cursor.h\"\n#include \"x11vnc.h\"\n#include <X11/keysym.h>\n#include <X11/Xproto.h>\n#include <string.h>\n\nint removeMD(Display* dpy, int dev_id)\n{\n#ifndef HAVE_XI2\n  return 0;\n#else\n  int found = 0, res = 0;\n  XIDeviceInfo\t*devinfo;\n  int\t\tnum_devices, i;\n\n  if(dev_id < 0)\n    return 0;\n\n  X_LOCK;\n\n  /* see if this device exists */\n  devinfo = XIQueryDevice(dpy, XIAllMasterDevices, &num_devices);\n  for(i = 0; i < num_devices; ++i)\n    if(devinfo[i].deviceid == dev_id)\n      found = 1;\n  XIFreeDeviceInfo(devinfo);\n\n  if(found) {\n    XIRemoveMasterInfo r;\n\n    /* we need to unset client pointer */\n    XISetClientPointer(dpy, None, dev_id);\n    XSync(dpy, False);\n  \n    /* actually remove device pair */\n    r.type = XIRemoveMaster;\n    r.deviceid = dev_id;\n    r.return_mode = XIFloating;\n\n    res = XIChangeHierarchy(dpy, (XIAnyHierarchyChangeInfo*)&r, 1) == Success ? 1 : 0;\n    XSync(dpy, False);\n  }\n\n  X_UNLOCK;\n\n  return res;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_user_command",
          "args": [
            "gone_cmd",
            "client",
            "\"gone\"",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "run_user_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "466-763",
          "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "void send_client_info(char *str);",
            "void adjust_grabs(int grab, int quiet);",
            "int accept_client(rfbClientPtr client);",
            "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static int action_match(char *action, int rc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"client_gone: using cmd: %s\\n\"",
            "client->host"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugly_window",
          "args": [
            "addr",
            "userhost",
            "x",
            "y",
            "timeout",
            "mode",
            "0"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "ugly_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1147-1466",
          "snippet": "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept) {\n#if NO_X11\n\tif (!addr || !userhost || !X || !Y || !timeout || !mode || !accept) {}\n\tRAWFB_RET(0)\n\tnox11_exit(1);\n\treturn 0;\n#else\n\n#define t2x2_width 16\n#define t2x2_height 16\nstatic unsigned char t2x2_bits[] = {\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff,\n   0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33,\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33};\n\n\tWindow awin;\n\tGC gc;\n\tXSizeHints hints;\n\tXGCValues values;\n\tstatic XFontStruct *font_info = NULL;\n\tstatic Pixmap ico = 0;\n\tunsigned long valuemask = 0;\n\tstatic char dash_list[] = {20, 40};\n\tint list_length = sizeof(dash_list);\n\n\tAtom wm_protocols;\n\tAtom wm_delete_window;\n\n\tXEvent ev;\n\tlong evmask = ExposureMask | KeyPressMask | ButtonPressMask\n\t    | StructureNotifyMask;\n\tdouble waited = 0.0;\n\n\t/* strings and geometries y/n */\n\tKeyCode key_y, key_n, key_v;\n\tchar strh[100];\n\tchar stri[100];\n\tchar str1_b[] = \"To accept: press \\\"y\\\" or click the \\\"Yes\\\" button\";\n\tchar str2_b[] = \"To reject: press \\\"n\\\" or click the \\\"No\\\" button\";\n\tchar str3_b[] = \"View only: press \\\"v\\\" or click the \\\"View\\\" button\";\n\tchar str1_m[] = \"To accept: click the \\\"Yes\\\" button\";\n\tchar str2_m[] = \"To reject: click the \\\"No\\\" button\";\n\tchar str3_m[] = \"View only: click the \\\"View\\\" button\";\n\tchar str1_k[] = \"To accept: press \\\"y\\\"\";\n\tchar str2_k[] = \"To reject: press \\\"n\\\"\";\n\tchar str3_k[] = \"View only: press \\\"v\\\"\";\n\tchar *str1, *str2, *str3;\n\tchar str_y[] = \"Yes\";\n\tchar str_n[] = \"No\";\n\tchar str_v[] = \"View\";\n\tint x, y, w = 345, h = 175, ret = 0;\n\tint X_sh = 20, Y_sh = 30, dY = 20;\n\tint Ye_x = 20,  Ye_y = 0, Ye_w = 45, Ye_h = 20;\n\tint No_x = 75,  No_y = 0, No_w = 45, No_h = 20; \n\tint Vi_x = 130, Vi_y = 0, Vi_w = 45, Vi_h = 20; \n\tchar *sprop = \"new x11vnc client\";\n\n\tKeyCode key_o;\n\n\tRAWFB_RET(0)\n\n\tif (! accept) {\n\t\tsprintf(str_y, \"OK\");\n\t\tsprop = \"x11vnc client disconnected\";\n\t\th = 110;\n\t\tstr1 = \"\";\n\t\tstr2 = \"\";\n\t\tstr3 = \"\";\n\t} else if (!strcmp(mode, \"mouse_only\")) {\n\t\tstr1 = str1_m;\n\t\tstr2 = str2_m;\n\t\tstr3 = str3_m;\n\t} else if (!strcmp(mode, \"key_only\")) {\n\t\tstr1 = str1_k;\n\t\tstr2 = str2_k;\n\t\tstr3 = str3_k;\n\t\th -= dY;\n\t} else {\n\t\tstr1 = str1_b;\n\t\tstr2 = str2_b;\n\t\tstr3 = str3_b;\n\t}\n\tif (view_only) {\n\t\th -= dY;\n\t}\n\n\t/* XXX handle coff_x/coff_y? */\n\tif (X < -dpy_x) {\n\t\tx = (dpy_x - w)/2;\t/* large negative: center */\n\t\tif (x < 0) x = 0;\n\t} else if (X < 0) {\n\t\tx = dpy_x + X - w;\t/* from lower right */\n\t} else {\n\t\tx = X;\t\t\t/* from upper left */\n\t}\n\t\n\tif (Y < -dpy_y) {\n\t\ty = (dpy_y - h)/2;\n\t\tif (y < 0) y = 0;\n\t} else if (Y < 0) {\n\t\ty = dpy_y + Y - h;\n\t} else {\n\t\ty = Y;\n\t}\n\n\tX_LOCK;\n\n\tawin = XCreateSimpleWindow(dpy, window, x, y, w, h, 4,\n\t    BlackPixel(dpy, scr), WhitePixel(dpy, scr));\n\n\twm_protocols = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\twm_delete_window = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\tXSetWMProtocols(dpy, awin, &wm_delete_window, 1);\n\n\tif (! ico) {\n\t\tico = XCreateBitmapFromData(dpy, awin, (char *) t2x2_bits,\n\t\t    t2x2_width, t2x2_height);\n\t}\n\n\thints.flags = PPosition | PSize | PMinSize;\n\thints.x = x;\n\thints.y = y;\n\thints.width = w;\n\thints.height = h;\n\thints.min_width = w;\n\thints.min_height = h;\n\n\tXSetStandardProperties(dpy, awin, sprop, \"x11vnc query\", ico, NULL,\n\t    0, &hints);\n\n\tXSelectInput_wr(dpy, awin, evmask);\n\n\tif (! font_info && (font_info = XLoadQueryFont(dpy, \"fixed\")) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"ugly_window: cannot locate font fixed.\\n\");\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\n\tgc = XCreateGC(dpy, awin, valuemask, &values);\n\tXSetFont(dpy, gc, font_info->fid);\n\tXSetForeground(dpy, gc, BlackPixel(dpy, scr));\n\tXSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter);\n\tXSetDashes(dpy, gc, 0, dash_list, list_length);\n\n\tXMapWindow(dpy, awin);\n\tXFlush_wr(dpy);\n\n\tif (accept) {\n\t\tchar *ip = addr;\n\t\tchar *type = \"accept\";\n\t\tif (unixpw && strstr(userhost, \"UNIX:\") != userhost) {\n\t\t\ttype = \"UNIXPW\";\n\t\t\tif (openssl_last_ip) {\n\t\t\t\tip = openssl_last_ip;\n\t\t\t}\n\t\t}\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: %s connection from %s?\", type, ip);\n\t} else {\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: client disconnected from %s\", addr);\n\t}\n\tsnprintf(stri, sizeof stri, \"        (%s)\", userhost);\n\n\tkey_o = XKeysymToKeycode(dpy, XStringToKeysym(\"o\"));\n\tkey_y = XKeysymToKeycode(dpy, XStringToKeysym(\"y\"));\n\tkey_n = XKeysymToKeycode(dpy, XStringToKeysym(\"n\"));\n\tkey_v = XKeysymToKeycode(dpy, XStringToKeysym(\"v\"));\n\n\twhile (1) {\n\t\tint out = -1, x, y, tw, k;\n\n\t\tif (XCheckWindowEvent(dpy, awin, evmask, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else if (XCheckTypedEvent(dpy, ClientMessage, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else {\n\t\t\tint ms = 100;\t/* sleep a bit */\n\t\t\tusleep(ms * 1000);\n\t\t\twaited += ((double) ms)/1000.;\n\t\t\tif (timeout && (int) waited >= timeout) {\n\t\t\t\trfbLog(\"ugly_window: popup timed out after \"\n\t\t\t\t    \"%d seconds.\\n\", timeout);\n\t\t\t\tout = 0;\n\t\t\t\tev.type = 0;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch(ev.type) {\n\t\tcase Expose:\n\t\t\twhile (XCheckTypedEvent(dpy, Expose, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tk=0;\n\n\t\t\t/* instructions */\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    strh, strlen(strh));\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    stri, strlen(stri));\n\t\t\tif (accept) {\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str1, strlen(str1));\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str2, strlen(str2));\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t\t    str3, strlen(str3));\n\t\t\t  }\n\t\t\t}\n\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* buttons */\n\t\t\tYe_y = Y_sh+k*dY;\n\t\t\tNo_y = Y_sh+k*dY;\n\t\t\tVi_y = Y_sh+k*dY;\n\t\t\tXDrawRectangle(dpy, awin, gc, Ye_x, Ye_y, Ye_w, Ye_h);\n\n\t\t\tif (accept) {\n\t\t\t  XDrawRectangle(dpy, awin, gc, No_x, No_y, No_w, No_h);\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawRectangle(dpy, awin, gc, Vi_x, Vi_y,\n\t\t\t\t    Vi_w, Vi_h);\n\t\t\t  }\n\t\t\t}\n\n\t\t\ttw = XTextWidth(font_info, str_y, strlen(str_y));\n\t\t\ttw = (Ye_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, Ye_x+tw, Ye_y+Ye_h-5,\n\t\t\t    str_y, strlen(str_y));\n\n\t\t\tif (!accept) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw = XTextWidth(font_info, str_n, strlen(str_n));\n\t\t\ttw = (No_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, No_x+tw, No_y+No_h-5,\n\t\t\t    str_n, strlen(str_n));\n\n\t\t\tif (! view_only) {\n\t\t\t\ttw = XTextWidth(font_info, str_v,\n\t\t\t\t    strlen(str_v));\n\t\t\t\ttw = (Vi_w - tw)/2;\n\t\t\t\tif (tw < 0) tw = 1;\n\t\t\t\tXDrawString(dpy, awin, gc, Vi_x+tw,\n\t\t\t\t    Vi_y+Vi_h-5, str_v, strlen(str_v));\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ClientMessage:\n\t\t\tif (ev.xclient.message_type == wm_protocols &&\n\t\t\t    (Atom) ev.xclient.data.l[0] == wm_delete_window) {\n\t\t\t\tout = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ButtonPress:\n\t\t\tx = ev.xbutton.x;\n\t\t\ty = ev.xbutton.y;\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\t;\n\t\t\t} else if (x > Ye_x && x < Ye_x+Ye_w && y > Ye_y\n\t\t\t    && y < Ye_y+Ye_h) {\n\t\t\t\tout = 1;\n\t\t\t} else if (! accept) {\n\t\t\t\t;\n\t\t\t} else if (x > No_x && x < No_x+No_w && y > No_y\n\t\t\t    && y < No_y+No_h) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && x > Vi_x && x < Vi_x+Vi_w\n\t\t\t    && y > Vi_y && y < Vi_y+Ye_h) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KeyPress:\n\t\t\tif (!strcmp(mode, \"mouse_only\")) {\n\t\t\t\t;\n\t\t\t} else if (! accept) {\n\t\t\t\tif (ev.xkey.keycode == key_o) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t\tif (ev.xkey.keycode == key_y) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t} else if (ev.xkey.keycode == key_y) {\n\t\t\t\tout = 1;\n\t\t\t\t;\n\t\t\t} else if (ev.xkey.keycode == key_n) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && ev.xkey.keycode == key_v) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (out != -1) {\n\t\t\tret = out;\n\t\t\tXSelectInput_wr(dpy, awin, 0);\n\t\t\tXUnmapWindow(dpy, awin);\n\t\t\tXFree_wr(gc);\n\t\t\tXDestroyWindow(dpy, awin);\n\t\t\tXFlush_wr(dpy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\treturn ret;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define t2x2_height 16",
            "#define t2x2_width 16"
          ],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);",
            "static void ugly_geom(char *p, int *x, int *y);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define t2x2_height 16\n#define t2x2_width 16\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\n\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept) {\n#if NO_X11\n\tif (!addr || !userhost || !X || !Y || !timeout || !mode || !accept) {}\n\tRAWFB_RET(0)\n\tnox11_exit(1);\n\treturn 0;\n#else\n\n#define t2x2_width 16\n#define t2x2_height 16\nstatic unsigned char t2x2_bits[] = {\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff,\n   0x33, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33,\n   0xff, 0xff, 0xff, 0xff, 0x33, 0x33, 0x33, 0x33};\n\n\tWindow awin;\n\tGC gc;\n\tXSizeHints hints;\n\tXGCValues values;\n\tstatic XFontStruct *font_info = NULL;\n\tstatic Pixmap ico = 0;\n\tunsigned long valuemask = 0;\n\tstatic char dash_list[] = {20, 40};\n\tint list_length = sizeof(dash_list);\n\n\tAtom wm_protocols;\n\tAtom wm_delete_window;\n\n\tXEvent ev;\n\tlong evmask = ExposureMask | KeyPressMask | ButtonPressMask\n\t    | StructureNotifyMask;\n\tdouble waited = 0.0;\n\n\t/* strings and geometries y/n */\n\tKeyCode key_y, key_n, key_v;\n\tchar strh[100];\n\tchar stri[100];\n\tchar str1_b[] = \"To accept: press \\\"y\\\" or click the \\\"Yes\\\" button\";\n\tchar str2_b[] = \"To reject: press \\\"n\\\" or click the \\\"No\\\" button\";\n\tchar str3_b[] = \"View only: press \\\"v\\\" or click the \\\"View\\\" button\";\n\tchar str1_m[] = \"To accept: click the \\\"Yes\\\" button\";\n\tchar str2_m[] = \"To reject: click the \\\"No\\\" button\";\n\tchar str3_m[] = \"View only: click the \\\"View\\\" button\";\n\tchar str1_k[] = \"To accept: press \\\"y\\\"\";\n\tchar str2_k[] = \"To reject: press \\\"n\\\"\";\n\tchar str3_k[] = \"View only: press \\\"v\\\"\";\n\tchar *str1, *str2, *str3;\n\tchar str_y[] = \"Yes\";\n\tchar str_n[] = \"No\";\n\tchar str_v[] = \"View\";\n\tint x, y, w = 345, h = 175, ret = 0;\n\tint X_sh = 20, Y_sh = 30, dY = 20;\n\tint Ye_x = 20,  Ye_y = 0, Ye_w = 45, Ye_h = 20;\n\tint No_x = 75,  No_y = 0, No_w = 45, No_h = 20; \n\tint Vi_x = 130, Vi_y = 0, Vi_w = 45, Vi_h = 20; \n\tchar *sprop = \"new x11vnc client\";\n\n\tKeyCode key_o;\n\n\tRAWFB_RET(0)\n\n\tif (! accept) {\n\t\tsprintf(str_y, \"OK\");\n\t\tsprop = \"x11vnc client disconnected\";\n\t\th = 110;\n\t\tstr1 = \"\";\n\t\tstr2 = \"\";\n\t\tstr3 = \"\";\n\t} else if (!strcmp(mode, \"mouse_only\")) {\n\t\tstr1 = str1_m;\n\t\tstr2 = str2_m;\n\t\tstr3 = str3_m;\n\t} else if (!strcmp(mode, \"key_only\")) {\n\t\tstr1 = str1_k;\n\t\tstr2 = str2_k;\n\t\tstr3 = str3_k;\n\t\th -= dY;\n\t} else {\n\t\tstr1 = str1_b;\n\t\tstr2 = str2_b;\n\t\tstr3 = str3_b;\n\t}\n\tif (view_only) {\n\t\th -= dY;\n\t}\n\n\t/* XXX handle coff_x/coff_y? */\n\tif (X < -dpy_x) {\n\t\tx = (dpy_x - w)/2;\t/* large negative: center */\n\t\tif (x < 0) x = 0;\n\t} else if (X < 0) {\n\t\tx = dpy_x + X - w;\t/* from lower right */\n\t} else {\n\t\tx = X;\t\t\t/* from upper left */\n\t}\n\t\n\tif (Y < -dpy_y) {\n\t\ty = (dpy_y - h)/2;\n\t\tif (y < 0) y = 0;\n\t} else if (Y < 0) {\n\t\ty = dpy_y + Y - h;\n\t} else {\n\t\ty = Y;\n\t}\n\n\tX_LOCK;\n\n\tawin = XCreateSimpleWindow(dpy, window, x, y, w, h, 4,\n\t    BlackPixel(dpy, scr), WhitePixel(dpy, scr));\n\n\twm_protocols = XInternAtom(dpy, \"WM_PROTOCOLS\", False);\n\twm_delete_window = XInternAtom(dpy, \"WM_DELETE_WINDOW\", False);\n\tXSetWMProtocols(dpy, awin, &wm_delete_window, 1);\n\n\tif (! ico) {\n\t\tico = XCreateBitmapFromData(dpy, awin, (char *) t2x2_bits,\n\t\t    t2x2_width, t2x2_height);\n\t}\n\n\thints.flags = PPosition | PSize | PMinSize;\n\thints.x = x;\n\thints.y = y;\n\thints.width = w;\n\thints.height = h;\n\thints.min_width = w;\n\thints.min_height = h;\n\n\tXSetStandardProperties(dpy, awin, sprop, \"x11vnc query\", ico, NULL,\n\t    0, &hints);\n\n\tXSelectInput_wr(dpy, awin, evmask);\n\n\tif (! font_info && (font_info = XLoadQueryFont(dpy, \"fixed\")) == NULL) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"ugly_window: cannot locate font fixed.\\n\");\n\t\tX_UNLOCK;\n\t\tclean_up_exit(1);\n\t}\n\n\tgc = XCreateGC(dpy, awin, valuemask, &values);\n\tXSetFont(dpy, gc, font_info->fid);\n\tXSetForeground(dpy, gc, BlackPixel(dpy, scr));\n\tXSetLineAttributes(dpy, gc, 1, LineSolid, CapButt, JoinMiter);\n\tXSetDashes(dpy, gc, 0, dash_list, list_length);\n\n\tXMapWindow(dpy, awin);\n\tXFlush_wr(dpy);\n\n\tif (accept) {\n\t\tchar *ip = addr;\n\t\tchar *type = \"accept\";\n\t\tif (unixpw && strstr(userhost, \"UNIX:\") != userhost) {\n\t\t\ttype = \"UNIXPW\";\n\t\t\tif (openssl_last_ip) {\n\t\t\t\tip = openssl_last_ip;\n\t\t\t}\n\t\t}\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: %s connection from %s?\", type, ip);\n\t} else {\n\t\tsnprintf(strh, sizeof strh, \"x11vnc: client disconnected from %s\", addr);\n\t}\n\tsnprintf(stri, sizeof stri, \"        (%s)\", userhost);\n\n\tkey_o = XKeysymToKeycode(dpy, XStringToKeysym(\"o\"));\n\tkey_y = XKeysymToKeycode(dpy, XStringToKeysym(\"y\"));\n\tkey_n = XKeysymToKeycode(dpy, XStringToKeysym(\"n\"));\n\tkey_v = XKeysymToKeycode(dpy, XStringToKeysym(\"v\"));\n\n\twhile (1) {\n\t\tint out = -1, x, y, tw, k;\n\n\t\tif (XCheckWindowEvent(dpy, awin, evmask, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else if (XCheckTypedEvent(dpy, ClientMessage, &ev)) {\n\t\t\t;\t/* proceed to handling */\n\t\t} else {\n\t\t\tint ms = 100;\t/* sleep a bit */\n\t\t\tusleep(ms * 1000);\n\t\t\twaited += ((double) ms)/1000.;\n\t\t\tif (timeout && (int) waited >= timeout) {\n\t\t\t\trfbLog(\"ugly_window: popup timed out after \"\n\t\t\t\t    \"%d seconds.\\n\", timeout);\n\t\t\t\tout = 0;\n\t\t\t\tev.type = 0;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch(ev.type) {\n\t\tcase Expose:\n\t\t\twhile (XCheckTypedEvent(dpy, Expose, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t\tk=0;\n\n\t\t\t/* instructions */\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    strh, strlen(strh));\n\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    stri, strlen(stri));\n\t\t\tif (accept) {\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str1, strlen(str1));\n\t\t\t  XDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t    str2, strlen(str2));\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawString(dpy, awin, gc, X_sh, Y_sh+(k++)*dY,\n\t\t\t\t    str3, strlen(str3));\n\t\t\t  }\n\t\t\t}\n\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* buttons */\n\t\t\tYe_y = Y_sh+k*dY;\n\t\t\tNo_y = Y_sh+k*dY;\n\t\t\tVi_y = Y_sh+k*dY;\n\t\t\tXDrawRectangle(dpy, awin, gc, Ye_x, Ye_y, Ye_w, Ye_h);\n\n\t\t\tif (accept) {\n\t\t\t  XDrawRectangle(dpy, awin, gc, No_x, No_y, No_w, No_h);\n\t\t\t  if (! view_only) {\n\t\t\t\tXDrawRectangle(dpy, awin, gc, Vi_x, Vi_y,\n\t\t\t\t    Vi_w, Vi_h);\n\t\t\t  }\n\t\t\t}\n\n\t\t\ttw = XTextWidth(font_info, str_y, strlen(str_y));\n\t\t\ttw = (Ye_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, Ye_x+tw, Ye_y+Ye_h-5,\n\t\t\t    str_y, strlen(str_y));\n\n\t\t\tif (!accept) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw = XTextWidth(font_info, str_n, strlen(str_n));\n\t\t\ttw = (No_w - tw)/2;\n\t\t\tif (tw < 0) tw = 1;\n\t\t\tXDrawString(dpy, awin, gc, No_x+tw, No_y+No_h-5,\n\t\t\t    str_n, strlen(str_n));\n\n\t\t\tif (! view_only) {\n\t\t\t\ttw = XTextWidth(font_info, str_v,\n\t\t\t\t    strlen(str_v));\n\t\t\t\ttw = (Vi_w - tw)/2;\n\t\t\t\tif (tw < 0) tw = 1;\n\t\t\t\tXDrawString(dpy, awin, gc, Vi_x+tw,\n\t\t\t\t    Vi_y+Vi_h-5, str_v, strlen(str_v));\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase ClientMessage:\n\t\t\tif (ev.xclient.message_type == wm_protocols &&\n\t\t\t    (Atom) ev.xclient.data.l[0] == wm_delete_window) {\n\t\t\t\tout = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ButtonPress:\n\t\t\tx = ev.xbutton.x;\n\t\t\ty = ev.xbutton.y;\n\t\t\tif (!strcmp(mode, \"key_only\")) {\n\t\t\t\t;\n\t\t\t} else if (x > Ye_x && x < Ye_x+Ye_w && y > Ye_y\n\t\t\t    && y < Ye_y+Ye_h) {\n\t\t\t\tout = 1;\n\t\t\t} else if (! accept) {\n\t\t\t\t;\n\t\t\t} else if (x > No_x && x < No_x+No_w && y > No_y\n\t\t\t    && y < No_y+No_h) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && x > Vi_x && x < Vi_x+Vi_w\n\t\t\t    && y > Vi_y && y < Vi_y+Ye_h) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase KeyPress:\n\t\t\tif (!strcmp(mode, \"mouse_only\")) {\n\t\t\t\t;\n\t\t\t} else if (! accept) {\n\t\t\t\tif (ev.xkey.keycode == key_o) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t\tif (ev.xkey.keycode == key_y) {\n\t\t\t\t\tout = 1;\n\t\t\t\t}\n\t\t\t} else if (ev.xkey.keycode == key_y) {\n\t\t\t\tout = 1;\n\t\t\t\t;\n\t\t\t} else if (ev.xkey.keycode == key_n) {\n\t\t\t\tout = 0;\n\t\t\t} else if (! view_only && ev.xkey.keycode == key_v) {\n\t\t\t\tout = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (out != -1) {\n\t\t\tret = out;\n\t\t\tXSelectInput_wr(dpy, awin, 0);\n\t\t\tXUnmapWindow(dpy, awin);\n\t\t\tXFree_wr(gc);\n\t\t\tXDestroyWindow(dpy, awin);\n\t\t\tXFlush_wr(dpy);\n\t\t\tbreak;\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\treturn ret;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "gone_cmd",
            "\"popupkey\""
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "gone_cmd",
            "\"popupmouse\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugly_geom",
          "args": [
            "p",
            "&x",
            "&y"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "ugly_geom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "1556-1572",
          "snippet": "static void ugly_geom(char *p, int *x, int *y) {\n\tint x1, y1;\n\n\tif (sscanf(p, \"+%d+%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"+%d-%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = -y1;\n\t} else if (sscanf(p, \"-%d+%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"-%d-%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = -y1;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ugly_geom(char *p, int *x, int *y);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void ugly_geom(char *p, int *x, int *y);\n\nstatic void ugly_geom(char *p, int *x, int *y) {\n\tint x1, y1;\n\n\tif (sscanf(p, \"+%d+%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"+%d-%d\", &x1, &y1) == 2) {\n\t\t*x = x1;\n\t\t*y = -y1;\n\t} else if (sscanf(p, \"-%d+%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = y1;\n\t} else if (sscanf(p, \"-%d-%d\", &x1, &y1) == 2) {\n\t\t*x = -x1;\n\t\t*y = -y1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "gone_cmd",
            "\"+-\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "p+1",
            "\"%d\"",
            "&in"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "gone_cmd",
            "':'"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ident_username",
          "args": [
            "client"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "ident_username",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "266-411",
          "snippet": "char *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "char *raw2host(char *raw, int len);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "char *ident_username(rfbClientPtr client);",
            "int accept_unix(int s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nchar *ident_username(rfbClientPtr client);\nint accept_unix(int s);\n\nchar *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "gone_cmd",
            "\"popup\""
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssl_helper_pid",
          "args": [
            "cd->ssl_helper_pid",
            "-1"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2999-3117",
          "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "cd->ssl_helper_pid",
            "&status",
            "WNOHANG"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "200*1000"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sending SIGTERM to ssl_helper_pid: %d\\n\"",
            "cd->ssl_helper_pid"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kde_no_animate",
          "args": [
            "1"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "kde_no_animate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1055-1160",
          "snippet": "void kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "static int dt_cmd(char *cmd);",
            "static char *cmd_output(char *cmd);",
            "static void solid_macosx(int restore);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nstatic int dt_cmd(char *cmd);\nstatic char *cmd_output(char *cmd);\nstatic void solid_macosx(int restore);\n\nvoid kde_no_animate(int restore) {\n#if NO_X11\n\tif (!restore) {}\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tchar query_setting[] =\n\t    \"kreadconfig  --file kwinrc --group Windows --key AnimateMinimize\";\n\tchar kwinrc_off[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool false\";\n\tchar kwinrc_on[] =\n\t    \"kwriteconfig --file kwinrc --group Windows --key AnimateMinimize --type bool true\";\n\tchar kwin_reconfigure[] =\n\t    \"dcop --user '%s' %s kwin KWinInterface reconfigure\";\n\tchar *cmd, *cmd2, *out, *user = NULL, *sess;\n\tint len;\n\tstatic int anim_state = 1;\n\n\tRAWFB_RET_VOID\n\n\tif (ncache_keep_anims) {\n\t\treturn;\n\t}\n\n\tif (restore) {\n\t\tif (anim_state == 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tuser = get_user_name();\n\t\tif (strstr(user, \"'\") != NULL)  {\n\t\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\t\tfree(user);\n\t\t\treturn;\n\t\t}\n\n\t\tsess = dcop_session();\n\n\t\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\t\tcmd = (char *) malloc(len);\n\t\tsprintf(cmd, kwin_reconfigure, user, sess);\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Restoring KDE kwinrc settings.\\n\");\n\t\trfbLog(\"\\n\");\n\t\tdt_cmd(cmd);\n\t\tfree(cmd);\n\t\tfree(user);\n\t\tfree(sess);\n\t\tanim_state = 1;\n\t\treturn;\n\t} else {\n\t\tif (anim_state == 0) {\n\t\t\treturn;\n\t\t}\n\t\tanim_state = 0;\n\t}\n\n\tuser = get_user_name();\n\tif (strstr(user, \"'\") != NULL)  {\n\t\trfbLog(\"invalid user: %s\\n\", user);\n\t\tfree(user);\n\t\treturn;\n\t}\n\tout = cmd_output(query_setting);\n\n\n\tif (!out || strstr(out, \"false\")) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"KDE kwinrc AnimateMinimize is false. Good.\\n\");\n\t\trfbLog(\"********************************************************\\n\");\n\t\trfbLog(\"\\n\");\n\t\tfree(user);\n\t\treturn;\n\t}\n\n\trfbLog(\"\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"To improve the -ncache client-side caching performance\\n\");\n\trfbLog(\"temporarily setting KDE kwinrc AnimateMinimize to false.\\n\");\n\trfbLog(\"It will be reset for the next session or when VNC client\\n\");\n\trfbLog(\"disconnects.  Or you can use the Control Center GUI to\\n\");\n\trfbLog(\"change it now (toggle its setting a few times):\\n\");\n\trfbLog(\"   Desktop -> Window Behavior -> Moving\\n\");\n\trfbLog(\"********************************************************\\n\");\n\trfbLog(\"\\n\");\n\n\tset_env(\"DISPLAY\", DisplayString(dpy));\n\n\tsess = dcop_session();\n\tlen = strlen(kwin_reconfigure) + strlen(user) + strlen(sess) + 1;\n\tcmd = (char *) malloc(len);\n\tsprintf(cmd, kwin_reconfigure, user, sess);\n\n\tlen = 1 + strlen(\"sleep 10\") + 2 + strlen(kwinrc_off) + 2 + strlen(cmd) + 2 + strlen(\"sleep 5\") + 2 + strlen(kwinrc_on) + 3 + 1;\n\tcmd2 = (char *) malloc(len);\n\n\tsprintf(cmd2, \"(sleep 10; %s; %s; sleep 5; %s) &\", kwinrc_off, cmd, kwinrc_on);\n\n\tdt_cmd(cmd2);\n\tfree(cmd);\n\tfree(cmd2);\n\tfree(user);\n\tfree(sess);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "solid_bg",
          "args": [
            "1"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "solid_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/solid.c",
          "lines": "1330-1425",
          "snippet": "void solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}",
          "includes": [
            "#include \"xevents.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *guess_desktop(void);",
            "void solid_bg(int restore);",
            "static void usr_bin_path(int restore);",
            "XImage *solid_root(char *color);",
            "static void solid_cde(char *color);",
            "static void solid_gnome(char *color);",
            "static void solid_kde(char *color);",
            "static void solid_macosx(int restore);",
            "static char *last_color = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xevents.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"x11vnc.h\"\n\nchar *guess_desktop(void);\nvoid solid_bg(int restore);\nstatic void usr_bin_path(int restore);\nXImage *solid_root(char *color);\nstatic void solid_cde(char *color);\nstatic void solid_gnome(char *color);\nstatic void solid_kde(char *color);\nstatic void solid_macosx(int restore);\nstatic char *last_color = NULL;\n\nvoid solid_bg(int restore) {\n\tstatic int desktop = -1;\n\tstatic int solid_on = 0;\n\tstatic char *prev_str;\n\tchar *dtname, *color;\n\n\tif (started_as_root == 1 && users_list) {\n\t\t/* we are still root, don't try. */\n\t\treturn;\n\t}\n\n\tif (macosx_console) {\n\t\tsolid_macosx(restore);\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (! solid_on) {\n\t\t\treturn;\n\t\t}\n\t\tif (desktop == 0) {\n\t\t\tsolid_root(NULL);\n\t\t} else if (desktop == 1) {\n\t\t\tsolid_gnome(NULL);\n\t\t} else if (desktop == 2) {\n\t\t\tsolid_kde(NULL);\n\t\t} else if (desktop == 3) {\n\t\t\tsolid_cde(NULL);\n\t\t} else if (desktop == 4) {\n\t\t\tsolid_xfce(NULL);\n\t\t}\n\t\tsolid_on = 0;\n\t\treturn;\n\t}\n\tif (! solid_str) {\n\t\treturn;\n\t}\n\tif (solid_on && !strcmp(prev_str, solid_str)) {\n\t\treturn;\n\t}\n\tif (strstr(solid_str, \"guess:\") == solid_str\n\t    || !strchr(solid_str, ':')) {\n\t\tdtname = guess_desktop();\n\t\trfbLog(\"guessed desktop: %s\\n\", dtname);\n\t} else {\n\t\tif (strstr(solid_str, \"gnome:\") == solid_str) {\n\t\t\tdtname = \"gnome\";\n\t\t} else if (strstr(solid_str, \"kde:\") == solid_str) {\n\t\t\tdtname = \"kde\";\n\t\t} else if (strstr(solid_str, \"cde:\") == solid_str) {\n\t\t\tdtname = \"cde\";\n\t\t} else if (strstr(solid_str, \"xfce:\") == solid_str) {\n\t\t\tdtname = \"xfce\";\n\t\t} else {\n\t\t\tdtname = \"root\";\n\t\t}\n\t}\n\n\tcolor = strchr(solid_str, ':');\n\tif (! color) {\n\t\tcolor = solid_str;\n\t} else {\n\t\tcolor++;\n\t\tif (*color == '\\0') {\n\t\t\tcolor = solid_default;\n\t\t}\n\t}\n\tif (last_color) {\n\t\tfree(last_color);\n\t}\n\tlast_color = strdup(color);\n\n\tif (!strcmp(dtname, \"gnome\")) {\n\t\tdesktop = 1;\n\t\tsolid_gnome(color);\n\t} else if (!strcmp(dtname, \"kde\")) {\n\t\tdesktop = 2;\n\t\tsolid_kde(color);\n\t} else if (!strcmp(dtname, \"cde\")) {\n\t\tdesktop = 3;\n\t\tsolid_cde(color);\n\t} else if (!strcmp(dtname, \"xfce\")) {\n\t\tdesktop = 4;\n\t\tsolid_xfce(color);\n\t} else {\n\t\tdesktop = 0;\n\t\tsolid_root(color);\n\t}\n\tif (prev_str) {\n\t\tfree(prev_str);\n\t}\n\tprev_str = strdup(solid_str);\n\tsolid_on = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autorepeat",
          "args": [
            "1",
            "0"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "autorepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "386-442",
          "snippet": "void autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);",
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static int save_auto_repeat = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic int save_auto_repeat = -1;\n\nvoid autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_screen",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "copy_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "2412-2455",
          "snippet": "int copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void shm_delete(XShmSegmentInfo *shm);",
            "int copy_screen(void);",
            "static void blackout_regions(void);",
            "static int fs_factor = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nint copy_screen(void);\nstatic void blackout_regions(void);\nstatic int fs_factor = 0;\n\nint copy_screen(void) {\n\tchar *fbp;\n\tint i, y, block_size;\n\n\tif (! fs_factor) {\n\t\treturn 0;\n\t}\n\tif (debug_tiles) fprintf(stderr, \"copy_screen\\n\");\n\n\tif (unixpw_in_progress) return 0;\n\n\n\tif (! main_fb) {\n\t\treturn 0;\n\t}\n\n\tblock_size = ((dpy_y/fs_factor) * main_bytes_per_line);\n\n\tfbp = main_fb;\n\ty = 0;\n\n\tX_LOCK;\n\n\t/* screen may be too big for 1 shm area, so broken into fs_factor */\n\tfor (i=0; i < fs_factor; i++) {\n\t\tXRANDR_SET_TRAP_RET(-1, \"copy_screen-set\");\n\t\tcopy_image(fullscreen, 0, y, 0, 0);\n\t\tXRANDR_CHK_TRAP_RET(-1, \"copy_screen-chk\");\n\n\t\tmemcpy(fbp, fullscreen->data, (size_t) block_size);\n\n\t\ty += dpy_y / fs_factor;\n\t\tfbp += block_size;\n\t}\n\n\tX_UNLOCK;\n\n\tif (blackouts) {\n\t\tblackout_regions();\n\t}\n\n\tmark_rect_as_modified(0, 0, dpy_x, dpy_y, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbRegisterTightVNCFileTransferExtension",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"rfbRegisterTightVNCFileTransferExtension: 3\\n\""
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"client_count: %d\\n\"",
            "client_count"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nrfbClientPtr inetd_client = NULL;\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic void ugly_geom(char *p, int *x, int *y);\nstatic int accepted_client = 0;\n\nvoid client_gone(rfbClientPtr client) {\n\tClientData *cd = NULL;\n\n\tCLIENT_LOCK;\n\n\tclient_count--;\n\tif (client_count < 0) client_count = 0;\n\n\tspeeds_net_rate_measured = 0;\n\tspeeds_net_latency_measured = 0;\n\n\trfbLog(\"client_count: %d\\n\", client_count);\n\tlast_client_gone = dnow();\n\n\tif (unixpw_in_progress && unixpw_client) {\n\t\tif (client == unixpw_client) {\n\t\t\tunixpw_in_progress = 0;\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = unixpw_file_xfer_save;\n\t\t\tif ((tightfilexfer = unixpw_tightvnc_xfer_save)) {\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 3\\n\");\n\t\t\t\trfbRegisterTightVNCFileTransferExtension();\n#endif\n\t\t\t}\n\t\t\tunixpw_client = NULL;\n\t\t\tcopy_screen();\n\t\t}\n\t}\n\n\n\tif (no_autorepeat && client_count == 0) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg && client_count == 0) {\n\t\tsolid_bg(1);\n\t}\n\tif ((ncache || ncache0) && client_count == 0) {\n\t\tkde_no_animate(1);\n\t}\n\tif (client->clientData) {\n\t\tcd = (ClientData *) client->clientData;\n\t\tif (cd->ssl_helper_pid > 0) {\n\t\t\tint status;\n\t\t\trfbLog(\"sending SIGTERM to ssl_helper_pid: %d\\n\",\n\t\t\t    cd->ssl_helper_pid);\n\t\t\tkill(cd->ssl_helper_pid, SIGTERM);\n\t\t\tusleep(200*1000);\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID \n\t\t\twaitpid(cd->ssl_helper_pid, &status, WNOHANG); \n#endif\n\t\t\tssl_helper_pid(cd->ssl_helper_pid, -1);\t/* delete */\n\t\t}\n\t}\n\tif (gone_cmd && *gone_cmd != '\\0') {\n\t\tif (strstr(gone_cmd, \"popup\") == gone_cmd) {\n\t\t\tint x = -64000, y = -64000, timeout = 120;\n\t\t\tchar *userhost = ident_username(client);\n\t\t\tchar *addr, *p, *mode;\n\n\t\t\t/* extract timeout */\n\t\t\tif ((p = strchr(gone_cmd, ':')) != NULL) {\n\t\t\t\tint in;\n\t\t\t\tif (sscanf(p+1, \"%d\", &in) == 1) {\n\t\t\t\t\ttimeout = in;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* extract geometry */\n\t\t\tif ((p = strpbrk(gone_cmd, \"+-\")) != NULL) {\n\t\t\t\tugly_geom(p, &x, &y);\n\t\t\t}\n\n\t\t\t/* find mode: mouse, key, or both */\n\t\t\tif (strstr(gone_cmd, \"popupmouse\") == gone_cmd) {\n\t\t\t\tmode = \"mouse_only\";\n\t\t\t} else if (strstr(gone_cmd, \"popupkey\") == gone_cmd) {\n\t\t\t\tmode = \"key_only\";\n\t\t\t} else {\n\t\t\t\tmode = \"both\";\n\t\t\t}\n\n\t\t\taddr = client->host;\n\n\t\t\tugly_window(addr, userhost, x, y, timeout, mode, 0);\n\n\t\t\tfree(userhost);\n\t\t} else {\n\t\t\trfbLog(\"client_gone: using cmd: %s\\n\", client->host);\n\t\t\trun_user_command(gone_cmd, client, \"gone\", NULL, 0, NULL);\n\t\t}\n\t}\n\n\t/* remove clients XInput2 master device */\n        if(use_multipointer) \n\t  if(removeMD(dpy, cd->ptr_id))\n\t    rfbLog(\"removed XInput2 MD for client %s.\\n\", client->host);\n\n\tfree_client_data(client);\n\n\tif (inetd && client == inetd_client) {\n\t\trfbLog(\"inetd viewer exited.\\n\");\n\t\tif (gui_pid > 0) {\n\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\tkill(gui_pid, SIGTERM);\n\t\t}\n\t\tclean_up_exit(0);\n\t}\n\n\tif (connect_once) {\n\t\t/*\n\t\t * This non-exit is done for a bad passwd to be consistent\n\t\t * with our RFB_CLIENT_REFUSE behavior in new_client()  (i.e.\n\t\t * we disconnect after 1 successful connection).\n\t\t */\n\t\tif ((client->state == RFB_PROTOCOL_VERSION ||\n\t\t     client->state == RFB_SECURITY_TYPE ||\n\t\t     client->state == RFB_AUTHENTICATION ||\n\t\t     client->state == RFB_INITIALISATION) && accepted_client) {\n\t\t\trfbLog(\"connect_once: invalid password or early \"\n\t\t\t   \"disconnect.  %d\\n\", client->state);\n\t\t\trfbLog(\"connect_once: waiting for next connection.\\n\"); \n\t\t\taccepted_client--;\n\t\t\tif (accepted_client < 0) {\n\t\t\t\taccepted_client = 0;\n\t\t\t}\n\t\t\tCLIENT_UNLOCK;\n\t\t\tif (connect_or_exit) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (shared && client_count > 0)  {\n\t\t\trfbLog(\"connect_once: other shared clients still \"\n\t\t\t    \"connected, not exiting.\\n\");\n\t\t\tCLIENT_UNLOCK;\n\t\t\treturn;\n\t\t}\n\n\t\trfbLog(\"viewer exited.\\n\");\n\t\tif ((client_connect || connect_or_exit) && gui_pid > 0) {\n\t\t\trfbLog(\"killing gui_pid %d\\n\", gui_pid);\n\t\t\tkill(gui_pid, SIGTERM);\n\t\t}\n\t\tCLIENT_UNLOCK;\n\t\tclean_up_exit(0);\n\t}\n#ifdef MACOSX\n\tif (macosx_console && client_count == 0) {\n\t\tmacosxCG_refresh_callback_off();\n\t}\n#endif\n\tCLIENT_UNLOCK;\n}"
  },
  {
    "function_name": "free_client_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "765-804",
    "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "client->clientData"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "cd->cursor_region"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbFreeCursor",
          "args": [
            "cd->cursor"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
  },
  {
    "function_name": "run_user_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "466-763",
    "snippet": "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "int cmd_ok(char *cmd);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
      "void send_client_info(char *str);",
      "void adjust_grabs(int grab, int quiet);",
      "int accept_client(rfbClientPtr client);",
      "int run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);",
      "int check_access(char *addr);",
      "void client_set_net(rfbClientPtr client);",
      "static rfbClientPtr *client_match(char *str);",
      "static void free_client_data(rfbClientPtr client);",
      "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
      "static int action_match(char *action, int rc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "old_display"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "old_display"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"command returned: %d\\n\"",
            "rc"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"/bin/sh\"",
            "\"/bin/sh\"",
            "\"-c\"",
            "cmd",
            "(char *) NULL"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpgrp",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"gone\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "close_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "358-379",
          "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&omask",
            "(sigset_t *) NULL"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGQUIT",
            "&quit",
            "(struct sigaction *) NULL"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&intr",
            "(struct sigaction *) NULL"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fork\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not fork\\n\""
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&omask",
            "(sigset_t *) NULL"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGQUIT",
            "&quit",
            "(struct sigaction *) NULL"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&intr",
            "(struct sigaction *) NULL"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&rc",
            "0"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&sa.sa_mask",
            "&omask"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&sa.sa_mask",
            "SIGCHLD"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGQUIT",
            "&sa",
            "&quit"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&sa",
            "&intr"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sa.sa_mask"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "ph"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fileno(ph)",
            "input",
            "len"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "ph"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"popen\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"popen(%s) failed\"",
            "cmd"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"w\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "ph"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line",
            "0",
            "sizeof(line)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "output"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"line: %s\"",
            "line"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "ph"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line",
            "0",
            "sizeof(line)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"popen\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"popen(%s) failed\"",
            "cmd"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd",
            "\"r\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "cmd2",
            "\"r\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd2",
            "\"/bin/cat %s | %s\"",
            "tmp",
            "cmd"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "100 + strlen(tmp) + strlen(cmd)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"mkstemp failed on: %s\\n\"",
            "tmp"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmp"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_exec_fds",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "close_exec_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "754-765",
          "snippet": "void close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_exec_fds(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid close_exec_fds(void);\n\nvoid close_exec_fds(void) {\n\tint fd;\n#ifdef FD_CLOEXEC\n\tfor (fd = 3; fd < 64; fd++) {\n\t\tint flags = fcntl(fd, F_GETFD);\n\t\tif (flags != -1) {\n\t\t\tflags |= FD_CLOEXEC;\n\t\t\tfcntl(fd, F_SETFD, flags);\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n  %s\\n\\n\"",
            "cmd"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"running command:\\n\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   exiting.\\n\""
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   \\\"%s\\\"\\n\"",
            "cmd"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cannot run external commands in -nocmds mode:\\n\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "1"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"custom_passwd\""
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"custom_passwd\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"read_passwds\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"cmd_verify\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"gone\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"afteraccept\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"accept\""
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mode",
            "\"env\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "client_count"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "getenv(\"DISPLAY\")"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "(int) time(NULL)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_connect_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "2631-2638",
          "snippet": "static void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define USE_TIMEOUT_INTERRUPT 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define USE_TIMEOUT_INTERRUPT 0\n\nstatic void reverse_connect_timeout (int sig) {\n\trfbLog(\"sig: %d, reverse_connect_timeout.\\n\", sig);\n#if USE_TIMEOUT_INTERRUPT\n\trfbLog(\"reverse_connect_timeout proceeding assuming connect(2) interrupt.\\n\");\n#else\n\tclean_up_exit(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\">%d\"",
            "(int) time(NULL)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "(int) cd->login_time"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "-1"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "cd->login_viewonly"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "get_local_port(client->sock)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_local_port",
          "args": [
            "client->sock"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "230-232",
          "snippet": "int get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "cd->server_port"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_local_host",
          "args": [
            "client->sock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "262-264",
          "snippet": "char *get_local_host(int sock) {\n\treturn get_host(sock, 0);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nchar *get_local_host(int sock) {\n\treturn get_host(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "get_remote_port(client->sock)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_remote_port",
          "args": [
            "client->sock"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "226-228",
          "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "cd->client_port"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"%d\"",
            "(int) getpid()"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"0x%x\"",
            "clients_served"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"0x%x\"",
            "cd->uid"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_set_net",
          "args": [
            "client"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "client_set_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3903-3920",
          "snippet": "void client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nvoid send_client_info(char *str);\nvoid adjust_grabs(int grab, int quiet);\nint accept_client(rfbClientPtr client);\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n    int len, FILE *output);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic int action_match(char *action, int rc);\n\nint run_user_command(char *cmd, rfbClientPtr client, char *mode, char *input,\n   int len, FILE *output) {\n\tchar *old_display = NULL;\n\tchar *addr = NULL;\n\tchar str[100];\n\tint rc, ok;\n\tClientData *cd = NULL;\n\tclient_set_net(client);\n\tif (client != NULL) {\n\t\tcd = (ClientData *) client->clientData;\n\t\taddr = client->host;\n\t}\n\n\tif (addr == NULL || addr[0] == '\\0') {\n\t\taddr = \"unknown-host\";\n\t}\n\n\t/* set RFB_CLIENT_ID to semi unique id for command to use */\n\tif (cd && cd->uid) {\n\t\tsprintf(str, \"0x%x\", cd->uid);\n\t} else {\n\t\t/* not accepted yet: */\n\t\tsprintf(str, \"0x%x\", clients_served);\n\t}\n\tset_env(\"RFB_CLIENT_ID\", str);\n\n\t/* set RFB_CLIENT_IP to IP addr for command to use */\n\tset_env(\"RFB_CLIENT_IP\", addr);\n\n\t/* set RFB_X11VNC_PID to our pid for command to use */\n\tsprintf(str, \"%d\", (int) getpid());\n\tset_env(\"RFB_X11VNC_PID\", str);\n\n\tif (client == NULL) {\n\t\t;\n\t} else if (client->state == RFB_PROTOCOL_VERSION) {\n\t\tset_env(\"RFB_STATE\", \"PROTOCOL_VERSION\");\n\t} else if (client->state == RFB_SECURITY_TYPE) {\n\t\tset_env(\"RFB_STATE\", \"SECURITY_TYPE\");\n\t} else if (client->state == RFB_AUTHENTICATION) {\n\t\tset_env(\"RFB_STATE\", \"AUTHENTICATION\");\n\t} else if (client->state == RFB_INITIALISATION) {\n\t\tset_env(\"RFB_STATE\", \"INITIALISATION\");\n\t} else if (client->state == RFB_NORMAL) {\n\t\tset_env(\"RFB_STATE\", \"NORMAL\");\n\t} else {\n\t\tset_env(\"RFB_STATE\", \"UNKNOWN\");\n\t}\n\tif (certret_str) {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", certret_str);\n\t} else {\n\t\tset_env(\"RFB_SSL_CLIENT_CERT\", \"\");\n\t}\n\n\t/* set RFB_CLIENT_PORT to peer port for command to use */\n\tif (cd && cd->client_port > 0) {\n\t\tsprintf(str, \"%d\", cd->client_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_remote_port(client->sock));\n\t}\n\tset_env(\"RFB_CLIENT_PORT\", str);\n\n\tset_env(\"RFB_MODE\", mode);\n\n\t/* \n\t * now do RFB_SERVER_IP and RFB_SERVER_PORT (i.e. us!)\n\t * This will establish a 5-tuple (including tcp) the external\n\t * program can potentially use to work out the virtual circuit\n\t * for this connection.\n\t */\n\tif (cd && cd->server_ip) {\n\t\tset_env(\"RFB_SERVER_IP\", cd->server_ip);\n\t} else if (client) {\n\t\tchar *sip = get_local_host(client->sock);\n\t\tset_env(\"RFB_SERVER_IP\", sip);\n\t\tif (sip) free(sip);\n\t}\n\n\tif (cd && cd->server_port > 0) {\n\t\tsprintf(str, \"%d\", cd->server_port);\n\t} else if (client) {\n\t\tsprintf(str, \"%d\", get_local_port(client->sock));\n\t}\n\tset_env(\"RFB_SERVER_PORT\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", cd->login_viewonly);\n\t} else {\n\t\tsprintf(str, \"%d\", -1);\n\t}\n\tset_env(\"RFB_LOGIN_VIEWONLY\", str);\n\n\tif (cd) {\n\t\tsprintf(str, \"%d\", (int) cd->login_time);\n\t} else {\n\t\tsprintf(str, \">%d\", (int) time(NULL));\n\t}\n\tset_env(\"RFB_LOGIN_TIME\", str);\n\n\tsprintf(str, \"%d\", (int) time(NULL));\n\tset_env(\"RFB_CURRENT_TIME\", str);\n\n\tif (!cd || !cd->username || cd->username[0] == '\\0') {\n\t\tset_env(\"RFB_USERNAME\", \"unknown-user\");\n\t} else {\n\t\tset_env(\"RFB_USERNAME\", cd->username);\n\t}\n\t/* \n\t * Better set DISPLAY to the one we are polling, if they\n\t * want something trickier, they can handle on their own\n\t * via environment, etc. \n\t */\n\tif (getenv(\"DISPLAY\")) {\n\t\told_display = strdup(getenv(\"DISPLAY\"));\n\t}\n\n\tif (raw_fb && ! dpy) {\t/* raw_fb hack */\n\t\tset_env(\"DISPLAY\", \"rawfb\");\n\t} else {\n\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t}\n\n\t/*\n\t * work out the number of clients (have to use client_count\n\t * since there is deadlock in rfbGetClientIterator) \n\t */\n\tsprintf(str, \"%d\", client_count);\n\tset_env(\"RFB_CLIENT_COUNT\", str);\n\n\t/* gone, accept, afteraccept */\n\tok = 0;\n\tif (!strcmp(mode, \"env\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(mode, \"accept\") && cmd_ok(\"accept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"afteraccept\") && cmd_ok(\"afteraccept\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"gone\") && cmd_ok(\"gone\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"cmd_verify\") && cmd_ok(\"unixpw\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"read_passwds\") && cmd_ok(\"passwdfile\")) {\n\t\tok = 1;\n\t}\n\tif (!strcmp(mode, \"custom_passwd\") && cmd_ok(\"custom_passwd\")) {\n\t\tok = 1;\n\t}\n\tif (no_external_cmds || !ok) {\n\t\trfbLogEnable(1);\n\t\trfbLog(\"cannot run external commands in -nocmds mode:\\n\");\n\t\trfbLog(\"   \\\"%s\\\"\\n\", cmd);\n\t\trfbLog(\"   exiting.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\trfbLog(\"running command:\\n\");\n\tif (!quiet) {\n\t\tfprintf(stderr, \"\\n  %s\\n\\n\", cmd);\n\t}\n\tclose_exec_fds();\n\n\tif (output != NULL) {\n\t\tFILE *ph;\n\t\tchar line[1024];\n\t\tchar *cmd2 = NULL;\n\t\tchar tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\t\tint deltmp = 0;\n\n\t\tif (input != NULL) {\n\t\t\tint tmp_fd = mkstemp(tmp);\n\t\t\tif (tmp_fd < 0) {\n\t\t\t\trfbLog(\"mkstemp failed on: %s\\n\", tmp);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\twrite(tmp_fd, input, len);\n\t\t\tclose(tmp_fd);\n\t\t\tdeltmp = 1;\n\t\t\tcmd2 = (char *) malloc(100 + strlen(tmp) + strlen(cmd));\n\t\t\tsprintf(cmd2, \"/bin/cat %s | %s\", tmp, cmd);\n\t\t\t\n\t\t\tph = popen(cmd2, \"r\");\n\t\t} else {\n\t\t\tph = popen(cmd, \"r\");\n\t\t}\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tmemset(line, 0, sizeof(line));\n\t\twhile (fgets(line, sizeof(line), ph) != NULL) {\n\t\t\tint j, k = -1;\n\t\t\tif (0) fprintf(stderr, \"line: %s\", line);\n\t\t\t/* take care to handle embedded nulls */\n\t\t\tfor (j=0; j < (int) sizeof(line); j++) {\n\t\t\t\tif (line[j] != '\\0') {\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k >= 0) {\n\t\t\t\twrite(fileno(output), line, k+1);\n\t\t\t}\n\t\t\tmemset(line, 0, sizeof(line));\n\t\t}\n\n\t\trc = pclose(ph);\n\n\t\tif (cmd2 != NULL) {\n\t\t\tfree(cmd2);\n\t\t}\n\t\tif (deltmp) {\n\t\t\tunlink(tmp);\n\t\t}\n\t\tgoto got_rc;\n\t} else if (input != NULL) {\n\t\tFILE *ph = popen(cmd, \"w\");\n\t\tif (ph == NULL) {\n\t\t\trfbLog(\"popen(%s) failed\", cmd);\n\t\t\trfbLogPerror(\"popen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twrite(fileno(ph), input, len);\n\t\trc = pclose(ph);\n\t\tgoto got_rc;\n\t}\n\n#if LIBVNCSERVER_HAVE_FORK\n\t{\n\t\tpid_t pid;\n\t\tstruct sigaction sa, intr, quit;\n\t\tsigset_t omask;\n\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsa.sa_flags = 0;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsigaction(SIGINT,  &sa, &intr);\n\t\tsigaction(SIGQUIT, &sa, &quit);\n\n\t\tsigaddset(&sa.sa_mask, SIGCHLD);\n\t\tsigprocmask(SIG_BLOCK, &sa.sa_mask, &omask);\n\n\t\tif ((pid = fork()) > 0 || pid == -1) {\n\n\t\t\tif (pid != -1) {\n\t\t\t\twaitpid(pid, &rc, 0);\n\t\t\t}\n\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\n\t\t\tif (pid == -1) {\n\t\t\t\tfprintf(stderr, \"could not fork\\n\");\n\t\t\t\trfbLogPerror(\"fork\");\n\t\t\t\trc = system(cmd);\n\t\t\t}\n\t\t} else {\n\t\t\t/* this should close port 5900, etc.. */\n\t\t\tint fd;\n\t\t\tsigaction(SIGINT,  &intr, (struct sigaction *) NULL);\n\t\t\tsigaction(SIGQUIT, &quit, (struct sigaction *) NULL);\n\t\t\tsigprocmask(SIG_SETMASK, &omask, (sigset_t *) NULL);\n\t\t\tfor (fd=3; fd<256; fd++) {\n\t\t\t\tclose(fd);\n\t\t\t}\n/* XXX test more */\n\t\t\tif (!strcmp(mode, \"gone\")) {\n#if HAVE_SETSID\n\t\t\t\tsetsid();\n#else\n\t\t\t\tsetpgrp();\n#endif\n\t\t\t}\n\t\t\texeclp(\"/bin/sh\", \"/bin/sh\", \"-c\", cmd, (char *) NULL);\n\t\t\texit(1);\n\t\t}\n\t}\n#else\n\trc = system(cmd);\n#endif\n\tgot_rc:\n\n\tif (rc >= 256) {\n\t\trc = rc/256;\n\t}\n\trfbLog(\"command returned: %d\\n\", rc);\n\n\tif (old_display) {\n\t\tset_env(\"DISPLAY\", old_display);\n\t\tfree(old_display);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cmd_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "436-460",
    "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "int cmd_ok(char *cmd);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "cmd"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "allowed_external_cmds"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
  },
  {
    "function_name": "set_child_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "417-434",
    "snippet": "void set_child_info(void) {\n\tchar pid[16];\n\t/* set up useful environment for child process */\n\tsprintf(pid, \"%d\", (int) getpid());\n\tset_env(\"X11VNC_PID\", pid);\n\tif (program_name) {\n\t\t/* e.g. for remote control -R */\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t}\n\tif (program_cmdline) {\n\t\tset_env(\"X11VNC_CMDLINE\", program_cmdline);\n\t}\n\tif (raw_fb_str) {\n\t\tset_env(\"X11VNC_RAWFB_STR\", raw_fb_str);\n\t} else {\n\t\tset_env(\"X11VNC_RAWFB_STR\", \"\");\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_child_info(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"X11VNC_RAWFB_STR\"",
            "\"\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pid",
            "\"%d\"",
            "(int) getpid()"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid set_child_info(void);\n\nvoid set_child_info(void) {\n\tchar pid[16];\n\t/* set up useful environment for child process */\n\tsprintf(pid, \"%d\", (int) getpid());\n\tset_env(\"X11VNC_PID\", pid);\n\tif (program_name) {\n\t\t/* e.g. for remote control -R */\n\t\tset_env(\"X11VNC_PROG\", program_name);\n\t}\n\tif (program_cmdline) {\n\t\tset_env(\"X11VNC_CMDLINE\", program_cmdline);\n\t}\n\tif (raw_fb_str) {\n\t\tset_env(\"X11VNC_RAWFB_STR\", raw_fb_str);\n\t} else {\n\t\tset_env(\"X11VNC_RAWFB_STR\", \"\");\n\t}\n}"
  },
  {
    "function_name": "set_client_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "381-415",
    "snippet": "void set_client_input(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\tchar *p, *val;\n\n\t/* str is \"match:value\" */\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tp = strrchr(str, ':');\n\tif (! p) {\n\t\treturn;\n\t}\n\t*p = '\\0';\n\tp++;\n\tval = short_kmbcf(p);\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\tClientData *cd = (ClientData *) (*cp)->clientData;\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tcd->input[0] = '\\0';\n\t\tstrcat(cd->input, \"_\");\n\t\tstrcat(cd->input, val);\n\t\tcp++;\n\t}\n\n\tfree(val);\n\tfree(cl_list);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "int set_xprop(char *prop, Window win, char *value);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cl_list"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cd->input",
            "val"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cd->input",
            "\"_\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_match",
          "args": [
            "str"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "client_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "267-356",
          "snippet": "static rfbClientPtr *client_match(char *str) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl, *cl_list;\n\tint i, n, host_warn = 0, hex_warn = 0;\n\n\tn = client_count + 10;\n\tcl_list = (rfbClientPtr *) malloc(n * sizeof(rfbClientPtr));\n\t\n\ti = 0;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tif (strstr(str, \"0x\") == str) {\n\t\t\tunsigned int in;\n\t\t\tint id;\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sscanf(str, \"0x%x\", &in) != 1) {\n\t\t\t\tif (hex_warn++) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"skipping invalid client hex id: %s\\n\",\n\t\t\t\t    str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid = (unsigned int) in;\n\t\t\tif (cd->uid == id) {\n\t\t\t\tcl_list[i++] = cl;\n\t\t\t}\n\t\t} else {\n\t\t\tint port = -1;\n\t\t\tchar *rstr = strdup(str);\n\t\t\tchar *q = strrchr(rstr, ':');\n\t\t\tif (q) {\n\t\t\t\tport = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t\tif (port == 0 && q[1] != '0') {\n\t\t\t\t\tport = -1;\n\t\t\t\t} else if (port < 0) {\n\t\t\t\t\tport = -port;\n\t\t\t\t} else if (port < 200) {\n\t\t\t\t\tport = 5500 + port;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ipv6_ip(str)) {\n\t\t\t\t;\n\t\t\t} else if (! dotted_ip(str, 0)) {\n\t\t\t\tchar *orig = rstr;\n\t\t\t\trstr = host2ip(rstr);\n\t\t\t\tfree(orig);\n\t\t\t\tif (rstr == NULL || *rstr == '\\0') {\n\t\t\t\t\tif (host_warn++) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"skipping bad lookup: \\\"%s\\\"\\n\", str);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"lookup: %s -> %s port=%d\\n\", str, rstr, port);\n\t\t\t}\n\t\t\tif (!strcmp(rstr, cl->host)) {\n\t\t\t\tint ok = 1;\n\t\t\t\tif (port > 0) {\n\t\t\t\t\tif (cd != NULL && cd->client_port > 0) {\n\t\t\t\t\t\tif (cd->client_port != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cport = get_remote_port(cl->sock);\n\t\t\t\t\t\tif (cport != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcl_list[i++] = cl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(rstr);\n\t\t}\n\t\tif (i >= n - 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl_list[i] = NULL;\n\n\treturn cl_list;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "void send_client_info(char *str);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nvoid send_client_info(char *str);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic rfbClientPtr *client_match(char *str) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl, *cl_list;\n\tint i, n, host_warn = 0, hex_warn = 0;\n\n\tn = client_count + 10;\n\tcl_list = (rfbClientPtr *) malloc(n * sizeof(rfbClientPtr));\n\t\n\ti = 0;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tif (strstr(str, \"0x\") == str) {\n\t\t\tunsigned int in;\n\t\t\tint id;\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sscanf(str, \"0x%x\", &in) != 1) {\n\t\t\t\tif (hex_warn++) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"skipping invalid client hex id: %s\\n\",\n\t\t\t\t    str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid = (unsigned int) in;\n\t\t\tif (cd->uid == id) {\n\t\t\t\tcl_list[i++] = cl;\n\t\t\t}\n\t\t} else {\n\t\t\tint port = -1;\n\t\t\tchar *rstr = strdup(str);\n\t\t\tchar *q = strrchr(rstr, ':');\n\t\t\tif (q) {\n\t\t\t\tport = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t\tif (port == 0 && q[1] != '0') {\n\t\t\t\t\tport = -1;\n\t\t\t\t} else if (port < 0) {\n\t\t\t\t\tport = -port;\n\t\t\t\t} else if (port < 200) {\n\t\t\t\t\tport = 5500 + port;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ipv6_ip(str)) {\n\t\t\t\t;\n\t\t\t} else if (! dotted_ip(str, 0)) {\n\t\t\t\tchar *orig = rstr;\n\t\t\t\trstr = host2ip(rstr);\n\t\t\t\tfree(orig);\n\t\t\t\tif (rstr == NULL || *rstr == '\\0') {\n\t\t\t\t\tif (host_warn++) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"skipping bad lookup: \\\"%s\\\"\\n\", str);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"lookup: %s -> %s port=%d\\n\", str, rstr, port);\n\t\t\t}\n\t\t\tif (!strcmp(rstr, cl->host)) {\n\t\t\t\tint ok = 1;\n\t\t\t\tif (port > 0) {\n\t\t\t\t\tif (cd != NULL && cd->client_port > 0) {\n\t\t\t\t\t\tif (cd->client_port != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cport = get_remote_port(cl->sock);\n\t\t\t\t\t\tif (cport != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcl_list[i++] = cl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(rstr);\n\t\t}\n\t\tif (i >= n - 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl_list[i] = NULL;\n\n\treturn cl_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "short_kmbcf",
          "args": [
            "p"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "short_kmbcf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2398-2428",
          "snippet": "char *short_kmbcf(char *str) {\n\tint i, saw_k = 0, saw_m = 0, saw_b = 0, saw_c = 0, saw_f = 0, n = 10;\n\tchar *p, tmp[10];\n\t\n\tfor (i=0; i<n; i++) {\n\t\ttmp[i] = '\\0';\n\t}\n\n\tp = str;\n\ti = 0;\n\twhile (*p) {\n\t\tif ((*p == 'K' || *p == 'k') && !saw_k) {\n\t\t\ttmp[i++] = 'K';\n\t\t\tsaw_k = 1;\n\t\t} else if ((*p == 'M' || *p == 'm') && !saw_m) {\n\t\t\ttmp[i++] = 'M';\n\t\t\tsaw_m = 1;\n\t\t} else if ((*p == 'B' || *p == 'b') && !saw_b) {\n\t\t\ttmp[i++] = 'B';\n\t\t\tsaw_b = 1;\n\t\t} else if ((*p == 'C' || *p == 'c') && !saw_c) {\n\t\t\ttmp[i++] = 'C';\n\t\t\tsaw_c = 1;\n\t\t} else if ((*p == 'F' || *p == 'f') && !saw_f) {\n\t\t\ttmp[i++] = 'F';\n\t\t\tsaw_f = 1;\n\t\t}\n\t\tp++;\n\t}\n\treturn(strdup(tmp));\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "static void add_dead_keysyms(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nstatic void add_dead_keysyms(char *str);\n\nchar *short_kmbcf(char *str) {\n\tint i, saw_k = 0, saw_m = 0, saw_b = 0, saw_c = 0, saw_f = 0, n = 10;\n\tchar *p, tmp[10];\n\t\n\tfor (i=0; i<n; i++) {\n\t\ttmp[i] = '\\0';\n\t}\n\n\tp = str;\n\ti = 0;\n\twhile (*p) {\n\t\tif ((*p == 'K' || *p == 'k') && !saw_k) {\n\t\t\ttmp[i++] = 'K';\n\t\t\tsaw_k = 1;\n\t\t} else if ((*p == 'M' || *p == 'm') && !saw_m) {\n\t\t\ttmp[i++] = 'M';\n\t\t\tsaw_m = 1;\n\t\t} else if ((*p == 'B' || *p == 'b') && !saw_b) {\n\t\t\ttmp[i++] = 'B';\n\t\t\tsaw_b = 1;\n\t\t} else if ((*p == 'C' || *p == 'c') && !saw_c) {\n\t\t\ttmp[i++] = 'C';\n\t\t\tsaw_c = 1;\n\t\t} else if ((*p == 'F' || *p == 'f') && !saw_f) {\n\t\t\ttmp[i++] = 'F';\n\t\t\tsaw_f = 1;\n\t\t}\n\t\tp++;\n\t}\n\treturn(strdup(tmp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "':'"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nint set_xprop(char *prop, Window win, char *value);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid set_client_input(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\tchar *p, *val;\n\n\t/* str is \"match:value\" */\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\tp = strrchr(str, ':');\n\tif (! p) {\n\t\treturn;\n\t}\n\t*p = '\\0';\n\tp++;\n\tval = short_kmbcf(p);\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\tClientData *cd = (ClientData *) (*cp)->clientData;\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tcd->input[0] = '\\0';\n\t\tstrcat(cd->input, \"_\");\n\t\tstrcat(cd->input, val);\n\t\tcp++;\n\t}\n\n\tfree(val);\n\tfree(cl_list);\n}"
  },
  {
    "function_name": "close_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "358-379",
    "snippet": "void close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void close_all_clients(void);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "void send_client_info(char *str);",
      "static rfbClientPtr *client_match(char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cl_list"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbClientConnectionGone",
          "args": [
            "*cp"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "*cp"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_match",
          "args": [
            "str"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "client_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "267-356",
          "snippet": "static rfbClientPtr *client_match(char *str) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl, *cl_list;\n\tint i, n, host_warn = 0, hex_warn = 0;\n\n\tn = client_count + 10;\n\tcl_list = (rfbClientPtr *) malloc(n * sizeof(rfbClientPtr));\n\t\n\ti = 0;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tif (strstr(str, \"0x\") == str) {\n\t\t\tunsigned int in;\n\t\t\tint id;\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sscanf(str, \"0x%x\", &in) != 1) {\n\t\t\t\tif (hex_warn++) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"skipping invalid client hex id: %s\\n\",\n\t\t\t\t    str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid = (unsigned int) in;\n\t\t\tif (cd->uid == id) {\n\t\t\t\tcl_list[i++] = cl;\n\t\t\t}\n\t\t} else {\n\t\t\tint port = -1;\n\t\t\tchar *rstr = strdup(str);\n\t\t\tchar *q = strrchr(rstr, ':');\n\t\t\tif (q) {\n\t\t\t\tport = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t\tif (port == 0 && q[1] != '0') {\n\t\t\t\t\tport = -1;\n\t\t\t\t} else if (port < 0) {\n\t\t\t\t\tport = -port;\n\t\t\t\t} else if (port < 200) {\n\t\t\t\t\tport = 5500 + port;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ipv6_ip(str)) {\n\t\t\t\t;\n\t\t\t} else if (! dotted_ip(str, 0)) {\n\t\t\t\tchar *orig = rstr;\n\t\t\t\trstr = host2ip(rstr);\n\t\t\t\tfree(orig);\n\t\t\t\tif (rstr == NULL || *rstr == '\\0') {\n\t\t\t\t\tif (host_warn++) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"skipping bad lookup: \\\"%s\\\"\\n\", str);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"lookup: %s -> %s port=%d\\n\", str, rstr, port);\n\t\t\t}\n\t\t\tif (!strcmp(rstr, cl->host)) {\n\t\t\t\tint ok = 1;\n\t\t\t\tif (port > 0) {\n\t\t\t\t\tif (cd != NULL && cd->client_port > 0) {\n\t\t\t\t\t\tif (cd->client_port != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cport = get_remote_port(cl->sock);\n\t\t\t\t\t\tif (cport != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcl_list[i++] = cl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(rstr);\n\t\t}\n\t\tif (i >= n - 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl_list[i] = NULL;\n\n\treturn cl_list;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "void send_client_info(char *str);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static rfbClientPtr *client_match(char *str);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nvoid send_client_info(char *str);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic rfbClientPtr *client_match(char *str) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl, *cl_list;\n\tint i, n, host_warn = 0, hex_warn = 0;\n\n\tn = client_count + 10;\n\tcl_list = (rfbClientPtr *) malloc(n * sizeof(rfbClientPtr));\n\t\n\ti = 0;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tif (strstr(str, \"0x\") == str) {\n\t\t\tunsigned int in;\n\t\t\tint id;\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sscanf(str, \"0x%x\", &in) != 1) {\n\t\t\t\tif (hex_warn++) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"skipping invalid client hex id: %s\\n\",\n\t\t\t\t    str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid = (unsigned int) in;\n\t\t\tif (cd->uid == id) {\n\t\t\t\tcl_list[i++] = cl;\n\t\t\t}\n\t\t} else {\n\t\t\tint port = -1;\n\t\t\tchar *rstr = strdup(str);\n\t\t\tchar *q = strrchr(rstr, ':');\n\t\t\tif (q) {\n\t\t\t\tport = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t\tif (port == 0 && q[1] != '0') {\n\t\t\t\t\tport = -1;\n\t\t\t\t} else if (port < 0) {\n\t\t\t\t\tport = -port;\n\t\t\t\t} else if (port < 200) {\n\t\t\t\t\tport = 5500 + port;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ipv6_ip(str)) {\n\t\t\t\t;\n\t\t\t} else if (! dotted_ip(str, 0)) {\n\t\t\t\tchar *orig = rstr;\n\t\t\t\trstr = host2ip(rstr);\n\t\t\t\tfree(orig);\n\t\t\t\tif (rstr == NULL || *rstr == '\\0') {\n\t\t\t\t\tif (host_warn++) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"skipping bad lookup: \\\"%s\\\"\\n\", str);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"lookup: %s -> %s port=%d\\n\", str, rstr, port);\n\t\t\t}\n\t\t\tif (!strcmp(rstr, cl->host)) {\n\t\t\t\tint ok = 1;\n\t\t\t\tif (port > 0) {\n\t\t\t\t\tif (cd != NULL && cd->client_port > 0) {\n\t\t\t\t\t\tif (cd->client_port != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cport = get_remote_port(cl->sock);\n\t\t\t\t\t\tif (cport != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcl_list[i++] = cl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(rstr);\n\t\t}\n\t\tif (i >= n - 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl_list[i] = NULL;\n\n\treturn cl_list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_all_clients",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "close_all_clients",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "251-265",
          "snippet": "void close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_all_clients(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\n\nvoid close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"*\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nvoid close_clients(char *str) {\n\trfbClientPtr *cl_list, *cp;\n\n\tif (!strcmp(str, \"all\") || !strcmp(str, \"*\")) {\n\t\tclose_all_clients();\n\t\treturn;\n\t}\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tcl_list = client_match(str);\n\n\tcp = cl_list;\n\twhile (*cp) {\n\t\trfbCloseClient(*cp);\n\t\trfbClientConnectionGone(*cp);\n\t\tcp++;\n\t}\n\tfree(cl_list);\n}"
  },
  {
    "function_name": "client_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "267-356",
    "snippet": "static rfbClientPtr *client_match(char *str) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl, *cl_list;\n\tint i, n, host_warn = 0, hex_warn = 0;\n\n\tn = client_count + 10;\n\tcl_list = (rfbClientPtr *) malloc(n * sizeof(rfbClientPtr));\n\t\n\ti = 0;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tif (strstr(str, \"0x\") == str) {\n\t\t\tunsigned int in;\n\t\t\tint id;\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sscanf(str, \"0x%x\", &in) != 1) {\n\t\t\t\tif (hex_warn++) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"skipping invalid client hex id: %s\\n\",\n\t\t\t\t    str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid = (unsigned int) in;\n\t\t\tif (cd->uid == id) {\n\t\t\t\tcl_list[i++] = cl;\n\t\t\t}\n\t\t} else {\n\t\t\tint port = -1;\n\t\t\tchar *rstr = strdup(str);\n\t\t\tchar *q = strrchr(rstr, ':');\n\t\t\tif (q) {\n\t\t\t\tport = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t\tif (port == 0 && q[1] != '0') {\n\t\t\t\t\tport = -1;\n\t\t\t\t} else if (port < 0) {\n\t\t\t\t\tport = -port;\n\t\t\t\t} else if (port < 200) {\n\t\t\t\t\tport = 5500 + port;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ipv6_ip(str)) {\n\t\t\t\t;\n\t\t\t} else if (! dotted_ip(str, 0)) {\n\t\t\t\tchar *orig = rstr;\n\t\t\t\trstr = host2ip(rstr);\n\t\t\t\tfree(orig);\n\t\t\t\tif (rstr == NULL || *rstr == '\\0') {\n\t\t\t\t\tif (host_warn++) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"skipping bad lookup: \\\"%s\\\"\\n\", str);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"lookup: %s -> %s port=%d\\n\", str, rstr, port);\n\t\t\t}\n\t\t\tif (!strcmp(rstr, cl->host)) {\n\t\t\t\tint ok = 1;\n\t\t\t\tif (port > 0) {\n\t\t\t\t\tif (cd != NULL && cd->client_port > 0) {\n\t\t\t\t\t\tif (cd->client_port != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cport = get_remote_port(cl->sock);\n\t\t\t\t\t\tif (cport != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcl_list[i++] = cl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(rstr);\n\t\t}\n\t\tif (i >= n - 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl_list[i] = NULL;\n\n\treturn cl_list;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void close_clients(char *str);",
      "void set_client_input(char *str);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "void reverse_connect(char *str);",
      "void set_vnc_connect_prop(char *str);",
      "void set_x11vnc_remote_prop(char *str);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "void send_client_info(char *str);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static rfbClientPtr *client_match(char *str);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "rstr"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_remote_port",
          "args": [
            "cl->sock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "226-228",
          "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rstr",
            "cl->host"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"lookup: %s -> %s port=%d\\n\"",
            "str",
            "rstr",
            "port"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping bad lookup: \\\"%s\\\"\\n\"",
            "str"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host2ip",
          "args": [
            "rstr"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "host2ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "68-86",
          "snippet": "char *host2ip(char *host) {\n\tstruct hostent *hp;\n\tstruct sockaddr_in addr;\n\tchar *str;\n\n\tif (! host_lookup) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyname(host);\n\tif (!hp) {\n\t\treturn NULL;\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr =  *(unsigned long *)hp->h_addr;\n\tstr = strdup(inet_ntoa(addr.sin_addr));\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nchar *host2ip(char *host) {\n\tstruct hostent *hp;\n\tstruct sockaddr_in addr;\n\tchar *str;\n\n\tif (! host_lookup) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyname(host);\n\tif (!hp) {\n\t\treturn NULL;\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr =  *(unsigned long *)hp->h_addr;\n\tstr = strdup(inet_ntoa(addr.sin_addr));\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dotted_ip",
          "args": [
            "str",
            "0"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "dotted_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "175-204",
          "snippet": "int dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "char *raw2host(char *raw, int len);",
            "int ipv6_ip(char *host);",
            "int dotted_ip(char *host, int partial);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint dotted_ip(char *host, int partial);\n\nint dotted_ip(char *host, int partial) {\n\tint len, dots = 0;\n\tchar *p = host;\n\n\tif (!host) {\n\t\treturn 0;\n\t}\n\n\tif (!isdigit((unsigned char) host[0])) {\n\t\treturn 0;\n\t}\n\n\tlen = strlen(host);\n\tif (!partial && !isdigit((unsigned char) host[len-1])) {\n\t\treturn 0;\n\t}\n\n\twhile (*p != '\\0') {\n\t\tif (*p == '.') dots++;\n\t\tif (*p == '.' || isdigit((unsigned char) (*p))) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!partial && dots != 3) {\n\t\treturn 0;\t\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipv6_ip",
          "args": [
            "str"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "138-173",
          "snippet": "int ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\n\nint ipv6_ip(char *host_in) {\n\tchar *p, *host, a[2];\n\tint ncol = 0, nhex = 0;\n\n\tif (host_in[0] == '[')  {\n\t\thost = host_in + 1;\n\t} else {\n\t\thost = host_in;\n\t}\n\n\tif (strstr(host, \"::ffff:\") == host || strstr(host, \"::FFFF:\") == host) {\n\t\treturn dotted_ip(host + strlen(\"::ffff:\"), 0);\n\t}\n\n\ta[1] = '\\0';\n\n\tp = host;\n\twhile (*p != '\\0' && *p != '%' && *p != ']') {\n\t\tif (*p == ':') {\n\t\t\tncol++;\n\t\t} else {\n\t\t\tnhex++;\n\t\t}\n\t\ta[0] = *p;\n\t\tif (strpbrk(a, \":abcdef0123456789\") == a) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (ncol < 2 || ncol > 8 || nhex == 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "q+1"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "rstr",
            "':'"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"skipping invalid client hex id: %s\\n\"",
            "str"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"0x%x\"",
            "&in"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"0x\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "n * sizeof(rfbClientPtr)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nvoid send_client_info(char *str);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic rfbClientPtr *client_match(char *str);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic rfbClientPtr *client_match(char *str) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl, *cl_list;\n\tint i, n, host_warn = 0, hex_warn = 0;\n\n\tn = client_count + 10;\n\tcl_list = (rfbClientPtr *) malloc(n * sizeof(rfbClientPtr));\n\t\n\ti = 0;\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tif (strstr(str, \"0x\") == str) {\n\t\t\tunsigned int in;\n\t\t\tint id;\n\t\t\tif (! cd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sscanf(str, \"0x%x\", &in) != 1) {\n\t\t\t\tif (hex_warn++) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"skipping invalid client hex id: %s\\n\",\n\t\t\t\t    str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid = (unsigned int) in;\n\t\t\tif (cd->uid == id) {\n\t\t\t\tcl_list[i++] = cl;\n\t\t\t}\n\t\t} else {\n\t\t\tint port = -1;\n\t\t\tchar *rstr = strdup(str);\n\t\t\tchar *q = strrchr(rstr, ':');\n\t\t\tif (q) {\n\t\t\t\tport = atoi(q+1);\n\t\t\t\t*q = '\\0';\n\t\t\t\tif (port == 0 && q[1] != '0') {\n\t\t\t\t\tport = -1;\n\t\t\t\t} else if (port < 0) {\n\t\t\t\t\tport = -port;\n\t\t\t\t} else if (port < 200) {\n\t\t\t\t\tport = 5500 + port;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ipv6_ip(str)) {\n\t\t\t\t;\n\t\t\t} else if (! dotted_ip(str, 0)) {\n\t\t\t\tchar *orig = rstr;\n\t\t\t\trstr = host2ip(rstr);\n\t\t\t\tfree(orig);\n\t\t\t\tif (rstr == NULL || *rstr == '\\0') {\n\t\t\t\t\tif (host_warn++) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\trfbLog(\"skipping bad lookup: \\\"%s\\\"\\n\", str);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trfbLog(\"lookup: %s -> %s port=%d\\n\", str, rstr, port);\n\t\t\t}\n\t\t\tif (!strcmp(rstr, cl->host)) {\n\t\t\t\tint ok = 1;\n\t\t\t\tif (port > 0) {\n\t\t\t\t\tif (cd != NULL && cd->client_port > 0) {\n\t\t\t\t\t\tif (cd->client_port != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint cport = get_remote_port(cl->sock);\n\t\t\t\t\t\tif (cport != port) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcl_list[i++] = cl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(rstr);\n\t\t}\n\t\tif (i >= n - 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tcl_list[i] = NULL;\n\n\treturn cl_list;\n}"
  },
  {
    "function_name": "close_all_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "251-265",
    "snippet": "void close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void close_all_clients(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientConnectionGone",
          "args": [
            "cl"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "cl"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_all_clients(void);\n\nvoid close_all_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! screen) {\n\t\treturn;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\trfbCloseClient(cl);\n\t\trfbClientConnectionGone(cl);\n\t}\n\trfbReleaseClientIterator(iter);\n}"
  },
  {
    "function_name": "new_fb_size_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "232-249",
    "snippet": "int new_fb_size_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->useNewFBSize) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int new_fb_size_clients(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\n\nint new_fb_size_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->useNewFBSize) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}"
  },
  {
    "function_name": "list_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "144-229",
    "snippet": "char *list_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *list, tmp[256];\n\tint count = 0;\n\n\tif (!screen) {\n\t\treturn strdup(\"\");\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tclient_set_net(cl);\n\t\tcount++;\n\t}\n\trfbReleaseClientIterator(iter);\n\n\t/*\n\t * each client:\n         * <id>:<ip>:<port>:<user>:<unix>:<hostname>:<input>:<loginview>:<time>,\n\t * 8+1+64+1+5+1+24+1+24+1+256+1+5+1+1+1+10+1\n\t * 123.123.123.123:60000/0x11111111-rw,\n\t * so count+1 * 1000 must cover it.\n\t */\n\tlist = (char *) malloc((count+1)*1000);\n\t\n\tlist[0] = '\\0';\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *tmp_host, *p;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*list != '\\0') {\n\t\t\tstrcat(list, \",\");\n\t\t}\n\t\tsprintf(tmp, \"0x%x:\", cd->uid);\n\t\tstrcat(list, tmp);\n\t\tp = tmp_host = strdup(cl->host);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d:\", cd->client_port);\n\t\tstrcat(list, tmp);\n\t\tif (cd->username[0] == '\\0') {\n\t\t\tchar *s = ident_username(cl);\n\t\t\tif (s) free(s);\n\t\t}\n\t\tif (strstr(cd->username, \"UNIX:\") == cd->username) {\n\t\t\tstrcat(list, cd->username + strlen(\"UNIX:\"));\n\t\t} else {\n\t\t\tstrcat(list, cd->username);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tif (cd->unixname[0] == '\\0') {\n\t\t\tstrcat(list, \"none\");\n\t\t} else {\n\t\t\tstrcat(list, cd->unixname);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tp = tmp_host = strdup(cd->hostname);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tstrcat(list, cd->input);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", cd->login_viewonly);\n\t\tstrcat(list, tmp);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", (int) cd->login_time);\n\t\tstrcat(list, tmp);\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn list;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *list_clients(void);",
      "int new_fb_size_clients(rfbScreenInfoPtr s);",
      "void client_gone(rfbClientPtr client);",
      "void client_gone_chat_helper(rfbClientPtr client);",
      "enum rfbNewClientAction new_client(rfbClientPtr client);",
      "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
      "int accept_client(rfbClientPtr client);",
      "void client_set_net(rfbClientPtr client);",
      "static void free_client_data(rfbClientPtr client);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "tmp"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%d\"",
            "(int) cd->login_time"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\":\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "tmp"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%d\"",
            "cd->login_viewonly"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\":\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "cd->input"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\":\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp_host"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "free_client_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "765-804",
          "snippet": "static void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nstatic void free_client_data(rfbClientPtr client) {\n\tif (! client) {\n\t\treturn;\n\t}\n\tif (client->clientData) {\n\t\tClientData *cd = (ClientData *) client->clientData;\n\t\tif (cd) {\n\t\t\tif (cd->server_ip) {\n\t\t\t\tfree(cd->server_ip);\n\t\t\t\tcd->server_ip = NULL;\n\t\t\t}\n\t\t\tif (cd->hostname) {\n\t\t\t\tfree(cd->hostname);\n\t\t\t\tcd->hostname = NULL;\n\t\t\t}\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t\tcd->username = NULL;\n\t\t\t}\n\t\t\tif (cd->unixname) {\n\t\t\t\tfree(cd->unixname);\n\t\t\t\tcd->unixname = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor) {\n\t\t\t        rfbFreeCursor(cd->cursor);\n\t\t\t        cd->cursor = NULL;\n\t\t\t}\n\t\t\tif (cd->under_cursor_buffer) {\n\t\t\t        free(cd->under_cursor_buffer);\n\t\t\t        cd->under_cursor_buffer = NULL;\n\t\t\t}\n\t\t\tif (cd->cursor_region) {\n\t\t\t\tsraRgnDestroy(cd->cursor_region);\n\t\t\t\tcd->cursor_region = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(client->clientData);\n\t\tclient->clientData = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "tmp_host"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cd->hostname"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\":\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "cd->unixname"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\"none\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\":\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "cd->username"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "cd->username + strlen(\"UNIX:\")"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"UNIX:\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cd->username",
            "\"UNIX:\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ident_username",
          "args": [
            "cl"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ident_username",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "266-411",
          "snippet": "char *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "char *raw2host(char *raw, int len);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "char *ident_username(rfbClientPtr client);",
            "int accept_unix(int s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nchar *raw2host(char *raw, int len);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nchar *ident_username(rfbClientPtr client);\nint accept_unix(int s);\n\nchar *ident_username(rfbClientPtr client) {\n\tClientData *cd = (ClientData *) client->clientData;\n\tchar *str, *newhost, *user = NULL, *newuser = NULL;\n\tint len;\n\n\tif (cd) {\n\t\tuser = cd->username;\n\t}\n\tif (!user || *user == '\\0') {\n\t\tint n, sock, ok = 0;\n\t\tint block = 0;\n\t\tint refused = 0;\n\n\t\t/*\n\t\t * need to check to see if the operation will block for\n\t\t * a long time: a firewall may just ignore our packets.\n\t\t */\n#if LIBVNCSERVER_HAVE_FORK\n\t    {\tpid_t pid, pidw;\n\t\tint rc;\n\t\tif ((pid = fork()) > 0) {\n\t\t\tusleep(100 * 1000);\t/* 0.1 sec for quick success or refusal */\n\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\tif (pidw <= 0) {\n\t\t\t\tusleep(1500 * 1000);\t/* 1.5 sec */\n\t\t\t\tpidw = waitpid(pid, &rc, WNOHANG);\n\t\t\t\tif (pidw <= 0) {\n\t\t\t\t\tint rc2;\n\t\t\t\t\trfbLog(\"ident_username: set block=1 (hung)\\n\");\n\t\t\t\t\tblock = 1;\n\t\t\t\t\tkill(pid, SIGTERM);\n\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\twaitpid(pid, &rc2, WNOHANG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pidw > 0 && !block) {\n\t\t\t\tif (WIFEXITED(rc) && WEXITSTATUS(rc) == 1) {\n\t\t\t\t\trfbLog(\"ident_username: set refused=1 (exit)\\n\");\n\t\t\t\t\trefused = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pid == -1) {\n\t\t\t;\n\t\t} else {\n\t\t\t/* child */\n\t\t\tsignal(SIGHUP,  SIG_DFL);\n\t\t\tsignal(SIGINT,  SIG_DFL);\n\t\t\tsignal(SIGQUIT, SIG_DFL);\n\t\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\t\tif ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\t\texit(1);\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t    }\n#endif\n\t\tif (block || refused) {\n\t\t\t;\n\t\t} else if ((sock = connect_tcp(client->host, 113)) < 0) {\n\t\t\trfbLog(\"ident_username: could not connect to ident: %s:%d\\n\",\n\t\t\t    client->host, 113);\n\t\t} else {\n\t\t\tchar msg[128];\n\t\t\tint ret;\n\t\t\tfd_set rfds;\n\t\t\tstruct timeval tv;\n\t\t\tint rport = get_remote_port(client->sock);\n\t\t\tint lport = get_local_port(client->sock);\n\n\t\t\tsprintf(msg, \"%d, %d\\r\\n\", rport, lport);\n\t\t\tn = write(sock, msg, strlen(msg));\n\n\t\t\tFD_ZERO(&rfds);\n\t\t\tFD_SET(sock, &rfds);\n\t\t\ttv.tv_sec  = 3;\n\t\t\ttv.tv_usec = 0;\n\t\t\tret = select(sock+1, &rfds, NULL, NULL, &tv); \n\n\t\t\tif (ret > 0) {\n\t\t\t\tint i;\n\t\t\t\tchar *q, *p;\n\t\t\t\tfor (i=0; i < (int) sizeof(msg); i++) {\n\t\t\t\t\tmsg[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tusleep(250*1000);\n\t\t\t\tn = read(sock, msg, 127);\n\t\t\t\tclose(sock);\n\t\t\t\tif (n <= 0) goto badreply;\n\n\t\t\t\t/* 32782 , 6000 : USERID : UNIX :runge */\n\t\t\t\tq = strstr(msg, \"USERID\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = strstr(q, \":\");\n\t\t\t\tif (!q) goto badreply;\n\t\t\t\tq++;\n\t\t\t\tq = lblanks(q);\n\t\t\t\tp = q;\n\t\t\t\twhile (*p) {\n\t\t\t\t\tif (*p == '\\r' || *p == '\\n') {\n\t\t\t\t\t\t*p = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tif (strlen(q) > 24) {\n\t\t\t\t\t*(q+24) = '\\0';\n\t\t\t\t}\n\t\t\t\tnewuser = strdup(q);\n\n\t\t\t\tbadreply:\n\t\t\t\tn = 0;\t/* avoid syntax error */\n\t\t\t} else {\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n\t\tif (! ok || !newuser) {\n\t\t\tnewuser = strdup(\"unknown-user\");\n\t\t}\n\t\tif (cd) {\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = newuser;\n\t\t}\n\t\tuser = newuser;\n\t}\n\tif (!strcmp(user, \"unknown-user\") && cd && cd->unixname[0] != '\\0') {\n\t\tuser = cd->unixname;\n\t}\n\tif (unixpw && openssl_last_ip && strstr(\"UNIX:\", user) != user) {\n\t\tnewhost = ip2host(openssl_last_ip);\n\t} else {\n\t\tnewhost = ip2host(client->host);\n\t}\n\tlen = strlen(user) + 1 + strlen(newhost) + 1;\n\tstr = (char *) malloc(len);\n\tsprintf(str, \"%s@%s\", user, newhost);\n\tfree(newhost);\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "tmp"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%d:\"",
            "cd->client_port"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\":\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "tmp_host"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cl->host"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "tmp"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"0x%x:\"",
            "cd->uid"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "list",
            "\",\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(count+1)*1000"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_set_net",
          "args": [
            "cl"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "client_set_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3903-3920",
          "snippet": "void client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "int accept_client(rfbClientPtr client);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nvoid client_set_net(rfbClientPtr client) {\n\tClientData *cd; \n\tif (client == NULL) {\n\t\treturn;\n\t}\n\tcd = (ClientData *) client->clientData;\n\tif (cd == NULL) {\n\t\treturn;\n\t}\n\tif (cd->client_port < 0) {\n\t\tdouble dt = dnow();\n\t\tcd->client_port = get_remote_port(client->sock);\n\t\tcd->server_port = get_local_port(client->sock);\n\t\tcd->server_ip   = get_local_host(client->sock);\n\t\tcd->hostname = ip2host(client->host);\n\t\trfbLog(\"client_set_net: %s  %.4f\\n\", client->host, dnow() - dt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *list_clients(void);\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nint accept_client(rfbClientPtr client);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\n\nchar *list_clients(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tchar *list, tmp[256];\n\tint count = 0;\n\n\tif (!screen) {\n\t\treturn strdup(\"\");\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tclient_set_net(cl);\n\t\tcount++;\n\t}\n\trfbReleaseClientIterator(iter);\n\n\t/*\n\t * each client:\n         * <id>:<ip>:<port>:<user>:<unix>:<hostname>:<input>:<loginview>:<time>,\n\t * 8+1+64+1+5+1+24+1+24+1+256+1+5+1+1+1+10+1\n\t * 123.123.123.123:60000/0x11111111-rw,\n\t * so count+1 * 1000 must cover it.\n\t */\n\tlist = (char *) malloc((count+1)*1000);\n\t\n\tlist[0] = '\\0';\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\t\tchar *tmp_host, *p;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (*list != '\\0') {\n\t\t\tstrcat(list, \",\");\n\t\t}\n\t\tsprintf(tmp, \"0x%x:\", cd->uid);\n\t\tstrcat(list, tmp);\n\t\tp = tmp_host = strdup(cl->host);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d:\", cd->client_port);\n\t\tstrcat(list, tmp);\n\t\tif (cd->username[0] == '\\0') {\n\t\t\tchar *s = ident_username(cl);\n\t\t\tif (s) free(s);\n\t\t}\n\t\tif (strstr(cd->username, \"UNIX:\") == cd->username) {\n\t\t\tstrcat(list, cd->username + strlen(\"UNIX:\"));\n\t\t} else {\n\t\t\tstrcat(list, cd->username);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tif (cd->unixname[0] == '\\0') {\n\t\t\tstrcat(list, \"none\");\n\t\t} else {\n\t\t\tstrcat(list, cd->unixname);\n\t\t}\n\t\tstrcat(list, \":\");\n\t\tp = tmp_host = strdup(cd->hostname);\n\t\twhile (*p) {\n\t\t\tif (*p == ':') *p = '#';\n\t\t\tp++;\n\t\t}\n\t\tstrcat(list, tmp_host);\n\t\tfree(tmp_host);\n\t\tstrcat(list, \":\");\n\t\tstrcat(list, cd->input);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", cd->login_viewonly);\n\t\tstrcat(list, tmp);\n\t\tstrcat(list, \":\");\n\t\tsprintf(tmp, \"%d\", (int) cd->login_time);\n\t\tstrcat(list, tmp);\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn list;\n}"
  },
  {
    "function_name": "all_clients_initialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
    "lines": "122-142",
    "snippet": "int all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"xrandr.h\"",
      "#include \"pointer.h\"",
      "#include \"userinput.h\"",
      "#include \"macosxCG.h\"",
      "#include \"macosx.h\"",
      "#include \"win_utils.h\"",
      "#include \"xevents.h\"",
      "#include \"xwrappers.h\"",
      "#include \"sslhelper.h\"",
      "#include \"sslcmds.h\"",
      "#include \"scan.h\"",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"screen.h\"",
      "#include \"rates.h\"",
      "#include \"solid.h\"",
      "#include \"gui.h\"",
      "#include \"cleanup.h\"",
      "#include \"keyboard.h\"",
      "#include \"remote.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int all_clients_initialized(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint all_clients_initialized(void);\n\nint all_clients_initialized(void) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint ok = 1;\n\n\tif (! screen) {\n\t\treturn ok;\n\t}\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->state != RFB_NORMAL) {\n\t\t\tok = 0;\n\t\t} else {\n\t\t\tclient_normal_count++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\treturn ok;\n}"
  }
]