[
  {
    "function_name": "macosxCG_keysym_inject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "963-985",
    "snippet": "void macosxCG_keysym_inject(int down, unsigned int keysym) {\n\tCGKeyCode keyCode = keyTable[(unsigned short)keysym];\n\tCGCharCode keyChar = 0;\n#if 0\n\tint pressModsForKeys = FALSE;\n\tUInt32 modsForKey = keyTableMods[keysym] << 8;\n#endif\n\n\tinit_key_table();\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject(down=%d, keysym=%d)\\n\", down, (int) keysym);\n\n\tif (keysym < 0xFF && macosx_us_kbd) {\n\t\tkeyChar = (CGCharCode) keysym;\n\t\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject keyChar=>%d\\n\", (int) keyChar);\n\t}\n\tif (keyCode == 0xFFFF) {\n\t\treturn;\n\t}\n\tmacosxCGP_undim();\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGPostKeyboardEvent_wr",
          "args": [
            "keyChar",
            "keyCode",
            "down"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "CGPostKeyboardEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "924-952",
          "snippet": "void CGPostKeyboardEvent_wr(CGCharCode keyChar, CGKeyCode keyCode, int down) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\", keyChar, keyCode, down);\n\t\tCGPostKeyboardEvent(keyChar, keyCode, down);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateKeyboardEvent(NULL, keyCode, down);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\", keyCode, down);\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid CGPostKeyboardEvent_wr(CGCharCode keyChar, CGKeyCode keyCode, int down) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\", keyChar, keyCode, down);\n\t\tCGPostKeyboardEvent(keyChar, keyCode, down);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateKeyboardEvent(NULL, keyCode, down);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\", keyCode, down);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGP_undim",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGP_undim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGP.c",
          "lines": "171-200",
          "snippet": "int macosxCGP_undim(void) {\n\tif (! initialized) {\n\t\treturn 0;\n\t}\n\tif (! macosx_nodimming) {\n\t\tif (! macosxCGP_save_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToDim, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (! macosx_nosleep) {\n\t\tif (! macosxCGP_save_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToSleep, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <IOKit/pwr_mgt/IOPM.h>",
            "#include <IOKit/pwr_mgt/IOPMLib.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <IOKit/pwr_mgt/IOPM.h>\n#include <IOKit/pwr_mgt/IOPMLib.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGP_undim(void) {\n\tif (! initialized) {\n\t\treturn 0;\n\t}\n\tif (! macosx_nodimming) {\n\t\tif (! macosxCGP_save_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToDim, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (! macosx_nosleep) {\n\t\tif (! macosxCGP_save_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToSleep, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"macosxCG_keysym_inject keyChar=>%d\\n\"",
            "(int) keyChar"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"macosxCG_keysym_inject(down=%d, keysym=%d)\\n\"",
            "down",
            "(int) keysym"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_key_table",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_init_key_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "897-917",
          "snippet": "void macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [
            "#define keyTableSize 0xFFFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define keyTableSize 0xFFFF\n\nvoid macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_keysym_inject(int down, unsigned int keysym) {\n\tCGKeyCode keyCode = keyTable[(unsigned short)keysym];\n\tCGCharCode keyChar = 0;\n#if 0\n\tint pressModsForKeys = FALSE;\n\tUInt32 modsForKey = keyTableMods[keysym] << 8;\n#endif\n\n\tinit_key_table();\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject(down=%d, keysym=%d)\\n\", down, (int) keysym);\n\n\tif (keysym < 0xFF && macosx_us_kbd) {\n\t\tkeyChar = (CGCharCode) keysym;\n\t\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keysym_inject keyChar=>%d\\n\", (int) keyChar);\n\t}\n\tif (keyCode == 0xFFFF) {\n\t\treturn;\n\t}\n\tmacosxCGP_undim();\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}"
  },
  {
    "function_name": "macosxCG_keycode_inject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "954-961",
    "snippet": "void macosxCG_keycode_inject(int down, int keycode) {\n\tCGKeyCode keyCode = (CGKeyCode) keycode;\n\tCGCharCode keyChar = 0;\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keycode_inject(down=%d, keycode=%d)\\n\", down, keycode);\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGPostKeyboardEvent_wr",
          "args": [
            "keyChar",
            "keyCode",
            "down"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "CGPostKeyboardEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "924-952",
          "snippet": "void CGPostKeyboardEvent_wr(CGCharCode keyChar, CGKeyCode keyCode, int down) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\", keyChar, keyCode, down);\n\t\tCGPostKeyboardEvent(keyChar, keyCode, down);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateKeyboardEvent(NULL, keyCode, down);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\", keyCode, down);\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid CGPostKeyboardEvent_wr(CGCharCode keyChar, CGKeyCode keyCode, int down) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\", keyChar, keyCode, down);\n\t\tCGPostKeyboardEvent(keyChar, keyCode, down);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateKeyboardEvent(NULL, keyCode, down);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\", keyCode, down);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"macosxCG_keycode_inject(down=%d, keycode=%d)\\n\"",
            "down",
            "keycode"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_keycode_inject(int down, int keycode) {\n\tCGKeyCode keyCode = (CGKeyCode) keycode;\n\tCGCharCode keyChar = 0;\n\n\tif (debug_keyboard) fprintf(stderr, \"macosxCG_keycode_inject(down=%d, keycode=%d)\\n\", down, keycode);\n\n\tCGPostKeyboardEvent_wr(keyChar, keyCode, down);\n}"
  },
  {
    "function_name": "CGPostKeyboardEvent_wr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "924-952",
    "snippet": "void CGPostKeyboardEvent_wr(CGCharCode keyChar, CGKeyCode keyCode, int down) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\", keyChar, keyCode, down);\n\t\tCGPostKeyboardEvent(keyChar, keyCode, down);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateKeyboardEvent(NULL, keyCode, down);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\", keyCode, down);\n\t}\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\"",
            "keyCode",
            "down"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateKeyboardEvent",
          "args": [
            "NULL",
            "keyCode",
            "down"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGPostKeyboardEvent",
          "args": [
            "keyChar",
            "keyCode",
            "down"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "CGPostKeyboardEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "924-952",
          "snippet": "void CGPostKeyboardEvent_wr(CGCharCode keyChar, CGKeyCode keyCode, int down) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\", keyChar, keyCode, down);\n\t\tCGPostKeyboardEvent(keyChar, keyCode, down);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateKeyboardEvent(NULL, keyCode, down);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\", keyCode, down);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\"",
            "keyChar",
            "keyCode",
            "down"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid CGPostKeyboardEvent_wr(CGCharCode keyChar, CGKeyCode keyCode, int down) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGPostKeyboardEvent(keyChar=%d, keyCode=%d, down=%d)\\n\", keyChar, keyCode, down);\n\t\tCGPostKeyboardEvent(keyChar, keyCode, down);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEKEYBOARDEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateKeyboardEvent(NULL, keyCode, down);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_keyboard) fprintf(stderr, \"CGEventCreateKeyboardEvent(NULL, keyCode=%d, down=%d)\\n\", keyCode, down);\n\t}\n}"
  },
  {
    "function_name": "macosxCG_init_key_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "897-917",
    "snippet": "void macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [
      "#define keyTableSize 0xFFFF"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\n#define keyTableSize 0xFFFF\n\nvoid macosxCG_init_key_table(void) {\n\tstatic int init = 0;\n\tint i;\n\tif (init) {\n\t\treturn;\n\t}\n\tinit = 1;\n\n\tfor (i=0; i < keyTableSize; i++) {\n\t\tkeyTable[i] = 0xFFFF;\n\t\tkeyTableMods[i] = 0;\n\t}\n\tfor (i=0; i< (int) (sizeof(USKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = USKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) USKeyCodes[i+1];\n\t}\n\tfor (i=0; i< (int) (sizeof(SpecialKeyCodes) / sizeof(int)); i += 2) {\n\t\tint j = SpecialKeyCodes[i];\n\t\tkeyTable[(unsigned short) j] = (CGKeyCode) SpecialKeyCodes[i+1];\n\t}\n}"
  },
  {
    "function_name": "macosxCG_pointer_inject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "671-715",
    "snippet": "void macosxCG_pointer_inject(int mask, int x, int y) {\n\tint swap23 = macosx_swap23;\n\tint s1 = 0, s2 = 1, s3 = 2, s4 = 3, s5 = 4;\n\tCGPoint loc;\n\tint wheel_distance = macosx_mouse_wheel_speed;\n\tstatic int cnt = 0;\n\tstatic int first = 1, prev1 = 0, prev2 = 0, prev3 = 0; \n\tint curr1, curr2, curr3;\n\n\tif (swap23) {\n\t\ts2 = 2;\n\t\ts3 = 1;\n\t}\n\n\tloc.x = x + off_x + coff_x;\n\tloc.y = y + off_y + coff_y;\n\n\tif ((cnt++ % 10) == 0) {\n\t\tmacosxCGP_undim();\n\t}\n\n\tif ((mask & (1 << s4))) {\n\t\tCGPostScrollWheelEvent_wr(1,  wheel_distance);\n\t}\n\tif ((mask & (1 << s5))) {\n\t\tCGPostScrollWheelEvent_wr(1, -wheel_distance);\n\t}\n\n\tcurr1 = (mask & (1 << s1)) ? TRUE : FALSE;\n\tcurr2 = (mask & (1 << s2)) ? TRUE : FALSE;\n\tcurr3 = (mask & (1 << s3)) ? TRUE : FALSE;\n\n\tif (first) {\n\t\tprev1 = curr1;\n\t\tprev2 = curr2;\n\t\tprev3 = curr3;\n\t\tfirst = 0;\n\t}\n\n\tCGPostMouseEvent_wr(loc, TRUE, 3, curr1, curr2, curr3, prev1, prev2, prev3);\n\n\tprev1 = curr1;\n\tprev2 = curr2;\n\tprev3 = curr3;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGPostMouseEvent_wr",
          "args": [
            "loc",
            "TRUE",
            "3",
            "curr1",
            "curr2",
            "curr3",
            "prev1",
            "prev2",
            "prev3"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "CGPostMouseEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "580-669",
          "snippet": "static void CGPostMouseEvent_wr(CGPoint loc, int update, int count, int d1, int d2, int d3, int p1, int p2, int p3) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostMouseEvent()\\n\");\n\t\tCGPostMouseEvent(loc, update, count, d1, d2, d3);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEMOUSEEVENT\n\t\tCGEventRef event;\n\t\tstatic int xp = -1, yp;\n\n\t\tif (xp == -1) {\n\t\t\txp = loc.x;\n\t\t\typ = loc.y;\n\t\t}\n\t\tif (xp != loc.x || yp != loc.y) {\n\t\t\tint moved = 0;\n\t\t\tif (p1 && p1 == d1) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p3 && p3 == d3) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventOtherMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p2 && p2 == d2) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventRightMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!moved) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventMouseMoved, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txp = loc.x;\n\t\typ = loc.y;\n\t\tif (p1 != d1) {\n\t\t\tCGEventType type = (!p1 && d1) ? kCGEventLeftMouseDown : kCGEventLeftMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p3 != d3) {\n\t\t\tCGEventType type = (!p3 && d3) ? kCGEventOtherMouseDown : kCGEventOtherMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, kCGMouseButtonCenter);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p2 != d2) {\n\t\t\tCGEventType type = (!p2 && d2) ? kCGEventRightMouseDown : kCGEventRightMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateMouseEvent()\\n\");\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic void CGPostMouseEvent_wr(CGPoint loc, int update, int count, int d1, int d2, int d3, int p1, int p2, int p3) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostMouseEvent()\\n\");\n\t\tCGPostMouseEvent(loc, update, count, d1, d2, d3);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEMOUSEEVENT\n\t\tCGEventRef event;\n\t\tstatic int xp = -1, yp;\n\n\t\tif (xp == -1) {\n\t\t\txp = loc.x;\n\t\t\typ = loc.y;\n\t\t}\n\t\tif (xp != loc.x || yp != loc.y) {\n\t\t\tint moved = 0;\n\t\t\tif (p1 && p1 == d1) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p3 && p3 == d3) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventOtherMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p2 && p2 == d2) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventRightMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!moved) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventMouseMoved, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txp = loc.x;\n\t\typ = loc.y;\n\t\tif (p1 != d1) {\n\t\t\tCGEventType type = (!p1 && d1) ? kCGEventLeftMouseDown : kCGEventLeftMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p3 != d3) {\n\t\t\tCGEventType type = (!p3 && d3) ? kCGEventOtherMouseDown : kCGEventOtherMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, kCGMouseButtonCenter);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p2 != d2) {\n\t\t\tCGEventType type = (!p2 && d2) ? kCGEventRightMouseDown : kCGEventRightMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateMouseEvent()\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CGPostScrollWheelEvent_wr",
          "args": [
            "1",
            "-wheel_distance"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "CGPostScrollWheelEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "550-578",
          "snippet": "static void CGPostScrollWheelEvent_wr(CGWheelCount wheel_count, int wheel_distance) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostScrollWheelEvent()\\n\");\n\t\tCGPostScrollWheelEvent(wheel_count, wheel_distance);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.5 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateScrollWheelEvent(NULL, kCGScrollEventUnitLine, wheel_count, wheel_distance);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateScrollWheelEvent()\\n\");\n\t}\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic void CGPostScrollWheelEvent_wr(CGWheelCount wheel_count, int wheel_distance) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostScrollWheelEvent()\\n\");\n\t\tCGPostScrollWheelEvent(wheel_count, wheel_distance);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.5 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateScrollWheelEvent(NULL, kCGScrollEventUnitLine, wheel_count, wheel_distance);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateScrollWheelEvent()\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGP_undim",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGP_undim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGP.c",
          "lines": "171-200",
          "snippet": "int macosxCGP_undim(void) {\n\tif (! initialized) {\n\t\treturn 0;\n\t}\n\tif (! macosx_nodimming) {\n\t\tif (! macosxCGP_save_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToDim, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (! macosx_nosleep) {\n\t\tif (! macosxCGP_save_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToSleep, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <IOKit/pwr_mgt/IOPM.h>",
            "#include <IOKit/pwr_mgt/IOPMLib.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <IOKit/pwr_mgt/IOPM.h>\n#include <IOKit/pwr_mgt/IOPMLib.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGP_undim(void) {\n\tif (! initialized) {\n\t\treturn 0;\n\t}\n\tif (! macosx_nodimming) {\n\t\tif (! macosxCGP_save_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToDim, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (! macosx_nosleep) {\n\t\tif (! macosxCGP_save_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToSleep, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (! macosxCGP_restore_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_pointer_inject(int mask, int x, int y) {\n\tint swap23 = macosx_swap23;\n\tint s1 = 0, s2 = 1, s3 = 2, s4 = 3, s5 = 4;\n\tCGPoint loc;\n\tint wheel_distance = macosx_mouse_wheel_speed;\n\tstatic int cnt = 0;\n\tstatic int first = 1, prev1 = 0, prev2 = 0, prev3 = 0; \n\tint curr1, curr2, curr3;\n\n\tif (swap23) {\n\t\ts2 = 2;\n\t\ts3 = 1;\n\t}\n\n\tloc.x = x + off_x + coff_x;\n\tloc.y = y + off_y + coff_y;\n\n\tif ((cnt++ % 10) == 0) {\n\t\tmacosxCGP_undim();\n\t}\n\n\tif ((mask & (1 << s4))) {\n\t\tCGPostScrollWheelEvent_wr(1,  wheel_distance);\n\t}\n\tif ((mask & (1 << s5))) {\n\t\tCGPostScrollWheelEvent_wr(1, -wheel_distance);\n\t}\n\n\tcurr1 = (mask & (1 << s1)) ? TRUE : FALSE;\n\tcurr2 = (mask & (1 << s2)) ? TRUE : FALSE;\n\tcurr3 = (mask & (1 << s3)) ? TRUE : FALSE;\n\n\tif (first) {\n\t\tprev1 = curr1;\n\t\tprev2 = curr2;\n\t\tprev3 = curr3;\n\t\tfirst = 0;\n\t}\n\n\tCGPostMouseEvent_wr(loc, TRUE, 3, curr1, curr2, curr3, prev1, prev2, prev3);\n\n\tprev1 = curr1;\n\tprev2 = curr2;\n\tprev3 = curr3;\n}"
  },
  {
    "function_name": "CGPostMouseEvent_wr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "580-669",
    "snippet": "static void CGPostMouseEvent_wr(CGPoint loc, int update, int count, int d1, int d2, int d3, int p1, int p2, int p3) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostMouseEvent()\\n\");\n\t\tCGPostMouseEvent(loc, update, count, d1, d2, d3);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEMOUSEEVENT\n\t\tCGEventRef event;\n\t\tstatic int xp = -1, yp;\n\n\t\tif (xp == -1) {\n\t\t\txp = loc.x;\n\t\t\typ = loc.y;\n\t\t}\n\t\tif (xp != loc.x || yp != loc.y) {\n\t\t\tint moved = 0;\n\t\t\tif (p1 && p1 == d1) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p3 && p3 == d3) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventOtherMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p2 && p2 == d2) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventRightMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!moved) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventMouseMoved, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txp = loc.x;\n\t\typ = loc.y;\n\t\tif (p1 != d1) {\n\t\t\tCGEventType type = (!p1 && d1) ? kCGEventLeftMouseDown : kCGEventLeftMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p3 != d3) {\n\t\t\tCGEventType type = (!p3 && d3) ? kCGEventOtherMouseDown : kCGEventOtherMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, kCGMouseButtonCenter);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p2 != d2) {\n\t\t\tCGEventType type = (!p2 && d2) ? kCGEventRightMouseDown : kCGEventRightMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateMouseEvent()\\n\");\n\t}\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CGEventCreateMouseEvent()\\n\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateMouseEvent",
          "args": [
            "NULL",
            "type",
            "loc",
            "0"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateMouseEvent",
          "args": [
            "NULL",
            "type",
            "loc",
            "kCGMouseButtonCenter"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateMouseEvent",
          "args": [
            "NULL",
            "type",
            "loc",
            "0"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateMouseEvent",
          "args": [
            "NULL",
            "kCGEventMouseMoved",
            "loc",
            "0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateMouseEvent",
          "args": [
            "NULL",
            "kCGEventRightMouseDragged",
            "loc",
            "0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateMouseEvent",
          "args": [
            "NULL",
            "kCGEventOtherMouseDragged",
            "loc",
            "0"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateMouseEvent",
          "args": [
            "NULL",
            "kCGEventLeftMouseDragged",
            "loc",
            "0"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGPostMouseEvent",
          "args": [
            "loc",
            "update",
            "count",
            "d1",
            "d2",
            "d3"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CGPostMouseEvent()\\n\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic void CGPostMouseEvent_wr(CGPoint loc, int update, int count, int d1, int d2, int d3, int p1, int p2, int p3) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostMouseEvent()\\n\");\n\t\tCGPostMouseEvent(loc, update, count, d1, d2, d3);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.4 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATEMOUSEEVENT\n\t\tCGEventRef event;\n\t\tstatic int xp = -1, yp;\n\n\t\tif (xp == -1) {\n\t\t\txp = loc.x;\n\t\t\typ = loc.y;\n\t\t}\n\t\tif (xp != loc.x || yp != loc.y) {\n\t\t\tint moved = 0;\n\t\t\tif (p1 && p1 == d1) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p3 && p3 == d3) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventOtherMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p2 && p2 == d2) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventRightMouseDragged, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tmoved = 1;\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!moved) {\n\t\t\t\tevent = CGEventCreateMouseEvent(NULL, kCGEventMouseMoved, loc, 0);\n\t\t\t\tif (event != NULL) {\n\t\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\t\tCFRelease(event);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txp = loc.x;\n\t\typ = loc.y;\n\t\tif (p1 != d1) {\n\t\t\tCGEventType type = (!p1 && d1) ? kCGEventLeftMouseDown : kCGEventLeftMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p3 != d3) {\n\t\t\tCGEventType type = (!p3 && d3) ? kCGEventOtherMouseDown : kCGEventOtherMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, kCGMouseButtonCenter);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n\t\tif (p2 != d2) {\n\t\t\tCGEventType type = (!p2 && d2) ? kCGEventRightMouseDown : kCGEventRightMouseUp;\n\t\t\tevent = CGEventCreateMouseEvent(NULL, type, loc, 0);\n\t\t\tif (event != NULL) {\n\t\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\t\tCFRelease(event);\n\t\t\t}\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateMouseEvent()\\n\");\n\t}\n}"
  },
  {
    "function_name": "CGPostScrollWheelEvent_wr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "550-578",
    "snippet": "static void CGPostScrollWheelEvent_wr(CGWheelCount wheel_count, int wheel_distance) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostScrollWheelEvent()\\n\");\n\t\tCGPostScrollWheelEvent(wheel_count, wheel_distance);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.5 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateScrollWheelEvent(NULL, kCGScrollEventUnitLine, wheel_count, wheel_distance);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateScrollWheelEvent()\\n\");\n\t}\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CGEventCreateScrollWheelEvent()\\n\""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFRelease",
          "args": [
            "event"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventPost",
          "args": [
            "kCGHIDEventTap",
            "event"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGEventCreateScrollWheelEvent",
          "args": [
            "NULL",
            "kCGScrollEventUnitLine",
            "wheel_count",
            "wheel_distance"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGPostScrollWheelEvent",
          "args": [
            "wheel_count",
            "wheel_distance"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "CGPostScrollWheelEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "550-578",
          "snippet": "static void CGPostScrollWheelEvent_wr(CGWheelCount wheel_count, int wheel_distance) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostScrollWheelEvent()\\n\");\n\t\tCGPostScrollWheelEvent(wheel_count, wheel_distance);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.5 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateScrollWheelEvent(NULL, kCGScrollEventUnitLine, wheel_count, wheel_distance);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateScrollWheelEvent()\\n\");\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CGPostScrollWheelEvent()\\n\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic void CGPostScrollWheelEvent_wr(CGWheelCount wheel_count, int wheel_distance) {\n\tstatic int post_mode = -1, mcnt = 0;\n\n#if !X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS && !X11VNC_MACOSX_NO_DEPRECATED\n\tif (post_mode < 0) {\n\t\tpost_mode = 1;\n\t\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\t\tpost_mode = 0;\n\t\t}\n\t}\n\t\n\tif (post_mode) {\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGPostScrollWheelEvent()\\n\");\n\t\tCGPostScrollWheelEvent(wheel_count, wheel_distance);\n\t} else\n#endif\n\t{\n\t\t/* XXX 10.5 and later */\n#ifndef X11VNC_MACOSX_NO_CGEVENTCREATESCROLLWHEELEVENT\n\t\tCGEventRef event;\n\t\tevent = CGEventCreateScrollWheelEvent(NULL, kCGScrollEventUnitLine, wheel_count, wheel_distance);\n\t\tif (event != NULL) {\n\t\t\tCGEventPost(kCGHIDEventTap, event);\n\t\t\tCFRelease(event);\n\t\t}\n#endif\n\t\tif (mcnt++ < 10 || debug_pointer) fprintf(stderr, \"CGEventCreateScrollWheelEvent()\\n\");\n\t}\n}"
  },
  {
    "function_name": "macosxCG_get_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "462-542",
    "snippet": "int macosxCG_get_cursor(void) {\n\tint last_idx = (int) get_cursor_serial(1);\n\tint which = 1;\n\tCGError err;\n\tint datasize, row_bytes, cdepth, comps, bpcomp;\n\tCGRect rect;\n\tCGPoint hot;\n\tunsigned char *data;\n\tint cursor_seed;\n\tstatic int last_cursor_seed = -1;\n\tstatic time_t last_fetch = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_idx) {\n\t\twhich = last_idx;\n\t}\n\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn which;\n\t\t}\n\t}\n\n\t/* XXX all of these interfaces are undocumented. */\n\n\tcursor_seed = CGSCurrentCursorSeed();\n\tif (last_idx && cursor_seed == last_cursor_seed) {\n\t\tif (now < last_fetch + 2) {\n\t\t\treturn which;\n\t\t}\n\t}\n\tlast_cursor_seed = cursor_seed;\n\tlast_fetch = now;\n\n\tif (CGSGetGlobalCursorDataSize(conn, &datasize) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorDataSize error\\n\");\n\t\treturn which;\n\t}\n\n\tdata = (unsigned char*) malloc(datasize);\n\n\terr = CGSGetGlobalCursorData(conn, data, &datasize, &row_bytes,\n\t    &rect, &hot, &cdepth, &comps, &bpcomp);\n#if 0\n\tfprintf(stderr, \"datasize: %d row_bytes: %d cdepth: %d comps: %d bpcomp: %d w: %d h: %d\\n\",\n\t  datasize, row_bytes, cdepth, comps, bpcomp, (int) rect.size.width, (int) rect.size.height);\n#endif\n\tif (err != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorData error\\n\");\n\t\treturn which;\n\t}\n\n\tif (cdepth == 24) {\n\t\tcdepth = 32;\n\t}\n\n\tif (sizeof(long) == 8 && comps * bpcomp <= 32) {\n\t\t/* pad it out to unsigned long array size (like xfixes) */\n\t\tint i;\n\t\tunsigned char *dsave;\n\t\tunsigned char *data64 = (unsigned char*) malloc(2 *datasize);\n\t\tunsigned int  *uI = (unsigned int  *) data;\n\t\tunsigned long *uL = (unsigned long *) data64;\n\t\tfor (i=0; i < datasize/4; i++) {\n\t\t\tuL[i] = uI[i];\n\t\t}\n\t\tdsave = data;\n\t\tdata = data64;\n\t\tfree(dsave);\n\t}\n\n\twhich = store_cursor(cursor_seed, (unsigned long*) data,\n\t    (int) rect.size.width, (int) rect.size.height, cdepth, (int) hot.x, (int) hot.y);\n\n\tfree(data);\n\treturn(which);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_cursor",
          "args": [
            "cursor_seed",
            "(unsigned long*) data",
            "(int) rect.size.width",
            "(int) rect.size.height",
            "cdepth",
            "(int) hot.x",
            "(int) hot.y"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "store_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1353-1450",
          "snippet": "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CURS_DYN_MAX CURS_DYN16",
            "#define CURS_DYN_MIN CURS_DYN1"
          ],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];",
            "static unsigned long last_cursor = 0;",
            "static int last_index = 0;",
            "static time_t curs_times[CURS_MAX];",
            "static unsigned long curs_index[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_DYN_MAX CURS_DYN16\n#define CURS_DYN_MIN CURS_DYN1\n\nint set_cursor(int x, int y, int which);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\nstatic time_t curs_times[CURS_MAX];\nstatic unsigned long curs_index[CURS_MAX];\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2 *datasize"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"CGSGetGlobalCursorData error\\n\""
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"datasize: %d row_bytes: %d cdepth: %d comps: %d bpcomp: %d w: %d h: %d\\n\"",
            "datasize",
            "row_bytes",
            "cdepth",
            "comps",
            "bpcomp",
            "(int) rect.size.width",
            "(int) rect.size.height"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSGetGlobalCursorData",
          "args": [
            "conn",
            "data",
            "&datasize",
            "&row_bytes",
            "&rect",
            "&hot",
            "&cdepth",
            "&comps",
            "&bpcomp"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "datasize"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSGetGlobalCursorDataSize",
          "args": [
            "conn",
            "&datasize"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSCurrentCursorSeed",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CGSNewConnection",
          "args": [
            "NULL",
            "&conn"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cursor_serial",
          "args": [
            "1"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "get_cursor_serial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1245-1253",
          "snippet": "unsigned long get_cursor_serial(int mode) {\n\tif (mode == 0) {\n\t\treturn last_cursor;\n\t} else if (mode == 1) {\n\t\treturn (unsigned long) last_index;\n\t} else {\n\t\treturn (unsigned long) last_index;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long get_cursor_serial(int mode);",
            "static unsigned long last_cursor = 0;",
            "static int last_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nunsigned long get_cursor_serial(int mode);\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\n\nunsigned long get_cursor_serial(int mode) {\n\tif (mode == 0) {\n\t\treturn last_cursor;\n\t} else if (mode == 1) {\n\t\treturn (unsigned long) last_index;\n\t} else {\n\t\treturn (unsigned long) last_index;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_get_cursor(void) {\n\tint last_idx = (int) get_cursor_serial(1);\n\tint which = 1;\n\tCGError err;\n\tint datasize, row_bytes, cdepth, comps, bpcomp;\n\tCGRect rect;\n\tCGPoint hot;\n\tunsigned char *data;\n\tint cursor_seed;\n\tstatic int last_cursor_seed = -1;\n\tstatic time_t last_fetch = 0;\n\ttime_t now = time(NULL);\n\n\tif (last_idx) {\n\t\twhich = last_idx;\n\t}\n\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn which;\n\t\t}\n\t}\n\n\t/* XXX all of these interfaces are undocumented. */\n\n\tcursor_seed = CGSCurrentCursorSeed();\n\tif (last_idx && cursor_seed == last_cursor_seed) {\n\t\tif (now < last_fetch + 2) {\n\t\t\treturn which;\n\t\t}\n\t}\n\tlast_cursor_seed = cursor_seed;\n\tlast_fetch = now;\n\n\tif (CGSGetGlobalCursorDataSize(conn, &datasize) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorDataSize error\\n\");\n\t\treturn which;\n\t}\n\n\tdata = (unsigned char*) malloc(datasize);\n\n\terr = CGSGetGlobalCursorData(conn, data, &datasize, &row_bytes,\n\t    &rect, &hot, &cdepth, &comps, &bpcomp);\n#if 0\n\tfprintf(stderr, \"datasize: %d row_bytes: %d cdepth: %d comps: %d bpcomp: %d w: %d h: %d\\n\",\n\t  datasize, row_bytes, cdepth, comps, bpcomp, (int) rect.size.width, (int) rect.size.height);\n#endif\n\tif (err != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetGlobalCursorData error\\n\");\n\t\treturn which;\n\t}\n\n\tif (cdepth == 24) {\n\t\tcdepth = 32;\n\t}\n\n\tif (sizeof(long) == 8 && comps * bpcomp <= 32) {\n\t\t/* pad it out to unsigned long array size (like xfixes) */\n\t\tint i;\n\t\tunsigned char *dsave;\n\t\tunsigned char *data64 = (unsigned char*) malloc(2 *datasize);\n\t\tunsigned int  *uI = (unsigned int  *) data;\n\t\tunsigned long *uL = (unsigned long *) data64;\n\t\tfor (i=0; i < datasize/4; i++) {\n\t\t\tuL[i] = uI[i];\n\t\t}\n\t\tdsave = data;\n\t\tdata = data64;\n\t\tfree(dsave);\n\t}\n\n\twhich = store_cursor(cursor_seed, (unsigned long*) data,\n\t    (int) rect.size.width, (int) rect.size.height, cdepth, (int) hot.x, (int) hot.y);\n\n\tfree(data);\n\treturn(which);\n}"
  },
  {
    "function_name": "macosxCG_get_cursor_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "452-457",
    "snippet": "int macosxCG_get_cursor_pos(int *x, int *y) {\n\tCGPoint pos = current_cursor_pos();\n\t*x = pos.x;\n\t*y = pos.y;\n\treturn 1;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_cursor_pos",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "current_cursor_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "415-450",
          "snippet": "static CGPoint current_cursor_pos(void) {\n\tCGPoint pos;\n\tpos.x = 0;\n\tpos.y = 0;\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (CGSGetCurrentCursorLocation(conn, &pos) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetCurrentCursorLocation error\\n\");\n\t}\n\n\tdisplay_button_mask = GetCurrentButtonState();\n#if 0\n/* not used yet */\n\tdisplay_mod_mask = GetCurrentKeyModifiers();\n#endif\n\n\tif (last_local_button_mask != display_button_mask) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t} else if (pos.x != last_local_x || pos.y != last_local_y) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t}\n\tlast_local_button_mask = display_button_mask;\n\tlast_local_mod_mask = display_mod_mask;\n\tlast_local_x = pos.x;\n\tlast_local_y = pos.y;\n\n\treturn pos;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic CGPoint current_cursor_pos(void) {\n\tCGPoint pos;\n\tpos.x = 0;\n\tpos.y = 0;\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (CGSGetCurrentCursorLocation(conn, &pos) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetCurrentCursorLocation error\\n\");\n\t}\n\n\tdisplay_button_mask = GetCurrentButtonState();\n#if 0\n/* not used yet */\n\tdisplay_mod_mask = GetCurrentKeyModifiers();\n#endif\n\n\tif (last_local_button_mask != display_button_mask) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t} else if (pos.x != last_local_x || pos.y != last_local_y) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t}\n\tlast_local_button_mask = display_button_mask;\n\tlast_local_mod_mask = display_mod_mask;\n\tlast_local_x = pos.x;\n\tlast_local_y = pos.y;\n\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_get_cursor_pos(int *x, int *y) {\n\tCGPoint pos = current_cursor_pos();\n\t*x = pos.x;\n\t*y = pos.y;\n\treturn 1;\n}"
  },
  {
    "function_name": "current_cursor_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "415-450",
    "snippet": "static CGPoint current_cursor_pos(void) {\n\tCGPoint pos;\n\tpos.x = 0;\n\tpos.y = 0;\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (CGSGetCurrentCursorLocation(conn, &pos) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetCurrentCursorLocation error\\n\");\n\t}\n\n\tdisplay_button_mask = GetCurrentButtonState();\n#if 0\n/* not used yet */\n\tdisplay_mod_mask = GetCurrentKeyModifiers();\n#endif\n\n\tif (last_local_button_mask != display_button_mask) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t} else if (pos.x != last_local_x || pos.y != last_local_y) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t}\n\tlast_local_button_mask = display_button_mask;\n\tlast_local_mod_mask = display_mod_mask;\n\tlast_local_x = pos.x;\n\tlast_local_y = pos.y;\n\n\treturn pos;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentKeyModifiers",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentButtonState",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"CGSGetCurrentCursorLocation error\\n\""
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CGSGetCurrentCursorLocation",
          "args": [
            "conn",
            "&pos"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CGSNewConnection",
          "args": [
            "NULL",
            "&conn"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic CGPoint current_cursor_pos(void) {\n\tCGPoint pos;\n\tpos.x = 0;\n\tpos.y = 0;\n\tif (! conn) {\n\t\tif (CGSNewConnection(NULL, &conn) != kCGErrorSuccess) {\n\t\t\tmacosx_log(\"CGSNewConnection error.\\n\");\n\t\t\tif (!dpy_x || !dpy_y || !wdpy_x || !wdpy_y) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (CGSGetCurrentCursorLocation(conn, &pos) != kCGErrorSuccess) {\n\t\tmacosx_log(\"CGSGetCurrentCursorLocation error\\n\");\n\t}\n\n\tdisplay_button_mask = GetCurrentButtonState();\n#if 0\n/* not used yet */\n\tdisplay_mod_mask = GetCurrentKeyModifiers();\n#endif\n\n\tif (last_local_button_mask != display_button_mask) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t} else if (pos.x != last_local_x || pos.y != last_local_y) {\n\t\tgot_local_pointer_input++;\n\t\tlast_local_input = time(NULL);\n\t}\n\tlast_local_button_mask = display_button_mask;\n\tlast_local_mod_mask = display_mod_mask;\n\tlast_local_x = pos.x;\n\tlast_local_y = pos.y;\n\n\treturn pos;\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayBytesPerRow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "385-390",
    "snippet": "int macosxCG_CGDisplayBytesPerRow(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width() * macosx_opengl_get_bpp()/8;\n\t}\n\treturn (int) CGDisplayBytesPerRow(displayID);;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGDisplayBytesPerRow",
          "args": [
            "displayID"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_bpp",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "70-72",
          "snippet": "int macosx_opengl_get_bpp(void) {\n\treturn 32;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bpp(void) {\n\treturn 32;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_width",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "56-61",
          "snippet": "int macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBytesPerRow(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width() * macosx_opengl_get_bpp()/8;\n\t}\n\treturn (int) CGDisplayBytesPerRow(displayID);;\n}"
  },
  {
    "function_name": "macosxCG_CGDisplaySamplesPerPixel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "379-384",
    "snippet": "int macosxCG_CGDisplaySamplesPerPixel(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_spp();\n\t}\n\treturn (int) CGDisplaySamplesPerPixel(displayID);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGDisplaySamplesPerPixel",
          "args": [
            "displayID"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_spp",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_spp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "78-80",
          "snippet": "int macosx_opengl_get_spp(void) {\n\treturn 3;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_spp(void) {\n\treturn 3;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplaySamplesPerPixel(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_spp();\n\t}\n\treturn (int) CGDisplaySamplesPerPixel(displayID);\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayBitsPerSample",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "373-378",
    "snippet": "int macosxCG_CGDisplayBitsPerSample(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bps();\n\t}\n\treturn (int) CGDisplayBitsPerSample(displayID);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGDisplayBitsPerSample",
          "args": [
            "displayID"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_bps",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "74-76",
          "snippet": "int macosx_opengl_get_bps(void) {\n\treturn 8;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bps(void) {\n\treturn 8;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBitsPerSample(void) {\n\tif (macosx_read_opengl || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bps();\n\t}\n\treturn (int) CGDisplayBitsPerSample(displayID);\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayBitsPerPixel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "367-372",
    "snippet": "int macosxCG_CGDisplayBitsPerPixel(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bpp();\n\t}\n\treturn (int) CGDisplayBitsPerPixel(displayID);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGDisplayBitsPerPixel",
          "args": [
            "displayID"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_bpp",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "70-72",
          "snippet": "int macosx_opengl_get_bpp(void) {\n\treturn 32;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bpp(void) {\n\treturn 32;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBitsPerPixel(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bpp();\n\t}\n\treturn (int) CGDisplayBitsPerPixel(displayID);\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayPixelsHigh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "361-366",
    "snippet": "int macosxCG_CGDisplayPixelsHigh(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_height();\n\t}\n\treturn (int) CGDisplayPixelsHigh(displayID);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGDisplayPixelsHigh",
          "args": [
            "displayID"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_height",
          "args": [],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_height",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "63-68",
          "snippet": "int macosx_opengl_get_height(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[3];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_height(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[3];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsHigh(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_height();\n\t}\n\treturn (int) CGDisplayPixelsHigh(displayID);\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayPixelsWide",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "355-360",
    "snippet": "int macosxCG_CGDisplayPixelsWide(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width();\n\t}\n\treturn (int) CGDisplayPixelsWide(displayID);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGDisplayPixelsWide",
          "args": [
            "displayID"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_width",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "56-61",
          "snippet": "int macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsWide(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width();\n\t}\n\treturn (int) CGDisplayPixelsWide(displayID);\n}"
  },
  {
    "function_name": "macosxCG_get_fb_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "339-353",
    "snippet": "char *macosxCG_get_fb_addr(void) {\n\tif (x11vnc_macosx_no_deprecated_framebuffer) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by env. var\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_no_rawfb) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by user.\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_read_opengl) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by OpenGL.\\n\");\n\t\treturn NULL;\n\t}\n\treturn (char *) CGDisplayBaseAddress(displayID);\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGDisplayBaseAddress",
          "args": [
            "displayID"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"CGDisplayBaseAddress disabled by OpenGL.\\n\""
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nchar *macosxCG_get_fb_addr(void) {\n\tif (x11vnc_macosx_no_deprecated_framebuffer) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by env. var\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_no_rawfb) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by user.\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_read_opengl) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by OpenGL.\\n\");\n\t\treturn NULL;\n\t}\n\treturn (char *) CGDisplayBaseAddress(displayID);\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayBytesPerRow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "333-335",
    "snippet": "int macosxCG_CGDisplayBytesPerRow(void) {\n\treturn macosx_opengl_get_width() * macosx_opengl_get_bpp() / 8;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_opengl_get_bpp",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "70-72",
          "snippet": "int macosx_opengl_get_bpp(void) {\n\treturn 32;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bpp(void) {\n\treturn 32;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_get_width",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "56-61",
          "snippet": "int macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBytesPerRow(void) {\n\treturn macosx_opengl_get_width() * macosx_opengl_get_bpp() / 8;\n}"
  },
  {
    "function_name": "macosxCG_CGDisplaySamplesPerPixel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "330-332",
    "snippet": "int macosxCG_CGDisplaySamplesPerPixel(void) {\n\treturn macosx_opengl_get_spp();\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_opengl_get_spp",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_spp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "78-80",
          "snippet": "int macosx_opengl_get_spp(void) {\n\treturn 3;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_spp(void) {\n\treturn 3;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplaySamplesPerPixel(void) {\n\treturn macosx_opengl_get_spp();\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayBitsPerSample",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "327-329",
    "snippet": "int macosxCG_CGDisplayBitsPerSample(void) {\n\treturn macosx_opengl_get_bps();\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_opengl_get_bps",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "74-76",
          "snippet": "int macosx_opengl_get_bps(void) {\n\treturn 8;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bps(void) {\n\treturn 8;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBitsPerSample(void) {\n\treturn macosx_opengl_get_bps();\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayBitsPerPixel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "324-326",
    "snippet": "int macosxCG_CGDisplayBitsPerPixel(void) {\n\treturn macosx_opengl_get_bpp();\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_opengl_get_bpp",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_bpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "70-72",
          "snippet": "int macosx_opengl_get_bpp(void) {\n\treturn 32;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_bpp(void) {\n\treturn 32;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBitsPerPixel(void) {\n\treturn macosx_opengl_get_bpp();\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayPixelsHigh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "321-323",
    "snippet": "int macosxCG_CGDisplayPixelsHigh(void) {\n\treturn macosx_opengl_get_height();\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_opengl_get_height",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_height",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "63-68",
          "snippet": "int macosx_opengl_get_height(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[3];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_height(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[3];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsHigh(void) {\n\treturn macosx_opengl_get_height();\n}"
  },
  {
    "function_name": "macosxCG_CGDisplayPixelsWide",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "318-320",
    "snippet": "int macosxCG_CGDisplayPixelsWide(void) {\n\treturn macosx_opengl_get_width();\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_opengl_get_width",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_get_width",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "56-61",
          "snippet": "int macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nint macosx_opengl_get_width(void) {\n\tGLint viewport[4];\n\n\tglGetIntegerv(GL_VIEWPORT, viewport);\n\treturn (int) viewport[2];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsWide(void) {\n\treturn macosx_opengl_get_width();\n}"
  },
  {
    "function_name": "macosxCG_get_fb_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "315-317",
    "snippet": "char *macosxCG_get_fb_addr(void) {\n\treturn NULL;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nchar *macosxCG_get_fb_addr(void) {\n\treturn NULL;\n}"
  },
  {
    "function_name": "macosxCG_event_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "242-303",
    "snippet": "void macosxCG_event_loop(void) {\n\tOSStatus rc;\n\tint nbpp;\n\tstatic int nbpp_save = -1;\n\n\tmacosxGCS_poll_pb();\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\trc = RunCurrentEventLoop(kEventDurationSecond/30);\n\n\tif (client_count) {\n\t\tmacosxCG_refresh_callback_on();\n\t} else {\n\t\tmacosxCG_refresh_callback_off();\n\t}\n\n\tnbpp = macosxCG_CGDisplayBitsPerPixel();\n\n\tif (nbpp_save < 0) {\n\t\tnbpp_save = nbpp;\n\t}\n\t\t\n\tif (nbpp > 0 && nbpp != nbpp_save) {\n\t\tnbpp_save = nbpp;\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t} else if (wdpy_x != macosxCG_CGDisplayPixelsWide()) {\n\t    if (wdpy_y != macosxCG_CGDisplayPixelsHigh()) {\n\t\tif (macosx_wait_for_switch) {\n\t\t\tint cnt = 0;\n\t\t\twhile (1) {\n\t\t\t\tif(macosxCG_CGDisplayPixelsWide() > 0) {\n\t\t\t\t\tif(macosxCG_CGDisplayPixelsHigh() > 0) {\n\t\t\t\t\t\tusleep(500*1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((cnt++ % 120) == 0) {\n\t\t\t\t\tmacosx_log(\"waiting for user to \"\n\t\t\t\t\t    \"switch back..\\n\");\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\tif (wdpy_x == macosxCG_CGDisplayPixelsWide()) {\n\t\t\t\tif (wdpy_y == macosxCG_CGDisplayPixelsHigh()) {\n\t\t\t\t\tmacosx_log(\"we're back...\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t    }\n\t}\n\tif (nbpp > 0) {\n\t\tnbpp_save = nbpp;\n\t}\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"we're back...\\n\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayPixelsHigh",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayPixelsHigh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "361-366",
          "snippet": "int macosxCG_CGDisplayPixelsHigh(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_height();\n\t}\n\treturn (int) CGDisplayPixelsHigh(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsHigh(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_height();\n\t}\n\treturn (int) CGDisplayPixelsHigh(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayPixelsWide",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayPixelsWide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "355-360",
          "snippet": "int macosxCG_CGDisplayPixelsWide(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width();\n\t}\n\treturn (int) CGDisplayPixelsWide(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayPixelsWide(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_width();\n\t}\n\treturn (int) CGDisplayPixelsWide(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "do_sleepin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/x11vnc.c",
          "lines": "1929-1959",
          "snippet": "static void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"solid.h\"",
            "#include \"pm.h\"",
            "#include \"selection.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"inet.h\"",
            "#include \"unixpw.h\"",
            "#include \"rates.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"keyboard.h\"",
            "#include \"cleanup.h\"",
            "#include \"user.h\"",
            "#include \"help.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"solid.h\"\n#include \"pm.h\"\n#include \"selection.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"inet.h\"\n#include \"unixpw.h\"\n#include \"rates.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"keyboard.h\"\n#include \"cleanup.h\"\n#include \"user.h\"\n#include \"help.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void do_sleepin(char *sleep) {\n\tint n1, n2, nt;\n\tdouble f1, f2, ft;\n\n\tif (strchr(sleep, '-')) {\n\t\tdouble s = atof(strchr(sleep, '-')+1); \n\t\tif (sscanf(sleep, \"%d-%d\", &n1, &n2) == 2) {\n\t\t\tif (n1 > n2) {\n\t\t\t\tnt = n1;\n\t\t\t\tn1 = n2;\n\t\t\t\tn2 = nt;\n\t\t\t}\n\t\t\ts = n1 + rfac() * (n2 - n1);\n\t\t} else if (sscanf(sleep, \"%lf-%lf\", &f1, &f2) == 2) {\n\t\t\tif (f1 > f2) {\n\t\t\t\tft = f1;\n\t\t\t\tf1 = f2;\n\t\t\t\tf2 = ft;\n\t\t\t}\n\t\t\ts = f1 + rfac() * (f2 - f1);\n\t\t}\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %f secs\\n\", s);\n\t\tusleep( (int) (1000*1000*s) );\n\t} else {\n\t\tn1 = atoi(sleep);\n\t\tif (getenv(\"DEBUG_SLEEPIN\")) fprintf(stderr, \"sleepin: %d secs\\n\", n1);\n\t\tif (n1 > 0) {\n\t\t\tusleep(1000*1000*n1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "500*1000"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxCG_CGDisplayBitsPerPixel",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_CGDisplayBitsPerPixel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "367-372",
          "snippet": "int macosxCG_CGDisplayBitsPerPixel(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bpp();\n\t}\n\treturn (int) CGDisplayBitsPerPixel(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCG_CGDisplayBitsPerPixel(void) {\n\tif ((0 && macosx_read_opengl) || x11vnc_macosx_no_deprecated_framebuffer) {\n\t\treturn macosx_opengl_get_bpp();\n\t}\n\treturn (int) CGDisplayBitsPerPixel(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_refresh_callback_off",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_refresh_callback_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "125-131",
          "snippet": "void macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_refresh_callback_on",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_refresh_callback_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "113-123",
          "snippet": "void macosxCG_refresh_callback_on(void) {\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\tif (! callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: register\\n\");\n\t\tCGRegisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 1;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_refresh_callback_on(void) {\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\tif (! callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: register\\n\");\n\t\tCGRegisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RunCurrentEventLoop",
          "args": [
            "kEventDurationSecond/30"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosxGCS_poll_pb",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "macosxGCS_poll_pb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "568-598",
          "snippet": "void macosxGCS_poll_pb(void) {\n\n\tstatic double dlast = 0.0;\n\tdouble now = dnow();\n\n\tif (now < dlast + 0.2) {\n\t\treturn;\n\t}\n\tdlast = now;\n\n   {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\t[pblock lock];\n\tif (pbcnt != [[NSPasteboard generalPasteboard] changeCount]) {\n\t\tpbcnt = [[NSPasteboard generalPasteboard] changeCount];\n\t\t[pbstr release];\n\t\tpbstr = nil;\n\t\tif ([[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]]) {\n\t\t\tpbstr = [[[NSPasteboard generalPasteboard] stringForType:NSStringPboardType] copy];\n\t\t\tif (pbstr) {\n\t\t\t\tNSData *str = [pbstr dataUsingEncoding:pbenc allowLossyConversion:YES];\n\t\t\t\tif ([str length]) {\n\t\t\t\t\tmacosx_send_sel((char *) [str bytes], [str length]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t[pblock unlock];\n\t[pool release];\n   }\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxGCS_poll_pb(void) {\n\n\tstatic double dlast = 0.0;\n\tdouble now = dnow();\n\n\tif (now < dlast + 0.2) {\n\t\treturn;\n\t}\n\tdlast = now;\n\n   {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\t[pblock lock];\n\tif (pbcnt != [[NSPasteboard generalPasteboard] changeCount]) {\n\t\tpbcnt = [[NSPasteboard generalPasteboard] changeCount];\n\t\t[pbstr release];\n\t\tpbstr = nil;\n\t\tif ([[NSPasteboard generalPasteboard] availableTypeFromArray:[NSArray arrayWithObject:NSStringPboardType]]) {\n\t\t\tpbstr = [[[NSPasteboard generalPasteboard] stringForType:NSStringPboardType] copy];\n\t\t\tif (pbstr) {\n\t\t\t\tNSData *str = [pbstr dataUsingEncoding:pbenc allowLossyConversion:YES];\n\t\t\t\tif ([str length]) {\n\t\t\t\t\tmacosx_send_sel((char *) [str bytes], [str length]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t[pblock unlock];\n\t[pool release];\n   }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_event_loop(void) {\n\tOSStatus rc;\n\tint nbpp;\n\tstatic int nbpp_save = -1;\n\n\tmacosxGCS_poll_pb();\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\trc = RunCurrentEventLoop(kEventDurationSecond/30);\n\n\tif (client_count) {\n\t\tmacosxCG_refresh_callback_on();\n\t} else {\n\t\tmacosxCG_refresh_callback_off();\n\t}\n\n\tnbpp = macosxCG_CGDisplayBitsPerPixel();\n\n\tif (nbpp_save < 0) {\n\t\tnbpp_save = nbpp;\n\t}\n\t\t\n\tif (nbpp > 0 && nbpp != nbpp_save) {\n\t\tnbpp_save = nbpp;\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t} else if (wdpy_x != macosxCG_CGDisplayPixelsWide()) {\n\t    if (wdpy_y != macosxCG_CGDisplayPixelsHigh()) {\n\t\tif (macosx_wait_for_switch) {\n\t\t\tint cnt = 0;\n\t\t\twhile (1) {\n\t\t\t\tif(macosxCG_CGDisplayPixelsWide() > 0) {\n\t\t\t\t\tif(macosxCG_CGDisplayPixelsHigh() > 0) {\n\t\t\t\t\t\tusleep(500*1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((cnt++ % 120) == 0) {\n\t\t\t\t\tmacosx_log(\"waiting for user to \"\n\t\t\t\t\t    \"switch back..\\n\");\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t\tif (wdpy_x == macosxCG_CGDisplayPixelsWide()) {\n\t\t\t\tif (wdpy_y == macosxCG_CGDisplayPixelsHigh()) {\n\t\t\t\t\tmacosx_log(\"we're back...\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (macosx_resize) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t    }\n\t}\n\tif (nbpp > 0) {\n\t\tnbpp_save = nbpp;\n\t}\n}"
  },
  {
    "function_name": "macosxCG_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "218-226",
    "snippet": "void macosxCG_fini(void) {\n\tmacosxCGP_dim_shutdown();\n\tif (macosx_noscreensaver) {\n\t\tmacosxCGP_screensaver_timer_off();\n\t}\n\tmacosxCG_refresh_callback_off();\n\tmacosx_opengl_fini();\n\tdisplayID = 0;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosx_opengl_fini",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "131-138",
          "snippet": "void macosx_opengl_fini(void) {\n\tif (!macosx_read_opengl) {\n\t\treturn;\n\t}\n\tCGLSetCurrentContext(NULL);\n\tCGLClearDrawable(glContextObj);\n\tCGLDestroyContext(glContextObj);\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nvoid macosx_opengl_fini(void) {\n\tif (!macosx_read_opengl) {\n\t\treturn;\n\t}\n\tCGLSetCurrentContext(NULL);\n\tCGLClearDrawable(glContextObj);\n\tCGLDestroyContext(glContextObj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_refresh_callback_off",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_refresh_callback_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "125-131",
          "snippet": "void macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGP_screensaver_timer_off",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGP_screensaver_timer_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGP.c",
          "lines": "83-87",
          "snippet": "void macosxCGP_screensaver_timer_off(void) {\n\tif (0) fprintf(stderr, \"macosxCGP_screensaver_timer_off: %d\\n\", (int) time(0));\n\tRemoveEventLoopTimer(sstimer);\n\tDisposeEventLoopTimerUPP(sstimerUPP);\n}",
          "includes": [
            "#include <IOKit/pwr_mgt/IOPM.h>",
            "#include <IOKit/pwr_mgt/IOPMLib.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <IOKit/pwr_mgt/IOPM.h>\n#include <IOKit/pwr_mgt/IOPMLib.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCGP_screensaver_timer_off(void) {\n\tif (0) fprintf(stderr, \"macosxCGP_screensaver_timer_off: %d\\n\", (int) time(0));\n\tRemoveEventLoopTimer(sstimer);\n\tDisposeEventLoopTimerUPP(sstimerUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGP_dim_shutdown",
          "args": [],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGP_dim_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGP.c",
          "lines": "202-217",
          "snippet": "int macosxCGP_dim_shutdown(void) {\n\tif (! initialized) {\n\t\treturn 0;\n\t}\n\tif (dim_time_saved) {\n\t\tif (! macosxCGP_restore_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (sleep_time_saved) {\n\t\tif (! macosxCGP_restore_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <IOKit/pwr_mgt/IOPM.h>",
            "#include <IOKit/pwr_mgt/IOPMLib.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <IOKit/pwr_mgt/IOPM.h>\n#include <IOKit/pwr_mgt/IOPMLib.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGP_dim_shutdown(void) {\n\tif (! initialized) {\n\t\treturn 0;\n\t}\n\tif (dim_time_saved) {\n\t\tif (! macosxCGP_restore_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (sleep_time_saved) {\n\t\tif (! macosxCGP_restore_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_fini(void) {\n\tmacosxCGP_dim_shutdown();\n\tif (macosx_noscreensaver) {\n\t\tmacosxCGP_screensaver_timer_off();\n\t}\n\tmacosxCG_refresh_callback_off();\n\tmacosx_opengl_fini();\n\tdisplayID = 0;\n}"
  },
  {
    "function_name": "macosxCG_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "150-216",
    "snippet": "void macosxCG_init(void) {\n\n\tx11vnc_macosx_no_deprecated_localevents = 0;\n\tx11vnc_macosx_no_deprecated_postevents  = 0;\n\tx11vnc_macosx_no_deprecated_framebuffer = 0;\n\n\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\tx11vnc_macosx_no_deprecated_localevents = 1;\n\t}\n\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\tx11vnc_macosx_no_deprecated_postevents = 1;\n\t}\n\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\tx11vnc_macosx_no_deprecated_framebuffer = 1;\n\t}\n\n\tif (displayID == 0) {\n\t\tmacosx_log(\"macosxCG_init: initializing display.\\n\");\n\n\t\tdisplayID = kCGDirectMainDisplay;\n#ifdef X11VNC_MACOSX_USE_GETMAINDEVICE\n\t\t/* not sure this ever did anything. */\n\t\t(void) GetMainDevice();\n#endif\n\t\tif (displayID == 0) {\n\t\t\tmacosx_log(\"macosxCG_init: could not get kCGDirectMainDisplay / CGMainDisplayID() display.\\n\");\n\t\t\texit(1);\n\t\t}\n\n#if X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS || X11VNC_MACOSX_NO_DEPRECATED\n\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsSuppressionInterval()\\n\");\n\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsFilterDuringSupressionState()\\n\");\n#else\n\t\tif (!x11vnc_macosx_no_deprecated_localevents) {\n\t\t\tCGSetLocalEventsSuppressionInterval(0.0);\n\t\t\tCGSetLocalEventsFilterDuringSupressionState(\n\t\t\t    kCGEventFilterMaskPermitAllEvents,\n\t\t\t    kCGEventSupressionStateSupressionInterval);\n\t\t\tCGSetLocalEventsFilterDuringSupressionState(\n\t\t\t    kCGEventFilterMaskPermitAllEvents,\n\t\t\t    kCGEventSupressionStateRemoteMouseDrag);\n\t\t} else {\n\t\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsSuppressionInterval()\\n\");\n\t\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsFilterDuringSupressionState()\\n\");\n\t\t}\n#endif\n\n\t\tmacosx_opengl_init();\n\n\t\tif (!macosx_read_opengl) {\n\t\t\tchar *addr = macosxCG_get_fb_addr();\n\t\t\tif (addr == NULL) {\n\t\t\t\tmacosx_log(\"macosxCG_init: could not get raw framebuffer address / CGDisplayBaseAddress().\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tmacosx_read_rawfb = 1;\n\t\t\tmacosx_log(\"macosxCG_init: using raw framebuffer address for screen capture.\\n\");\n\t\t}\n\n\t\tmacosxCGP_init_dimming();\n\t\tif (macosx_noscreensaver) {\n\t\t\tmacosxCGP_screensaver_timer_on();\n\t\t}\n\n\t\tmacosxGCS_initpb();\n\t}\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "macosxGCS_initpb",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "macosxGCS_initpb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGS.c",
          "lines": "531-542",
          "snippet": "void macosxGCS_initpb(void) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tpblock = [[NSLock alloc] init];\n\tif (![NSPasteboard generalPasteboard]) {\n\t\tmacosx_log(\"macosxGCS_initpb: **PASTEBOARD INACCESSIBLE**.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Clipboard exchange will NOT work.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Start x11vnc *inside* Aqua for Clipboard.\\n\");\n\t\tpbcnt = 0;\n\t\tpbstr = [[NSString alloc] initWithString:@\"\\e<PASTEBOARD INACCESSIBLE>\\e\"]; \n\t}\n\t[pool release];\n}",
          "includes": [
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxGCS_initpb(void) {\n\tNSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n\tpblock = [[NSLock alloc] init];\n\tif (![NSPasteboard generalPasteboard]) {\n\t\tmacosx_log(\"macosxGCS_initpb: **PASTEBOARD INACCESSIBLE**.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Clipboard exchange will NOT work.\\n\");\n\t\tmacosx_log(\"macosxGCS_initpb: Start x11vnc *inside* Aqua for Clipboard.\\n\");\n\t\tpbcnt = 0;\n\t\tpbstr = [[NSString alloc] initWithString:@\"\\e<PASTEBOARD INACCESSIBLE>\\e\"]; \n\t}\n\t[pool release];\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGP_screensaver_timer_on",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGP_screensaver_timer_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGP.c",
          "lines": "89-94",
          "snippet": "void macosxCGP_screensaver_timer_on(void) {\n\tif (0) fprintf(stderr, \"macosxCGP_screensaver_timer_on: %d\\n\", (int) time(0));\n\tsstimerUPP = NewEventLoopTimerUPP(macosxCG_screensaver_timer);\n\tInstallEventLoopTimer(GetMainEventLoop(), kEventDurationSecond * 30,\n\t    kEventDurationSecond * 30, sstimerUPP, NULL, &sstimer);\n}",
          "includes": [
            "#include <IOKit/pwr_mgt/IOPM.h>",
            "#include <IOKit/pwr_mgt/IOPMLib.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <IOKit/pwr_mgt/IOPM.h>\n#include <IOKit/pwr_mgt/IOPMLib.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCGP_screensaver_timer_on(void) {\n\tif (0) fprintf(stderr, \"macosxCGP_screensaver_timer_on: %d\\n\", (int) time(0));\n\tsstimerUPP = NewEventLoopTimerUPP(macosxCG_screensaver_timer);\n\tInstallEventLoopTimer(GetMainEventLoop(), kEventDurationSecond * 30,\n\t    kEventDurationSecond * 30, sstimerUPP, NULL, &sstimer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCGP_init_dimming",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCGP_init_dimming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCGP.c",
          "lines": "140-169",
          "snippet": "int macosxCGP_init_dimming(void) {\n\tif (IOMasterPort(bootstrap_port, &master_dev_port) != \n\t    kIOReturnSuccess) {\n\t\treturn 0;\n\t}\n\tif (!(power_mgt = IOPMFindPowerManagement(master_dev_port))) {\n\t\treturn 0;\n\t}\n\tif (macosx_nodimming) {\n\t\tif (! macosxCGP_save_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToDim, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (macosx_nosleep) {\n\t\tif (! macosxCGP_save_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToSleep, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tinitialized = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <IOKit/pwr_mgt/IOPM.h>",
            "#include <IOKit/pwr_mgt/IOPMLib.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <IOKit/pwr_mgt/IOPM.h>\n#include <IOKit/pwr_mgt/IOPMLib.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nint macosxCGP_init_dimming(void) {\n\tif (IOMasterPort(bootstrap_port, &master_dev_port) != \n\t    kIOReturnSuccess) {\n\t\treturn 0;\n\t}\n\tif (!(power_mgt = IOPMFindPowerManagement(master_dev_port))) {\n\t\treturn 0;\n\t}\n\tif (macosx_nodimming) {\n\t\tif (! macosxCGP_save_dim()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToDim, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (macosx_nosleep) {\n\t\tif (! macosxCGP_save_sleep()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (IOPMSetAggressiveness(power_mgt, kPMMinutesToSleep, 0)\n\t\t    != kIOReturnSuccess) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tinitialized = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"macosxCG_init: using raw framebuffer address for screen capture.\\n\""
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosxCG_get_fb_addr",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "macosxCG_get_fb_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
          "lines": "339-353",
          "snippet": "char *macosxCG_get_fb_addr(void) {\n\tif (x11vnc_macosx_no_deprecated_framebuffer) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by env. var\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_no_rawfb) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by user.\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_read_opengl) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by OpenGL.\\n\");\n\t\treturn NULL;\n\t}\n\treturn (char *) CGDisplayBaseAddress(displayID);\n}",
          "includes": [
            "#include <rfb/keysym.h>",
            "#include <Carbon/Carbon.h>",
            "#include <Cocoa/Cocoa.h>",
            "#include <ApplicationServices/ApplicationServices.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nchar *macosxCG_get_fb_addr(void) {\n\tif (x11vnc_macosx_no_deprecated_framebuffer) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by env. var\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_no_rawfb) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by user.\\n\");\n\t\treturn NULL;\n\t}\n\tif (macosx_read_opengl) {\n\t\tmacosx_log(\"CGDisplayBaseAddress disabled by OpenGL.\\n\");\n\t\treturn NULL;\n\t}\n\treturn (char *) CGDisplayBaseAddress(displayID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_opengl_init",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_opengl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx_opengl.c",
          "lines": "82-129",
          "snippet": "void macosx_opengl_init(void) {\n\tCGLPixelFormatObj pixelFormatObj;\n\tGLint numPixelFormats;\n\tCGLPixelFormatAttribute attribs[] = {\n\t\tkCGLPFAFullScreen,\n\t\tkCGLPFADisplayMask,\n\t\t0,\n\t\t0\n\t};\n\n\tif (macosx_no_opengl) {\n\t\treturn;\n\t}\n\n\tattribs[2] = CGDisplayIDToOpenGLDisplayMask(displayID);\n\n\tCGLChoosePixelFormat(attribs, &pixelFormatObj, &numPixelFormats);\n\tif (pixelFormatObj == NULL) {\n\t\trfbLog(\"macosx_opengl_init: CGLChoosePixelFormat failed. Not using OpenGL.\\n\");\n\t\treturn;\n\t}\n\n\tCGLCreateContext(pixelFormatObj, NULL, &glContextObj);\n\tCGLDestroyPixelFormat(pixelFormatObj);\n\n\tif (glContextObj == NULL) {\n\t\trfbLog(\"macosx_opengl_init: CGLCreateContext failed. Not using OpenGL.\\n\");\n\t\treturn;\n\t}\n\n\tCGLSetCurrentContext(glContextObj);\n\tCGLSetFullScreen(glContextObj);\n\n\tmacosx_opengl_width  = macosx_opengl_get_width();\n\tmacosx_opengl_height = macosx_opengl_get_height();\n\n\tmacosx_opengl_bpp = macosx_opengl_get_bpp();\n\n\tglFinish();\n\n\tglPixelStorei(GL_PACK_ALIGNMENT, 4);\n\tglPixelStorei(GL_PACK_ROW_LENGTH, 0);\n\tglPixelStorei(GL_PACK_SKIP_ROWS, 0);\n\tglPixelStorei(GL_PACK_SKIP_PIXELS, 0);\n\n\trfbLog(\"macosx_opengl_init: Using OpenGL for screen capture.\\n\");\n\tmacosx_read_opengl = 1;\n}",
          "includes": [
            "#include <OpenGL/gl.h>",
            "#include <OpenGL/OpenGL.h>",
            "#include <rfb/rfb.h>",
            "#include \"config.h\"",
            "#include <ApplicationServices/ApplicationServices.h>",
            "#include <CoreFoundation/CoreFoundation.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <OpenGL/gl.h>\n#include <OpenGL/OpenGL.h>\n#include <rfb/rfb.h>\n#include \"config.h\"\n#include <ApplicationServices/ApplicationServices.h>\n#include <CoreFoundation/CoreFoundation.h>\n\nvoid macosx_opengl_init(void) {\n\tCGLPixelFormatObj pixelFormatObj;\n\tGLint numPixelFormats;\n\tCGLPixelFormatAttribute attribs[] = {\n\t\tkCGLPFAFullScreen,\n\t\tkCGLPFADisplayMask,\n\t\t0,\n\t\t0\n\t};\n\n\tif (macosx_no_opengl) {\n\t\treturn;\n\t}\n\n\tattribs[2] = CGDisplayIDToOpenGLDisplayMask(displayID);\n\n\tCGLChoosePixelFormat(attribs, &pixelFormatObj, &numPixelFormats);\n\tif (pixelFormatObj == NULL) {\n\t\trfbLog(\"macosx_opengl_init: CGLChoosePixelFormat failed. Not using OpenGL.\\n\");\n\t\treturn;\n\t}\n\n\tCGLCreateContext(pixelFormatObj, NULL, &glContextObj);\n\tCGLDestroyPixelFormat(pixelFormatObj);\n\n\tif (glContextObj == NULL) {\n\t\trfbLog(\"macosx_opengl_init: CGLCreateContext failed. Not using OpenGL.\\n\");\n\t\treturn;\n\t}\n\n\tCGLSetCurrentContext(glContextObj);\n\tCGLSetFullScreen(glContextObj);\n\n\tmacosx_opengl_width  = macosx_opengl_get_width();\n\tmacosx_opengl_height = macosx_opengl_get_height();\n\n\tmacosx_opengl_bpp = macosx_opengl_get_bpp();\n\n\tglFinish();\n\n\tglPixelStorei(GL_PACK_ALIGNMENT, 4);\n\tglPixelStorei(GL_PACK_ROW_LENGTH, 0);\n\tglPixelStorei(GL_PACK_SKIP_ROWS, 0);\n\tglPixelStorei(GL_PACK_SKIP_PIXELS, 0);\n\n\trfbLog(\"macosx_opengl_init: Using OpenGL for screen capture.\\n\");\n\tmacosx_read_opengl = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CGSetLocalEventsFilterDuringSupressionState",
          "args": [
            "kCGEventFilterMaskPermitAllEvents",
            "kCGEventSupressionStateRemoteMouseDrag"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSetLocalEventsFilterDuringSupressionState",
          "args": [
            "kCGEventFilterMaskPermitAllEvents",
            "kCGEventSupressionStateSupressionInterval"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CGSetLocalEventsSuppressionInterval",
          "args": [
            "0.0"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMainDevice",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_init(void) {\n\n\tx11vnc_macosx_no_deprecated_localevents = 0;\n\tx11vnc_macosx_no_deprecated_postevents  = 0;\n\tx11vnc_macosx_no_deprecated_framebuffer = 0;\n\n\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\tx11vnc_macosx_no_deprecated_localevents = 1;\n\t}\n\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_POSTEVENTS\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\tx11vnc_macosx_no_deprecated_postevents = 1;\n\t}\n\tif (getenv(\"X11VNC_MACOSX_NO_DEPRECATED_FRAMEBUFFER\") || getenv(\"X11VNC_MACOSX_NO_DEPRECATED\")) {\n\t\tx11vnc_macosx_no_deprecated_framebuffer = 1;\n\t}\n\n\tif (displayID == 0) {\n\t\tmacosx_log(\"macosxCG_init: initializing display.\\n\");\n\n\t\tdisplayID = kCGDirectMainDisplay;\n#ifdef X11VNC_MACOSX_USE_GETMAINDEVICE\n\t\t/* not sure this ever did anything. */\n\t\t(void) GetMainDevice();\n#endif\n\t\tif (displayID == 0) {\n\t\t\tmacosx_log(\"macosxCG_init: could not get kCGDirectMainDisplay / CGMainDisplayID() display.\\n\");\n\t\t\texit(1);\n\t\t}\n\n#if X11VNC_MACOSX_NO_DEPRECATED_LOCALEVENTS || X11VNC_MACOSX_NO_DEPRECATED\n\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsSuppressionInterval()\\n\");\n\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsFilterDuringSupressionState()\\n\");\n#else\n\t\tif (!x11vnc_macosx_no_deprecated_localevents) {\n\t\t\tCGSetLocalEventsSuppressionInterval(0.0);\n\t\t\tCGSetLocalEventsFilterDuringSupressionState(\n\t\t\t    kCGEventFilterMaskPermitAllEvents,\n\t\t\t    kCGEventSupressionStateSupressionInterval);\n\t\t\tCGSetLocalEventsFilterDuringSupressionState(\n\t\t\t    kCGEventFilterMaskPermitAllEvents,\n\t\t\t    kCGEventSupressionStateRemoteMouseDrag);\n\t\t} else {\n\t\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsSuppressionInterval()\\n\");\n\t\t\tmacosx_log(\"NO_DEPRECATED_LOCALEVENTS: not calling CGSetLocalEventsFilterDuringSupressionState()\\n\");\n\t\t}\n#endif\n\n\t\tmacosx_opengl_init();\n\n\t\tif (!macosx_read_opengl) {\n\t\t\tchar *addr = macosxCG_get_fb_addr();\n\t\t\tif (addr == NULL) {\n\t\t\t\tmacosx_log(\"macosxCG_init: could not get raw framebuffer address / CGDisplayBaseAddress().\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tmacosx_read_rawfb = 1;\n\t\t\tmacosx_log(\"macosxCG_init: using raw framebuffer address for screen capture.\\n\");\n\t\t}\n\n\t\tmacosxCGP_init_dimming();\n\t\tif (macosx_noscreensaver) {\n\t\t\tmacosxCGP_screensaver_timer_on();\n\t\t}\n\n\t\tmacosxGCS_initpb();\n\t}\n}"
  },
  {
    "function_name": "macosxCG_refresh_callback_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "125-131",
    "snippet": "void macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGUnregisterScreenRefreshCallback",
          "args": [
            "macosxCG_callback",
            "NULL"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"macosxCG_refresh_callback: unregister\\n\""
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_refresh_callback_off(void) {\n\tif (callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: unregister\\n\");\n\t\tCGUnregisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 0;\n}"
  },
  {
    "function_name": "macosxCG_refresh_callback_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "113-123",
    "snippet": "void macosxCG_refresh_callback_on(void) {\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\tif (! callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: register\\n\");\n\t\tCGRegisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 1;\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CGRegisterScreenRefreshCallback",
          "args": [
            "macosxCG_callback",
            "NULL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_log",
          "args": [
            "\"macosxCG_refresh_callback: register\\n\""
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "81-83",
          "snippet": "void macosx_log(char *str) {\n\trfbLog(str);\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_log(char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_log(char *);\n\nvoid macosx_log(char *str) {\n\trfbLog(str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_refresh_callback_on(void) {\n\tif (nofb) {\n\t\treturn;\n\t}\n\n\tif (! callback_set) {\n\t\tif (1) macosx_log(\"macosxCG_refresh_callback: register\\n\");\n\t\tCGRegisterScreenRefreshCallback(macosxCG_callback, NULL);\n\t}\n\tcallback_set = 1;\n}"
  },
  {
    "function_name": "macosxCG_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "73-82",
    "snippet": "static void macosxCG_callback(CGRectCount n, const CGRect *rects, void *dum) {\n\tint i, db = 0;\n\tif (db) fprintf(stderr, \"macosx_callback: n=%d\\n\", (int) n);\n\tif (!dum) {}\n\tfor (i=0; i < (int) n; i++) {\n\t\tif (db > 1) fprintf(stderr, \"               : %g %g - %g %g\\n\", rects[i].origin.x, rects[i].origin.y, rects[i].size.width, rects[i].size.height);\n\t\tcollect_non_X_xdamage( (int) rects[i].origin.x, (int) rects[i].origin.y,\n\t\t    (int) rects[i].size.width, (int) rects[i].size.height, 1);\n\t}\n}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_non_X_xdamage",
          "args": [
            "(int) rects[i].origin.x",
            "(int) rects[i].origin.y",
            "(int) rects[i].size.width",
            "(int) rects[i].size.height",
            "1"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "collect_non_X_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "260-388",
          "snippet": "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int XD_skip = 0, XD_tot = 0, XD_des = 0;",
            "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
            "int collect_xdamage(int scancnt, int call);",
            "int xdamage_hint_skip(int y);",
            "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint XD_skip = 0, XD_tot = 0, XD_des = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nint xdamage_hint_skip(int y);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"               : %g %g - %g %g\\n\"",
            "rects[i].origin.x",
            "rects[i].origin.y",
            "rects[i].size.width",
            "rects[i].size.height"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"macosx_callback: n=%d\\n\"",
            "(int) n"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nstatic void macosxCG_callback(CGRectCount n, const CGRect *rects, void *dum) {\n\tint i, db = 0;\n\tif (db) fprintf(stderr, \"macosx_callback: n=%d\\n\", (int) n);\n\tif (!dum) {}\n\tfor (i=0; i < (int) n; i++) {\n\t\tif (db > 1) fprintf(stderr, \"               : %g %g - %g %g\\n\", rects[i].origin.x, rects[i].origin.y, rects[i].size.width, rects[i].size.height);\n\t\tcollect_non_X_xdamage( (int) rects[i].origin.x, (int) rects[i].origin.y,\n\t\t    (int) rects[i].size.width, (int) rects[i].size.height, 1);\n\t}\n}"
  },
  {
    "function_name": "macosxCG_dummy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosxCG.c",
    "lines": "41-41",
    "snippet": "void macosxCG_dummy(void) {}",
    "includes": [
      "#include <rfb/keysym.h>",
      "#include <Carbon/Carbon.h>",
      "#include <Cocoa/Cocoa.h>",
      "#include <ApplicationServices/ApplicationServices.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <rfb/keysym.h>\n#include <Carbon/Carbon.h>\n#include <Cocoa/Cocoa.h>\n#include <ApplicationServices/ApplicationServices.h>\n\nvoid macosxCG_dummy(void) {}"
  }
]