[
  {
    "function_name": "lookup_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "1297-1474",
    "snippet": "static int lookup_code(int keysym) {\n\n\tif (keysym == NoSymbol) {\n\t\treturn -1;\n\t}\n\n\tswitch(keysym) {\n#ifdef UINPUT_OK\n\tcase XK_Escape:\treturn KEY_ESC;\n\tcase XK_1:\t\treturn KEY_1;\n\tcase XK_2:\t\treturn KEY_2;\n\tcase XK_3:\t\treturn KEY_3;\n\tcase XK_4:\t\treturn KEY_4;\n\tcase XK_5:\t\treturn KEY_5;\n\tcase XK_6:\t\treturn KEY_6;\n\tcase XK_7:\t\treturn KEY_7;\n\tcase XK_8:\t\treturn KEY_8;\n\tcase XK_9:\t\treturn KEY_9;\n\tcase XK_0:\t\treturn KEY_0;\n\tcase XK_exclam:\treturn KEY_1;\n\tcase XK_at:\t\treturn KEY_2;\n\tcase XK_numbersign:\treturn KEY_3;\n\tcase XK_dollar:\treturn KEY_4;\n\tcase XK_percent:\treturn KEY_5;\n\tcase XK_asciicircum:\treturn KEY_6;\n\tcase XK_ampersand:\treturn KEY_7;\n\tcase XK_asterisk:\treturn KEY_8;\n\tcase XK_parenleft:\treturn KEY_9;\n\tcase XK_parenright:\treturn KEY_0;\n\tcase XK_minus:\treturn KEY_MINUS;\n\tcase XK_underscore:\treturn KEY_MINUS;\n\tcase XK_equal:\treturn KEY_EQUAL;\n\tcase XK_plus:\treturn KEY_EQUAL;\n\tcase XK_BackSpace:\treturn KEY_BACKSPACE;\n\tcase XK_Tab:\t\treturn KEY_TAB;\n\tcase XK_q:\t\treturn KEY_Q;\n\tcase XK_Q:\t\treturn KEY_Q;\n\tcase XK_w:\t\treturn KEY_W;\n\tcase XK_W:\t\treturn KEY_W;\n\tcase XK_e:\t\treturn KEY_E;\n\tcase XK_E:\t\treturn KEY_E;\n\tcase XK_r:\t\treturn KEY_R;\n\tcase XK_R:\t\treturn KEY_R;\n\tcase XK_t:\t\treturn KEY_T;\n\tcase XK_T:\t\treturn KEY_T;\n\tcase XK_y:\t\treturn KEY_Y;\n\tcase XK_Y:\t\treturn KEY_Y;\n\tcase XK_u:\t\treturn KEY_U;\n\tcase XK_U:\t\treturn KEY_U;\n\tcase XK_i:\t\treturn KEY_I;\n\tcase XK_I:\t\treturn KEY_I;\n\tcase XK_o:\t\treturn KEY_O;\n\tcase XK_O:\t\treturn KEY_O;\n\tcase XK_p:\t\treturn KEY_P;\n\tcase XK_P:\t\treturn KEY_P;\n\tcase XK_braceleft:\treturn KEY_LEFTBRACE;\n\tcase XK_braceright:\treturn KEY_RIGHTBRACE;\n\tcase XK_bracketleft:\treturn KEY_LEFTBRACE;\n\tcase XK_bracketright:\treturn KEY_RIGHTBRACE;\n\tcase XK_Return:\treturn KEY_ENTER;\n\tcase XK_Control_L:\treturn KEY_LEFTCTRL;\n\tcase XK_a:\t\treturn KEY_A;\n\tcase XK_A:\t\treturn KEY_A;\n\tcase XK_s:\t\treturn KEY_S;\n\tcase XK_S:\t\treturn KEY_S;\n\tcase XK_d:\t\treturn KEY_D;\n\tcase XK_D:\t\treturn KEY_D;\n\tcase XK_f:\t\treturn KEY_F;\n\tcase XK_F:\t\treturn KEY_F;\n\tcase XK_g:\t\treturn KEY_G;\n\tcase XK_G:\t\treturn KEY_G;\n\tcase XK_h:\t\treturn KEY_H;\n\tcase XK_H:\t\treturn KEY_H;\n\tcase XK_j:\t\treturn KEY_J;\n\tcase XK_J:\t\treturn KEY_J;\n\tcase XK_k:\t\treturn KEY_K;\n\tcase XK_K:\t\treturn KEY_K;\n\tcase XK_l:\t\treturn KEY_L;\n\tcase XK_L:\t\treturn KEY_L;\n\tcase XK_semicolon:\treturn KEY_SEMICOLON;\n\tcase XK_colon:\treturn KEY_SEMICOLON;\n\tcase XK_apostrophe:\treturn KEY_APOSTROPHE;\n\tcase XK_quotedbl:\treturn KEY_APOSTROPHE;\n\tcase XK_grave:\treturn KEY_GRAVE;\n\tcase XK_asciitilde:\treturn KEY_GRAVE;\n\tcase XK_Shift_L:\treturn KEY_LEFTSHIFT;\n\tcase XK_backslash:\treturn KEY_BACKSLASH;\n\tcase XK_bar:\t\treturn KEY_BACKSLASH;\n\tcase XK_z:\t\treturn KEY_Z;\n\tcase XK_Z:\t\treturn KEY_Z;\n\tcase XK_x:\t\treturn KEY_X;\n\tcase XK_X:\t\treturn KEY_X;\n\tcase XK_c:\t\treturn KEY_C;\n\tcase XK_C:\t\treturn KEY_C;\n\tcase XK_v:\t\treturn KEY_V;\n\tcase XK_V:\t\treturn KEY_V;\n\tcase XK_b:\t\treturn KEY_B;\n\tcase XK_B:\t\treturn KEY_B;\n\tcase XK_n:\t\treturn KEY_N;\n\tcase XK_N:\t\treturn KEY_N;\n\tcase XK_m:\t\treturn KEY_M;\n\tcase XK_M:\t\treturn KEY_M;\n\tcase XK_comma:\treturn KEY_COMMA;\n\tcase XK_less:\treturn KEY_COMMA;\n\tcase XK_period:\treturn KEY_DOT;\n\tcase XK_greater:\treturn KEY_DOT;\n\tcase XK_slash:\treturn KEY_SLASH;\n\tcase XK_question:\treturn KEY_SLASH;\n\tcase XK_Shift_R:\treturn KEY_RIGHTSHIFT;\n\tcase XK_KP_Multiply:\treturn KEY_KPASTERISK;\n\tcase XK_Alt_L:\treturn KEY_LEFTALT;\n\tcase XK_space:\treturn KEY_SPACE;\n\tcase XK_Caps_Lock:\treturn KEY_CAPSLOCK;\n\tcase XK_F1:\t\treturn KEY_F1;\n\tcase XK_F2:\t\treturn KEY_F2;\n\tcase XK_F3:\t\treturn KEY_F3;\n\tcase XK_F4:\t\treturn KEY_F4;\n\tcase XK_F5:\t\treturn KEY_F5;\n\tcase XK_F6:\t\treturn KEY_F6;\n\tcase XK_F7:\t\treturn KEY_F7;\n\tcase XK_F8:\t\treturn KEY_F8;\n\tcase XK_F9:\t\treturn KEY_F9;\n\tcase XK_F10:\t\treturn KEY_F10;\n\tcase XK_Num_Lock:\treturn KEY_NUMLOCK;\n\tcase XK_Scroll_Lock:\treturn KEY_SCROLLLOCK;\n\tcase XK_KP_7:\t\treturn KEY_KP7;\n\tcase XK_KP_8:\t\treturn KEY_KP8;\n\tcase XK_KP_9:\t\treturn KEY_KP9;\n\tcase XK_KP_Subtract:\treturn KEY_KPMINUS;\n\tcase XK_KP_4:\t\treturn KEY_KP4;\n\tcase XK_KP_5:\t\treturn KEY_KP5;\n\tcase XK_KP_6:\t\treturn KEY_KP6;\n\tcase XK_KP_Add:\treturn KEY_KPPLUS;\n\tcase XK_KP_1:\t\treturn KEY_KP1;\n\tcase XK_KP_2:\t\treturn KEY_KP2;\n\tcase XK_KP_3:\t\treturn KEY_KP3;\n\tcase XK_KP_0:\t\treturn KEY_KP0;\n\tcase XK_KP_Decimal:\treturn KEY_KPDOT;\n\tcase XK_F13:\t\treturn KEY_F13;\n\tcase XK_F11:\t\treturn KEY_F11;\n\tcase XK_F12:\t\treturn KEY_F12;\n\tcase XK_F14:\t\treturn KEY_F14;\n\tcase XK_F15:\t\treturn KEY_F15;\n\tcase XK_F16:\t\treturn KEY_F16;\n\tcase XK_F17:\t\treturn KEY_F17;\n\tcase XK_F18:\t\treturn KEY_F18;\n\tcase XK_F19:\t\treturn KEY_F19;\n\tcase XK_F20:\t\treturn KEY_F20;\n\tcase XK_KP_Enter:\treturn KEY_KPENTER;\n\tcase XK_Control_R:\treturn KEY_RIGHTCTRL;\n\tcase XK_KP_Divide:\treturn KEY_KPSLASH;\n\tcase XK_Sys_Req:\treturn KEY_SYSRQ;\n\tcase XK_Alt_R:\treturn KEY_RIGHTALT;\n\tcase XK_Linefeed:\treturn KEY_LINEFEED;\n\tcase XK_Home:\t\treturn KEY_HOME;\n\tcase XK_Up:\t\treturn KEY_UP;\n\tcase XK_Page_Up:\treturn KEY_PAGEUP;\n\tcase XK_Left:\t\treturn KEY_LEFT;\n\tcase XK_Right:\treturn KEY_RIGHT;\n\tcase XK_End:\t\treturn KEY_END;\n\tcase XK_Down:\t\treturn KEY_DOWN;\n\tcase XK_Page_Down:\treturn KEY_PAGEDOWN;\n\tcase XK_Insert:\treturn KEY_INSERT;\n\tcase XK_Delete:\treturn KEY_DELETE;\n\tcase XK_KP_Equal:\treturn KEY_KPEQUAL;\n\tcase XK_Pause:\treturn KEY_PAUSE;\n\tcase XK_F21:\t\treturn KEY_F21;\n\tcase XK_F22:\t\treturn KEY_F22;\n\tcase XK_F23:\t\treturn KEY_F23;\n\tcase XK_F24:\t\treturn KEY_F24;\n\tcase XK_KP_Separator:\treturn KEY_KPCOMMA;\n\tcase XK_Meta_L:\treturn KEY_LEFTMETA;\n\tcase XK_Meta_R:\treturn KEY_RIGHTMETA;\n\tcase XK_Multi_key:\treturn KEY_COMPOSE;\n#endif\n\tdefault:\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "static int lookup_code(int keysym);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nstatic int lookup_code(int keysym);\n\nstatic int lookup_code(int keysym) {\n\n\tif (keysym == NoSymbol) {\n\t\treturn -1;\n\t}\n\n\tswitch(keysym) {\n#ifdef UINPUT_OK\n\tcase XK_Escape:\treturn KEY_ESC;\n\tcase XK_1:\t\treturn KEY_1;\n\tcase XK_2:\t\treturn KEY_2;\n\tcase XK_3:\t\treturn KEY_3;\n\tcase XK_4:\t\treturn KEY_4;\n\tcase XK_5:\t\treturn KEY_5;\n\tcase XK_6:\t\treturn KEY_6;\n\tcase XK_7:\t\treturn KEY_7;\n\tcase XK_8:\t\treturn KEY_8;\n\tcase XK_9:\t\treturn KEY_9;\n\tcase XK_0:\t\treturn KEY_0;\n\tcase XK_exclam:\treturn KEY_1;\n\tcase XK_at:\t\treturn KEY_2;\n\tcase XK_numbersign:\treturn KEY_3;\n\tcase XK_dollar:\treturn KEY_4;\n\tcase XK_percent:\treturn KEY_5;\n\tcase XK_asciicircum:\treturn KEY_6;\n\tcase XK_ampersand:\treturn KEY_7;\n\tcase XK_asterisk:\treturn KEY_8;\n\tcase XK_parenleft:\treturn KEY_9;\n\tcase XK_parenright:\treturn KEY_0;\n\tcase XK_minus:\treturn KEY_MINUS;\n\tcase XK_underscore:\treturn KEY_MINUS;\n\tcase XK_equal:\treturn KEY_EQUAL;\n\tcase XK_plus:\treturn KEY_EQUAL;\n\tcase XK_BackSpace:\treturn KEY_BACKSPACE;\n\tcase XK_Tab:\t\treturn KEY_TAB;\n\tcase XK_q:\t\treturn KEY_Q;\n\tcase XK_Q:\t\treturn KEY_Q;\n\tcase XK_w:\t\treturn KEY_W;\n\tcase XK_W:\t\treturn KEY_W;\n\tcase XK_e:\t\treturn KEY_E;\n\tcase XK_E:\t\treturn KEY_E;\n\tcase XK_r:\t\treturn KEY_R;\n\tcase XK_R:\t\treturn KEY_R;\n\tcase XK_t:\t\treturn KEY_T;\n\tcase XK_T:\t\treturn KEY_T;\n\tcase XK_y:\t\treturn KEY_Y;\n\tcase XK_Y:\t\treturn KEY_Y;\n\tcase XK_u:\t\treturn KEY_U;\n\tcase XK_U:\t\treturn KEY_U;\n\tcase XK_i:\t\treturn KEY_I;\n\tcase XK_I:\t\treturn KEY_I;\n\tcase XK_o:\t\treturn KEY_O;\n\tcase XK_O:\t\treturn KEY_O;\n\tcase XK_p:\t\treturn KEY_P;\n\tcase XK_P:\t\treturn KEY_P;\n\tcase XK_braceleft:\treturn KEY_LEFTBRACE;\n\tcase XK_braceright:\treturn KEY_RIGHTBRACE;\n\tcase XK_bracketleft:\treturn KEY_LEFTBRACE;\n\tcase XK_bracketright:\treturn KEY_RIGHTBRACE;\n\tcase XK_Return:\treturn KEY_ENTER;\n\tcase XK_Control_L:\treturn KEY_LEFTCTRL;\n\tcase XK_a:\t\treturn KEY_A;\n\tcase XK_A:\t\treturn KEY_A;\n\tcase XK_s:\t\treturn KEY_S;\n\tcase XK_S:\t\treturn KEY_S;\n\tcase XK_d:\t\treturn KEY_D;\n\tcase XK_D:\t\treturn KEY_D;\n\tcase XK_f:\t\treturn KEY_F;\n\tcase XK_F:\t\treturn KEY_F;\n\tcase XK_g:\t\treturn KEY_G;\n\tcase XK_G:\t\treturn KEY_G;\n\tcase XK_h:\t\treturn KEY_H;\n\tcase XK_H:\t\treturn KEY_H;\n\tcase XK_j:\t\treturn KEY_J;\n\tcase XK_J:\t\treturn KEY_J;\n\tcase XK_k:\t\treturn KEY_K;\n\tcase XK_K:\t\treturn KEY_K;\n\tcase XK_l:\t\treturn KEY_L;\n\tcase XK_L:\t\treturn KEY_L;\n\tcase XK_semicolon:\treturn KEY_SEMICOLON;\n\tcase XK_colon:\treturn KEY_SEMICOLON;\n\tcase XK_apostrophe:\treturn KEY_APOSTROPHE;\n\tcase XK_quotedbl:\treturn KEY_APOSTROPHE;\n\tcase XK_grave:\treturn KEY_GRAVE;\n\tcase XK_asciitilde:\treturn KEY_GRAVE;\n\tcase XK_Shift_L:\treturn KEY_LEFTSHIFT;\n\tcase XK_backslash:\treturn KEY_BACKSLASH;\n\tcase XK_bar:\t\treturn KEY_BACKSLASH;\n\tcase XK_z:\t\treturn KEY_Z;\n\tcase XK_Z:\t\treturn KEY_Z;\n\tcase XK_x:\t\treturn KEY_X;\n\tcase XK_X:\t\treturn KEY_X;\n\tcase XK_c:\t\treturn KEY_C;\n\tcase XK_C:\t\treturn KEY_C;\n\tcase XK_v:\t\treturn KEY_V;\n\tcase XK_V:\t\treturn KEY_V;\n\tcase XK_b:\t\treturn KEY_B;\n\tcase XK_B:\t\treturn KEY_B;\n\tcase XK_n:\t\treturn KEY_N;\n\tcase XK_N:\t\treturn KEY_N;\n\tcase XK_m:\t\treturn KEY_M;\n\tcase XK_M:\t\treturn KEY_M;\n\tcase XK_comma:\treturn KEY_COMMA;\n\tcase XK_less:\treturn KEY_COMMA;\n\tcase XK_period:\treturn KEY_DOT;\n\tcase XK_greater:\treturn KEY_DOT;\n\tcase XK_slash:\treturn KEY_SLASH;\n\tcase XK_question:\treturn KEY_SLASH;\n\tcase XK_Shift_R:\treturn KEY_RIGHTSHIFT;\n\tcase XK_KP_Multiply:\treturn KEY_KPASTERISK;\n\tcase XK_Alt_L:\treturn KEY_LEFTALT;\n\tcase XK_space:\treturn KEY_SPACE;\n\tcase XK_Caps_Lock:\treturn KEY_CAPSLOCK;\n\tcase XK_F1:\t\treturn KEY_F1;\n\tcase XK_F2:\t\treturn KEY_F2;\n\tcase XK_F3:\t\treturn KEY_F3;\n\tcase XK_F4:\t\treturn KEY_F4;\n\tcase XK_F5:\t\treturn KEY_F5;\n\tcase XK_F6:\t\treturn KEY_F6;\n\tcase XK_F7:\t\treturn KEY_F7;\n\tcase XK_F8:\t\treturn KEY_F8;\n\tcase XK_F9:\t\treturn KEY_F9;\n\tcase XK_F10:\t\treturn KEY_F10;\n\tcase XK_Num_Lock:\treturn KEY_NUMLOCK;\n\tcase XK_Scroll_Lock:\treturn KEY_SCROLLLOCK;\n\tcase XK_KP_7:\t\treturn KEY_KP7;\n\tcase XK_KP_8:\t\treturn KEY_KP8;\n\tcase XK_KP_9:\t\treturn KEY_KP9;\n\tcase XK_KP_Subtract:\treturn KEY_KPMINUS;\n\tcase XK_KP_4:\t\treturn KEY_KP4;\n\tcase XK_KP_5:\t\treturn KEY_KP5;\n\tcase XK_KP_6:\t\treturn KEY_KP6;\n\tcase XK_KP_Add:\treturn KEY_KPPLUS;\n\tcase XK_KP_1:\t\treturn KEY_KP1;\n\tcase XK_KP_2:\t\treturn KEY_KP2;\n\tcase XK_KP_3:\t\treturn KEY_KP3;\n\tcase XK_KP_0:\t\treturn KEY_KP0;\n\tcase XK_KP_Decimal:\treturn KEY_KPDOT;\n\tcase XK_F13:\t\treturn KEY_F13;\n\tcase XK_F11:\t\treturn KEY_F11;\n\tcase XK_F12:\t\treturn KEY_F12;\n\tcase XK_F14:\t\treturn KEY_F14;\n\tcase XK_F15:\t\treturn KEY_F15;\n\tcase XK_F16:\t\treturn KEY_F16;\n\tcase XK_F17:\t\treturn KEY_F17;\n\tcase XK_F18:\t\treturn KEY_F18;\n\tcase XK_F19:\t\treturn KEY_F19;\n\tcase XK_F20:\t\treturn KEY_F20;\n\tcase XK_KP_Enter:\treturn KEY_KPENTER;\n\tcase XK_Control_R:\treturn KEY_RIGHTCTRL;\n\tcase XK_KP_Divide:\treturn KEY_KPSLASH;\n\tcase XK_Sys_Req:\treturn KEY_SYSRQ;\n\tcase XK_Alt_R:\treturn KEY_RIGHTALT;\n\tcase XK_Linefeed:\treturn KEY_LINEFEED;\n\tcase XK_Home:\t\treturn KEY_HOME;\n\tcase XK_Up:\t\treturn KEY_UP;\n\tcase XK_Page_Up:\treturn KEY_PAGEUP;\n\tcase XK_Left:\t\treturn KEY_LEFT;\n\tcase XK_Right:\treturn KEY_RIGHT;\n\tcase XK_End:\t\treturn KEY_END;\n\tcase XK_Down:\t\treturn KEY_DOWN;\n\tcase XK_Page_Down:\treturn KEY_PAGEDOWN;\n\tcase XK_Insert:\treturn KEY_INSERT;\n\tcase XK_Delete:\treturn KEY_DELETE;\n\tcase XK_KP_Equal:\treturn KEY_KPEQUAL;\n\tcase XK_Pause:\treturn KEY_PAUSE;\n\tcase XK_F21:\t\treturn KEY_F21;\n\tcase XK_F22:\t\treturn KEY_F22;\n\tcase XK_F23:\t\treturn KEY_F23;\n\tcase XK_F24:\t\treturn KEY_F24;\n\tcase XK_KP_Separator:\treturn KEY_KPCOMMA;\n\tcase XK_Meta_L:\treturn KEY_LEFTMETA;\n\tcase XK_Meta_R:\treturn KEY_RIGHTMETA;\n\tcase XK_Multi_key:\treturn KEY_COMPOSE;\n#endif\n\tdefault:\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "uinput_key_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "1244-1291",
    "snippet": "void uinput_key_command(int down, int keysym, rfbClientPtr client) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint scancode;\n\tallowed_input_t input;\n\tint d = direct_key_fd < 0 ? fd : direct_key_fd;\n\n\tif (injectable && strchr(injectable, 'K') == NULL) {\n\t\treturn;\n\t}\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\treturn;\n\t}\n\n\tscancode = lookup_code(keysym);\n\n\tif (scancode < 0) {\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"uinput_key_command: %d -> %d %s fd=%d\\n\", keysym, scancode, down ? \"down\" : \"up\", d);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_KEY;\n\tev.code = (unsigned char) scancode;\n\tev.value = down;\n\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n\n\tif (0 <= scancode && scancode < 256) {\n\t\tkey_pressed[scancode] = down ? 1 : 0;\n\t}\n#else\n\tif (!down || !keysym || !client) {}\n#endif\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define input_event_usec time.tv_usec",
      "#define input_event_sec time.tv_sec",
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "void uinput_pointer_command(int mask, int x, int y, rfbClientPtr client);",
      "void uinput_key_command(int down, int keysym, rfbClientPtr client);",
      "static int lookup_code(int keysym);",
      "static int fd = -1;",
      "static int direct_key_fd = -1;",
      "static int db = 0;",
      "static char *injectable = NULL;",
      "static int key_pressed[256];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "d",
            "&ev",
            "sizeof(ev)"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&tval",
            "NULL"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ev",
            "0",
            "sizeof(ev)"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"uinput_key_command: %d -> %d %s fd=%d\\n\"",
            "keysym",
            "scancode",
            "down ? \"down\" : \"up\"",
            "d"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_code",
          "args": [
            "keysym"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "1297-1474",
          "snippet": "static int lookup_code(int keysym) {\n\n\tif (keysym == NoSymbol) {\n\t\treturn -1;\n\t}\n\n\tswitch(keysym) {\n#ifdef UINPUT_OK\n\tcase XK_Escape:\treturn KEY_ESC;\n\tcase XK_1:\t\treturn KEY_1;\n\tcase XK_2:\t\treturn KEY_2;\n\tcase XK_3:\t\treturn KEY_3;\n\tcase XK_4:\t\treturn KEY_4;\n\tcase XK_5:\t\treturn KEY_5;\n\tcase XK_6:\t\treturn KEY_6;\n\tcase XK_7:\t\treturn KEY_7;\n\tcase XK_8:\t\treturn KEY_8;\n\tcase XK_9:\t\treturn KEY_9;\n\tcase XK_0:\t\treturn KEY_0;\n\tcase XK_exclam:\treturn KEY_1;\n\tcase XK_at:\t\treturn KEY_2;\n\tcase XK_numbersign:\treturn KEY_3;\n\tcase XK_dollar:\treturn KEY_4;\n\tcase XK_percent:\treturn KEY_5;\n\tcase XK_asciicircum:\treturn KEY_6;\n\tcase XK_ampersand:\treturn KEY_7;\n\tcase XK_asterisk:\treturn KEY_8;\n\tcase XK_parenleft:\treturn KEY_9;\n\tcase XK_parenright:\treturn KEY_0;\n\tcase XK_minus:\treturn KEY_MINUS;\n\tcase XK_underscore:\treturn KEY_MINUS;\n\tcase XK_equal:\treturn KEY_EQUAL;\n\tcase XK_plus:\treturn KEY_EQUAL;\n\tcase XK_BackSpace:\treturn KEY_BACKSPACE;\n\tcase XK_Tab:\t\treturn KEY_TAB;\n\tcase XK_q:\t\treturn KEY_Q;\n\tcase XK_Q:\t\treturn KEY_Q;\n\tcase XK_w:\t\treturn KEY_W;\n\tcase XK_W:\t\treturn KEY_W;\n\tcase XK_e:\t\treturn KEY_E;\n\tcase XK_E:\t\treturn KEY_E;\n\tcase XK_r:\t\treturn KEY_R;\n\tcase XK_R:\t\treturn KEY_R;\n\tcase XK_t:\t\treturn KEY_T;\n\tcase XK_T:\t\treturn KEY_T;\n\tcase XK_y:\t\treturn KEY_Y;\n\tcase XK_Y:\t\treturn KEY_Y;\n\tcase XK_u:\t\treturn KEY_U;\n\tcase XK_U:\t\treturn KEY_U;\n\tcase XK_i:\t\treturn KEY_I;\n\tcase XK_I:\t\treturn KEY_I;\n\tcase XK_o:\t\treturn KEY_O;\n\tcase XK_O:\t\treturn KEY_O;\n\tcase XK_p:\t\treturn KEY_P;\n\tcase XK_P:\t\treturn KEY_P;\n\tcase XK_braceleft:\treturn KEY_LEFTBRACE;\n\tcase XK_braceright:\treturn KEY_RIGHTBRACE;\n\tcase XK_bracketleft:\treturn KEY_LEFTBRACE;\n\tcase XK_bracketright:\treturn KEY_RIGHTBRACE;\n\tcase XK_Return:\treturn KEY_ENTER;\n\tcase XK_Control_L:\treturn KEY_LEFTCTRL;\n\tcase XK_a:\t\treturn KEY_A;\n\tcase XK_A:\t\treturn KEY_A;\n\tcase XK_s:\t\treturn KEY_S;\n\tcase XK_S:\t\treturn KEY_S;\n\tcase XK_d:\t\treturn KEY_D;\n\tcase XK_D:\t\treturn KEY_D;\n\tcase XK_f:\t\treturn KEY_F;\n\tcase XK_F:\t\treturn KEY_F;\n\tcase XK_g:\t\treturn KEY_G;\n\tcase XK_G:\t\treturn KEY_G;\n\tcase XK_h:\t\treturn KEY_H;\n\tcase XK_H:\t\treturn KEY_H;\n\tcase XK_j:\t\treturn KEY_J;\n\tcase XK_J:\t\treturn KEY_J;\n\tcase XK_k:\t\treturn KEY_K;\n\tcase XK_K:\t\treturn KEY_K;\n\tcase XK_l:\t\treturn KEY_L;\n\tcase XK_L:\t\treturn KEY_L;\n\tcase XK_semicolon:\treturn KEY_SEMICOLON;\n\tcase XK_colon:\treturn KEY_SEMICOLON;\n\tcase XK_apostrophe:\treturn KEY_APOSTROPHE;\n\tcase XK_quotedbl:\treturn KEY_APOSTROPHE;\n\tcase XK_grave:\treturn KEY_GRAVE;\n\tcase XK_asciitilde:\treturn KEY_GRAVE;\n\tcase XK_Shift_L:\treturn KEY_LEFTSHIFT;\n\tcase XK_backslash:\treturn KEY_BACKSLASH;\n\tcase XK_bar:\t\treturn KEY_BACKSLASH;\n\tcase XK_z:\t\treturn KEY_Z;\n\tcase XK_Z:\t\treturn KEY_Z;\n\tcase XK_x:\t\treturn KEY_X;\n\tcase XK_X:\t\treturn KEY_X;\n\tcase XK_c:\t\treturn KEY_C;\n\tcase XK_C:\t\treturn KEY_C;\n\tcase XK_v:\t\treturn KEY_V;\n\tcase XK_V:\t\treturn KEY_V;\n\tcase XK_b:\t\treturn KEY_B;\n\tcase XK_B:\t\treturn KEY_B;\n\tcase XK_n:\t\treturn KEY_N;\n\tcase XK_N:\t\treturn KEY_N;\n\tcase XK_m:\t\treturn KEY_M;\n\tcase XK_M:\t\treturn KEY_M;\n\tcase XK_comma:\treturn KEY_COMMA;\n\tcase XK_less:\treturn KEY_COMMA;\n\tcase XK_period:\treturn KEY_DOT;\n\tcase XK_greater:\treturn KEY_DOT;\n\tcase XK_slash:\treturn KEY_SLASH;\n\tcase XK_question:\treturn KEY_SLASH;\n\tcase XK_Shift_R:\treturn KEY_RIGHTSHIFT;\n\tcase XK_KP_Multiply:\treturn KEY_KPASTERISK;\n\tcase XK_Alt_L:\treturn KEY_LEFTALT;\n\tcase XK_space:\treturn KEY_SPACE;\n\tcase XK_Caps_Lock:\treturn KEY_CAPSLOCK;\n\tcase XK_F1:\t\treturn KEY_F1;\n\tcase XK_F2:\t\treturn KEY_F2;\n\tcase XK_F3:\t\treturn KEY_F3;\n\tcase XK_F4:\t\treturn KEY_F4;\n\tcase XK_F5:\t\treturn KEY_F5;\n\tcase XK_F6:\t\treturn KEY_F6;\n\tcase XK_F7:\t\treturn KEY_F7;\n\tcase XK_F8:\t\treturn KEY_F8;\n\tcase XK_F9:\t\treturn KEY_F9;\n\tcase XK_F10:\t\treturn KEY_F10;\n\tcase XK_Num_Lock:\treturn KEY_NUMLOCK;\n\tcase XK_Scroll_Lock:\treturn KEY_SCROLLLOCK;\n\tcase XK_KP_7:\t\treturn KEY_KP7;\n\tcase XK_KP_8:\t\treturn KEY_KP8;\n\tcase XK_KP_9:\t\treturn KEY_KP9;\n\tcase XK_KP_Subtract:\treturn KEY_KPMINUS;\n\tcase XK_KP_4:\t\treturn KEY_KP4;\n\tcase XK_KP_5:\t\treturn KEY_KP5;\n\tcase XK_KP_6:\t\treturn KEY_KP6;\n\tcase XK_KP_Add:\treturn KEY_KPPLUS;\n\tcase XK_KP_1:\t\treturn KEY_KP1;\n\tcase XK_KP_2:\t\treturn KEY_KP2;\n\tcase XK_KP_3:\t\treturn KEY_KP3;\n\tcase XK_KP_0:\t\treturn KEY_KP0;\n\tcase XK_KP_Decimal:\treturn KEY_KPDOT;\n\tcase XK_F13:\t\treturn KEY_F13;\n\tcase XK_F11:\t\treturn KEY_F11;\n\tcase XK_F12:\t\treturn KEY_F12;\n\tcase XK_F14:\t\treturn KEY_F14;\n\tcase XK_F15:\t\treturn KEY_F15;\n\tcase XK_F16:\t\treturn KEY_F16;\n\tcase XK_F17:\t\treturn KEY_F17;\n\tcase XK_F18:\t\treturn KEY_F18;\n\tcase XK_F19:\t\treturn KEY_F19;\n\tcase XK_F20:\t\treturn KEY_F20;\n\tcase XK_KP_Enter:\treturn KEY_KPENTER;\n\tcase XK_Control_R:\treturn KEY_RIGHTCTRL;\n\tcase XK_KP_Divide:\treturn KEY_KPSLASH;\n\tcase XK_Sys_Req:\treturn KEY_SYSRQ;\n\tcase XK_Alt_R:\treturn KEY_RIGHTALT;\n\tcase XK_Linefeed:\treturn KEY_LINEFEED;\n\tcase XK_Home:\t\treturn KEY_HOME;\n\tcase XK_Up:\t\treturn KEY_UP;\n\tcase XK_Page_Up:\treturn KEY_PAGEUP;\n\tcase XK_Left:\t\treturn KEY_LEFT;\n\tcase XK_Right:\treturn KEY_RIGHT;\n\tcase XK_End:\t\treturn KEY_END;\n\tcase XK_Down:\t\treturn KEY_DOWN;\n\tcase XK_Page_Down:\treturn KEY_PAGEDOWN;\n\tcase XK_Insert:\treturn KEY_INSERT;\n\tcase XK_Delete:\treturn KEY_DELETE;\n\tcase XK_KP_Equal:\treturn KEY_KPEQUAL;\n\tcase XK_Pause:\treturn KEY_PAUSE;\n\tcase XK_F21:\t\treturn KEY_F21;\n\tcase XK_F22:\t\treturn KEY_F22;\n\tcase XK_F23:\t\treturn KEY_F23;\n\tcase XK_F24:\t\treturn KEY_F24;\n\tcase XK_KP_Separator:\treturn KEY_KPCOMMA;\n\tcase XK_Meta_L:\treturn KEY_LEFTMETA;\n\tcase XK_Meta_R:\treturn KEY_RIGHTMETA;\n\tcase XK_Multi_key:\treturn KEY_COMPOSE;\n#endif\n\tdefault:\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "static int lookup_code(int keysym);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nstatic int lookup_code(int keysym);\n\nstatic int lookup_code(int keysym) {\n\n\tif (keysym == NoSymbol) {\n\t\treturn -1;\n\t}\n\n\tswitch(keysym) {\n#ifdef UINPUT_OK\n\tcase XK_Escape:\treturn KEY_ESC;\n\tcase XK_1:\t\treturn KEY_1;\n\tcase XK_2:\t\treturn KEY_2;\n\tcase XK_3:\t\treturn KEY_3;\n\tcase XK_4:\t\treturn KEY_4;\n\tcase XK_5:\t\treturn KEY_5;\n\tcase XK_6:\t\treturn KEY_6;\n\tcase XK_7:\t\treturn KEY_7;\n\tcase XK_8:\t\treturn KEY_8;\n\tcase XK_9:\t\treturn KEY_9;\n\tcase XK_0:\t\treturn KEY_0;\n\tcase XK_exclam:\treturn KEY_1;\n\tcase XK_at:\t\treturn KEY_2;\n\tcase XK_numbersign:\treturn KEY_3;\n\tcase XK_dollar:\treturn KEY_4;\n\tcase XK_percent:\treturn KEY_5;\n\tcase XK_asciicircum:\treturn KEY_6;\n\tcase XK_ampersand:\treturn KEY_7;\n\tcase XK_asterisk:\treturn KEY_8;\n\tcase XK_parenleft:\treturn KEY_9;\n\tcase XK_parenright:\treturn KEY_0;\n\tcase XK_minus:\treturn KEY_MINUS;\n\tcase XK_underscore:\treturn KEY_MINUS;\n\tcase XK_equal:\treturn KEY_EQUAL;\n\tcase XK_plus:\treturn KEY_EQUAL;\n\tcase XK_BackSpace:\treturn KEY_BACKSPACE;\n\tcase XK_Tab:\t\treturn KEY_TAB;\n\tcase XK_q:\t\treturn KEY_Q;\n\tcase XK_Q:\t\treturn KEY_Q;\n\tcase XK_w:\t\treturn KEY_W;\n\tcase XK_W:\t\treturn KEY_W;\n\tcase XK_e:\t\treturn KEY_E;\n\tcase XK_E:\t\treturn KEY_E;\n\tcase XK_r:\t\treturn KEY_R;\n\tcase XK_R:\t\treturn KEY_R;\n\tcase XK_t:\t\treturn KEY_T;\n\tcase XK_T:\t\treturn KEY_T;\n\tcase XK_y:\t\treturn KEY_Y;\n\tcase XK_Y:\t\treturn KEY_Y;\n\tcase XK_u:\t\treturn KEY_U;\n\tcase XK_U:\t\treturn KEY_U;\n\tcase XK_i:\t\treturn KEY_I;\n\tcase XK_I:\t\treturn KEY_I;\n\tcase XK_o:\t\treturn KEY_O;\n\tcase XK_O:\t\treturn KEY_O;\n\tcase XK_p:\t\treturn KEY_P;\n\tcase XK_P:\t\treturn KEY_P;\n\tcase XK_braceleft:\treturn KEY_LEFTBRACE;\n\tcase XK_braceright:\treturn KEY_RIGHTBRACE;\n\tcase XK_bracketleft:\treturn KEY_LEFTBRACE;\n\tcase XK_bracketright:\treturn KEY_RIGHTBRACE;\n\tcase XK_Return:\treturn KEY_ENTER;\n\tcase XK_Control_L:\treturn KEY_LEFTCTRL;\n\tcase XK_a:\t\treturn KEY_A;\n\tcase XK_A:\t\treturn KEY_A;\n\tcase XK_s:\t\treturn KEY_S;\n\tcase XK_S:\t\treturn KEY_S;\n\tcase XK_d:\t\treturn KEY_D;\n\tcase XK_D:\t\treturn KEY_D;\n\tcase XK_f:\t\treturn KEY_F;\n\tcase XK_F:\t\treturn KEY_F;\n\tcase XK_g:\t\treturn KEY_G;\n\tcase XK_G:\t\treturn KEY_G;\n\tcase XK_h:\t\treturn KEY_H;\n\tcase XK_H:\t\treturn KEY_H;\n\tcase XK_j:\t\treturn KEY_J;\n\tcase XK_J:\t\treturn KEY_J;\n\tcase XK_k:\t\treturn KEY_K;\n\tcase XK_K:\t\treturn KEY_K;\n\tcase XK_l:\t\treturn KEY_L;\n\tcase XK_L:\t\treturn KEY_L;\n\tcase XK_semicolon:\treturn KEY_SEMICOLON;\n\tcase XK_colon:\treturn KEY_SEMICOLON;\n\tcase XK_apostrophe:\treturn KEY_APOSTROPHE;\n\tcase XK_quotedbl:\treturn KEY_APOSTROPHE;\n\tcase XK_grave:\treturn KEY_GRAVE;\n\tcase XK_asciitilde:\treturn KEY_GRAVE;\n\tcase XK_Shift_L:\treturn KEY_LEFTSHIFT;\n\tcase XK_backslash:\treturn KEY_BACKSLASH;\n\tcase XK_bar:\t\treturn KEY_BACKSLASH;\n\tcase XK_z:\t\treturn KEY_Z;\n\tcase XK_Z:\t\treturn KEY_Z;\n\tcase XK_x:\t\treturn KEY_X;\n\tcase XK_X:\t\treturn KEY_X;\n\tcase XK_c:\t\treturn KEY_C;\n\tcase XK_C:\t\treturn KEY_C;\n\tcase XK_v:\t\treturn KEY_V;\n\tcase XK_V:\t\treturn KEY_V;\n\tcase XK_b:\t\treturn KEY_B;\n\tcase XK_B:\t\treturn KEY_B;\n\tcase XK_n:\t\treturn KEY_N;\n\tcase XK_N:\t\treturn KEY_N;\n\tcase XK_m:\t\treturn KEY_M;\n\tcase XK_M:\t\treturn KEY_M;\n\tcase XK_comma:\treturn KEY_COMMA;\n\tcase XK_less:\treturn KEY_COMMA;\n\tcase XK_period:\treturn KEY_DOT;\n\tcase XK_greater:\treturn KEY_DOT;\n\tcase XK_slash:\treturn KEY_SLASH;\n\tcase XK_question:\treturn KEY_SLASH;\n\tcase XK_Shift_R:\treturn KEY_RIGHTSHIFT;\n\tcase XK_KP_Multiply:\treturn KEY_KPASTERISK;\n\tcase XK_Alt_L:\treturn KEY_LEFTALT;\n\tcase XK_space:\treturn KEY_SPACE;\n\tcase XK_Caps_Lock:\treturn KEY_CAPSLOCK;\n\tcase XK_F1:\t\treturn KEY_F1;\n\tcase XK_F2:\t\treturn KEY_F2;\n\tcase XK_F3:\t\treturn KEY_F3;\n\tcase XK_F4:\t\treturn KEY_F4;\n\tcase XK_F5:\t\treturn KEY_F5;\n\tcase XK_F6:\t\treturn KEY_F6;\n\tcase XK_F7:\t\treturn KEY_F7;\n\tcase XK_F8:\t\treturn KEY_F8;\n\tcase XK_F9:\t\treturn KEY_F9;\n\tcase XK_F10:\t\treturn KEY_F10;\n\tcase XK_Num_Lock:\treturn KEY_NUMLOCK;\n\tcase XK_Scroll_Lock:\treturn KEY_SCROLLLOCK;\n\tcase XK_KP_7:\t\treturn KEY_KP7;\n\tcase XK_KP_8:\t\treturn KEY_KP8;\n\tcase XK_KP_9:\t\treturn KEY_KP9;\n\tcase XK_KP_Subtract:\treturn KEY_KPMINUS;\n\tcase XK_KP_4:\t\treturn KEY_KP4;\n\tcase XK_KP_5:\t\treturn KEY_KP5;\n\tcase XK_KP_6:\t\treturn KEY_KP6;\n\tcase XK_KP_Add:\treturn KEY_KPPLUS;\n\tcase XK_KP_1:\t\treturn KEY_KP1;\n\tcase XK_KP_2:\t\treturn KEY_KP2;\n\tcase XK_KP_3:\t\treturn KEY_KP3;\n\tcase XK_KP_0:\t\treturn KEY_KP0;\n\tcase XK_KP_Decimal:\treturn KEY_KPDOT;\n\tcase XK_F13:\t\treturn KEY_F13;\n\tcase XK_F11:\t\treturn KEY_F11;\n\tcase XK_F12:\t\treturn KEY_F12;\n\tcase XK_F14:\t\treturn KEY_F14;\n\tcase XK_F15:\t\treturn KEY_F15;\n\tcase XK_F16:\t\treturn KEY_F16;\n\tcase XK_F17:\t\treturn KEY_F17;\n\tcase XK_F18:\t\treturn KEY_F18;\n\tcase XK_F19:\t\treturn KEY_F19;\n\tcase XK_F20:\t\treturn KEY_F20;\n\tcase XK_KP_Enter:\treturn KEY_KPENTER;\n\tcase XK_Control_R:\treturn KEY_RIGHTCTRL;\n\tcase XK_KP_Divide:\treturn KEY_KPSLASH;\n\tcase XK_Sys_Req:\treturn KEY_SYSRQ;\n\tcase XK_Alt_R:\treturn KEY_RIGHTALT;\n\tcase XK_Linefeed:\treturn KEY_LINEFEED;\n\tcase XK_Home:\t\treturn KEY_HOME;\n\tcase XK_Up:\t\treturn KEY_UP;\n\tcase XK_Page_Up:\treturn KEY_PAGEUP;\n\tcase XK_Left:\t\treturn KEY_LEFT;\n\tcase XK_Right:\treturn KEY_RIGHT;\n\tcase XK_End:\t\treturn KEY_END;\n\tcase XK_Down:\t\treturn KEY_DOWN;\n\tcase XK_Page_Down:\treturn KEY_PAGEDOWN;\n\tcase XK_Insert:\treturn KEY_INSERT;\n\tcase XK_Delete:\treturn KEY_DELETE;\n\tcase XK_KP_Equal:\treturn KEY_KPEQUAL;\n\tcase XK_Pause:\treturn KEY_PAUSE;\n\tcase XK_F21:\t\treturn KEY_F21;\n\tcase XK_F22:\t\treturn KEY_F22;\n\tcase XK_F23:\t\treturn KEY_F23;\n\tcase XK_F24:\t\treturn KEY_F24;\n\tcase XK_KP_Separator:\treturn KEY_KPCOMMA;\n\tcase XK_Meta_L:\treturn KEY_LEFTMETA;\n\tcase XK_Meta_R:\treturn KEY_RIGHTMETA;\n\tcase XK_Multi_key:\treturn KEY_COMPOSE;\n#endif\n\tdefault:\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_allowed_input",
          "args": [
            "client",
            "&input"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "get_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2791-2847",
          "snippet": "void get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\n\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "injectable",
            "'K'"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nvoid uinput_pointer_command(int mask, int x, int y, rfbClientPtr client);\nvoid uinput_key_command(int down, int keysym, rfbClientPtr client);\nstatic int lookup_code(int keysym);\nstatic int fd = -1;\nstatic int direct_key_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\nstatic int key_pressed[256];\n\nvoid uinput_key_command(int down, int keysym, rfbClientPtr client) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint scancode;\n\tallowed_input_t input;\n\tint d = direct_key_fd < 0 ? fd : direct_key_fd;\n\n\tif (injectable && strchr(injectable, 'K') == NULL) {\n\t\treturn;\n\t}\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\tif (! input.keystroke) {\n\t\treturn;\n\t}\n\n\tscancode = lookup_code(keysym);\n\n\tif (scancode < 0) {\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"uinput_key_command: %d -> %d %s fd=%d\\n\", keysym, scancode, down ? \"down\" : \"up\", d);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_KEY;\n\tev.code = (unsigned char) scancode;\n\tev.value = down;\n\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n\n\tif (0 <= scancode && scancode < 256) {\n\t\tkey_pressed[scancode] = down ? 1 : 0;\n\t}\n#else\n\tif (!down || !keysym || !client) {}\n#endif\n}"
  },
  {
    "function_name": "uinput_pointer_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "1011-1242",
    "snippet": "void uinput_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\tstatic int last_x = -1, last_y = -1, last_mask = -1;\n\tstatic double last_zero = 0.0;\n\tallowed_input_t input;\n\tint do_reset, reset_lower_right = 1;\n\tdouble now;\n\tstatic int first = 1;\n\tClientData *cd = (ClientData *) client->clientData;\n\n\tif (first) {\n\t\tif (getenv(\"RESET_ALWAYS\")) {\n\t\t\tset_uinput_always(1);\n\t\t} else {\n\t\t\tset_uinput_always(0);\n\t\t}\n\t}\n\tfirst = 0;\n\t\n\tif (db) fprintf(stderr, \"uinput_pointer_command: %d %d - %d\\n\", x, y, mask);\n\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\n\tnow = dnow();\n\n\tdo_reset = 1;\n\tif (mask || bmask) {\n\t\tdo_reset = 0;\t/* do not do reset if mouse button down */\n\t} else if (! input.motion) {\n\t\tdo_reset = 0;\n\t} else if (now < last_zero + zero_delay) {\n\t\tdo_reset = 0;\n\t}\n\tif (do_reset) {\n\t\tif (mod_is_down()) {\n\t\t\tdo_reset = 0;\n\t\t} else if (now < last_button_click + 0.25) {\n\t\t\tdo_reset = 0;\n\t\t}\n\t}\n\n\tif (uinput_always && !mask && !bmask && input.motion) {\n\t\tdo_reset = 1;\n\t}\n\tif (uinput_abs) {\n\t\tdo_reset = 0;\n\t}\n\n\tif (do_reset) {\n\t\tstatic int first = 1;\n\n\t\tif (zero_delay > 0.0 || first) {\n\t\t\t/* try to push it to 0,0 */\n\t\t\tint tx, ty, bigjump = 1;\n\n\t\t\tif (reset_lower_right) {\n\t\t\t\ttx = fudge_x * (dpy_x - last_x);\n\t\t\t\tty = fudge_y * (dpy_y - last_y);\n\t\t\t} else {\n\t\t\t\ttx = fudge_x * last_x;\n\t\t\t\tty = fudge_y * last_y;\n\t\t\t}\n\n\t\t\ttx += 50;\n\t\t\tty += 50;\n\n\t\t\tif (bigjump) {\n\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\tptr_move(0, +ty);\n\t\t\t\t\tusleep(2*1000);\n\t\t\t\t\tptr_move(+tx, +ty);\n\t\t\t\t\tptr_move(+tx, +ty);\n\t\t\t\t} else {\n\t\t\t\t\tptr_move(0, -ty);\n\t\t\t\t\tusleep(2*1000);\n\t\t\t\t\tptr_move(-tx, -ty);\n\t\t\t\t\tptr_move(-tx, -ty);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint i, step, n = 20;\n\t\t\t\tstep = dpy_x / n;\n\n\t\t\t\tif (step < 100) step = 100;\n\n\t\t\t\tfor (i=0; i < n; i++)  {\n\t\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\t\tptr_move(+step, +step);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tptr_move(-step, -step);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i=0; i < n; i++)  {\n\t\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\t\tptr_move(+1, +1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tptr_move(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (db) {\n\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\tfprintf(stderr, \"uinput_pointer_command: reset -> (W,H) (%d,%d)  [%d,%d]\\n\", x, y, tx, ty);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"uinput_pointer_command: reset -> (0,0) (%d,%d)  [%d,%d]\\n\", x, y, tx, ty);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* rest a bit for system to absorb the change */\n\t\t\tif (uinput_always) {\n\t\t\t\tstatic double last_sleep = 0.0;\n\t\t\t\tdouble nw = dnow(), delay = zero_delay;\n\t\t\t\tif (delay <= 0.0) delay = 0.1;\n\t\t\t\tif (nw > last_sleep + delay) {\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tlast_sleep = nw;\n\t\t\t\t} else {\n\t\t\t\t\tusleep(1*1000);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tusleep(30*1000);\n\t\t\t}\n\n\t\t\t/* now jump back out */\n\t\t\tif (reset_lower_right) {\n\t\t\t\tptr_rel(x - dpy_x, y - dpy_y);\n\t\t\t} else {\n\t\t\t\tptr_rel(x, y);\n\t\t\t}\n\t\t\tif (1) {usleep(10*1000) ;}\n\n\t\t\tlast_x = x;\n\t\t\tlast_y = y;\n\t\t\tresid_x = 0.0;\n\t\t\tresid_y = 0.0;\n\n\t\t\tfirst = 0;\n\t\t}\n\t\tlast_zero = dnow();\n\t}\n\n\tif (input.motion) {\n\t\tif (x != last_x || y != last_y) {\n\t\t\tif (uinput_touchscreen) {\n\t\t\t\t;\n\t\t\t} else if (uinput_abs) {\n\t\t\t\tptr_abs(x, y, -1);\n\t\t\t} else {\n\t\t\t\tptr_rel(x - last_x, y - last_y);\n\t\t\t}\n\t\t\tlast_x = x;\n\t\t\tlast_y = y;\n\t\t}\n\t}\n\n\tif (! input.button) {\n\t\treturn;\n\t}\n\n\tif (last_mask < 0) {\n\t\tlast_mask = mask;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"mask:        %s\\n\", bitprint(mask, 16));\n\t\tfprintf(stderr, \"bmask:       %s\\n\", bitprint(bmask, 16));\n\t\tfprintf(stderr, \"last_mask:   %s\\n\", bitprint(last_mask, 16));\n\t\tfprintf(stderr, \"button_mask: %s\\n\", bitprint(cd->ptr_buttonmask, 16));\n\t}\n\n\tif (uinput_touchscreen) {\n\t\tif (!btn_touch) {\n\t\t\tstatic int down_count = 0;\n\t\t\tint p = touch_pressure >=0 ? touch_pressure : 0;\n\t\t\tif (!last_mask && !mask) {\n\t\t\t\tif (touch_always) {\n\t\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\t}\n\t\t\t} else if (!last_mask && mask) {\n\t\t\t\tptr_abs(last_x, last_y, p);\n\t\t\t\tdown_count = 0;\n\t\t\t} else if (last_mask && !mask) {\n\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t} else if (last_mask && mask) {\n\t\t\t\tdown_count++;\n\t\t\t\tif (dragskip > 0) {\n\t\t\t\t\tif (down_count % dragskip == 0) {\n\t\t\t\t\t\tptr_abs(last_x, last_y, p);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tptr_abs(last_x, last_y, p);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!last_mask && !mask) {\n\t\t\t\tif (touch_always) {\n\t\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\t}\n\t\t\t} else if (!last_mask && mask) {\n\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\tbutton_click(1, 0);\n\t\t\t} else if (last_mask && !mask) {\n\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\tbutton_click(0, 0);\n\t\t\t} else if (last_mask && mask) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tlast_mask = mask;\n\t} else if (mask != last_mask) {\n\t\tint i;\n\t\tfor (i=1; i <= MAX_BUTTONS; i++) {\n\t\t\tint down, b = 1 << (i-1);\n\t\t\tif ( (last_mask & b) == (mask & b)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mask & b) {\n\t\t\t\tdown = 1;\n\t\t\t} else {\n\t\t\t\tdown = 0;\n\t\t\t}\n\t\t\tbutton_click(down, i);\n\t\t}\n\t\tif (mask && uinput_abs && touch_pressure >= 0) {\n\t\t\tptr_abs(last_x, last_y, touch_pressure);\n\t\t}\n\t\tlast_mask = mask;\n\t}\n\tbmask = mask;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_uinput_always(int);",
      "void uinput_pointer_command(int mask, int x, int y, rfbClientPtr client);",
      "void uinput_key_command(int down, int keysym, rfbClientPtr client);",
      "static int mod_is_down(void);",
      "static int bmask = 0;",
      "static int db = 0;",
      "static double a[7];",
      "static int uinput_touchscreen = 0;",
      "static int uinput_abs = 0;",
      "static int btn_touch = 0;",
      "static int dragskip = 0;",
      "static int touch_always = 0;",
      "static int touch_pressure = 1;",
      "static double fudge_x = 0.5;",
      "static double fudge_y = 0.5;",
      "static double resid_x = 0.0;",
      "static double resid_y = 0.0;",
      "static double zero_delay = 0.15;",
      "static double last_button_click = 0.0;",
      "static int uinput_always = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr_abs",
          "args": [
            "last_x",
            "last_y",
            "touch_pressure"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "763-819",
          "snippet": "static void ptr_abs(int x, int y, int p) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint x0, y0;\n\tint d = direct_abs_fd < 0 ? fd : direct_abs_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tx0 = x;\n\ty0 = y;\n\n\tif (tslib_cal) {\n\t\tapply_tslib(&x, &y);\n\t}\n\n\tif (db) fprintf(stderr, \"ptr_abs(%d, %d => %d %d, p=%d) fd=%d\\n\", x0, y0, x, y, p, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_ABS;\n\tev.code = ABS_Y;\n\tev.value = y;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_ABS;\n\tev.code = ABS_X;\n\tev.value = x;\n\twrite(d, &ev, sizeof(ev));\n\n\tif (p >= 0) {\n\t\tev.type = EV_ABS;\n\t\tev.code = ABS_PRESSURE;\n\t\tev.value = p;\n\t\twrite(d, &ev, sizeof(ev));\n\n\t\tif (!btn_touch) {\n\t\t\tev.type = EV_KEY;\n\t\t\tev.code = BTN_TOUCH;\n\t\t\tev.value = p ? 1 : 0;\n\t\t\twrite(d, &ev, sizeof(ev));\n\t\t}\n\t}\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!x || !y) {}\n#endif\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define input_event_usec time.tv_usec",
            "#define input_event_sec time.tv_sec",
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "static int fd = -1;",
            "static int direct_abs_fd = -1;",
            "static int db = 0;",
            "static char *injectable = NULL;",
            "static char *tslib_cal = NULL;",
            "static int btn_touch = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nstatic int fd = -1;\nstatic int direct_abs_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\nstatic char *tslib_cal = NULL;\nstatic int btn_touch = 0;\n\nstatic void ptr_abs(int x, int y, int p) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint x0, y0;\n\tint d = direct_abs_fd < 0 ? fd : direct_abs_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tx0 = x;\n\ty0 = y;\n\n\tif (tslib_cal) {\n\t\tapply_tslib(&x, &y);\n\t}\n\n\tif (db) fprintf(stderr, \"ptr_abs(%d, %d => %d %d, p=%d) fd=%d\\n\", x0, y0, x, y, p, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_ABS;\n\tev.code = ABS_Y;\n\tev.value = y;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_ABS;\n\tev.code = ABS_X;\n\tev.value = x;\n\twrite(d, &ev, sizeof(ev));\n\n\tif (p >= 0) {\n\t\tev.type = EV_ABS;\n\t\tev.code = ABS_PRESSURE;\n\t\tev.value = p;\n\t\twrite(d, &ev, sizeof(ev));\n\n\t\tif (!btn_touch) {\n\t\t\tev.type = EV_KEY;\n\t\t\tev.code = BTN_TOUCH;\n\t\t\tev.value = p ? 1 : 0;\n\t\t\twrite(d, &ev, sizeof(ev));\n\t\t}\n\t}\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!x || !y) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "button_click",
          "args": [
            "down",
            "i"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "button_click",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "961-1008",
          "snippet": "static void button_click(int down, int btn) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_btn_fd < 0 ? fd : direct_btn_fd;\n\n\tif (injectable && strchr(injectable, 'B') == NULL) {\n\t\treturn;\n\t}\n\n\tif (db) fprintf(stderr, \"button_click: btn %d %s fd=%d\\n\", btn, down ? \"down\" : \"up\", d);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_KEY;\n\tev.value = down;\n\n\tif (uinput_touchscreen) {\n\t\tev.code = BTN_TOUCH;\n\t\tif (db) fprintf(stderr, \"set code to BTN_TOUCH\\n\");\n\t} else if (btn == 1) {\n\t\tev.code = BTN_LEFT;\n\t} else if (btn == 2) {\n\t\tev.code = BTN_MIDDLE;\n\t} else if (btn == 3) {\n\t\tev.code = BTN_RIGHT;\n\t} else if (btn == 4) {\n\t\tev.code = BTN_FORWARD;\n\t} else if (btn == 5) {\n\t\tev.code = BTN_BACK;\n\t} else {\n\t\treturn;\n\t}\n\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n\n\tlast_button_click = dnow();\n#else\n\tif (!down || !btn) {}\n#endif\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define input_event_usec time.tv_usec",
            "#define input_event_sec time.tv_sec",
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "static void button_click(int down, int btn);",
            "static int fd = -1;",
            "static int direct_btn_fd = -1;",
            "static int db = 0;",
            "static char *injectable = NULL;",
            "static int uinput_touchscreen = 0;",
            "static double last_button_click = 0.0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nstatic void button_click(int down, int btn);\nstatic int fd = -1;\nstatic int direct_btn_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\nstatic int uinput_touchscreen = 0;\nstatic double last_button_click = 0.0;\n\nstatic void button_click(int down, int btn) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_btn_fd < 0 ? fd : direct_btn_fd;\n\n\tif (injectable && strchr(injectable, 'B') == NULL) {\n\t\treturn;\n\t}\n\n\tif (db) fprintf(stderr, \"button_click: btn %d %s fd=%d\\n\", btn, down ? \"down\" : \"up\", d);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_KEY;\n\tev.value = down;\n\n\tif (uinput_touchscreen) {\n\t\tev.code = BTN_TOUCH;\n\t\tif (db) fprintf(stderr, \"set code to BTN_TOUCH\\n\");\n\t} else if (btn == 1) {\n\t\tev.code = BTN_LEFT;\n\t} else if (btn == 2) {\n\t\tev.code = BTN_MIDDLE;\n\t} else if (btn == 3) {\n\t\tev.code = BTN_RIGHT;\n\t} else if (btn == 4) {\n\t\tev.code = BTN_FORWARD;\n\t} else if (btn == 5) {\n\t\tev.code = BTN_BACK;\n\t} else {\n\t\treturn;\n\t}\n\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n\n\tlast_button_click = dnow();\n#else\n\tif (!down || !btn) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"button_mask: %s\\n\"",
            "bitprint(cd->ptr_buttonmask, 16)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitprint",
          "args": [
            "cd->ptr_buttonmask",
            "16"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "bitprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "251-269",
          "snippet": "char *bitprint(unsigned int st, int nbits) {\n\tstatic char str[33];\n\tint i, mask;\n\tif (nbits > 32) {\n\t\tnbits = 32;\n\t}\n\tfor (i=0; i<nbits; i++) {\n\t\tstr[i] = '0';\n\t}\n\tstr[nbits] = '\\0';\n\tmask = 1;\n\tfor (i=nbits-1; i>=0; i--) {\n\t\tif (st & mask) {\n\t\t\tstr[i] = '1';\n\t\t}\n\t\tmask = mask << 1;\n\t}\n\treturn str;\t/* take care to use or copy immediately */\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "char *bitprint(unsigned int st, int nbits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nchar *bitprint(unsigned int st, int nbits);\n\nchar *bitprint(unsigned int st, int nbits) {\n\tstatic char str[33];\n\tint i, mask;\n\tif (nbits > 32) {\n\t\tnbits = 32;\n\t}\n\tfor (i=0; i<nbits; i++) {\n\t\tstr[i] = '0';\n\t}\n\tstr[nbits] = '\\0';\n\tmask = 1;\n\tfor (i=nbits-1; i>=0; i--) {\n\t\tif (st & mask) {\n\t\t\tstr[i] = '1';\n\t\t}\n\t\tmask = mask << 1;\n\t}\n\treturn str;\t/* take care to use or copy immediately */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"last_mask:   %s\\n\"",
            "bitprint(last_mask, 16)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bmask:       %s\\n\"",
            "bitprint(bmask, 16)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"mask:        %s\\n\"",
            "bitprint(mask, 16)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_rel",
          "args": [
            "x - last_x",
            "y - last_y"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_rel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "836-959",
          "snippet": "static void ptr_rel(int dx, int dy) {\n\tint dxf, dyf, nx, ny, k;\n\tint accel, thresh_high, thresh_mid;\n\tdouble fx, fy;\n\tstatic int try_threshes = -1;\n\n\tif (try_threshes < 0) {\n\t\tif (getenv(\"X11VNC_UINPUT_THRESHOLDS\")) {\n\t\t\ttry_threshes = 1;\n\t\t} else {\n\t\t\ttry_threshes = 0;\n\t\t}\n\t}\n\n\tif (try_threshes) {\n\t\tthresh_high = (int) ( (double) thresh/fudge_x );\n\t\tthresh_mid =  (int) ( (double) (thresh + thresh_high) / 2.0 );\n\n\t\tif (thresh_mid <= thresh) {\n\t\t\tthresh_mid = thresh + 1;\n\t\t}\n\t\tif (thresh_high <= thresh_mid) {\n\t\t\tthresh_high = thresh_mid + 1;\n\t\t}\n\n\t\tif (inside_thresh(dx, dy, thresh)) {\n\t\t\taccel = 0;\n\t\t} else {\n\t\t\taccel = 1;\n\t\t}\n\t\tnx = nabs(dx);\n\t\tny = nabs(dy);\n\n\t} else {\n\t\taccel = 1;\n\t\tthresh_high = 0;\n\t\tnx = ny = 1;\n\t}\n\n\tif (accel && nx + ny > 0 ) {\n\t\tif (thresh_high > 0 && inside_thresh(dx, dy, thresh_high)) {\n\t\t\tdouble alpha, t;\n\t\t\t/* XXX */\n\t\t\tif (1 || inside_thresh(dx, dy, thresh_mid)) {\n\t\t\t\tt = thresh; \n\t\t\t\taccel = 2;\n\t\t\t} else {\n\t\t\t\taccel = 3;\n\t\t\t\tt = thresh_high;\n\t\t\t}\n\t\t\tif (thresh_or) {\n\t\t\t\tif (nx > ny) {\n\t\t\t\t\tfx = t;\n\t\t\t\t\tfy =  ((double) ny / (double) nx) * t;\n\t\t\t\t} else {\n\t\t\t\t\tfx =  ((double) nx / (double) ny) * t;\n\t\t\t\t\tfy = t;\n\t\t\t\t}\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (t > 1) {\n\t\t\t\t\t/* XXX */\n\t\t\t\t\tt = t - 1.0;\n\t\t\t\t}\n\t\t\t\talpha = t/(nx + ny);\n\t\t\t\tfx = alpha * dx;\n\t\t\t\tfy = alpha * dy;\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t}\n\t\t} else {\n\t\t\tfx = fudge_x * (double) dx;\n\t\t\tfy = fudge_y * (double) dy;\n\t\t\tdxf = (int) fx;\n\t\t\tdyf = (int) fy;\n\t\t}\n\t} else {\n\t\tfx = dx;\n\t\tfy = dy;\n\t\tdxf = dx;\n\t\tdyf = dy;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"old dx dy: %d %d\\n\", dx, dy);\n\tif (db > 1) fprintf(stderr, \"new dx dy: %d %d  accel: %d\\n\", dxf, dyf, accel);\n\n\tptr_move(dxf, dyf);\n\n\tresid_x += fx - dxf;\n\tresid_y += fy - dyf;\n\n\tfor (k = 0; k < 4; k++) {\n\t\tif (resid_x <= -1.0 || resid_x >= 1.0 || resid_y <= -1.0 || resid_y >= 1.0) {\n\t\t\tdxf = 0;\n\t\t\tdyf = 0;\n\t\t\tif (resid_x >= 1.0) {\n\t\t\t\tdxf = (int) resid_x;\n\t\t\t\tdxf = 1;\n\t\t\t} else if (resid_x <= -1.0)  {\n\t\t\t\tdxf = -((int) (-resid_x));\n\t\t\t\tdxf = -1;\n\t\t\t}\n\t\t\tresid_x -= dxf;\n\t\t\tif (resid_y >= 1.0) {\n\t\t\t\tdyf = (int) resid_y;\n\t\t\t\tdyf = 1;\n\t\t\t} else if (resid_y <= -1.0)  {\n\t\t\t\tdyf = -((int) (-resid_y));\n\t\t\t\tdyf = -1;\n\t\t\t}\n\t\t\tresid_y -= dyf;\n\n\t\t\tif (db > 1) fprintf(stderr, \"*%s resid: dx dy: %d %d  %f %f\\n\", accel > 1 ? \"*\" : \" \", dxf, dyf, resid_x, resid_y);\nif (0) {usleep(100*1000) ;}\n\t\t\tptr_move(dxf, dyf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_uinput_accel_xy(double fx, double fy);",
            "static void ptr_move(int dx, int dy);",
            "static void ptr_rel(int dx, int dy);",
            "static int db = 0;",
            "static double fudge_x = 0.5;",
            "static double fudge_y = 0.5;",
            "static int thresh = 5;",
            "static int thresh_or = 1;",
            "static double resid_x = 0.0;",
            "static double resid_y = 0.0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic void ptr_move(int dx, int dy);\nstatic void ptr_rel(int dx, int dy);\nstatic int db = 0;\nstatic double fudge_x = 0.5;\nstatic double fudge_y = 0.5;\nstatic int thresh = 5;\nstatic int thresh_or = 1;\nstatic double resid_x = 0.0;\nstatic double resid_y = 0.0;\n\nstatic void ptr_rel(int dx, int dy) {\n\tint dxf, dyf, nx, ny, k;\n\tint accel, thresh_high, thresh_mid;\n\tdouble fx, fy;\n\tstatic int try_threshes = -1;\n\n\tif (try_threshes < 0) {\n\t\tif (getenv(\"X11VNC_UINPUT_THRESHOLDS\")) {\n\t\t\ttry_threshes = 1;\n\t\t} else {\n\t\t\ttry_threshes = 0;\n\t\t}\n\t}\n\n\tif (try_threshes) {\n\t\tthresh_high = (int) ( (double) thresh/fudge_x );\n\t\tthresh_mid =  (int) ( (double) (thresh + thresh_high) / 2.0 );\n\n\t\tif (thresh_mid <= thresh) {\n\t\t\tthresh_mid = thresh + 1;\n\t\t}\n\t\tif (thresh_high <= thresh_mid) {\n\t\t\tthresh_high = thresh_mid + 1;\n\t\t}\n\n\t\tif (inside_thresh(dx, dy, thresh)) {\n\t\t\taccel = 0;\n\t\t} else {\n\t\t\taccel = 1;\n\t\t}\n\t\tnx = nabs(dx);\n\t\tny = nabs(dy);\n\n\t} else {\n\t\taccel = 1;\n\t\tthresh_high = 0;\n\t\tnx = ny = 1;\n\t}\n\n\tif (accel && nx + ny > 0 ) {\n\t\tif (thresh_high > 0 && inside_thresh(dx, dy, thresh_high)) {\n\t\t\tdouble alpha, t;\n\t\t\t/* XXX */\n\t\t\tif (1 || inside_thresh(dx, dy, thresh_mid)) {\n\t\t\t\tt = thresh; \n\t\t\t\taccel = 2;\n\t\t\t} else {\n\t\t\t\taccel = 3;\n\t\t\t\tt = thresh_high;\n\t\t\t}\n\t\t\tif (thresh_or) {\n\t\t\t\tif (nx > ny) {\n\t\t\t\t\tfx = t;\n\t\t\t\t\tfy =  ((double) ny / (double) nx) * t;\n\t\t\t\t} else {\n\t\t\t\t\tfx =  ((double) nx / (double) ny) * t;\n\t\t\t\t\tfy = t;\n\t\t\t\t}\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (t > 1) {\n\t\t\t\t\t/* XXX */\n\t\t\t\t\tt = t - 1.0;\n\t\t\t\t}\n\t\t\t\talpha = t/(nx + ny);\n\t\t\t\tfx = alpha * dx;\n\t\t\t\tfy = alpha * dy;\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t}\n\t\t} else {\n\t\t\tfx = fudge_x * (double) dx;\n\t\t\tfy = fudge_y * (double) dy;\n\t\t\tdxf = (int) fx;\n\t\t\tdyf = (int) fy;\n\t\t}\n\t} else {\n\t\tfx = dx;\n\t\tfy = dy;\n\t\tdxf = dx;\n\t\tdyf = dy;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"old dx dy: %d %d\\n\", dx, dy);\n\tif (db > 1) fprintf(stderr, \"new dx dy: %d %d  accel: %d\\n\", dxf, dyf, accel);\n\n\tptr_move(dxf, dyf);\n\n\tresid_x += fx - dxf;\n\tresid_y += fy - dyf;\n\n\tfor (k = 0; k < 4; k++) {\n\t\tif (resid_x <= -1.0 || resid_x >= 1.0 || resid_y <= -1.0 || resid_y >= 1.0) {\n\t\t\tdxf = 0;\n\t\t\tdyf = 0;\n\t\t\tif (resid_x >= 1.0) {\n\t\t\t\tdxf = (int) resid_x;\n\t\t\t\tdxf = 1;\n\t\t\t} else if (resid_x <= -1.0)  {\n\t\t\t\tdxf = -((int) (-resid_x));\n\t\t\t\tdxf = -1;\n\t\t\t}\n\t\t\tresid_x -= dxf;\n\t\t\tif (resid_y >= 1.0) {\n\t\t\t\tdyf = (int) resid_y;\n\t\t\t\tdyf = 1;\n\t\t\t} else if (resid_y <= -1.0)  {\n\t\t\t\tdyf = -((int) (-resid_y));\n\t\t\t\tdyf = -1;\n\t\t\t}\n\t\t\tresid_y -= dyf;\n\n\t\t\tif (db > 1) fprintf(stderr, \"*%s resid: dx dy: %d %d  %f %f\\n\", accel > 1 ? \"*\" : \" \", dxf, dyf, resid_x, resid_y);\nif (0) {usleep(100*1000) ;}\n\t\t\tptr_move(dxf, dyf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10*1000"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "30*1000"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1*1000"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10*1000"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"uinput_pointer_command: reset -> (0,0) (%d,%d)  [%d,%d]\\n\"",
            "x",
            "y",
            "tx",
            "ty"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"uinput_pointer_command: reset -> (W,H) (%d,%d)  [%d,%d]\\n\"",
            "x",
            "y",
            "tx",
            "ty"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_move",
          "args": [
            "-1",
            "-1"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "715-749",
          "snippet": "static void ptr_move(int dx, int dy) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_rel_fd < 0 ? fd : direct_rel_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tif (db) fprintf(stderr, \"ptr_move(%d, %d) fd=%d\\n\", dx, dy, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_REL;\n\tev.code = REL_Y;\n\tev.value = dy;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_REL;\n\tev.code = REL_X;\n\tev.value = dx;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!dx || !dy) {}\n#endif\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define input_event_usec time.tv_usec",
            "#define input_event_sec time.tv_sec",
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "static void ptr_move(int dx, int dy);",
            "static void ptr_rel(int dx, int dy);",
            "static int fd = -1;",
            "static int direct_rel_fd = -1;",
            "static int db = 0;",
            "static char *injectable = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nstatic void ptr_move(int dx, int dy);\nstatic void ptr_rel(int dx, int dy);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\n\nstatic void ptr_move(int dx, int dy) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_rel_fd < 0 ? fd : direct_rel_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tif (db) fprintf(stderr, \"ptr_move(%d, %d) fd=%d\\n\", dx, dy, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_REL;\n\tev.code = REL_Y;\n\tev.value = dy;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_REL;\n\tev.code = REL_X;\n\tev.value = dx;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!dx || !dy) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*1000"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "2*1000"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_is_down",
          "args": [],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "mod_is_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "194-203",
          "snippet": "static int mod_is_down(void) {\n\tint i;\n\tif (0) {key_is_down();}\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i] && key_ismod[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mod_is_down(void);",
            "static int key_is_down(void);",
            "static int key_pressed[256];",
            "static int key_ismod[256];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int mod_is_down(void);\nstatic int key_is_down(void);\nstatic int key_pressed[256];\nstatic int key_ismod[256];\n\nstatic int mod_is_down(void) {\n\tint i;\n\tif (0) {key_is_down();}\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i] && key_ismod[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_allowed_input",
          "args": [
            "client",
            "&input"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "get_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2791-2847",
          "snippet": "void get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\n\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"uinput_pointer_command: %d %d - %d\\n\"",
            "x",
            "y",
            "mask"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_always",
          "args": [
            "0"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "568-570",
          "snippet": "void set_uinput_always(int a) {\n\tuinput_always = a;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_uinput_always(int);",
            "static double a[7];",
            "static int uinput_always = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_always(int);\nstatic double a[7];\nstatic int uinput_always = 0;\n\nvoid set_uinput_always(int a) {\n\tuinput_always = a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"RESET_ALWAYS\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_always(int);\nvoid uinput_pointer_command(int mask, int x, int y, rfbClientPtr client);\nvoid uinput_key_command(int down, int keysym, rfbClientPtr client);\nstatic int mod_is_down(void);\nstatic int bmask = 0;\nstatic int db = 0;\nstatic double a[7];\nstatic int uinput_touchscreen = 0;\nstatic int uinput_abs = 0;\nstatic int btn_touch = 0;\nstatic int dragskip = 0;\nstatic int touch_always = 0;\nstatic int touch_pressure = 1;\nstatic double fudge_x = 0.5;\nstatic double fudge_y = 0.5;\nstatic double resid_x = 0.0;\nstatic double resid_y = 0.0;\nstatic double zero_delay = 0.15;\nstatic double last_button_click = 0.0;\nstatic int uinput_always = 0;\n\nvoid uinput_pointer_command(int mask, int x, int y, rfbClientPtr client) {\n\tstatic int last_x = -1, last_y = -1, last_mask = -1;\n\tstatic double last_zero = 0.0;\n\tallowed_input_t input;\n\tint do_reset, reset_lower_right = 1;\n\tdouble now;\n\tstatic int first = 1;\n\tClientData *cd = (ClientData *) client->clientData;\n\n\tif (first) {\n\t\tif (getenv(\"RESET_ALWAYS\")) {\n\t\t\tset_uinput_always(1);\n\t\t} else {\n\t\t\tset_uinput_always(0);\n\t\t}\n\t}\n\tfirst = 0;\n\t\n\tif (db) fprintf(stderr, \"uinput_pointer_command: %d %d - %d\\n\", x, y, mask);\n\n\tif (view_only) {\n\t\treturn;\n\t}\n\tget_allowed_input(client, &input);\n\n\tnow = dnow();\n\n\tdo_reset = 1;\n\tif (mask || bmask) {\n\t\tdo_reset = 0;\t/* do not do reset if mouse button down */\n\t} else if (! input.motion) {\n\t\tdo_reset = 0;\n\t} else if (now < last_zero + zero_delay) {\n\t\tdo_reset = 0;\n\t}\n\tif (do_reset) {\n\t\tif (mod_is_down()) {\n\t\t\tdo_reset = 0;\n\t\t} else if (now < last_button_click + 0.25) {\n\t\t\tdo_reset = 0;\n\t\t}\n\t}\n\n\tif (uinput_always && !mask && !bmask && input.motion) {\n\t\tdo_reset = 1;\n\t}\n\tif (uinput_abs) {\n\t\tdo_reset = 0;\n\t}\n\n\tif (do_reset) {\n\t\tstatic int first = 1;\n\n\t\tif (zero_delay > 0.0 || first) {\n\t\t\t/* try to push it to 0,0 */\n\t\t\tint tx, ty, bigjump = 1;\n\n\t\t\tif (reset_lower_right) {\n\t\t\t\ttx = fudge_x * (dpy_x - last_x);\n\t\t\t\tty = fudge_y * (dpy_y - last_y);\n\t\t\t} else {\n\t\t\t\ttx = fudge_x * last_x;\n\t\t\t\tty = fudge_y * last_y;\n\t\t\t}\n\n\t\t\ttx += 50;\n\t\t\tty += 50;\n\n\t\t\tif (bigjump) {\n\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\tptr_move(0, +ty);\n\t\t\t\t\tusleep(2*1000);\n\t\t\t\t\tptr_move(+tx, +ty);\n\t\t\t\t\tptr_move(+tx, +ty);\n\t\t\t\t} else {\n\t\t\t\t\tptr_move(0, -ty);\n\t\t\t\t\tusleep(2*1000);\n\t\t\t\t\tptr_move(-tx, -ty);\n\t\t\t\t\tptr_move(-tx, -ty);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint i, step, n = 20;\n\t\t\t\tstep = dpy_x / n;\n\n\t\t\t\tif (step < 100) step = 100;\n\n\t\t\t\tfor (i=0; i < n; i++)  {\n\t\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\t\tptr_move(+step, +step);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tptr_move(-step, -step);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i=0; i < n; i++)  {\n\t\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\t\tptr_move(+1, +1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tptr_move(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (db) {\n\t\t\t\tif (reset_lower_right) {\n\t\t\t\t\tfprintf(stderr, \"uinput_pointer_command: reset -> (W,H) (%d,%d)  [%d,%d]\\n\", x, y, tx, ty);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"uinput_pointer_command: reset -> (0,0) (%d,%d)  [%d,%d]\\n\", x, y, tx, ty);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* rest a bit for system to absorb the change */\n\t\t\tif (uinput_always) {\n\t\t\t\tstatic double last_sleep = 0.0;\n\t\t\t\tdouble nw = dnow(), delay = zero_delay;\n\t\t\t\tif (delay <= 0.0) delay = 0.1;\n\t\t\t\tif (nw > last_sleep + delay) {\n\t\t\t\t\tusleep(10*1000);\n\t\t\t\t\tlast_sleep = nw;\n\t\t\t\t} else {\n\t\t\t\t\tusleep(1*1000);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tusleep(30*1000);\n\t\t\t}\n\n\t\t\t/* now jump back out */\n\t\t\tif (reset_lower_right) {\n\t\t\t\tptr_rel(x - dpy_x, y - dpy_y);\n\t\t\t} else {\n\t\t\t\tptr_rel(x, y);\n\t\t\t}\n\t\t\tif (1) {usleep(10*1000) ;}\n\n\t\t\tlast_x = x;\n\t\t\tlast_y = y;\n\t\t\tresid_x = 0.0;\n\t\t\tresid_y = 0.0;\n\n\t\t\tfirst = 0;\n\t\t}\n\t\tlast_zero = dnow();\n\t}\n\n\tif (input.motion) {\n\t\tif (x != last_x || y != last_y) {\n\t\t\tif (uinput_touchscreen) {\n\t\t\t\t;\n\t\t\t} else if (uinput_abs) {\n\t\t\t\tptr_abs(x, y, -1);\n\t\t\t} else {\n\t\t\t\tptr_rel(x - last_x, y - last_y);\n\t\t\t}\n\t\t\tlast_x = x;\n\t\t\tlast_y = y;\n\t\t}\n\t}\n\n\tif (! input.button) {\n\t\treturn;\n\t}\n\n\tif (last_mask < 0) {\n\t\tlast_mask = mask;\n\t}\n\n\tif (db > 2) {\n\t\tfprintf(stderr, \"mask:        %s\\n\", bitprint(mask, 16));\n\t\tfprintf(stderr, \"bmask:       %s\\n\", bitprint(bmask, 16));\n\t\tfprintf(stderr, \"last_mask:   %s\\n\", bitprint(last_mask, 16));\n\t\tfprintf(stderr, \"button_mask: %s\\n\", bitprint(cd->ptr_buttonmask, 16));\n\t}\n\n\tif (uinput_touchscreen) {\n\t\tif (!btn_touch) {\n\t\t\tstatic int down_count = 0;\n\t\t\tint p = touch_pressure >=0 ? touch_pressure : 0;\n\t\t\tif (!last_mask && !mask) {\n\t\t\t\tif (touch_always) {\n\t\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\t}\n\t\t\t} else if (!last_mask && mask) {\n\t\t\t\tptr_abs(last_x, last_y, p);\n\t\t\t\tdown_count = 0;\n\t\t\t} else if (last_mask && !mask) {\n\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t} else if (last_mask && mask) {\n\t\t\t\tdown_count++;\n\t\t\t\tif (dragskip > 0) {\n\t\t\t\t\tif (down_count % dragskip == 0) {\n\t\t\t\t\t\tptr_abs(last_x, last_y, p);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tptr_abs(last_x, last_y, p);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!last_mask && !mask) {\n\t\t\t\tif (touch_always) {\n\t\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\t}\n\t\t\t} else if (!last_mask && mask) {\n\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\tbutton_click(1, 0);\n\t\t\t} else if (last_mask && !mask) {\n\t\t\t\tptr_abs(last_x, last_y, 0);\n\t\t\t\tbutton_click(0, 0);\n\t\t\t} else if (last_mask && mask) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tlast_mask = mask;\n\t} else if (mask != last_mask) {\n\t\tint i;\n\t\tfor (i=1; i <= MAX_BUTTONS; i++) {\n\t\t\tint down, b = 1 << (i-1);\n\t\t\tif ( (last_mask & b) == (mask & b)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mask & b) {\n\t\t\t\tdown = 1;\n\t\t\t} else {\n\t\t\t\tdown = 0;\n\t\t\t}\n\t\t\tbutton_click(down, i);\n\t\t}\n\t\tif (mask && uinput_abs && touch_pressure >= 0) {\n\t\t\tptr_abs(last_x, last_y, touch_pressure);\n\t\t}\n\t\tlast_mask = mask;\n\t}\n\tbmask = mask;\n}"
  },
  {
    "function_name": "button_click",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "961-1008",
    "snippet": "static void button_click(int down, int btn) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_btn_fd < 0 ? fd : direct_btn_fd;\n\n\tif (injectable && strchr(injectable, 'B') == NULL) {\n\t\treturn;\n\t}\n\n\tif (db) fprintf(stderr, \"button_click: btn %d %s fd=%d\\n\", btn, down ? \"down\" : \"up\", d);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_KEY;\n\tev.value = down;\n\n\tif (uinput_touchscreen) {\n\t\tev.code = BTN_TOUCH;\n\t\tif (db) fprintf(stderr, \"set code to BTN_TOUCH\\n\");\n\t} else if (btn == 1) {\n\t\tev.code = BTN_LEFT;\n\t} else if (btn == 2) {\n\t\tev.code = BTN_MIDDLE;\n\t} else if (btn == 3) {\n\t\tev.code = BTN_RIGHT;\n\t} else if (btn == 4) {\n\t\tev.code = BTN_FORWARD;\n\t} else if (btn == 5) {\n\t\tev.code = BTN_BACK;\n\t} else {\n\t\treturn;\n\t}\n\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n\n\tlast_button_click = dnow();\n#else\n\tif (!down || !btn) {}\n#endif\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define input_event_usec time.tv_usec",
      "#define input_event_sec time.tv_sec",
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "static void button_click(int down, int btn);",
      "static int fd = -1;",
      "static int direct_btn_fd = -1;",
      "static int db = 0;",
      "static char *injectable = NULL;",
      "static int uinput_touchscreen = 0;",
      "static double last_button_click = 0.0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "d",
            "&ev",
            "sizeof(ev)"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"set code to BTN_TOUCH\\n\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&tval",
            "NULL"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ev",
            "0",
            "sizeof(ev)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"button_click: btn %d %s fd=%d\\n\"",
            "btn",
            "down ? \"down\" : \"up\"",
            "d"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "injectable",
            "'B'"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nstatic void button_click(int down, int btn);\nstatic int fd = -1;\nstatic int direct_btn_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\nstatic int uinput_touchscreen = 0;\nstatic double last_button_click = 0.0;\n\nstatic void button_click(int down, int btn) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_btn_fd < 0 ? fd : direct_btn_fd;\n\n\tif (injectable && strchr(injectable, 'B') == NULL) {\n\t\treturn;\n\t}\n\n\tif (db) fprintf(stderr, \"button_click: btn %d %s fd=%d\\n\", btn, down ? \"down\" : \"up\", d);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_KEY;\n\tev.value = down;\n\n\tif (uinput_touchscreen) {\n\t\tev.code = BTN_TOUCH;\n\t\tif (db) fprintf(stderr, \"set code to BTN_TOUCH\\n\");\n\t} else if (btn == 1) {\n\t\tev.code = BTN_LEFT;\n\t} else if (btn == 2) {\n\t\tev.code = BTN_MIDDLE;\n\t} else if (btn == 3) {\n\t\tev.code = BTN_RIGHT;\n\t} else if (btn == 4) {\n\t\tev.code = BTN_FORWARD;\n\t} else if (btn == 5) {\n\t\tev.code = BTN_BACK;\n\t} else {\n\t\treturn;\n\t}\n\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n\n\tlast_button_click = dnow();\n#else\n\tif (!down || !btn) {}\n#endif\n}"
  },
  {
    "function_name": "ptr_rel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "836-959",
    "snippet": "static void ptr_rel(int dx, int dy) {\n\tint dxf, dyf, nx, ny, k;\n\tint accel, thresh_high, thresh_mid;\n\tdouble fx, fy;\n\tstatic int try_threshes = -1;\n\n\tif (try_threshes < 0) {\n\t\tif (getenv(\"X11VNC_UINPUT_THRESHOLDS\")) {\n\t\t\ttry_threshes = 1;\n\t\t} else {\n\t\t\ttry_threshes = 0;\n\t\t}\n\t}\n\n\tif (try_threshes) {\n\t\tthresh_high = (int) ( (double) thresh/fudge_x );\n\t\tthresh_mid =  (int) ( (double) (thresh + thresh_high) / 2.0 );\n\n\t\tif (thresh_mid <= thresh) {\n\t\t\tthresh_mid = thresh + 1;\n\t\t}\n\t\tif (thresh_high <= thresh_mid) {\n\t\t\tthresh_high = thresh_mid + 1;\n\t\t}\n\n\t\tif (inside_thresh(dx, dy, thresh)) {\n\t\t\taccel = 0;\n\t\t} else {\n\t\t\taccel = 1;\n\t\t}\n\t\tnx = nabs(dx);\n\t\tny = nabs(dy);\n\n\t} else {\n\t\taccel = 1;\n\t\tthresh_high = 0;\n\t\tnx = ny = 1;\n\t}\n\n\tif (accel && nx + ny > 0 ) {\n\t\tif (thresh_high > 0 && inside_thresh(dx, dy, thresh_high)) {\n\t\t\tdouble alpha, t;\n\t\t\t/* XXX */\n\t\t\tif (1 || inside_thresh(dx, dy, thresh_mid)) {\n\t\t\t\tt = thresh; \n\t\t\t\taccel = 2;\n\t\t\t} else {\n\t\t\t\taccel = 3;\n\t\t\t\tt = thresh_high;\n\t\t\t}\n\t\t\tif (thresh_or) {\n\t\t\t\tif (nx > ny) {\n\t\t\t\t\tfx = t;\n\t\t\t\t\tfy =  ((double) ny / (double) nx) * t;\n\t\t\t\t} else {\n\t\t\t\t\tfx =  ((double) nx / (double) ny) * t;\n\t\t\t\t\tfy = t;\n\t\t\t\t}\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (t > 1) {\n\t\t\t\t\t/* XXX */\n\t\t\t\t\tt = t - 1.0;\n\t\t\t\t}\n\t\t\t\talpha = t/(nx + ny);\n\t\t\t\tfx = alpha * dx;\n\t\t\t\tfy = alpha * dy;\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t}\n\t\t} else {\n\t\t\tfx = fudge_x * (double) dx;\n\t\t\tfy = fudge_y * (double) dy;\n\t\t\tdxf = (int) fx;\n\t\t\tdyf = (int) fy;\n\t\t}\n\t} else {\n\t\tfx = dx;\n\t\tfy = dy;\n\t\tdxf = dx;\n\t\tdyf = dy;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"old dx dy: %d %d\\n\", dx, dy);\n\tif (db > 1) fprintf(stderr, \"new dx dy: %d %d  accel: %d\\n\", dxf, dyf, accel);\n\n\tptr_move(dxf, dyf);\n\n\tresid_x += fx - dxf;\n\tresid_y += fy - dyf;\n\n\tfor (k = 0; k < 4; k++) {\n\t\tif (resid_x <= -1.0 || resid_x >= 1.0 || resid_y <= -1.0 || resid_y >= 1.0) {\n\t\t\tdxf = 0;\n\t\t\tdyf = 0;\n\t\t\tif (resid_x >= 1.0) {\n\t\t\t\tdxf = (int) resid_x;\n\t\t\t\tdxf = 1;\n\t\t\t} else if (resid_x <= -1.0)  {\n\t\t\t\tdxf = -((int) (-resid_x));\n\t\t\t\tdxf = -1;\n\t\t\t}\n\t\t\tresid_x -= dxf;\n\t\t\tif (resid_y >= 1.0) {\n\t\t\t\tdyf = (int) resid_y;\n\t\t\t\tdyf = 1;\n\t\t\t} else if (resid_y <= -1.0)  {\n\t\t\t\tdyf = -((int) (-resid_y));\n\t\t\t\tdyf = -1;\n\t\t\t}\n\t\t\tresid_y -= dyf;\n\n\t\t\tif (db > 1) fprintf(stderr, \"*%s resid: dx dy: %d %d  %f %f\\n\", accel > 1 ? \"*\" : \" \", dxf, dyf, resid_x, resid_y);\nif (0) {usleep(100*1000) ;}\n\t\t\tptr_move(dxf, dyf);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_uinput_accel_xy(double fx, double fy);",
      "static void ptr_move(int dx, int dy);",
      "static void ptr_rel(int dx, int dy);",
      "static int db = 0;",
      "static double fudge_x = 0.5;",
      "static double fudge_y = 0.5;",
      "static int thresh = 5;",
      "static int thresh_or = 1;",
      "static double resid_x = 0.0;",
      "static double resid_y = 0.0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr_move",
          "args": [
            "dxf",
            "dyf"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ptr_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "715-749",
          "snippet": "static void ptr_move(int dx, int dy) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_rel_fd < 0 ? fd : direct_rel_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tif (db) fprintf(stderr, \"ptr_move(%d, %d) fd=%d\\n\", dx, dy, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_REL;\n\tev.code = REL_Y;\n\tev.value = dy;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_REL;\n\tev.code = REL_X;\n\tev.value = dx;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!dx || !dy) {}\n#endif\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define input_event_usec time.tv_usec",
            "#define input_event_sec time.tv_sec",
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "static void ptr_move(int dx, int dy);",
            "static void ptr_rel(int dx, int dy);",
            "static int fd = -1;",
            "static int direct_rel_fd = -1;",
            "static int db = 0;",
            "static char *injectable = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nstatic void ptr_move(int dx, int dy);\nstatic void ptr_rel(int dx, int dy);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\n\nstatic void ptr_move(int dx, int dy) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_rel_fd < 0 ? fd : direct_rel_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tif (db) fprintf(stderr, \"ptr_move(%d, %d) fd=%d\\n\", dx, dy, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_REL;\n\tev.code = REL_Y;\n\tev.value = dy;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_REL;\n\tev.code = REL_X;\n\tev.value = dx;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!dx || !dy) {}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100*1000"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*%s resid: dx dy: %d %d  %f %f\\n\"",
            "accel > 1 ? \"*\" : \" \"",
            "dxf",
            "dyf",
            "resid_x",
            "resid_y"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"new dx dy: %d %d  accel: %d\\n\"",
            "dxf",
            "dyf",
            "accel"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"old dx dy: %d %d\\n\"",
            "dx",
            "dy"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inside_thresh",
          "args": [
            "dx",
            "dy",
            "thresh_mid"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "inside_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "821-834",
          "snippet": "static int inside_thresh(int dx, int dy, int thr) {\n\tif (thresh_or) {\n\t\t/* this is peeking at qt-embedded qmouse_qws.cpp */\n\t\tif (nabs(dx) <= thresh && nabs(dy) <= thr) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/* this is peeking at xfree/xorg xf86Xinput.c */\n\t\tif (nabs(dx) + nabs(dy) < thr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ptr_move(int dx, int dy);",
            "static void ptr_rel(int dx, int dy);",
            "static int thresh = 5;",
            "static int thresh_or = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void ptr_move(int dx, int dy);\nstatic void ptr_rel(int dx, int dy);\nstatic int thresh = 5;\nstatic int thresh_or = 1;\n\nstatic int inside_thresh(int dx, int dy, int thr) {\n\tif (thresh_or) {\n\t\t/* this is peeking at qt-embedded qmouse_qws.cpp */\n\t\tif (nabs(dx) <= thresh && nabs(dy) <= thr) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/* this is peeking at xfree/xorg xf86Xinput.c */\n\t\tif (nabs(dx) + nabs(dy) < thr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "dy"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_UINPUT_THRESHOLDS\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic void ptr_move(int dx, int dy);\nstatic void ptr_rel(int dx, int dy);\nstatic int db = 0;\nstatic double fudge_x = 0.5;\nstatic double fudge_y = 0.5;\nstatic int thresh = 5;\nstatic int thresh_or = 1;\nstatic double resid_x = 0.0;\nstatic double resid_y = 0.0;\n\nstatic void ptr_rel(int dx, int dy) {\n\tint dxf, dyf, nx, ny, k;\n\tint accel, thresh_high, thresh_mid;\n\tdouble fx, fy;\n\tstatic int try_threshes = -1;\n\n\tif (try_threshes < 0) {\n\t\tif (getenv(\"X11VNC_UINPUT_THRESHOLDS\")) {\n\t\t\ttry_threshes = 1;\n\t\t} else {\n\t\t\ttry_threshes = 0;\n\t\t}\n\t}\n\n\tif (try_threshes) {\n\t\tthresh_high = (int) ( (double) thresh/fudge_x );\n\t\tthresh_mid =  (int) ( (double) (thresh + thresh_high) / 2.0 );\n\n\t\tif (thresh_mid <= thresh) {\n\t\t\tthresh_mid = thresh + 1;\n\t\t}\n\t\tif (thresh_high <= thresh_mid) {\n\t\t\tthresh_high = thresh_mid + 1;\n\t\t}\n\n\t\tif (inside_thresh(dx, dy, thresh)) {\n\t\t\taccel = 0;\n\t\t} else {\n\t\t\taccel = 1;\n\t\t}\n\t\tnx = nabs(dx);\n\t\tny = nabs(dy);\n\n\t} else {\n\t\taccel = 1;\n\t\tthresh_high = 0;\n\t\tnx = ny = 1;\n\t}\n\n\tif (accel && nx + ny > 0 ) {\n\t\tif (thresh_high > 0 && inside_thresh(dx, dy, thresh_high)) {\n\t\t\tdouble alpha, t;\n\t\t\t/* XXX */\n\t\t\tif (1 || inside_thresh(dx, dy, thresh_mid)) {\n\t\t\t\tt = thresh; \n\t\t\t\taccel = 2;\n\t\t\t} else {\n\t\t\t\taccel = 3;\n\t\t\t\tt = thresh_high;\n\t\t\t}\n\t\t\tif (thresh_or) {\n\t\t\t\tif (nx > ny) {\n\t\t\t\t\tfx = t;\n\t\t\t\t\tfy =  ((double) ny / (double) nx) * t;\n\t\t\t\t} else {\n\t\t\t\t\tfx =  ((double) nx / (double) ny) * t;\n\t\t\t\t\tfy = t;\n\t\t\t\t}\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (t > 1) {\n\t\t\t\t\t/* XXX */\n\t\t\t\t\tt = t - 1.0;\n\t\t\t\t}\n\t\t\t\talpha = t/(nx + ny);\n\t\t\t\tfx = alpha * dx;\n\t\t\t\tfy = alpha * dy;\n\t\t\t\tdxf = (int) fx;\n\t\t\t\tdyf = (int) fy;\n\t\t\t\tfx = dx;\n\t\t\t\tfy = dy;\n\t\t\t}\n\t\t} else {\n\t\t\tfx = fudge_x * (double) dx;\n\t\t\tfy = fudge_y * (double) dy;\n\t\t\tdxf = (int) fx;\n\t\t\tdyf = (int) fy;\n\t\t}\n\t} else {\n\t\tfx = dx;\n\t\tfy = dy;\n\t\tdxf = dx;\n\t\tdyf = dy;\n\t}\n\n\tif (db > 1) fprintf(stderr, \"old dx dy: %d %d\\n\", dx, dy);\n\tif (db > 1) fprintf(stderr, \"new dx dy: %d %d  accel: %d\\n\", dxf, dyf, accel);\n\n\tptr_move(dxf, dyf);\n\n\tresid_x += fx - dxf;\n\tresid_y += fy - dyf;\n\n\tfor (k = 0; k < 4; k++) {\n\t\tif (resid_x <= -1.0 || resid_x >= 1.0 || resid_y <= -1.0 || resid_y >= 1.0) {\n\t\t\tdxf = 0;\n\t\t\tdyf = 0;\n\t\t\tif (resid_x >= 1.0) {\n\t\t\t\tdxf = (int) resid_x;\n\t\t\t\tdxf = 1;\n\t\t\t} else if (resid_x <= -1.0)  {\n\t\t\t\tdxf = -((int) (-resid_x));\n\t\t\t\tdxf = -1;\n\t\t\t}\n\t\t\tresid_x -= dxf;\n\t\t\tif (resid_y >= 1.0) {\n\t\t\t\tdyf = (int) resid_y;\n\t\t\t\tdyf = 1;\n\t\t\t} else if (resid_y <= -1.0)  {\n\t\t\t\tdyf = -((int) (-resid_y));\n\t\t\t\tdyf = -1;\n\t\t\t}\n\t\t\tresid_y -= dyf;\n\n\t\t\tif (db > 1) fprintf(stderr, \"*%s resid: dx dy: %d %d  %f %f\\n\", accel > 1 ? \"*\" : \" \", dxf, dyf, resid_x, resid_y);\nif (0) {usleep(100*1000) ;}\n\t\t\tptr_move(dxf, dyf);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "inside_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "821-834",
    "snippet": "static int inside_thresh(int dx, int dy, int thr) {\n\tif (thresh_or) {\n\t\t/* this is peeking at qt-embedded qmouse_qws.cpp */\n\t\tif (nabs(dx) <= thresh && nabs(dy) <= thr) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/* this is peeking at xfree/xorg xf86Xinput.c */\n\t\tif (nabs(dx) + nabs(dy) < thr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ptr_move(int dx, int dy);",
      "static void ptr_rel(int dx, int dy);",
      "static int thresh = 5;",
      "static int thresh_or = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "dy"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void ptr_move(int dx, int dy);\nstatic void ptr_rel(int dx, int dy);\nstatic int thresh = 5;\nstatic int thresh_or = 1;\n\nstatic int inside_thresh(int dx, int dy, int thr) {\n\tif (thresh_or) {\n\t\t/* this is peeking at qt-embedded qmouse_qws.cpp */\n\t\tif (nabs(dx) <= thresh && nabs(dy) <= thr) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/* this is peeking at xfree/xorg xf86Xinput.c */\n\t\tif (nabs(dx) + nabs(dy) < thr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ptr_abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "763-819",
    "snippet": "static void ptr_abs(int x, int y, int p) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint x0, y0;\n\tint d = direct_abs_fd < 0 ? fd : direct_abs_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tx0 = x;\n\ty0 = y;\n\n\tif (tslib_cal) {\n\t\tapply_tslib(&x, &y);\n\t}\n\n\tif (db) fprintf(stderr, \"ptr_abs(%d, %d => %d %d, p=%d) fd=%d\\n\", x0, y0, x, y, p, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_ABS;\n\tev.code = ABS_Y;\n\tev.value = y;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_ABS;\n\tev.code = ABS_X;\n\tev.value = x;\n\twrite(d, &ev, sizeof(ev));\n\n\tif (p >= 0) {\n\t\tev.type = EV_ABS;\n\t\tev.code = ABS_PRESSURE;\n\t\tev.value = p;\n\t\twrite(d, &ev, sizeof(ev));\n\n\t\tif (!btn_touch) {\n\t\t\tev.type = EV_KEY;\n\t\t\tev.code = BTN_TOUCH;\n\t\t\tev.value = p ? 1 : 0;\n\t\t\twrite(d, &ev, sizeof(ev));\n\t\t}\n\t}\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!x || !y) {}\n#endif\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define input_event_usec time.tv_usec",
      "#define input_event_sec time.tv_sec",
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "static int fd = -1;",
      "static int direct_abs_fd = -1;",
      "static int db = 0;",
      "static char *injectable = NULL;",
      "static char *tslib_cal = NULL;",
      "static int btn_touch = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "d",
            "&ev",
            "sizeof(ev)"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&tval",
            "NULL"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ptr_abs(%d, %d => %d %d, p=%d) fd=%d\\n\"",
            "x0",
            "y0",
            "x",
            "y",
            "p",
            "d"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_tslib",
          "args": [
            "&x",
            "&y"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "apply_tslib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "751-760",
          "snippet": "static void apply_tslib(int *x, int *y) {\n\tdouble x1 = *x, y1 = *y, x2, y2;\n\n\t/* this is the inverse of the tslib linear transform: */\n\tx2 = (a[4] * (a[6] * x1 - a[2]) - a[1] * (a[6] * y1 - a[5]))/(a[4]*a[0] - a[1]*a[3]);\n\ty2 = (a[0] * (a[6] * y1 - a[5]) - a[3] * (a[6] * x1 - a[2]))/(a[4]*a[0] - a[1]*a[3]);\n\n\t*x = (int) x2;\n\t*y = (int) y2;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double a[7];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic double a[7];\n\nstatic void apply_tslib(int *x, int *y) {\n\tdouble x1 = *x, y1 = *y, x2, y2;\n\n\t/* this is the inverse of the tslib linear transform: */\n\tx2 = (a[4] * (a[6] * x1 - a[2]) - a[1] * (a[6] * y1 - a[5]))/(a[4]*a[0] - a[1]*a[3]);\n\ty2 = (a[0] * (a[6] * y1 - a[5]) - a[3] * (a[6] * x1 - a[2]))/(a[4]*a[0] - a[1]*a[3]);\n\n\t*x = (int) x2;\n\t*y = (int) y2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ev",
            "0",
            "sizeof(ev)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "injectable",
            "'M'"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nstatic int fd = -1;\nstatic int direct_abs_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\nstatic char *tslib_cal = NULL;\nstatic int btn_touch = 0;\n\nstatic void ptr_abs(int x, int y, int p) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint x0, y0;\n\tint d = direct_abs_fd < 0 ? fd : direct_abs_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tx0 = x;\n\ty0 = y;\n\n\tif (tslib_cal) {\n\t\tapply_tslib(&x, &y);\n\t}\n\n\tif (db) fprintf(stderr, \"ptr_abs(%d, %d => %d %d, p=%d) fd=%d\\n\", x0, y0, x, y, p, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_ABS;\n\tev.code = ABS_Y;\n\tev.value = y;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_ABS;\n\tev.code = ABS_X;\n\tev.value = x;\n\twrite(d, &ev, sizeof(ev));\n\n\tif (p >= 0) {\n\t\tev.type = EV_ABS;\n\t\tev.code = ABS_PRESSURE;\n\t\tev.value = p;\n\t\twrite(d, &ev, sizeof(ev));\n\n\t\tif (!btn_touch) {\n\t\t\tev.type = EV_KEY;\n\t\t\tev.code = BTN_TOUCH;\n\t\t\tev.value = p ? 1 : 0;\n\t\t\twrite(d, &ev, sizeof(ev));\n\t\t}\n\t}\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!x || !y) {}\n#endif\n}"
  },
  {
    "function_name": "apply_tslib",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "751-760",
    "snippet": "static void apply_tslib(int *x, int *y) {\n\tdouble x1 = *x, y1 = *y, x2, y2;\n\n\t/* this is the inverse of the tslib linear transform: */\n\tx2 = (a[4] * (a[6] * x1 - a[2]) - a[1] * (a[6] * y1 - a[5]))/(a[4]*a[0] - a[1]*a[3]);\n\ty2 = (a[0] * (a[6] * y1 - a[5]) - a[3] * (a[6] * x1 - a[2]))/(a[4]*a[0] - a[1]*a[3]);\n\n\t*x = (int) x2;\n\t*y = (int) y2;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double a[7];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic double a[7];\n\nstatic void apply_tslib(int *x, int *y) {\n\tdouble x1 = *x, y1 = *y, x2, y2;\n\n\t/* this is the inverse of the tslib linear transform: */\n\tx2 = (a[4] * (a[6] * x1 - a[2]) - a[1] * (a[6] * y1 - a[5]))/(a[4]*a[0] - a[1]*a[3]);\n\ty2 = (a[0] * (a[6] * y1 - a[5]) - a[3] * (a[6] * x1 - a[2]))/(a[4]*a[0] - a[1]*a[3]);\n\n\t*x = (int) x2;\n\t*y = (int) y2;\n}"
  },
  {
    "function_name": "ptr_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "715-749",
    "snippet": "static void ptr_move(int dx, int dy) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_rel_fd < 0 ? fd : direct_rel_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tif (db) fprintf(stderr, \"ptr_move(%d, %d) fd=%d\\n\", dx, dy, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_REL;\n\tev.code = REL_Y;\n\tev.value = dy;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_REL;\n\tev.code = REL_X;\n\tev.value = dx;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!dx || !dy) {}\n#endif\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define input_event_usec time.tv_usec",
      "#define input_event_sec time.tv_sec",
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "static void ptr_move(int dx, int dy);",
      "static void ptr_rel(int dx, int dy);",
      "static int fd = -1;",
      "static int direct_rel_fd = -1;",
      "static int db = 0;",
      "static char *injectable = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "d",
            "&ev",
            "sizeof(ev)"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&tval",
            "NULL"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ptr_move(%d, %d) fd=%d\\n\"",
            "dx",
            "dy",
            "d"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ev",
            "0",
            "sizeof(ev)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "injectable",
            "'M'"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define input_event_usec time.tv_usec\n#define input_event_sec time.tv_sec\n#define UINPUT_OK\n\nstatic void ptr_move(int dx, int dy);\nstatic void ptr_rel(int dx, int dy);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int db = 0;\nstatic char *injectable = NULL;\n\nstatic void ptr_move(int dx, int dy) {\n#ifdef UINPUT_OK\n\tstruct input_event ev;\n\tstruct timeval tval;\n\tint d = direct_rel_fd < 0 ? fd : direct_rel_fd;\n\n\tif (injectable && strchr(injectable, 'M') == NULL) {\n\t\treturn;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\n\tif (db) fprintf(stderr, \"ptr_move(%d, %d) fd=%d\\n\", dx, dy, d);\n\n\tgettimeofday(&tval, NULL);\n\tev.input_event_sec = tval.tv_sec;\n\tev.input_event_usec = tval.tv_usec;\n\tev.type = EV_REL;\n\tev.code = REL_Y;\n\tev.value = dy;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_REL;\n\tev.code = REL_X;\n\tev.value = dx;\n\twrite(d, &ev, sizeof(ev));\n\n\tev.type = EV_SYN;\n\tev.code = SYN_REPORT;\n\tev.value = 0;\n\twrite(d, &ev, sizeof(ev));\n#else\n\tif (!dx || !dy) {}\n#endif\n}"
  },
  {
    "function_name": "parse_uinput_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "602-713",
    "snippet": "void parse_uinput_str(char *in) {\n\tchar *p, *q, *str = strdup(in);\n\n\tif (injectable) {\n\t\tfree(injectable);\n\t\tinjectable = strdup(\"KMB\");\n\t}\n\n\tuinput_touchscreen = 0;\n\tuinput_abs = 0;\n\tabs_x = abs_y = 0;\n\n\tif (tslib_cal) {\n\t\tfree(tslib_cal);\n\t\ttslib_cal = NULL;\n\t}\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (p[0] == '/') {\n\t\t\tif (uinput_dev) {\n\t\t\t\tfree(uinput_dev);\n\t\t\t}\n\t\t\tuinput_dev = strdup(p);\n\t\t} else if (strstr(p, \"nouinput\") == p) {\n\t\t\tif (uinput_dev) {\n\t\t\t\tfree(uinput_dev);\n\t\t\t}\n\t\t\tuinput_dev = strdup(p);\n\t\t} else if (strstr(p, \"accel=\") == p) {\n\t\t\tq = p + strlen(\"accel=\");\n\t\t\tif (! set_uinput_accel(q)) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else if (strstr(p, \"thresh=\") == p) {\n\t\t\tq = p + strlen(\"thresh=\");\n\t\t\tset_uinput_thresh(q);\n\n\t\t} else if (strstr(p, \"reset=\") == p) {\n\t\t\tint n = atoi(p + strlen(\"reset=\"));\n\t\t\tset_uinput_reset(n);\n\t\t} else if (strstr(p, \"always=\") == p) {\n\t\t\tint n = atoi(p + strlen(\"always=\"));\n\t\t\tset_uinput_always(n);\n\t\t} else if (strpbrk(p, \"KMB\") == p) {\n\t\t\tif (injectable) {\n\t\t\t\tfree(injectable);\n\t\t\t}\n\t\t\tinjectable = strdup(p);\n\t\t} else if (strstr(p, \"touch_always=\") == p) {\n\t\t\ttouch_always = atoi(p + strlen(\"touch_always=\"));\n\t\t} else if (strstr(p, \"btn_touch=\") == p) {\n\t\t\tbtn_touch = atoi(p + strlen(\"btn_touch=\"));\n\t\t} else if (strstr(p, \"dragskip=\") == p) {\n\t\t\tdragskip = atoi(p + strlen(\"dragskip=\"));\n\t\t} else if (strstr(p, \"touch\") == p) {\n\t\t\tint gw, gh;\n\t\t\tq = strchr(p, '=');\n\t\t\tset_uinput_touchscreen(1);\n\t\t\tset_uinput_abs(1);\n\t\t\tif (q && sscanf(q+1, \"%dx%d\", &gw, &gh) == 2) {\n\t\t\t\tabs_x = gw;\n\t\t\t\tabs_y = gh;\n\t\t\t}\n\t\t} else if (strstr(p, \"abs\") == p) {\n\t\t\tint gw, gh;\n\t\t\tq = strchr(p, '=');\n\t\t\tset_uinput_abs(1);\n\t\t\tif (q && sscanf(q+1, \"%dx%d\", &gw, &gh) == 2) {\n\t\t\t\tabs_x = gw;\n\t\t\t\tabs_y = gh;\n\t\t\t}\n\t\t} else if (strstr(p, \"pressure=\") == p) {\n\t\t\ttouch_pressure = atoi(p + strlen(\"pressure=\"));\n\t\t} else if (strstr(p, \"direct_rel=\") == p) {\n\t\t\tdirect_rel_fd = open(p+strlen(\"direct_rel=\"), O_WRONLY);\n\t\t\tif (direct_rel_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_rel open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_rel_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"direct_abs=\") == p) {\n\t\t\tdirect_abs_fd = open(p+strlen(\"direct_abs=\"), O_WRONLY);\n\t\t\tif (direct_abs_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_abs open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_abs_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"direct_btn=\") == p) {\n\t\t\tdirect_btn_fd = open(p+strlen(\"direct_btn=\"), O_WRONLY);\n\t\t\tif (direct_btn_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_btn open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_btn_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"direct_key=\") == p) {\n\t\t\tdirect_key_fd = open(p+strlen(\"direct_key=\"), O_WRONLY);\n\t\t\tif (direct_key_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_key open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_key_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"tslib_cal=\") == p) {\n\t\t\ttslib_cal = strdup(p+strlen(\"tslib_cal=\"));\n\t\t} else {\n\t\t\trfbLog(\"invalid UINPUT option: %s\\n\", p);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int set_uinput_accel(char *str);",
      "int set_uinput_thresh(char *str);",
      "void set_uinput_always(int);",
      "void set_uinput_touchscreen(int);",
      "void set_uinput_abs(int);",
      "void parse_uinput_str(char *str);",
      "static int fd = -1;",
      "static int direct_rel_fd = -1;",
      "static int direct_abs_fd = -1;",
      "static int direct_btn_fd = -1;",
      "static int direct_key_fd = -1;",
      "static char *injectable = NULL;",
      "static char *uinput_dev = NULL;",
      "static char *tslib_cal = NULL;",
      "static int uinput_touchscreen = 0;",
      "static int uinput_abs = 0;",
      "static int btn_touch = 0;",
      "static int dragskip = 0;",
      "static int touch_always = 0;",
      "static int touch_pressure = 1;",
      "static int abs_x = 0, abs_y = 0;",
      "static int thresh = 5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid UINPUT option: %s\\n\"",
            "p"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p+strlen(\"tslib_cal=\")"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"tslib_cal=\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"tslib_cal=\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"uinput: opened: %s fd=%d\\n\"",
            "p",
            "direct_key_fd"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"uinput: direct_key open\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "p+strlen(\"direct_key=\")",
            "O_WRONLY"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"direct_key=\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"direct_key=\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"uinput: opened: %s fd=%d\\n\"",
            "p",
            "direct_btn_fd"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"uinput: direct_btn open\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"direct_btn=\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"direct_btn=\""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"uinput: opened: %s fd=%d\\n\"",
            "p",
            "direct_abs_fd"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"uinput: direct_abs open\""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"direct_abs=\""
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"direct_abs=\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"uinput: opened: %s fd=%d\\n\"",
            "p",
            "direct_rel_fd"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"uinput: direct_rel open\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"direct_rel=\""
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"direct_rel=\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"pressure=\")"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"pressure=\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"pressure=\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q+1",
            "\"%dx%d\"",
            "&gw",
            "&gh"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_abs",
          "args": [
            "1"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "576-578",
          "snippet": "void set_uinput_abs(int b) {\n\tuinput_abs = b;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_uinput_abs(int);",
            "static int uinput_abs = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_abs(int);\nstatic int uinput_abs = 0;\n\nvoid set_uinput_abs(int b) {\n\tuinput_abs = b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"abs\""
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q+1",
            "\"%dx%d\"",
            "&gw",
            "&gh"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_touchscreen",
          "args": [
            "1"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_touchscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "572-574",
          "snippet": "void set_uinput_touchscreen(int b) {\n\tuinput_touchscreen = b;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_uinput_touchscreen(int);",
            "static int uinput_touchscreen = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_touchscreen(int);\nstatic int uinput_touchscreen = 0;\n\nvoid set_uinput_touchscreen(int b) {\n\tuinput_touchscreen = b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"touch\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"dragskip=\")"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"dragskip=\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"dragskip=\""
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"btn_touch=\")"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"btn_touch=\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"btn_touch=\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"touch_always=\")"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"touch_always=\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"touch_always=\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "p",
            "\"KMB\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_always",
          "args": [
            "n"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "568-570",
          "snippet": "void set_uinput_always(int a) {\n\tuinput_always = a;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_uinput_always(int);",
            "static double a[7];",
            "static int uinput_always = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_always(int);\nstatic double a[7];\nstatic int uinput_always = 0;\n\nvoid set_uinput_always(int a) {\n\tuinput_always = a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"always=\")"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"always=\""
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"always=\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_reset",
          "args": [
            "n"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "563-566",
          "snippet": "void set_uinput_reset(int ms) {\n\tzero_delay = (double) ms/1000.;\n\trfbLog(\"set_uinput_reset: %d\\n\", ms);\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_uinput_reset(int ms);",
            "static double zero_delay = 0.15;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_reset(int ms);\nstatic double zero_delay = 0.15;\n\nvoid set_uinput_reset(int ms) {\n\tzero_delay = (double) ms/1000.;\n\trfbLog(\"set_uinput_reset: %d\\n\", ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"reset=\")"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"reset=\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"reset=\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_thresh",
          "args": [
            "q"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "550-561",
          "snippet": "int set_uinput_thresh(char *str) {\n\trfbLog(\"set_uinput_thresh: str=%s\\n\", str);\n\tif (str[0] == '+') {\n\t\tthresh_or = 0;\n\t}\n\tthresh = atoi(str);\n\tif (uinput_thresh_str) {\n\t\tfree(uinput_thresh_str);\n\t}\n\tuinput_thresh_str = strdup(str);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_uinput_accel(char *str);",
            "int set_uinput_thresh(char *str);",
            "void parse_uinput_str(char *str);",
            "static int thresh = 5;",
            "static int thresh_or = 1;",
            "static char *uinput_thresh_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint set_uinput_accel(char *str);\nint set_uinput_thresh(char *str);\nvoid parse_uinput_str(char *str);\nstatic int thresh = 5;\nstatic int thresh_or = 1;\nstatic char *uinput_thresh_str = NULL;\n\nint set_uinput_thresh(char *str) {\n\trfbLog(\"set_uinput_thresh: str=%s\\n\", str);\n\tif (str[0] == '+') {\n\t\tthresh_or = 0;\n\t}\n\tthresh = atoi(str);\n\tif (uinput_thresh_str) {\n\t\tfree(uinput_thresh_str);\n\t}\n\tuinput_thresh_str = strdup(str);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"thresh=\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"thresh=\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_accel",
          "args": [
            "q"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_accel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "532-548",
          "snippet": "int set_uinput_accel(char *str) {\n\tdouble fx, fy;\n\trfbLog(\"set_uinput_accel: str=%s\\n\", str);\n\tif (sscanf(str, \"%lf+%lf\", &fx, &fy) == 2) {\n\t\tset_uinput_accel_xy(fx, fy);\n\t} else if (sscanf(str, \"%lf\", &fx) == 1) {\n\t\tset_uinput_accel_xy(fx, fx);\n\t} else {\n\t\trfbLog(\"invalid UINPUT accel= option: %s\\n\", str);\n\t\treturn 0;\n\t}\n\tif (uinput_accel_str) {\n\t\tfree(uinput_accel_str);\n\t}\n\tuinput_accel_str = strdup(str);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_uinput_accel(char *str);",
            "int set_uinput_thresh(char *str);",
            "void parse_uinput_str(char *str);",
            "static void set_uinput_accel_xy(double fx, double fy);",
            "static char *uinput_accel_str = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint set_uinput_accel(char *str);\nint set_uinput_thresh(char *str);\nvoid parse_uinput_str(char *str);\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic char *uinput_accel_str = NULL;\n\nint set_uinput_accel(char *str) {\n\tdouble fx, fy;\n\trfbLog(\"set_uinput_accel: str=%s\\n\", str);\n\tif (sscanf(str, \"%lf+%lf\", &fx, &fy) == 2) {\n\t\tset_uinput_accel_xy(fx, fy);\n\t} else if (sscanf(str, \"%lf\", &fx) == 1) {\n\t\tset_uinput_accel_xy(fx, fx);\n\t} else {\n\t\trfbLog(\"invalid UINPUT accel= option: %s\\n\", str);\n\t\treturn 0;\n\t}\n\tif (uinput_accel_str) {\n\t\tfree(uinput_accel_str);\n\t}\n\tuinput_accel_str = strdup(str);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"accel=\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"accel=\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"nouinput\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "p"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"KMB\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "in"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint set_uinput_accel(char *str);\nint set_uinput_thresh(char *str);\nvoid set_uinput_always(int);\nvoid set_uinput_touchscreen(int);\nvoid set_uinput_abs(int);\nvoid parse_uinput_str(char *str);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int direct_abs_fd = -1;\nstatic int direct_btn_fd = -1;\nstatic int direct_key_fd = -1;\nstatic char *injectable = NULL;\nstatic char *uinput_dev = NULL;\nstatic char *tslib_cal = NULL;\nstatic int uinput_touchscreen = 0;\nstatic int uinput_abs = 0;\nstatic int btn_touch = 0;\nstatic int dragskip = 0;\nstatic int touch_always = 0;\nstatic int touch_pressure = 1;\nstatic int abs_x = 0, abs_y = 0;\nstatic int thresh = 5;\n\nvoid parse_uinput_str(char *in) {\n\tchar *p, *q, *str = strdup(in);\n\n\tif (injectable) {\n\t\tfree(injectable);\n\t\tinjectable = strdup(\"KMB\");\n\t}\n\n\tuinput_touchscreen = 0;\n\tuinput_abs = 0;\n\tabs_x = abs_y = 0;\n\n\tif (tslib_cal) {\n\t\tfree(tslib_cal);\n\t\ttslib_cal = NULL;\n\t}\n\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (p[0] == '/') {\n\t\t\tif (uinput_dev) {\n\t\t\t\tfree(uinput_dev);\n\t\t\t}\n\t\t\tuinput_dev = strdup(p);\n\t\t} else if (strstr(p, \"nouinput\") == p) {\n\t\t\tif (uinput_dev) {\n\t\t\t\tfree(uinput_dev);\n\t\t\t}\n\t\t\tuinput_dev = strdup(p);\n\t\t} else if (strstr(p, \"accel=\") == p) {\n\t\t\tq = p + strlen(\"accel=\");\n\t\t\tif (! set_uinput_accel(q)) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t} else if (strstr(p, \"thresh=\") == p) {\n\t\t\tq = p + strlen(\"thresh=\");\n\t\t\tset_uinput_thresh(q);\n\n\t\t} else if (strstr(p, \"reset=\") == p) {\n\t\t\tint n = atoi(p + strlen(\"reset=\"));\n\t\t\tset_uinput_reset(n);\n\t\t} else if (strstr(p, \"always=\") == p) {\n\t\t\tint n = atoi(p + strlen(\"always=\"));\n\t\t\tset_uinput_always(n);\n\t\t} else if (strpbrk(p, \"KMB\") == p) {\n\t\t\tif (injectable) {\n\t\t\t\tfree(injectable);\n\t\t\t}\n\t\t\tinjectable = strdup(p);\n\t\t} else if (strstr(p, \"touch_always=\") == p) {\n\t\t\ttouch_always = atoi(p + strlen(\"touch_always=\"));\n\t\t} else if (strstr(p, \"btn_touch=\") == p) {\n\t\t\tbtn_touch = atoi(p + strlen(\"btn_touch=\"));\n\t\t} else if (strstr(p, \"dragskip=\") == p) {\n\t\t\tdragskip = atoi(p + strlen(\"dragskip=\"));\n\t\t} else if (strstr(p, \"touch\") == p) {\n\t\t\tint gw, gh;\n\t\t\tq = strchr(p, '=');\n\t\t\tset_uinput_touchscreen(1);\n\t\t\tset_uinput_abs(1);\n\t\t\tif (q && sscanf(q+1, \"%dx%d\", &gw, &gh) == 2) {\n\t\t\t\tabs_x = gw;\n\t\t\t\tabs_y = gh;\n\t\t\t}\n\t\t} else if (strstr(p, \"abs\") == p) {\n\t\t\tint gw, gh;\n\t\t\tq = strchr(p, '=');\n\t\t\tset_uinput_abs(1);\n\t\t\tif (q && sscanf(q+1, \"%dx%d\", &gw, &gh) == 2) {\n\t\t\t\tabs_x = gw;\n\t\t\t\tabs_y = gh;\n\t\t\t}\n\t\t} else if (strstr(p, \"pressure=\") == p) {\n\t\t\ttouch_pressure = atoi(p + strlen(\"pressure=\"));\n\t\t} else if (strstr(p, \"direct_rel=\") == p) {\n\t\t\tdirect_rel_fd = open(p+strlen(\"direct_rel=\"), O_WRONLY);\n\t\t\tif (direct_rel_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_rel open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_rel_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"direct_abs=\") == p) {\n\t\t\tdirect_abs_fd = open(p+strlen(\"direct_abs=\"), O_WRONLY);\n\t\t\tif (direct_abs_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_abs open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_abs_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"direct_btn=\") == p) {\n\t\t\tdirect_btn_fd = open(p+strlen(\"direct_btn=\"), O_WRONLY);\n\t\t\tif (direct_btn_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_btn open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_btn_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"direct_key=\") == p) {\n\t\t\tdirect_key_fd = open(p+strlen(\"direct_key=\"), O_WRONLY);\n\t\t\tif (direct_key_fd < 0) {\n\t\t\t\trfbLogPerror(\"uinput: direct_key open\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"uinput: opened: %s fd=%d\\n\", p, direct_key_fd);\n\t\t\t}\n\t\t} else if (strstr(p, \"tslib_cal=\") == p) {\n\t\t\ttslib_cal = strdup(p+strlen(\"tslib_cal=\"));\n\t\t} else {\n\t\t\trfbLog(\"invalid UINPUT option: %s\\n\", p);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n}"
  },
  {
    "function_name": "get_uinput_abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "598-600",
    "snippet": "int get_uinput_abs(void) {\n\treturn uinput_abs;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_uinput_abs();",
      "static int uinput_abs = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint get_uinput_abs();\nstatic int uinput_abs = 0;\n\nint get_uinput_abs(void) {\n\treturn uinput_abs;\n}"
  },
  {
    "function_name": "get_uinput_touchscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "594-596",
    "snippet": "int get_uinput_touchscreen(void) {\n\treturn uinput_touchscreen;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_uinput_touchscreen();",
      "static int uinput_touchscreen = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint get_uinput_touchscreen();\nstatic int uinput_touchscreen = 0;\n\nint get_uinput_touchscreen(void) {\n\treturn uinput_touchscreen;\n}"
  },
  {
    "function_name": "get_uinput_always",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "590-592",
    "snippet": "int get_uinput_always(void) {\n\treturn uinput_always;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_uinput_always();",
      "static int uinput_always = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint get_uinput_always();\nstatic int uinput_always = 0;\n\nint get_uinput_always(void) {\n\treturn uinput_always;\n}"
  },
  {
    "function_name": "get_uinput_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "586-588",
    "snippet": "int get_uinput_reset(void) {\n\treturn (int) (1000 * zero_delay);\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_uinput_reset();",
      "static double zero_delay = 0.15;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint get_uinput_reset();\nstatic double zero_delay = 0.15;\n\nint get_uinput_reset(void) {\n\treturn (int) (1000 * zero_delay);\n}"
  },
  {
    "function_name": "get_uinput_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "583-585",
    "snippet": "char *get_uinput_thresh(void) {\n\treturn uinput_thresh_str;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_uinput_thresh();",
      "static char *uinput_thresh_str = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *get_uinput_thresh();\nstatic char *uinput_thresh_str = NULL;\n\nchar *get_uinput_thresh(void) {\n\treturn uinput_thresh_str;\n}"
  },
  {
    "function_name": "get_uinput_accel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "580-582",
    "snippet": "char *get_uinput_accel(void) {\n\treturn uinput_accel_str;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_uinput_accel();",
      "static char *uinput_accel_str = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *get_uinput_accel();\nstatic char *uinput_accel_str = NULL;\n\nchar *get_uinput_accel(void) {\n\treturn uinput_accel_str;\n}"
  },
  {
    "function_name": "set_uinput_abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "576-578",
    "snippet": "void set_uinput_abs(int b) {\n\tuinput_abs = b;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_uinput_abs(int);",
      "static int uinput_abs = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_abs(int);\nstatic int uinput_abs = 0;\n\nvoid set_uinput_abs(int b) {\n\tuinput_abs = b;\n}"
  },
  {
    "function_name": "set_uinput_touchscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "572-574",
    "snippet": "void set_uinput_touchscreen(int b) {\n\tuinput_touchscreen = b;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_uinput_touchscreen(int);",
      "static int uinput_touchscreen = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_touchscreen(int);\nstatic int uinput_touchscreen = 0;\n\nvoid set_uinput_touchscreen(int b) {\n\tuinput_touchscreen = b;\n}"
  },
  {
    "function_name": "set_uinput_always",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "568-570",
    "snippet": "void set_uinput_always(int a) {\n\tuinput_always = a;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_uinput_always(int);",
      "static double a[7];",
      "static int uinput_always = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_always(int);\nstatic double a[7];\nstatic int uinput_always = 0;\n\nvoid set_uinput_always(int a) {\n\tuinput_always = a;\n}"
  },
  {
    "function_name": "set_uinput_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "563-566",
    "snippet": "void set_uinput_reset(int ms) {\n\tzero_delay = (double) ms/1000.;\n\trfbLog(\"set_uinput_reset: %d\\n\", ms);\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_uinput_reset(int ms);",
      "static double zero_delay = 0.15;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_reset: %d\\n\"",
            "ms"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_uinput_reset(int ms);\nstatic double zero_delay = 0.15;\n\nvoid set_uinput_reset(int ms) {\n\tzero_delay = (double) ms/1000.;\n\trfbLog(\"set_uinput_reset: %d\\n\", ms);\n}"
  },
  {
    "function_name": "set_uinput_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "550-561",
    "snippet": "int set_uinput_thresh(char *str) {\n\trfbLog(\"set_uinput_thresh: str=%s\\n\", str);\n\tif (str[0] == '+') {\n\t\tthresh_or = 0;\n\t}\n\tthresh = atoi(str);\n\tif (uinput_thresh_str) {\n\t\tfree(uinput_thresh_str);\n\t}\n\tuinput_thresh_str = strdup(str);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int set_uinput_accel(char *str);",
      "int set_uinput_thresh(char *str);",
      "void parse_uinput_str(char *str);",
      "static int thresh = 5;",
      "static int thresh_or = 1;",
      "static char *uinput_thresh_str = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uinput_thresh_str"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "str"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_thresh: str=%s\\n\"",
            "str"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint set_uinput_accel(char *str);\nint set_uinput_thresh(char *str);\nvoid parse_uinput_str(char *str);\nstatic int thresh = 5;\nstatic int thresh_or = 1;\nstatic char *uinput_thresh_str = NULL;\n\nint set_uinput_thresh(char *str) {\n\trfbLog(\"set_uinput_thresh: str=%s\\n\", str);\n\tif (str[0] == '+') {\n\t\tthresh_or = 0;\n\t}\n\tthresh = atoi(str);\n\tif (uinput_thresh_str) {\n\t\tfree(uinput_thresh_str);\n\t}\n\tuinput_thresh_str = strdup(str);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_uinput_accel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "532-548",
    "snippet": "int set_uinput_accel(char *str) {\n\tdouble fx, fy;\n\trfbLog(\"set_uinput_accel: str=%s\\n\", str);\n\tif (sscanf(str, \"%lf+%lf\", &fx, &fy) == 2) {\n\t\tset_uinput_accel_xy(fx, fy);\n\t} else if (sscanf(str, \"%lf\", &fx) == 1) {\n\t\tset_uinput_accel_xy(fx, fx);\n\t} else {\n\t\trfbLog(\"invalid UINPUT accel= option: %s\\n\", str);\n\t\treturn 0;\n\t}\n\tif (uinput_accel_str) {\n\t\tfree(uinput_accel_str);\n\t}\n\tuinput_accel_str = strdup(str);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int set_uinput_accel(char *str);",
      "int set_uinput_thresh(char *str);",
      "void parse_uinput_str(char *str);",
      "static void set_uinput_accel_xy(double fx, double fy);",
      "static char *uinput_accel_str = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uinput_accel_str"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"invalid UINPUT accel= option: %s\\n\"",
            "str"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_accel_xy",
          "args": [
            "fx",
            "fx"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_accel_xy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "522-527",
          "snippet": "static void set_uinput_accel_xy(double fx, double fy) {\n\tfudge_x = 1.0/fx;\n\tfudge_y = 1.0/fy;\n\trfbLog(\"set_uinput_accel:  fx=%.5f fy=%.5f\\n\", fx, fy);\n\trfbLog(\"set_uinput_accel:  ix=%.5f iy=%.5f\\n\", fudge_x, fudge_y);\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_uinput_accel_xy(double fx, double fy);",
            "static double fudge_x = 0.5;",
            "static double fudge_y = 0.5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic double fudge_x = 0.5;\nstatic double fudge_y = 0.5;\n\nstatic void set_uinput_accel_xy(double fx, double fy) {\n\tfudge_x = 1.0/fx;\n\tfudge_y = 1.0/fy;\n\trfbLog(\"set_uinput_accel:  fx=%.5f fy=%.5f\\n\", fx, fy);\n\trfbLog(\"set_uinput_accel:  ix=%.5f iy=%.5f\\n\", fudge_x, fudge_y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lf\"",
            "&fx"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%lf+%lf\"",
            "&fx",
            "&fy"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_accel: str=%s\\n\"",
            "str"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint set_uinput_accel(char *str);\nint set_uinput_thresh(char *str);\nvoid parse_uinput_str(char *str);\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic char *uinput_accel_str = NULL;\n\nint set_uinput_accel(char *str) {\n\tdouble fx, fy;\n\trfbLog(\"set_uinput_accel: str=%s\\n\", str);\n\tif (sscanf(str, \"%lf+%lf\", &fx, &fy) == 2) {\n\t\tset_uinput_accel_xy(fx, fy);\n\t} else if (sscanf(str, \"%lf\", &fx) == 1) {\n\t\tset_uinput_accel_xy(fx, fx);\n\t} else {\n\t\trfbLog(\"invalid UINPUT accel= option: %s\\n\", str);\n\t\treturn 0;\n\t}\n\tif (uinput_accel_str) {\n\t\tfree(uinput_accel_str);\n\t}\n\tuinput_accel_str = strdup(str);\n\treturn 1;\n}"
  },
  {
    "function_name": "set_uinput_accel_xy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "522-527",
    "snippet": "static void set_uinput_accel_xy(double fx, double fy) {\n\tfudge_x = 1.0/fx;\n\tfudge_y = 1.0/fy;\n\trfbLog(\"set_uinput_accel:  fx=%.5f fy=%.5f\\n\", fx, fy);\n\trfbLog(\"set_uinput_accel:  ix=%.5f iy=%.5f\\n\", fudge_x, fudge_y);\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_uinput_accel_xy(double fx, double fy);",
      "static double fudge_x = 0.5;",
      "static double fudge_y = 0.5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_accel:  ix=%.5f iy=%.5f\\n\"",
            "fudge_x",
            "fudge_y"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_uinput_accel:  fx=%.5f fy=%.5f\\n\"",
            "fx",
            "fy"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic double fudge_x = 0.5;\nstatic double fudge_y = 0.5;\n\nstatic void set_uinput_accel_xy(double fx, double fy) {\n\tfudge_x = 1.0/fx;\n\tfudge_y = 1.0/fy;\n\trfbLog(\"set_uinput_accel:  fx=%.5f fy=%.5f\\n\", fx, fy);\n\trfbLog(\"set_uinput_accel:  ix=%.5f iy=%.5f\\n\", fudge_x, fudge_y);\n}"
  },
  {
    "function_name": "initialize_uinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "360-505",
    "snippet": "int initialize_uinput(void) {\n#ifndef UINPUT_OK\n\treturn 0;\n#else\n\tint i;\n\tchar *s;\n\tstruct uinput_user_dev udev;\n\n\tif (fd >= 0) {\n\t\tshutdown_uinput();\n\t}\n\tfd = -1;\n\n\tif (getenv(\"X11VNC_UINPUT_DEBUG\")) {\n\t\tdb = atoi(getenv(\"X11VNC_UINPUT_DEBUG\"));\n\t\trfbLog(\"set uinput debug to: %d\\n\", db);\n\t}\n\n\tif (tslib_cal) {\n\t\tload_tslib_cal();\t\n\t}\n\n\tinit_key_tracker();\n\t\n\tif (uinput_dev) {\n\t\tif (!strcmp(uinput_dev, \"nouinput\")) {\n\t\t\trfbLog(\"initialize_uinput: not creating uinput device.\\n\");\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfd = open(uinput_dev, O_WRONLY | O_NDELAY);\n\t\t\trfbLog(\"initialize_uinput: using: %s %d\\n\", uinput_dev, fd);\n\t\t}\n\t} else {\n\t\ti = 0;\n\t\twhile (devs[i] != NULL) {\n\t\t\tif ( (fd = open(devs[i], O_WRONLY | O_NDELAY)) >= 0) {\n\t\t\t\trfbLog(\"initialize_uinput: using: %s %d\\n\",\n\t\t\t\t    devs[i], fd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\trfbLog(\"initialize_uinput: could not open an uinput device.\\n\");\n\t\trfbLogPerror(\"open\");\n\t\tif (direct_rel_fd < 0 && direct_abs_fd < 0 && direct_btn_fd < 0 && direct_key_fd < 0) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tmemset(&udev, 0, sizeof(udev));\n\n\tstrncpy(udev.name, \"x11vnc injector\", UINPUT_MAX_NAME_SIZE);\n\n\ts = getenv(\"X11VNC_UINPUT_BUS\");\n\tif (s) {\n\t\tudev.id.bustype = get_bustype(s);\n\t} else if (0) {\n\t\tudev.id.bustype = BUS_USB;\n\t}\n\n\ts = getenv(\"X11VNC_UINPUT_VERSION\");\n\tif (s) {\n\t\tudev.id.version = atoi(s);\n\t} else if (0) {\n\t\tudev.id.version = 4;\n\t}\n\n\tioctl(fd, UI_SET_EVBIT, EV_REL);\n\tioctl(fd, UI_SET_RELBIT, REL_X);\n\tioctl(fd, UI_SET_RELBIT, REL_Y);\n\n\tioctl(fd, UI_SET_EVBIT, EV_KEY);\n\n\tioctl(fd, UI_SET_EVBIT, EV_SYN);\n\n\tfor (i=0; i < 256; i++) {\n\t\tioctl(fd, UI_SET_KEYBIT, i);\n\t}\n\n\tioctl(fd, UI_SET_KEYBIT, BTN_MOUSE);\n\tioctl(fd, UI_SET_KEYBIT, BTN_LEFT);\n\tioctl(fd, UI_SET_KEYBIT, BTN_MIDDLE);\n\tioctl(fd, UI_SET_KEYBIT, BTN_RIGHT);\n\tioctl(fd, UI_SET_KEYBIT, BTN_FORWARD);\n\tioctl(fd, UI_SET_KEYBIT, BTN_BACK);\n\n\tif (uinput_touchscreen) {\n\t\tioctl(fd, UI_SET_KEYBIT, BTN_TOUCH);\n\t\trfbLog(\"uinput: touchscreen enabled.\\n\");\n\t}\n\tif (uinput_touchscreen || uinput_abs) {\n\t\tint gw = abs_x, gh = abs_y;\n\t\tif (! gw || ! gh) {\n\t\t\tgw = fb_x; gh = fb_y;\n\t\t}\n\t\tif (! gw || ! gh) {\n\t\t\tgw = dpy_x; gh = dpy_y;\n\t\t}\n\t\tabs_x = gw;\n\t\tabs_y = gh;\n\t\tioctl(fd, UI_SET_EVBIT, EV_ABS);\n\t\tioctl(fd, UI_SET_ABSBIT, ABS_X);\n\t\tioctl(fd, UI_SET_ABSBIT, ABS_Y);\n\t\tudev.absmin[ABS_X] = 0;\n\t\tudev.absmax[ABS_X] = gw;\n\t\tudev.absfuzz[ABS_X] = 0;\n\t\tudev.absflat[ABS_X] = 0;\n\t\tudev.absmin[ABS_Y] = 0;\n\t\tudev.absmax[ABS_Y] = gh;\n\t\tudev.absfuzz[ABS_Y] = 0;\n\t\tudev.absflat[ABS_Y] = 0;\n\t\trfbLog(\"uinput: absolute pointer enabled at %dx%d.\\n\", abs_x, abs_y);\n\t\tset_uinput_accel_xy(1.0, 1.0);\n\t}\n\n\tif (db) {\n\t\trfbLog(\"   udev.name:             %s\\n\", udev.name);\n\t\trfbLog(\"   udev.id.bustype:       %d\\n\", udev.id.bustype);\n\t\trfbLog(\"   udev.id.vendor:        %d\\n\", udev.id.vendor);\n\t\trfbLog(\"   udev.id.product:       %d\\n\", udev.id.product);\n\t\trfbLog(\"   udev.id.version:       %d\\n\", udev.id.version);\n\t\trfbLog(\"   udev.ff_effects_max:   %d\\n\", udev.ff_effects_max);\n\t\trfbLog(\"   udev.absmin[ABS_X]:    %d\\n\", udev.absmin[ABS_X]);\n\t\trfbLog(\"   udev.absmax[ABS_X]:    %d\\n\", udev.absmax[ABS_X]);\n\t\trfbLog(\"   udev.absfuzz[ABS_X]:   %d\\n\", udev.absfuzz[ABS_X]);\n\t\trfbLog(\"   udev.absflat[ABS_X]:   %d\\n\", udev.absflat[ABS_X]);\n\t\trfbLog(\"   udev.absmin[ABS_Y]:    %d\\n\", udev.absmin[ABS_Y]);\n\t\trfbLog(\"   udev.absmax[ABS_Y]:    %d\\n\", udev.absmax[ABS_Y]);\n\t\trfbLog(\"   udev.absfuzz[ABS_Y]:   %d\\n\", udev.absfuzz[ABS_Y]);\n\t\trfbLog(\"   udev.absflat[ABS_Y]:   %d\\n\", udev.absflat[ABS_Y]);\n\t}\n\n\twrite(fd, &udev, sizeof(udev));\n\n\tif (ioctl(fd, UI_DEV_CREATE) != 0) {\n\t\trfbLog(\"ioctl(fd, UI_DEV_CREATE) failed.\\n\");\n\t\trfbLogPerror(\"ioctl\");\n\t\tclose(fd);\n\t\tclean_up_exit(1);\n\t}\n\treturn 1;\n#endif\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define O_NDELAY 0",
      "#define O_NDELAY O_NONBLOCK",
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "int initialize_uinput(void);",
      "void shutdown_uinput(void);",
      "static void init_key_tracker(void);",
      "static int fd = -1;",
      "static int direct_rel_fd = -1;",
      "static int direct_abs_fd = -1;",
      "static int direct_btn_fd = -1;",
      "static int direct_key_fd = -1;",
      "static int db = 0;",
      "static char *uinput_dev = NULL;",
      "static char *tslib_cal = NULL;",
      "static int uinput_touchscreen = 0;",
      "static int uinput_abs = 0;",
      "static int abs_x = 0, abs_y = 0;",
      "static char *devs[] = {\n\t\"/dev/misc/uinput\",\n\t\"/dev/input/uinput\",\n\t\"/dev/uinput\",\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"ioctl\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"ioctl(fd, UI_DEV_CREATE) failed.\\n\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_DEV_CREATE"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "&udev",
            "sizeof(udev)"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absflat[ABS_Y]:   %d\\n\"",
            "udev.absflat[ABS_Y]"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absfuzz[ABS_Y]:   %d\\n\"",
            "udev.absfuzz[ABS_Y]"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absmax[ABS_Y]:    %d\\n\"",
            "udev.absmax[ABS_Y]"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absmin[ABS_Y]:    %d\\n\"",
            "udev.absmin[ABS_Y]"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absflat[ABS_X]:   %d\\n\"",
            "udev.absflat[ABS_X]"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absfuzz[ABS_X]:   %d\\n\"",
            "udev.absfuzz[ABS_X]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absmax[ABS_X]:    %d\\n\"",
            "udev.absmax[ABS_X]"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.absmin[ABS_X]:    %d\\n\"",
            "udev.absmin[ABS_X]"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.ff_effects_max:   %d\\n\"",
            "udev.ff_effects_max"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.id.version:       %d\\n\"",
            "udev.id.version"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.id.product:       %d\\n\"",
            "udev.id.product"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.id.vendor:        %d\\n\"",
            "udev.id.vendor"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.id.bustype:       %d\\n\"",
            "udev.id.bustype"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   udev.name:             %s\\n\"",
            "udev.name"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_uinput_accel_xy",
          "args": [
            "1.0",
            "1.0"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "set_uinput_accel_xy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "522-527",
          "snippet": "static void set_uinput_accel_xy(double fx, double fy) {\n\tfudge_x = 1.0/fx;\n\tfudge_y = 1.0/fy;\n\trfbLog(\"set_uinput_accel:  fx=%.5f fy=%.5f\\n\", fx, fy);\n\trfbLog(\"set_uinput_accel:  ix=%.5f iy=%.5f\\n\", fudge_x, fudge_y);\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_uinput_accel_xy(double fx, double fy);",
            "static double fudge_x = 0.5;",
            "static double fudge_y = 0.5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_uinput_accel_xy(double fx, double fy);\nstatic double fudge_x = 0.5;\nstatic double fudge_y = 0.5;\n\nstatic void set_uinput_accel_xy(double fx, double fy) {\n\tfudge_x = 1.0/fx;\n\tfudge_y = 1.0/fy;\n\trfbLog(\"set_uinput_accel:  fx=%.5f fy=%.5f\\n\", fx, fy);\n\trfbLog(\"set_uinput_accel:  ix=%.5f iy=%.5f\\n\", fudge_x, fudge_y);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"uinput: absolute pointer enabled at %dx%d.\\n\"",
            "abs_x",
            "abs_y"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_ABSBIT",
            "ABS_Y"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_ABSBIT",
            "ABS_X"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_EVBIT",
            "EV_ABS"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"uinput: touchscreen enabled.\\n\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "BTN_TOUCH"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "BTN_BACK"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "BTN_FORWARD"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "BTN_RIGHT"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "BTN_MIDDLE"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "BTN_LEFT"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "BTN_MOUSE"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_KEYBIT",
            "i"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_EVBIT",
            "EV_SYN"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_EVBIT",
            "EV_KEY"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_RELBIT",
            "REL_Y"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_RELBIT",
            "REL_X"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_SET_EVBIT",
            "EV_REL"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_UINPUT_VERSION\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bustype",
          "args": [
            "s"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "get_bustype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "241-306",
          "snippet": "static int get_bustype(char *s) {\n#ifdef UINPUT_OK\n\n\tif (!s) return 0;\n\n#ifdef BUS_PCI\n\tif(!strcmp(s, \"BUS_PCI\"))\treturn BUS_PCI;\n#endif\n#ifdef BUS_ISAPNP\n\tif(!strcmp(s, \"BUS_ISAPNP\"))\treturn BUS_ISAPNP;\n#endif\n#ifdef BUS_USB\n\tif(!strcmp(s, \"BUS_USB\"))\treturn BUS_USB;\n#endif\n#ifdef BUS_HIL\n\tif(!strcmp(s, \"BUS_HIL\"))\treturn BUS_HIL;\n#endif\n#ifdef BUS_BLUETOOTH\n\tif(!strcmp(s, \"BUS_BLUETOOTH\"))\treturn BUS_BLUETOOTH;\n#endif\n#ifdef BUS_VIRTUAL\n\tif(!strcmp(s, \"BUS_VIRTUAL\"))\treturn BUS_VIRTUAL;\n#endif\n#ifdef BUS_ISA\n\tif(!strcmp(s, \"BUS_ISA\"))\treturn BUS_ISA;\n#endif\n#ifdef BUS_I8042\n\tif(!strcmp(s, \"BUS_I8042\"))\treturn BUS_I8042;\n#endif\n#ifdef BUS_XTKBD\n\tif(!strcmp(s, \"BUS_XTKBD\"))\treturn BUS_XTKBD;\n#endif\n#ifdef BUS_RS232\n\tif(!strcmp(s, \"BUS_RS232\"))\treturn BUS_RS232;\n#endif\n#ifdef BUS_GAMEPORT\n\tif(!strcmp(s, \"BUS_GAMEPORT\"))\treturn BUS_GAMEPORT;\n#endif\n#ifdef BUS_PARPORT\n\tif(!strcmp(s, \"BUS_PARPORT\"))\treturn BUS_PARPORT;\n#endif\n#ifdef BUS_AMIGA\n\tif(!strcmp(s, \"BUS_AMIGA\"))\treturn BUS_AMIGA;\n#endif\n#ifdef BUS_ADB\n\tif(!strcmp(s, \"BUS_ADB\"))\treturn BUS_ADB;\n#endif\n#ifdef BUS_I2C\n\tif(!strcmp(s, \"BUS_I2C\"))\treturn BUS_I2C;\n#endif\n#ifdef BUS_HOST\n\tif(!strcmp(s, \"BUS_HOST\"))\treturn BUS_HOST;\n#endif\n#ifdef BUS_GSC\n\tif(!strcmp(s, \"BUS_GSC\"))\treturn BUS_GSC;\n#endif\n#ifdef BUS_ATARI\n\tif(!strcmp(s, \"BUS_ATARI\"))\treturn BUS_ATARI;\n#endif\n\tif (atoi(s) > 0) {\n\t\treturn atoi(s);\n\t}\n\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UINPUT_OK"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nstatic int get_bustype(char *s) {\n#ifdef UINPUT_OK\n\n\tif (!s) return 0;\n\n#ifdef BUS_PCI\n\tif(!strcmp(s, \"BUS_PCI\"))\treturn BUS_PCI;\n#endif\n#ifdef BUS_ISAPNP\n\tif(!strcmp(s, \"BUS_ISAPNP\"))\treturn BUS_ISAPNP;\n#endif\n#ifdef BUS_USB\n\tif(!strcmp(s, \"BUS_USB\"))\treturn BUS_USB;\n#endif\n#ifdef BUS_HIL\n\tif(!strcmp(s, \"BUS_HIL\"))\treturn BUS_HIL;\n#endif\n#ifdef BUS_BLUETOOTH\n\tif(!strcmp(s, \"BUS_BLUETOOTH\"))\treturn BUS_BLUETOOTH;\n#endif\n#ifdef BUS_VIRTUAL\n\tif(!strcmp(s, \"BUS_VIRTUAL\"))\treturn BUS_VIRTUAL;\n#endif\n#ifdef BUS_ISA\n\tif(!strcmp(s, \"BUS_ISA\"))\treturn BUS_ISA;\n#endif\n#ifdef BUS_I8042\n\tif(!strcmp(s, \"BUS_I8042\"))\treturn BUS_I8042;\n#endif\n#ifdef BUS_XTKBD\n\tif(!strcmp(s, \"BUS_XTKBD\"))\treturn BUS_XTKBD;\n#endif\n#ifdef BUS_RS232\n\tif(!strcmp(s, \"BUS_RS232\"))\treturn BUS_RS232;\n#endif\n#ifdef BUS_GAMEPORT\n\tif(!strcmp(s, \"BUS_GAMEPORT\"))\treturn BUS_GAMEPORT;\n#endif\n#ifdef BUS_PARPORT\n\tif(!strcmp(s, \"BUS_PARPORT\"))\treturn BUS_PARPORT;\n#endif\n#ifdef BUS_AMIGA\n\tif(!strcmp(s, \"BUS_AMIGA\"))\treturn BUS_AMIGA;\n#endif\n#ifdef BUS_ADB\n\tif(!strcmp(s, \"BUS_ADB\"))\treturn BUS_ADB;\n#endif\n#ifdef BUS_I2C\n\tif(!strcmp(s, \"BUS_I2C\"))\treturn BUS_I2C;\n#endif\n#ifdef BUS_HOST\n\tif(!strcmp(s, \"BUS_HOST\"))\treturn BUS_HOST;\n#endif\n#ifdef BUS_GSC\n\tif(!strcmp(s, \"BUS_GSC\"))\treturn BUS_GSC;\n#endif\n#ifdef BUS_ATARI\n\tif(!strcmp(s, \"BUS_ATARI\"))\treturn BUS_ATARI;\n#endif\n\tif (atoi(s) > 0) {\n\t\treturn atoi(s);\n\t}\n\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_UINPUT_BUS\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "udev.name",
            "\"x11vnc injector\"",
            "UINPUT_MAX_NAME_SIZE"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&udev",
            "0",
            "sizeof(udev)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"open\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_uinput: could not open an uinput device.\\n\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_uinput: using: %s %d\\n\"",
            "devs[i]",
            "fd"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "devs[i]",
            "O_WRONLY | O_NDELAY"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_uinput: using: %s %d\\n\"",
            "uinput_dev",
            "fd"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialize_uinput: not creating uinput device.\\n\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uinput_dev",
            "\"nouinput\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_key_tracker",
          "args": [],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "init_key_tracker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "178-192",
          "snippet": "static void init_key_tracker(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tkey_pressed[i] = 0;\n\t\tkey_ismod[i] = 0;\n\t}\n\ti = lookup_code(XK_Shift_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Shift_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_key_tracker(void);",
            "static int key_pressed[256];",
            "static int key_ismod[256];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void init_key_tracker(void);\nstatic int key_pressed[256];\nstatic int key_ismod[256];\n\nstatic void init_key_tracker(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tkey_pressed[i] = 0;\n\t\tkey_ismod[i] = 0;\n\t}\n\ti = lookup_code(XK_Shift_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Shift_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_tslib_cal",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "load_tslib_cal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "308-357",
          "snippet": "static void load_tslib_cal(void) {\n\tFILE *f;\n\tchar line[1024], *p;\n\tint i;\n\n\t/* /etc/pointercal -528 33408 -3417516 -44200 408 40292028 56541 */\n\n\t/* this is the identity transformation: */\n\ta[0] = 1.0;\n\ta[1] = 0.0;\n\ta[2] = 0.0;\n\ta[3] = 0.0;\n\ta[4] = 1.0;\n\ta[5] = 0.0;\n\ta[6] = 1.0;\n\n\tif (tslib_cal == NULL) {\n\t\treturn;\n\t}\n\n\trfbLog(\"load_tslib_cal: reading %s\\n\", tslib_cal);\n\tf = fopen(tslib_cal, \"r\");\n\tif (f == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fopen\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (fgets(line, sizeof(line), f) == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tfclose(f);\n\n\tp = strtok(line, \" \\t\");\n\ti = 0;\n\twhile (p) {\n\t\ta[i] = (double) atoi(p);\n\t\trfbLog(\"load_tslib_cal: a[%d] %.3f\\n\", i, a[i]);\n\t\tp = strtok(NULL, \" \\t\");\n\t\ti++;\n\t\tif (i >= 7) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i != 7) {\n\t\trfbLog(\"load_tslib_cal: invalid tslib file format: i=%d %s\\n\",\n\t\t    i, tslib_cal);\n\t\tclean_up_exit(1);\n\t}\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *tslib_cal = NULL;",
            "static double a[7];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic char *tslib_cal = NULL;\nstatic double a[7];\n\nstatic void load_tslib_cal(void) {\n\tFILE *f;\n\tchar line[1024], *p;\n\tint i;\n\n\t/* /etc/pointercal -528 33408 -3417516 -44200 408 40292028 56541 */\n\n\t/* this is the identity transformation: */\n\ta[0] = 1.0;\n\ta[1] = 0.0;\n\ta[2] = 0.0;\n\ta[3] = 0.0;\n\ta[4] = 1.0;\n\ta[5] = 0.0;\n\ta[6] = 1.0;\n\n\tif (tslib_cal == NULL) {\n\t\treturn;\n\t}\n\n\trfbLog(\"load_tslib_cal: reading %s\\n\", tslib_cal);\n\tf = fopen(tslib_cal, \"r\");\n\tif (f == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fopen\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (fgets(line, sizeof(line), f) == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tfclose(f);\n\n\tp = strtok(line, \" \\t\");\n\ti = 0;\n\twhile (p) {\n\t\ta[i] = (double) atoi(p);\n\t\trfbLog(\"load_tslib_cal: a[%d] %.3f\\n\", i, a[i]);\n\t\tp = strtok(NULL, \" \\t\");\n\t\ti++;\n\t\tif (i >= 7) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i != 7) {\n\t\trfbLog(\"load_tslib_cal: invalid tslib file format: i=%d %s\\n\",\n\t\t    i, tslib_cal);\n\t\tclean_up_exit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set uinput debug to: %d\\n\"",
            "db"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_UINPUT_DEBUG\")"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_UINPUT_DEBUG\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_UINPUT_DEBUG\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown_uinput",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_uinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "215-236",
          "snippet": "void shutdown_uinput(void) {\n#ifdef UINPUT_OK\n\tif (fd >= 0) {\n\t\tif (db) {\n\t\t\trfbLog(\"shutdown_uinput called on fd=%d\\n\", fd);\n\t\t}\n\t\tioctl(fd, UI_DEV_DESTROY);\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\t/* close direct injection files too: */\n\tif (direct_rel_fd >= 0) close(direct_rel_fd);\n\tif (direct_abs_fd >= 0) close(direct_abs_fd);\n\tif (direct_btn_fd >= 0) close(direct_btn_fd);\n\tif (direct_key_fd >= 0) close(direct_key_fd);\n\tdirect_rel_fd = -1;\n\tdirect_abs_fd = -1;\n\tdirect_btn_fd = -1;\n\tdirect_key_fd = -1;\n#endif\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "void shutdown_uinput(void);",
            "static int fd = -1;",
            "static int direct_rel_fd = -1;",
            "static int direct_abs_fd = -1;",
            "static int direct_btn_fd = -1;",
            "static int direct_key_fd = -1;",
            "static int db = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nvoid shutdown_uinput(void);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int direct_abs_fd = -1;\nstatic int direct_btn_fd = -1;\nstatic int direct_key_fd = -1;\nstatic int db = 0;\n\nvoid shutdown_uinput(void) {\n#ifdef UINPUT_OK\n\tif (fd >= 0) {\n\t\tif (db) {\n\t\t\trfbLog(\"shutdown_uinput called on fd=%d\\n\", fd);\n\t\t}\n\t\tioctl(fd, UI_DEV_DESTROY);\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\t/* close direct injection files too: */\n\tif (direct_rel_fd >= 0) close(direct_rel_fd);\n\tif (direct_abs_fd >= 0) close(direct_abs_fd);\n\tif (direct_btn_fd >= 0) close(direct_btn_fd);\n\tif (direct_key_fd >= 0) close(direct_key_fd);\n\tdirect_rel_fd = -1;\n\tdirect_abs_fd = -1;\n\tdirect_btn_fd = -1;\n\tdirect_key_fd = -1;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define O_NDELAY 0\n#define O_NDELAY O_NONBLOCK\n#define UINPUT_OK\n\nint initialize_uinput(void);\nvoid shutdown_uinput(void);\nstatic void init_key_tracker(void);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int direct_abs_fd = -1;\nstatic int direct_btn_fd = -1;\nstatic int direct_key_fd = -1;\nstatic int db = 0;\nstatic char *uinput_dev = NULL;\nstatic char *tslib_cal = NULL;\nstatic int uinput_touchscreen = 0;\nstatic int uinput_abs = 0;\nstatic int abs_x = 0, abs_y = 0;\nstatic char *devs[] = {\n\t\"/dev/misc/uinput\",\n\t\"/dev/input/uinput\",\n\t\"/dev/uinput\",\n\tNULL\n};\n\nint initialize_uinput(void) {\n#ifndef UINPUT_OK\n\treturn 0;\n#else\n\tint i;\n\tchar *s;\n\tstruct uinput_user_dev udev;\n\n\tif (fd >= 0) {\n\t\tshutdown_uinput();\n\t}\n\tfd = -1;\n\n\tif (getenv(\"X11VNC_UINPUT_DEBUG\")) {\n\t\tdb = atoi(getenv(\"X11VNC_UINPUT_DEBUG\"));\n\t\trfbLog(\"set uinput debug to: %d\\n\", db);\n\t}\n\n\tif (tslib_cal) {\n\t\tload_tslib_cal();\t\n\t}\n\n\tinit_key_tracker();\n\t\n\tif (uinput_dev) {\n\t\tif (!strcmp(uinput_dev, \"nouinput\")) {\n\t\t\trfbLog(\"initialize_uinput: not creating uinput device.\\n\");\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tfd = open(uinput_dev, O_WRONLY | O_NDELAY);\n\t\t\trfbLog(\"initialize_uinput: using: %s %d\\n\", uinput_dev, fd);\n\t\t}\n\t} else {\n\t\ti = 0;\n\t\twhile (devs[i] != NULL) {\n\t\t\tif ( (fd = open(devs[i], O_WRONLY | O_NDELAY)) >= 0) {\n\t\t\t\trfbLog(\"initialize_uinput: using: %s %d\\n\",\n\t\t\t\t    devs[i], fd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\trfbLog(\"initialize_uinput: could not open an uinput device.\\n\");\n\t\trfbLogPerror(\"open\");\n\t\tif (direct_rel_fd < 0 && direct_abs_fd < 0 && direct_btn_fd < 0 && direct_key_fd < 0) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tmemset(&udev, 0, sizeof(udev));\n\n\tstrncpy(udev.name, \"x11vnc injector\", UINPUT_MAX_NAME_SIZE);\n\n\ts = getenv(\"X11VNC_UINPUT_BUS\");\n\tif (s) {\n\t\tudev.id.bustype = get_bustype(s);\n\t} else if (0) {\n\t\tudev.id.bustype = BUS_USB;\n\t}\n\n\ts = getenv(\"X11VNC_UINPUT_VERSION\");\n\tif (s) {\n\t\tudev.id.version = atoi(s);\n\t} else if (0) {\n\t\tudev.id.version = 4;\n\t}\n\n\tioctl(fd, UI_SET_EVBIT, EV_REL);\n\tioctl(fd, UI_SET_RELBIT, REL_X);\n\tioctl(fd, UI_SET_RELBIT, REL_Y);\n\n\tioctl(fd, UI_SET_EVBIT, EV_KEY);\n\n\tioctl(fd, UI_SET_EVBIT, EV_SYN);\n\n\tfor (i=0; i < 256; i++) {\n\t\tioctl(fd, UI_SET_KEYBIT, i);\n\t}\n\n\tioctl(fd, UI_SET_KEYBIT, BTN_MOUSE);\n\tioctl(fd, UI_SET_KEYBIT, BTN_LEFT);\n\tioctl(fd, UI_SET_KEYBIT, BTN_MIDDLE);\n\tioctl(fd, UI_SET_KEYBIT, BTN_RIGHT);\n\tioctl(fd, UI_SET_KEYBIT, BTN_FORWARD);\n\tioctl(fd, UI_SET_KEYBIT, BTN_BACK);\n\n\tif (uinput_touchscreen) {\n\t\tioctl(fd, UI_SET_KEYBIT, BTN_TOUCH);\n\t\trfbLog(\"uinput: touchscreen enabled.\\n\");\n\t}\n\tif (uinput_touchscreen || uinput_abs) {\n\t\tint gw = abs_x, gh = abs_y;\n\t\tif (! gw || ! gh) {\n\t\t\tgw = fb_x; gh = fb_y;\n\t\t}\n\t\tif (! gw || ! gh) {\n\t\t\tgw = dpy_x; gh = dpy_y;\n\t\t}\n\t\tabs_x = gw;\n\t\tabs_y = gh;\n\t\tioctl(fd, UI_SET_EVBIT, EV_ABS);\n\t\tioctl(fd, UI_SET_ABSBIT, ABS_X);\n\t\tioctl(fd, UI_SET_ABSBIT, ABS_Y);\n\t\tudev.absmin[ABS_X] = 0;\n\t\tudev.absmax[ABS_X] = gw;\n\t\tudev.absfuzz[ABS_X] = 0;\n\t\tudev.absflat[ABS_X] = 0;\n\t\tudev.absmin[ABS_Y] = 0;\n\t\tudev.absmax[ABS_Y] = gh;\n\t\tudev.absfuzz[ABS_Y] = 0;\n\t\tudev.absflat[ABS_Y] = 0;\n\t\trfbLog(\"uinput: absolute pointer enabled at %dx%d.\\n\", abs_x, abs_y);\n\t\tset_uinput_accel_xy(1.0, 1.0);\n\t}\n\n\tif (db) {\n\t\trfbLog(\"   udev.name:             %s\\n\", udev.name);\n\t\trfbLog(\"   udev.id.bustype:       %d\\n\", udev.id.bustype);\n\t\trfbLog(\"   udev.id.vendor:        %d\\n\", udev.id.vendor);\n\t\trfbLog(\"   udev.id.product:       %d\\n\", udev.id.product);\n\t\trfbLog(\"   udev.id.version:       %d\\n\", udev.id.version);\n\t\trfbLog(\"   udev.ff_effects_max:   %d\\n\", udev.ff_effects_max);\n\t\trfbLog(\"   udev.absmin[ABS_X]:    %d\\n\", udev.absmin[ABS_X]);\n\t\trfbLog(\"   udev.absmax[ABS_X]:    %d\\n\", udev.absmax[ABS_X]);\n\t\trfbLog(\"   udev.absfuzz[ABS_X]:   %d\\n\", udev.absfuzz[ABS_X]);\n\t\trfbLog(\"   udev.absflat[ABS_X]:   %d\\n\", udev.absflat[ABS_X]);\n\t\trfbLog(\"   udev.absmin[ABS_Y]:    %d\\n\", udev.absmin[ABS_Y]);\n\t\trfbLog(\"   udev.absmax[ABS_Y]:    %d\\n\", udev.absmax[ABS_Y]);\n\t\trfbLog(\"   udev.absfuzz[ABS_Y]:   %d\\n\", udev.absfuzz[ABS_Y]);\n\t\trfbLog(\"   udev.absflat[ABS_Y]:   %d\\n\", udev.absflat[ABS_Y]);\n\t}\n\n\twrite(fd, &udev, sizeof(udev));\n\n\tif (ioctl(fd, UI_DEV_CREATE) != 0) {\n\t\trfbLog(\"ioctl(fd, UI_DEV_CREATE) failed.\\n\");\n\t\trfbLogPerror(\"ioctl\");\n\t\tclose(fd);\n\t\tclean_up_exit(1);\n\t}\n\treturn 1;\n#endif\n}"
  },
  {
    "function_name": "load_tslib_cal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "308-357",
    "snippet": "static void load_tslib_cal(void) {\n\tFILE *f;\n\tchar line[1024], *p;\n\tint i;\n\n\t/* /etc/pointercal -528 33408 -3417516 -44200 408 40292028 56541 */\n\n\t/* this is the identity transformation: */\n\ta[0] = 1.0;\n\ta[1] = 0.0;\n\ta[2] = 0.0;\n\ta[3] = 0.0;\n\ta[4] = 1.0;\n\ta[5] = 0.0;\n\ta[6] = 1.0;\n\n\tif (tslib_cal == NULL) {\n\t\treturn;\n\t}\n\n\trfbLog(\"load_tslib_cal: reading %s\\n\", tslib_cal);\n\tf = fopen(tslib_cal, \"r\");\n\tif (f == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fopen\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (fgets(line, sizeof(line), f) == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tfclose(f);\n\n\tp = strtok(line, \" \\t\");\n\ti = 0;\n\twhile (p) {\n\t\ta[i] = (double) atoi(p);\n\t\trfbLog(\"load_tslib_cal: a[%d] %.3f\\n\", i, a[i]);\n\t\tp = strtok(NULL, \" \\t\");\n\t\ti++;\n\t\tif (i >= 7) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i != 7) {\n\t\trfbLog(\"load_tslib_cal: invalid tslib file format: i=%d %s\\n\",\n\t\t    i, tslib_cal);\n\t\tclean_up_exit(1);\n\t}\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *tslib_cal = NULL;",
      "static double a[7];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"load_tslib_cal: invalid tslib file format: i=%d %s\\n\"",
            "i",
            "tslib_cal"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \\t\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"load_tslib_cal: a[%d] %.3f\\n\"",
            "i",
            "a[i]"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "line",
            "\" \\t\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"load_tslib_cal: fgets\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "f"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"load_tslib_cal: fopen\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tslib_cal",
            "\"r\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"load_tslib_cal: reading %s\\n\"",
            "tslib_cal"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic char *tslib_cal = NULL;\nstatic double a[7];\n\nstatic void load_tslib_cal(void) {\n\tFILE *f;\n\tchar line[1024], *p;\n\tint i;\n\n\t/* /etc/pointercal -528 33408 -3417516 -44200 408 40292028 56541 */\n\n\t/* this is the identity transformation: */\n\ta[0] = 1.0;\n\ta[1] = 0.0;\n\ta[2] = 0.0;\n\ta[3] = 0.0;\n\ta[4] = 1.0;\n\ta[5] = 0.0;\n\ta[6] = 1.0;\n\n\tif (tslib_cal == NULL) {\n\t\treturn;\n\t}\n\n\trfbLog(\"load_tslib_cal: reading %s\\n\", tslib_cal);\n\tf = fopen(tslib_cal, \"r\");\n\tif (f == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fopen\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (fgets(line, sizeof(line), f) == NULL) {\n\t\trfbLogPerror(\"load_tslib_cal: fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tfclose(f);\n\n\tp = strtok(line, \" \\t\");\n\ti = 0;\n\twhile (p) {\n\t\ta[i] = (double) atoi(p);\n\t\trfbLog(\"load_tslib_cal: a[%d] %.3f\\n\", i, a[i]);\n\t\tp = strtok(NULL, \" \\t\");\n\t\ti++;\n\t\tif (i >= 7) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i != 7) {\n\t\trfbLog(\"load_tslib_cal: invalid tslib file format: i=%d %s\\n\",\n\t\t    i, tslib_cal);\n\t\tclean_up_exit(1);\n\t}\n}"
  },
  {
    "function_name": "get_bustype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "241-306",
    "snippet": "static int get_bustype(char *s) {\n#ifdef UINPUT_OK\n\n\tif (!s) return 0;\n\n#ifdef BUS_PCI\n\tif(!strcmp(s, \"BUS_PCI\"))\treturn BUS_PCI;\n#endif\n#ifdef BUS_ISAPNP\n\tif(!strcmp(s, \"BUS_ISAPNP\"))\treturn BUS_ISAPNP;\n#endif\n#ifdef BUS_USB\n\tif(!strcmp(s, \"BUS_USB\"))\treturn BUS_USB;\n#endif\n#ifdef BUS_HIL\n\tif(!strcmp(s, \"BUS_HIL\"))\treturn BUS_HIL;\n#endif\n#ifdef BUS_BLUETOOTH\n\tif(!strcmp(s, \"BUS_BLUETOOTH\"))\treturn BUS_BLUETOOTH;\n#endif\n#ifdef BUS_VIRTUAL\n\tif(!strcmp(s, \"BUS_VIRTUAL\"))\treturn BUS_VIRTUAL;\n#endif\n#ifdef BUS_ISA\n\tif(!strcmp(s, \"BUS_ISA\"))\treturn BUS_ISA;\n#endif\n#ifdef BUS_I8042\n\tif(!strcmp(s, \"BUS_I8042\"))\treturn BUS_I8042;\n#endif\n#ifdef BUS_XTKBD\n\tif(!strcmp(s, \"BUS_XTKBD\"))\treturn BUS_XTKBD;\n#endif\n#ifdef BUS_RS232\n\tif(!strcmp(s, \"BUS_RS232\"))\treturn BUS_RS232;\n#endif\n#ifdef BUS_GAMEPORT\n\tif(!strcmp(s, \"BUS_GAMEPORT\"))\treturn BUS_GAMEPORT;\n#endif\n#ifdef BUS_PARPORT\n\tif(!strcmp(s, \"BUS_PARPORT\"))\treturn BUS_PARPORT;\n#endif\n#ifdef BUS_AMIGA\n\tif(!strcmp(s, \"BUS_AMIGA\"))\treturn BUS_AMIGA;\n#endif\n#ifdef BUS_ADB\n\tif(!strcmp(s, \"BUS_ADB\"))\treturn BUS_ADB;\n#endif\n#ifdef BUS_I2C\n\tif(!strcmp(s, \"BUS_I2C\"))\treturn BUS_I2C;\n#endif\n#ifdef BUS_HOST\n\tif(!strcmp(s, \"BUS_HOST\"))\treturn BUS_HOST;\n#endif\n#ifdef BUS_GSC\n\tif(!strcmp(s, \"BUS_GSC\"))\treturn BUS_GSC;\n#endif\n#ifdef BUS_ATARI\n\tif(!strcmp(s, \"BUS_ATARI\"))\treturn BUS_ATARI;\n#endif\n\tif (atoi(s) > 0) {\n\t\treturn atoi(s);\n\t}\n\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define UINPUT_OK"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_ATARI\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_GSC\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_HOST\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_I2C\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_ADB\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_AMIGA\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_PARPORT\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_GAMEPORT\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_RS232\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_XTKBD\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_I8042\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_ISA\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_VIRTUAL\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_BLUETOOTH\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_HIL\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_USB\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_ISAPNP\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"BUS_PCI\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nstatic int get_bustype(char *s) {\n#ifdef UINPUT_OK\n\n\tif (!s) return 0;\n\n#ifdef BUS_PCI\n\tif(!strcmp(s, \"BUS_PCI\"))\treturn BUS_PCI;\n#endif\n#ifdef BUS_ISAPNP\n\tif(!strcmp(s, \"BUS_ISAPNP\"))\treturn BUS_ISAPNP;\n#endif\n#ifdef BUS_USB\n\tif(!strcmp(s, \"BUS_USB\"))\treturn BUS_USB;\n#endif\n#ifdef BUS_HIL\n\tif(!strcmp(s, \"BUS_HIL\"))\treturn BUS_HIL;\n#endif\n#ifdef BUS_BLUETOOTH\n\tif(!strcmp(s, \"BUS_BLUETOOTH\"))\treturn BUS_BLUETOOTH;\n#endif\n#ifdef BUS_VIRTUAL\n\tif(!strcmp(s, \"BUS_VIRTUAL\"))\treturn BUS_VIRTUAL;\n#endif\n#ifdef BUS_ISA\n\tif(!strcmp(s, \"BUS_ISA\"))\treturn BUS_ISA;\n#endif\n#ifdef BUS_I8042\n\tif(!strcmp(s, \"BUS_I8042\"))\treturn BUS_I8042;\n#endif\n#ifdef BUS_XTKBD\n\tif(!strcmp(s, \"BUS_XTKBD\"))\treturn BUS_XTKBD;\n#endif\n#ifdef BUS_RS232\n\tif(!strcmp(s, \"BUS_RS232\"))\treturn BUS_RS232;\n#endif\n#ifdef BUS_GAMEPORT\n\tif(!strcmp(s, \"BUS_GAMEPORT\"))\treturn BUS_GAMEPORT;\n#endif\n#ifdef BUS_PARPORT\n\tif(!strcmp(s, \"BUS_PARPORT\"))\treturn BUS_PARPORT;\n#endif\n#ifdef BUS_AMIGA\n\tif(!strcmp(s, \"BUS_AMIGA\"))\treturn BUS_AMIGA;\n#endif\n#ifdef BUS_ADB\n\tif(!strcmp(s, \"BUS_ADB\"))\treturn BUS_ADB;\n#endif\n#ifdef BUS_I2C\n\tif(!strcmp(s, \"BUS_I2C\"))\treturn BUS_I2C;\n#endif\n#ifdef BUS_HOST\n\tif(!strcmp(s, \"BUS_HOST\"))\treturn BUS_HOST;\n#endif\n#ifdef BUS_GSC\n\tif(!strcmp(s, \"BUS_GSC\"))\treturn BUS_GSC;\n#endif\n#ifdef BUS_ATARI\n\tif(!strcmp(s, \"BUS_ATARI\"))\treturn BUS_ATARI;\n#endif\n\tif (atoi(s) > 0) {\n\t\treturn atoi(s);\n\t}\n\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "shutdown_uinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "215-236",
    "snippet": "void shutdown_uinput(void) {\n#ifdef UINPUT_OK\n\tif (fd >= 0) {\n\t\tif (db) {\n\t\t\trfbLog(\"shutdown_uinput called on fd=%d\\n\", fd);\n\t\t}\n\t\tioctl(fd, UI_DEV_DESTROY);\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\t/* close direct injection files too: */\n\tif (direct_rel_fd >= 0) close(direct_rel_fd);\n\tif (direct_abs_fd >= 0) close(direct_abs_fd);\n\tif (direct_btn_fd >= 0) close(direct_btn_fd);\n\tif (direct_key_fd >= 0) close(direct_key_fd);\n\tdirect_rel_fd = -1;\n\tdirect_abs_fd = -1;\n\tdirect_btn_fd = -1;\n\tdirect_key_fd = -1;\n#endif\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "void shutdown_uinput(void);",
      "static int fd = -1;",
      "static int direct_rel_fd = -1;",
      "static int direct_abs_fd = -1;",
      "static int direct_btn_fd = -1;",
      "static int direct_key_fd = -1;",
      "static int db = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "direct_key_fd"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "fd",
            "UI_DEV_DESTROY"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"shutdown_uinput called on fd=%d\\n\"",
            "fd"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nvoid shutdown_uinput(void);\nstatic int fd = -1;\nstatic int direct_rel_fd = -1;\nstatic int direct_abs_fd = -1;\nstatic int direct_btn_fd = -1;\nstatic int direct_key_fd = -1;\nstatic int db = 0;\n\nvoid shutdown_uinput(void) {\n#ifdef UINPUT_OK\n\tif (fd >= 0) {\n\t\tif (db) {\n\t\t\trfbLog(\"shutdown_uinput called on fd=%d\\n\", fd);\n\t\t}\n\t\tioctl(fd, UI_DEV_DESTROY);\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\n\t/* close direct injection files too: */\n\tif (direct_rel_fd >= 0) close(direct_rel_fd);\n\tif (direct_abs_fd >= 0) close(direct_abs_fd);\n\tif (direct_btn_fd >= 0) close(direct_btn_fd);\n\tif (direct_key_fd >= 0) close(direct_key_fd);\n\tdirect_rel_fd = -1;\n\tdirect_abs_fd = -1;\n\tdirect_btn_fd = -1;\n\tdirect_key_fd = -1;\n#endif\n}"
  },
  {
    "function_name": "key_is_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "205-213",
    "snippet": "static int key_is_down(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int key_is_down(void);",
      "static int key_pressed[256];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int key_is_down(void);\nstatic int key_pressed[256];\n\nstatic int key_is_down(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mod_is_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "194-203",
    "snippet": "static int mod_is_down(void) {\n\tint i;\n\tif (0) {key_is_down();}\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i] && key_ismod[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int mod_is_down(void);",
      "static int key_is_down(void);",
      "static int key_pressed[256];",
      "static int key_ismod[256];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_is_down",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "key_is_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "205-213",
          "snippet": "static int key_is_down(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int key_is_down(void);",
            "static int key_pressed[256];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int key_is_down(void);\nstatic int key_pressed[256];\n\nstatic int key_is_down(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int mod_is_down(void);\nstatic int key_is_down(void);\nstatic int key_pressed[256];\nstatic int key_ismod[256];\n\nstatic int mod_is_down(void) {\n\tint i;\n\tif (0) {key_is_down();}\n\tfor (i = 0; i < 256; i++) {\n\t\tif (key_pressed[i] && key_ismod[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "init_key_tracker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "178-192",
    "snippet": "static void init_key_tracker(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tkey_pressed[i] = 0;\n\t\tkey_ismod[i] = 0;\n\t}\n\ti = lookup_code(XK_Shift_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Shift_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_key_tracker(void);",
      "static int key_pressed[256];",
      "static int key_ismod[256];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_code",
          "args": [
            "XK_Meta_R"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
          "lines": "1297-1474",
          "snippet": "static int lookup_code(int keysym) {\n\n\tif (keysym == NoSymbol) {\n\t\treturn -1;\n\t}\n\n\tswitch(keysym) {\n#ifdef UINPUT_OK\n\tcase XK_Escape:\treturn KEY_ESC;\n\tcase XK_1:\t\treturn KEY_1;\n\tcase XK_2:\t\treturn KEY_2;\n\tcase XK_3:\t\treturn KEY_3;\n\tcase XK_4:\t\treturn KEY_4;\n\tcase XK_5:\t\treturn KEY_5;\n\tcase XK_6:\t\treturn KEY_6;\n\tcase XK_7:\t\treturn KEY_7;\n\tcase XK_8:\t\treturn KEY_8;\n\tcase XK_9:\t\treturn KEY_9;\n\tcase XK_0:\t\treturn KEY_0;\n\tcase XK_exclam:\treturn KEY_1;\n\tcase XK_at:\t\treturn KEY_2;\n\tcase XK_numbersign:\treturn KEY_3;\n\tcase XK_dollar:\treturn KEY_4;\n\tcase XK_percent:\treturn KEY_5;\n\tcase XK_asciicircum:\treturn KEY_6;\n\tcase XK_ampersand:\treturn KEY_7;\n\tcase XK_asterisk:\treturn KEY_8;\n\tcase XK_parenleft:\treturn KEY_9;\n\tcase XK_parenright:\treturn KEY_0;\n\tcase XK_minus:\treturn KEY_MINUS;\n\tcase XK_underscore:\treturn KEY_MINUS;\n\tcase XK_equal:\treturn KEY_EQUAL;\n\tcase XK_plus:\treturn KEY_EQUAL;\n\tcase XK_BackSpace:\treturn KEY_BACKSPACE;\n\tcase XK_Tab:\t\treturn KEY_TAB;\n\tcase XK_q:\t\treturn KEY_Q;\n\tcase XK_Q:\t\treturn KEY_Q;\n\tcase XK_w:\t\treturn KEY_W;\n\tcase XK_W:\t\treturn KEY_W;\n\tcase XK_e:\t\treturn KEY_E;\n\tcase XK_E:\t\treturn KEY_E;\n\tcase XK_r:\t\treturn KEY_R;\n\tcase XK_R:\t\treturn KEY_R;\n\tcase XK_t:\t\treturn KEY_T;\n\tcase XK_T:\t\treturn KEY_T;\n\tcase XK_y:\t\treturn KEY_Y;\n\tcase XK_Y:\t\treturn KEY_Y;\n\tcase XK_u:\t\treturn KEY_U;\n\tcase XK_U:\t\treturn KEY_U;\n\tcase XK_i:\t\treturn KEY_I;\n\tcase XK_I:\t\treturn KEY_I;\n\tcase XK_o:\t\treturn KEY_O;\n\tcase XK_O:\t\treturn KEY_O;\n\tcase XK_p:\t\treturn KEY_P;\n\tcase XK_P:\t\treturn KEY_P;\n\tcase XK_braceleft:\treturn KEY_LEFTBRACE;\n\tcase XK_braceright:\treturn KEY_RIGHTBRACE;\n\tcase XK_bracketleft:\treturn KEY_LEFTBRACE;\n\tcase XK_bracketright:\treturn KEY_RIGHTBRACE;\n\tcase XK_Return:\treturn KEY_ENTER;\n\tcase XK_Control_L:\treturn KEY_LEFTCTRL;\n\tcase XK_a:\t\treturn KEY_A;\n\tcase XK_A:\t\treturn KEY_A;\n\tcase XK_s:\t\treturn KEY_S;\n\tcase XK_S:\t\treturn KEY_S;\n\tcase XK_d:\t\treturn KEY_D;\n\tcase XK_D:\t\treturn KEY_D;\n\tcase XK_f:\t\treturn KEY_F;\n\tcase XK_F:\t\treturn KEY_F;\n\tcase XK_g:\t\treturn KEY_G;\n\tcase XK_G:\t\treturn KEY_G;\n\tcase XK_h:\t\treturn KEY_H;\n\tcase XK_H:\t\treturn KEY_H;\n\tcase XK_j:\t\treturn KEY_J;\n\tcase XK_J:\t\treturn KEY_J;\n\tcase XK_k:\t\treturn KEY_K;\n\tcase XK_K:\t\treturn KEY_K;\n\tcase XK_l:\t\treturn KEY_L;\n\tcase XK_L:\t\treturn KEY_L;\n\tcase XK_semicolon:\treturn KEY_SEMICOLON;\n\tcase XK_colon:\treturn KEY_SEMICOLON;\n\tcase XK_apostrophe:\treturn KEY_APOSTROPHE;\n\tcase XK_quotedbl:\treturn KEY_APOSTROPHE;\n\tcase XK_grave:\treturn KEY_GRAVE;\n\tcase XK_asciitilde:\treturn KEY_GRAVE;\n\tcase XK_Shift_L:\treturn KEY_LEFTSHIFT;\n\tcase XK_backslash:\treturn KEY_BACKSLASH;\n\tcase XK_bar:\t\treturn KEY_BACKSLASH;\n\tcase XK_z:\t\treturn KEY_Z;\n\tcase XK_Z:\t\treturn KEY_Z;\n\tcase XK_x:\t\treturn KEY_X;\n\tcase XK_X:\t\treturn KEY_X;\n\tcase XK_c:\t\treturn KEY_C;\n\tcase XK_C:\t\treturn KEY_C;\n\tcase XK_v:\t\treturn KEY_V;\n\tcase XK_V:\t\treturn KEY_V;\n\tcase XK_b:\t\treturn KEY_B;\n\tcase XK_B:\t\treturn KEY_B;\n\tcase XK_n:\t\treturn KEY_N;\n\tcase XK_N:\t\treturn KEY_N;\n\tcase XK_m:\t\treturn KEY_M;\n\tcase XK_M:\t\treturn KEY_M;\n\tcase XK_comma:\treturn KEY_COMMA;\n\tcase XK_less:\treturn KEY_COMMA;\n\tcase XK_period:\treturn KEY_DOT;\n\tcase XK_greater:\treturn KEY_DOT;\n\tcase XK_slash:\treturn KEY_SLASH;\n\tcase XK_question:\treturn KEY_SLASH;\n\tcase XK_Shift_R:\treturn KEY_RIGHTSHIFT;\n\tcase XK_KP_Multiply:\treturn KEY_KPASTERISK;\n\tcase XK_Alt_L:\treturn KEY_LEFTALT;\n\tcase XK_space:\treturn KEY_SPACE;\n\tcase XK_Caps_Lock:\treturn KEY_CAPSLOCK;\n\tcase XK_F1:\t\treturn KEY_F1;\n\tcase XK_F2:\t\treturn KEY_F2;\n\tcase XK_F3:\t\treturn KEY_F3;\n\tcase XK_F4:\t\treturn KEY_F4;\n\tcase XK_F5:\t\treturn KEY_F5;\n\tcase XK_F6:\t\treturn KEY_F6;\n\tcase XK_F7:\t\treturn KEY_F7;\n\tcase XK_F8:\t\treturn KEY_F8;\n\tcase XK_F9:\t\treturn KEY_F9;\n\tcase XK_F10:\t\treturn KEY_F10;\n\tcase XK_Num_Lock:\treturn KEY_NUMLOCK;\n\tcase XK_Scroll_Lock:\treturn KEY_SCROLLLOCK;\n\tcase XK_KP_7:\t\treturn KEY_KP7;\n\tcase XK_KP_8:\t\treturn KEY_KP8;\n\tcase XK_KP_9:\t\treturn KEY_KP9;\n\tcase XK_KP_Subtract:\treturn KEY_KPMINUS;\n\tcase XK_KP_4:\t\treturn KEY_KP4;\n\tcase XK_KP_5:\t\treturn KEY_KP5;\n\tcase XK_KP_6:\t\treturn KEY_KP6;\n\tcase XK_KP_Add:\treturn KEY_KPPLUS;\n\tcase XK_KP_1:\t\treturn KEY_KP1;\n\tcase XK_KP_2:\t\treturn KEY_KP2;\n\tcase XK_KP_3:\t\treturn KEY_KP3;\n\tcase XK_KP_0:\t\treturn KEY_KP0;\n\tcase XK_KP_Decimal:\treturn KEY_KPDOT;\n\tcase XK_F13:\t\treturn KEY_F13;\n\tcase XK_F11:\t\treturn KEY_F11;\n\tcase XK_F12:\t\treturn KEY_F12;\n\tcase XK_F14:\t\treturn KEY_F14;\n\tcase XK_F15:\t\treturn KEY_F15;\n\tcase XK_F16:\t\treturn KEY_F16;\n\tcase XK_F17:\t\treturn KEY_F17;\n\tcase XK_F18:\t\treturn KEY_F18;\n\tcase XK_F19:\t\treturn KEY_F19;\n\tcase XK_F20:\t\treturn KEY_F20;\n\tcase XK_KP_Enter:\treturn KEY_KPENTER;\n\tcase XK_Control_R:\treturn KEY_RIGHTCTRL;\n\tcase XK_KP_Divide:\treturn KEY_KPSLASH;\n\tcase XK_Sys_Req:\treturn KEY_SYSRQ;\n\tcase XK_Alt_R:\treturn KEY_RIGHTALT;\n\tcase XK_Linefeed:\treturn KEY_LINEFEED;\n\tcase XK_Home:\t\treturn KEY_HOME;\n\tcase XK_Up:\t\treturn KEY_UP;\n\tcase XK_Page_Up:\treturn KEY_PAGEUP;\n\tcase XK_Left:\t\treturn KEY_LEFT;\n\tcase XK_Right:\treturn KEY_RIGHT;\n\tcase XK_End:\t\treturn KEY_END;\n\tcase XK_Down:\t\treturn KEY_DOWN;\n\tcase XK_Page_Down:\treturn KEY_PAGEDOWN;\n\tcase XK_Insert:\treturn KEY_INSERT;\n\tcase XK_Delete:\treturn KEY_DELETE;\n\tcase XK_KP_Equal:\treturn KEY_KPEQUAL;\n\tcase XK_Pause:\treturn KEY_PAUSE;\n\tcase XK_F21:\t\treturn KEY_F21;\n\tcase XK_F22:\t\treturn KEY_F22;\n\tcase XK_F23:\t\treturn KEY_F23;\n\tcase XK_F24:\t\treturn KEY_F24;\n\tcase XK_KP_Separator:\treturn KEY_KPCOMMA;\n\tcase XK_Meta_L:\treturn KEY_LEFTMETA;\n\tcase XK_Meta_R:\treturn KEY_RIGHTMETA;\n\tcase XK_Multi_key:\treturn KEY_COMPOSE;\n#endif\n\tdefault:\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <linux/uinput.h>",
            "#include <linux/input.h>",
            "#include <sys/ioctl.h>",
            "#include \"allowed_input_t.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"xinerama.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define UINPUT_OK"
          ],
          "globals_used": [
            "static int lookup_code(int keysym);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define UINPUT_OK\n\nstatic int lookup_code(int keysym);\n\nstatic int lookup_code(int keysym) {\n\n\tif (keysym == NoSymbol) {\n\t\treturn -1;\n\t}\n\n\tswitch(keysym) {\n#ifdef UINPUT_OK\n\tcase XK_Escape:\treturn KEY_ESC;\n\tcase XK_1:\t\treturn KEY_1;\n\tcase XK_2:\t\treturn KEY_2;\n\tcase XK_3:\t\treturn KEY_3;\n\tcase XK_4:\t\treturn KEY_4;\n\tcase XK_5:\t\treturn KEY_5;\n\tcase XK_6:\t\treturn KEY_6;\n\tcase XK_7:\t\treturn KEY_7;\n\tcase XK_8:\t\treturn KEY_8;\n\tcase XK_9:\t\treturn KEY_9;\n\tcase XK_0:\t\treturn KEY_0;\n\tcase XK_exclam:\treturn KEY_1;\n\tcase XK_at:\t\treturn KEY_2;\n\tcase XK_numbersign:\treturn KEY_3;\n\tcase XK_dollar:\treturn KEY_4;\n\tcase XK_percent:\treturn KEY_5;\n\tcase XK_asciicircum:\treturn KEY_6;\n\tcase XK_ampersand:\treturn KEY_7;\n\tcase XK_asterisk:\treturn KEY_8;\n\tcase XK_parenleft:\treturn KEY_9;\n\tcase XK_parenright:\treturn KEY_0;\n\tcase XK_minus:\treturn KEY_MINUS;\n\tcase XK_underscore:\treturn KEY_MINUS;\n\tcase XK_equal:\treturn KEY_EQUAL;\n\tcase XK_plus:\treturn KEY_EQUAL;\n\tcase XK_BackSpace:\treturn KEY_BACKSPACE;\n\tcase XK_Tab:\t\treturn KEY_TAB;\n\tcase XK_q:\t\treturn KEY_Q;\n\tcase XK_Q:\t\treturn KEY_Q;\n\tcase XK_w:\t\treturn KEY_W;\n\tcase XK_W:\t\treturn KEY_W;\n\tcase XK_e:\t\treturn KEY_E;\n\tcase XK_E:\t\treturn KEY_E;\n\tcase XK_r:\t\treturn KEY_R;\n\tcase XK_R:\t\treturn KEY_R;\n\tcase XK_t:\t\treturn KEY_T;\n\tcase XK_T:\t\treturn KEY_T;\n\tcase XK_y:\t\treturn KEY_Y;\n\tcase XK_Y:\t\treturn KEY_Y;\n\tcase XK_u:\t\treturn KEY_U;\n\tcase XK_U:\t\treturn KEY_U;\n\tcase XK_i:\t\treturn KEY_I;\n\tcase XK_I:\t\treturn KEY_I;\n\tcase XK_o:\t\treturn KEY_O;\n\tcase XK_O:\t\treturn KEY_O;\n\tcase XK_p:\t\treturn KEY_P;\n\tcase XK_P:\t\treturn KEY_P;\n\tcase XK_braceleft:\treturn KEY_LEFTBRACE;\n\tcase XK_braceright:\treturn KEY_RIGHTBRACE;\n\tcase XK_bracketleft:\treturn KEY_LEFTBRACE;\n\tcase XK_bracketright:\treturn KEY_RIGHTBRACE;\n\tcase XK_Return:\treturn KEY_ENTER;\n\tcase XK_Control_L:\treturn KEY_LEFTCTRL;\n\tcase XK_a:\t\treturn KEY_A;\n\tcase XK_A:\t\treturn KEY_A;\n\tcase XK_s:\t\treturn KEY_S;\n\tcase XK_S:\t\treturn KEY_S;\n\tcase XK_d:\t\treturn KEY_D;\n\tcase XK_D:\t\treturn KEY_D;\n\tcase XK_f:\t\treturn KEY_F;\n\tcase XK_F:\t\treturn KEY_F;\n\tcase XK_g:\t\treturn KEY_G;\n\tcase XK_G:\t\treturn KEY_G;\n\tcase XK_h:\t\treturn KEY_H;\n\tcase XK_H:\t\treturn KEY_H;\n\tcase XK_j:\t\treturn KEY_J;\n\tcase XK_J:\t\treturn KEY_J;\n\tcase XK_k:\t\treturn KEY_K;\n\tcase XK_K:\t\treturn KEY_K;\n\tcase XK_l:\t\treturn KEY_L;\n\tcase XK_L:\t\treturn KEY_L;\n\tcase XK_semicolon:\treturn KEY_SEMICOLON;\n\tcase XK_colon:\treturn KEY_SEMICOLON;\n\tcase XK_apostrophe:\treturn KEY_APOSTROPHE;\n\tcase XK_quotedbl:\treturn KEY_APOSTROPHE;\n\tcase XK_grave:\treturn KEY_GRAVE;\n\tcase XK_asciitilde:\treturn KEY_GRAVE;\n\tcase XK_Shift_L:\treturn KEY_LEFTSHIFT;\n\tcase XK_backslash:\treturn KEY_BACKSLASH;\n\tcase XK_bar:\t\treturn KEY_BACKSLASH;\n\tcase XK_z:\t\treturn KEY_Z;\n\tcase XK_Z:\t\treturn KEY_Z;\n\tcase XK_x:\t\treturn KEY_X;\n\tcase XK_X:\t\treturn KEY_X;\n\tcase XK_c:\t\treturn KEY_C;\n\tcase XK_C:\t\treturn KEY_C;\n\tcase XK_v:\t\treturn KEY_V;\n\tcase XK_V:\t\treturn KEY_V;\n\tcase XK_b:\t\treturn KEY_B;\n\tcase XK_B:\t\treturn KEY_B;\n\tcase XK_n:\t\treturn KEY_N;\n\tcase XK_N:\t\treturn KEY_N;\n\tcase XK_m:\t\treturn KEY_M;\n\tcase XK_M:\t\treturn KEY_M;\n\tcase XK_comma:\treturn KEY_COMMA;\n\tcase XK_less:\treturn KEY_COMMA;\n\tcase XK_period:\treturn KEY_DOT;\n\tcase XK_greater:\treturn KEY_DOT;\n\tcase XK_slash:\treturn KEY_SLASH;\n\tcase XK_question:\treturn KEY_SLASH;\n\tcase XK_Shift_R:\treturn KEY_RIGHTSHIFT;\n\tcase XK_KP_Multiply:\treturn KEY_KPASTERISK;\n\tcase XK_Alt_L:\treturn KEY_LEFTALT;\n\tcase XK_space:\treturn KEY_SPACE;\n\tcase XK_Caps_Lock:\treturn KEY_CAPSLOCK;\n\tcase XK_F1:\t\treturn KEY_F1;\n\tcase XK_F2:\t\treturn KEY_F2;\n\tcase XK_F3:\t\treturn KEY_F3;\n\tcase XK_F4:\t\treturn KEY_F4;\n\tcase XK_F5:\t\treturn KEY_F5;\n\tcase XK_F6:\t\treturn KEY_F6;\n\tcase XK_F7:\t\treturn KEY_F7;\n\tcase XK_F8:\t\treturn KEY_F8;\n\tcase XK_F9:\t\treturn KEY_F9;\n\tcase XK_F10:\t\treturn KEY_F10;\n\tcase XK_Num_Lock:\treturn KEY_NUMLOCK;\n\tcase XK_Scroll_Lock:\treturn KEY_SCROLLLOCK;\n\tcase XK_KP_7:\t\treturn KEY_KP7;\n\tcase XK_KP_8:\t\treturn KEY_KP8;\n\tcase XK_KP_9:\t\treturn KEY_KP9;\n\tcase XK_KP_Subtract:\treturn KEY_KPMINUS;\n\tcase XK_KP_4:\t\treturn KEY_KP4;\n\tcase XK_KP_5:\t\treturn KEY_KP5;\n\tcase XK_KP_6:\t\treturn KEY_KP6;\n\tcase XK_KP_Add:\treturn KEY_KPPLUS;\n\tcase XK_KP_1:\t\treturn KEY_KP1;\n\tcase XK_KP_2:\t\treturn KEY_KP2;\n\tcase XK_KP_3:\t\treturn KEY_KP3;\n\tcase XK_KP_0:\t\treturn KEY_KP0;\n\tcase XK_KP_Decimal:\treturn KEY_KPDOT;\n\tcase XK_F13:\t\treturn KEY_F13;\n\tcase XK_F11:\t\treturn KEY_F11;\n\tcase XK_F12:\t\treturn KEY_F12;\n\tcase XK_F14:\t\treturn KEY_F14;\n\tcase XK_F15:\t\treturn KEY_F15;\n\tcase XK_F16:\t\treturn KEY_F16;\n\tcase XK_F17:\t\treturn KEY_F17;\n\tcase XK_F18:\t\treturn KEY_F18;\n\tcase XK_F19:\t\treturn KEY_F19;\n\tcase XK_F20:\t\treturn KEY_F20;\n\tcase XK_KP_Enter:\treturn KEY_KPENTER;\n\tcase XK_Control_R:\treturn KEY_RIGHTCTRL;\n\tcase XK_KP_Divide:\treturn KEY_KPSLASH;\n\tcase XK_Sys_Req:\treturn KEY_SYSRQ;\n\tcase XK_Alt_R:\treturn KEY_RIGHTALT;\n\tcase XK_Linefeed:\treturn KEY_LINEFEED;\n\tcase XK_Home:\t\treturn KEY_HOME;\n\tcase XK_Up:\t\treturn KEY_UP;\n\tcase XK_Page_Up:\treturn KEY_PAGEUP;\n\tcase XK_Left:\t\treturn KEY_LEFT;\n\tcase XK_Right:\treturn KEY_RIGHT;\n\tcase XK_End:\t\treturn KEY_END;\n\tcase XK_Down:\t\treturn KEY_DOWN;\n\tcase XK_Page_Down:\treturn KEY_PAGEDOWN;\n\tcase XK_Insert:\treturn KEY_INSERT;\n\tcase XK_Delete:\treturn KEY_DELETE;\n\tcase XK_KP_Equal:\treturn KEY_KPEQUAL;\n\tcase XK_Pause:\treturn KEY_PAUSE;\n\tcase XK_F21:\t\treturn KEY_F21;\n\tcase XK_F22:\t\treturn KEY_F22;\n\tcase XK_F23:\t\treturn KEY_F23;\n\tcase XK_F24:\t\treturn KEY_F24;\n\tcase XK_KP_Separator:\treturn KEY_KPCOMMA;\n\tcase XK_Meta_L:\treturn KEY_LEFTMETA;\n\tcase XK_Meta_R:\treturn KEY_RIGHTMETA;\n\tcase XK_Multi_key:\treturn KEY_COMPOSE;\n#endif\n\tdefault:\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void init_key_tracker(void);\nstatic int key_pressed[256];\nstatic int key_ismod[256];\n\nstatic void init_key_tracker(void) {\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tkey_pressed[i] = 0;\n\t\tkey_ismod[i] = 0;\n\t}\n\ti = lookup_code(XK_Shift_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Shift_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Control_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Alt_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_L);\tif (0<=i && i<256) key_ismod[i] = 1;\n\ti = lookup_code(XK_Meta_R);\tif (0<=i && i<256) key_ismod[i] = 1;\n}"
  },
  {
    "function_name": "check_uinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/uinput.c",
    "lines": "138-173",
    "snippet": "int check_uinput(void) {\n#ifndef UINPUT_OK\n\treturn 0;\n#else\n\tint i;\n\tif (UT.release) {\n\t\tint maj, min;\n\t\t/* guard against linux 2.4 */\n\t\tif (sscanf(UT.release, \"%d.%d.\", &maj, &min) == 2) {\n\t\t\tif (maj < 2) {\n\t\t\t\treturn 0;\n\t\t\t} else if (maj == 2) {\n\t\t\t\t/* hmmm IPAQ 2.4.19-rmk6-pxa1-hh37 works... */\n#if 0\n\t\t\t\tif (min < 6) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\tfd = -1;\n\ti = 0;\n\twhile (devs[i] != NULL) {\n\t\tif ( (fd = open(devs[i++], O_WRONLY | O_NDELAY)) >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\tclose(fd);\n\tfd = -1;\n\treturn 1;\n#endif\n}",
    "includes": [
      "#include <linux/uinput.h>",
      "#include <linux/input.h>",
      "#include <sys/ioctl.h>",
      "#include \"allowed_input_t.h\"",
      "#include \"keyboard.h\"",
      "#include \"pointer.h\"",
      "#include \"screen.h\"",
      "#include \"xinerama.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define O_NDELAY 0",
      "#define O_NDELAY O_NONBLOCK",
      "#define UINPUT_OK"
    ],
    "globals_used": [
      "int check_uinput(void);",
      "static int fd = -1;",
      "static char *devs[] = {\n\t\"/dev/misc/uinput\",\n\t\"/dev/input/uinput\",\n\t\"/dev/uinput\",\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "devs[i++]",
            "O_WRONLY | O_NDELAY"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "UT.release",
            "\"%d.%d.\"",
            "&maj",
            "&min"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uinput.h>\n#include <linux/input.h>\n#include <sys/ioctl.h>\n#include \"allowed_input_t.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"xinerama.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define O_NDELAY 0\n#define O_NDELAY O_NONBLOCK\n#define UINPUT_OK\n\nint check_uinput(void);\nstatic int fd = -1;\nstatic char *devs[] = {\n\t\"/dev/misc/uinput\",\n\t\"/dev/input/uinput\",\n\t\"/dev/uinput\",\n\tNULL\n};\n\nint check_uinput(void) {\n#ifndef UINPUT_OK\n\treturn 0;\n#else\n\tint i;\n\tif (UT.release) {\n\t\tint maj, min;\n\t\t/* guard against linux 2.4 */\n\t\tif (sscanf(UT.release, \"%d.%d.\", &maj, &min) == 2) {\n\t\t\tif (maj < 2) {\n\t\t\t\treturn 0;\n\t\t\t} else if (maj == 2) {\n\t\t\t\t/* hmmm IPAQ 2.4.19-rmk6-pxa1-hh37 works... */\n#if 0\n\t\t\t\tif (min < 6) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\tfd = -1;\n\ti = 0;\n\twhile (devs[i] != NULL) {\n\t\tif ( (fd = open(devs[i++], O_WRONLY | O_NDELAY)) >= 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fd < 0) {\n\t\treturn 0;\n\t}\n\tclose(fd);\n\tfd = -1;\n\treturn 1;\n#endif\n}"
  }
]