[
  {
    "function_name": "restore_under_cursor_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "2328-2372",
    "snippet": "void restore_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c) \n    return;\n\n  /* sanity checks */\n  x1 = cd->cursor_x_saved - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0)\n    return; /* nothing to do */\n\n  y1 = cd->cursor_y_saved - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0)\n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n  /* restore framebuffer from saved data */\n  if(cd->under_cursor_buffer_len > 0) {\n    for(j=0;j<y2;j++)\n      memcpy(screen->frameBuffer+(y1+j)*rowstride+x1*bpp,\n\t     cd->under_cursor_buffer+j*x2*bpp,\n\t     x2*bpp);\n\n    /* seems the additional w/2 and h/2 rect extension is needed in threaded mode */\n    mark_rect_as_modified(x1-x2/2, y1-y2/2, x1+x2+x2/2, y1+y2+y2/2, 1);\n  }\n  UNLOCK(cl->screen->cursorMutex);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
      "unsigned long get_cursor_serial(int mode);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->screen->cursorMutex"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x1-x2/2",
            "y1-y2/2",
            "x1+x2+x2/2",
            "y1+y2+y2/2",
            "1"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "screen->frameBuffer+(y1+j)*rowstride+x1*bpp",
            "cd->under_cursor_buffer+j*x2*bpp",
            "x2*bpp"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->screen->cursorMutex"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nunsigned long get_cursor_serial(int mode);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\n\nvoid restore_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c) \n    return;\n\n  /* sanity checks */\n  x1 = cd->cursor_x_saved - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0)\n    return; /* nothing to do */\n\n  y1 = cd->cursor_y_saved - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0)\n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n  /* restore framebuffer from saved data */\n  if(cd->under_cursor_buffer_len > 0) {\n    for(j=0;j<y2;j++)\n      memcpy(screen->frameBuffer+(y1+j)*rowstride+x1*bpp,\n\t     cd->under_cursor_buffer+j*x2*bpp,\n\t     x2*bpp);\n\n    /* seems the additional w/2 and h/2 rect extension is needed in threaded mode */\n    mark_rect_as_modified(x1-x2/2, y1-y2/2, x1+x2+x2/2, y1+y2+y2/2, 1);\n  }\n  UNLOCK(cl->screen->cursorMutex);\n}"
  },
  {
    "function_name": "draw_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "2182-2323",
    "snippet": "void draw_cursor(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int i,j,x1,x2,y1,y2,i1,j1,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes, w;  \n \n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  w = (c->width+7)/8;\n \n  /* sanity checks */ \n  i1=j1=0; \n\n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { i1=-x1; x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { j1=-y1; y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n\n  if (c->alphaSource) {\n    int rmax, rshift;\n    int gmax, gshift;\n    int bmax, bshift;\n    int amax = 255;\t/* alphaSource is always 8bits of info per pixel */\n    unsigned int rmask, gmask, bmask;\n\n    rmax   = screen->serverFormat.redMax;\n    gmax   = screen->serverFormat.greenMax;\n    bmax   = screen->serverFormat.blueMax;\n    rshift = screen->serverFormat.redShift;\n    gshift = screen->serverFormat.greenShift;\n    bshift = screen->serverFormat.blueShift;\n\n    rmask = (rmax << rshift);\n    gmask = (gmax << gshift);\n    bmask = (bmax << bshift);\n\n    for(j=0;j<y2;j++) {\n      for(i=0;i<x2;i++) {\n\t/*\n\t * we loop over the whole cursor ignoring c->mask[],\n\t * using the extracted alpha value instead.\n\t */\n\tchar *dest;\n\tunsigned char *src, *aptr;\n\tunsigned int val, dval, sval;\n\tint rdst, gdst, bdst;\t\t/* fb RGB */\n\tint asrc, rsrc, gsrc, bsrc;\t/* rich source ARGB */\n\n\tdest = screen->frameBuffer + (j+y1)*rowstride + (i+x1)*bpp;\n\tsrc  = c->richSource  + (j+j1)*c->width*bpp + (i+i1)*bpp;\n\taptr = c->alphaSource + (j+j1)*c->width + (i+i1);\n\n\tasrc = *aptr;\n\tif (!asrc) {\n\t  continue;\n\t}\n\n\tif (bpp == 1) {\n\t  dval = *((unsigned char*) dest);\n\t  sval = *((unsigned char*) src);\n\t} else if (bpp == 2) {\n\t  dval = *((unsigned short*) dest);\n\t  sval = *((unsigned short*) src);\n\t} else if (bpp == 3) {\n\t  unsigned char *dst = (unsigned char *) dest;\n\t  dval = 0;\n\t  dval |= ((*(dst+0)) << 0);\n\t  dval |= ((*(dst+1)) << 8);\n\t  dval |= ((*(dst+2)) << 16);\n\t  sval = 0;\n\t  sval |= ((*(src+0)) << 0);\n\t  sval |= ((*(src+1)) << 8);\n\t  sval |= ((*(src+2)) << 16);\n\t} else if (bpp == 4) {\n\t  dval = *((unsigned int*) dest);\n\t  sval = *((unsigned int*) src);\n\t} else {\n\t  continue;\n\t}\n\n\t/* extract dest and src RGB */\n\trdst = (dval & rmask) >> rshift;\t/* fb */\n\tgdst = (dval & gmask) >> gshift;\n\tbdst = (dval & bmask) >> bshift;\n\n\trsrc = (sval & rmask) >> rshift;\t/* richcursor */\n\tgsrc = (sval & gmask) >> gshift;\n\tbsrc = (sval & bmask) >> bshift;\n\n\t/* blend in fb data. */\n\tif (! c->alphaPreMultiplied) {\n\t  rsrc = (asrc * rsrc)/amax;\n\t  gsrc = (asrc * gsrc)/amax;\n\t  bsrc = (asrc * bsrc)/amax;\n\t}\n\trdst = rsrc + ((amax - asrc) * rdst)/amax;\n\tgdst = gsrc + ((amax - asrc) * gdst)/amax;\n\tbdst = bsrc + ((amax - asrc) * bdst)/amax;\n\n\tval = 0;\n\tval |= (rdst << rshift);\n\tval |= (gdst << gshift);\n\tval |= (bdst << bshift);\n\n\t/* insert the cooked pixel into the fb */\n\tmemcpy(dest, &val, bpp);\n      }\n    }\n  }\n  else {\n    /* no alpha  */\n    for(j=0;j<y2;j++)\n      for(i=0;i<x2;i++)\n\tif((c->mask[(j+j1)*w+(i+i1)/8]<<((i+i1)&7))&0x80)\n\t  memcpy(screen->frameBuffer+(j+y1)*rowstride+(i+x1)*bpp,\n\t\t c->richSource+(j+j1)*c->width*bpp+(i+i1)*bpp,bpp);\n  }\n\n  mark_rect_as_modified(x1, y1, x1+x2, y1+y2, 1);\n\n  UNLOCK(cl->screen->cursorMutex);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void curs_copy(cursor_info_t *dest, cursor_info_t *src);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->screen->cursorMutex"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x1",
            "y1",
            "x1+x2",
            "y1+y2",
            "1"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "screen->frameBuffer+(j+y1)*rowstride+(i+x1)*bpp",
            "c->richSource+(j+j1)*c->width*bpp+(i+i1)*bpp",
            "bpp"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "&val",
            "bpp"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->screen->cursorMutex"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src);\n\nvoid draw_cursor(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int i,j,x1,x2,y1,y2,i1,j1,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes, w;  \n \n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  w = (c->width+7)/8;\n \n  /* sanity checks */ \n  i1=j1=0; \n\n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { i1=-x1; x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { j1=-y1; y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n\n  if (c->alphaSource) {\n    int rmax, rshift;\n    int gmax, gshift;\n    int bmax, bshift;\n    int amax = 255;\t/* alphaSource is always 8bits of info per pixel */\n    unsigned int rmask, gmask, bmask;\n\n    rmax   = screen->serverFormat.redMax;\n    gmax   = screen->serverFormat.greenMax;\n    bmax   = screen->serverFormat.blueMax;\n    rshift = screen->serverFormat.redShift;\n    gshift = screen->serverFormat.greenShift;\n    bshift = screen->serverFormat.blueShift;\n\n    rmask = (rmax << rshift);\n    gmask = (gmax << gshift);\n    bmask = (bmax << bshift);\n\n    for(j=0;j<y2;j++) {\n      for(i=0;i<x2;i++) {\n\t/*\n\t * we loop over the whole cursor ignoring c->mask[],\n\t * using the extracted alpha value instead.\n\t */\n\tchar *dest;\n\tunsigned char *src, *aptr;\n\tunsigned int val, dval, sval;\n\tint rdst, gdst, bdst;\t\t/* fb RGB */\n\tint asrc, rsrc, gsrc, bsrc;\t/* rich source ARGB */\n\n\tdest = screen->frameBuffer + (j+y1)*rowstride + (i+x1)*bpp;\n\tsrc  = c->richSource  + (j+j1)*c->width*bpp + (i+i1)*bpp;\n\taptr = c->alphaSource + (j+j1)*c->width + (i+i1);\n\n\tasrc = *aptr;\n\tif (!asrc) {\n\t  continue;\n\t}\n\n\tif (bpp == 1) {\n\t  dval = *((unsigned char*) dest);\n\t  sval = *((unsigned char*) src);\n\t} else if (bpp == 2) {\n\t  dval = *((unsigned short*) dest);\n\t  sval = *((unsigned short*) src);\n\t} else if (bpp == 3) {\n\t  unsigned char *dst = (unsigned char *) dest;\n\t  dval = 0;\n\t  dval |= ((*(dst+0)) << 0);\n\t  dval |= ((*(dst+1)) << 8);\n\t  dval |= ((*(dst+2)) << 16);\n\t  sval = 0;\n\t  sval |= ((*(src+0)) << 0);\n\t  sval |= ((*(src+1)) << 8);\n\t  sval |= ((*(src+2)) << 16);\n\t} else if (bpp == 4) {\n\t  dval = *((unsigned int*) dest);\n\t  sval = *((unsigned int*) src);\n\t} else {\n\t  continue;\n\t}\n\n\t/* extract dest and src RGB */\n\trdst = (dval & rmask) >> rshift;\t/* fb */\n\tgdst = (dval & gmask) >> gshift;\n\tbdst = (dval & bmask) >> bshift;\n\n\trsrc = (sval & rmask) >> rshift;\t/* richcursor */\n\tgsrc = (sval & gmask) >> gshift;\n\tbsrc = (sval & bmask) >> bshift;\n\n\t/* blend in fb data. */\n\tif (! c->alphaPreMultiplied) {\n\t  rsrc = (asrc * rsrc)/amax;\n\t  gsrc = (asrc * gsrc)/amax;\n\t  bsrc = (asrc * bsrc)/amax;\n\t}\n\trdst = rsrc + ((amax - asrc) * rdst)/amax;\n\tgdst = gsrc + ((amax - asrc) * gdst)/amax;\n\tbdst = bsrc + ((amax - asrc) * bdst)/amax;\n\n\tval = 0;\n\tval |= (rdst << rshift);\n\tval |= (gdst << gshift);\n\tval |= (bdst << bshift);\n\n\t/* insert the cooked pixel into the fb */\n\tmemcpy(dest, &val, bpp);\n      }\n    }\n  }\n  else {\n    /* no alpha  */\n    for(j=0;j<y2;j++)\n      for(i=0;i<x2;i++)\n\tif((c->mask[(j+j1)*w+(i+i1)/8]<<((i+i1)&7))&0x80)\n\t  memcpy(screen->frameBuffer+(j+y1)*rowstride+(i+x1)*bpp,\n\t\t c->richSource+(j+j1)*c->width*bpp+(i+i1)*bpp,bpp);\n  }\n\n  mark_rect_as_modified(x1, y1, x1+x2, y1+y2, 1);\n\n  UNLOCK(cl->screen->cursorMutex);\n}"
  },
  {
    "function_name": "save_under_cursor_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "2124-2180",
    "snippet": "void save_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes,\n    bufsize;  \n  rfbBool wasChanged=FALSE;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  bufsize = c->width * c->height * bpp;\n\n  /* make sure the buffer is big enough */\n  if(cd->under_cursor_buffer_len < bufsize) {\n    LOCK(cl->updateMutex);\n    cd->under_cursor_buffer = realloc(cd->under_cursor_buffer, bufsize);\n    cd->under_cursor_buffer_len = bufsize;\n    UNLOCK(cl->updateMutex);\n  }\n\n  /* sanity checks */ \n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->updateMutex);\n  /* save what's under the cursor now */\n  for(j=0;j<y2;j++) {\n    char* dest = cd->under_cursor_buffer+j*x2*bpp;\n    const char* src = screen->frameBuffer+(y1+j)*rowstride+x1*bpp;\n    unsigned int count=x2*bpp;\n    if(wasChanged || memcmp(dest,src,count)) {\n       wasChanged=TRUE;\n       memcpy(dest,src,count);\n    }\n  }\n  UNLOCK(cl->updateMutex);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void curs_copy(cursor_info_t *dest, cursor_info_t *src);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "src",
            "count"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dest",
            "src",
            "count"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "cd->under_cursor_buffer",
            "bufsize"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cl->updateMutex"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid save_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes,\n    bufsize;  \n  rfbBool wasChanged=FALSE;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  bufsize = c->width * c->height * bpp;\n\n  /* make sure the buffer is big enough */\n  if(cd->under_cursor_buffer_len < bufsize) {\n    LOCK(cl->updateMutex);\n    cd->under_cursor_buffer = realloc(cd->under_cursor_buffer, bufsize);\n    cd->under_cursor_buffer_len = bufsize;\n    UNLOCK(cl->updateMutex);\n  }\n\n  /* sanity checks */ \n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->updateMutex);\n  /* save what's under the cursor now */\n  for(j=0;j<y2;j++) {\n    char* dest = cd->under_cursor_buffer+j*x2*bpp;\n    const char* src = screen->frameBuffer+(y1+j)*rowstride+x1*bpp;\n    unsigned int count=x2*bpp;\n    if(wasChanged || memcmp(dest,src,count)) {\n       wasChanged=TRUE;\n       memcpy(dest,src,count);\n    }\n  }\n  UNLOCK(cl->updateMutex);\n}"
  },
  {
    "function_name": "check_x11_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1985-2112",
    "snippet": "int check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int get_which_cursor(void);",
      "void cursor_position(int x, int y, rfbClientPtr client);",
      "int check_x11_pointer(void);",
      "unsigned long get_cursor_serial(int mode);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cursor",
          "args": [
            "x",
            "y",
            "get_which_cursor()"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "set_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1963-1979",
          "snippet": "int set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\n\nint set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_which_cursor",
          "args": [],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "get_which_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1512-1640",
          "snippet": "int get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int use_xfixes = 1;",
            "int get_which_cursor(void);",
            "int set_cursor(int x, int y, int which);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_rfb_cursor(int which);",
            "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint use_xfixes = 1;\nint get_which_cursor(void);\nint set_cursor(int x, int y, int which);\nunsigned long get_cursor_serial(int mode);\nstatic void set_rfb_cursor(int which);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\n\nint get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cursor_position",
          "args": [
            "x",
            "y",
            "NULL"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "cursor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1811-1936",
          "snippet": "void cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void cursor_position(int x, int y, rfbClientPtr client);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Skipping cursor_position() outside our clipshift\\n\""
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XQueryPointer:     x:%4d, y:%4d)\\n\"",
            "root_x",
            "root_y"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_x11_pointer %d %d\\n\"",
            "root_x",
            "root_y"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "rootwin",
            "&root_w",
            "&child_w",
            "&root_x",
            "&root_y",
            "&win_x",
            "&win_y",
            "&mask"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Skipping cursor_position() outside our clipshift\\n\""
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"XIQueryPointer:     x:%4f, y:%4f)\\n\"",
            "root_x",
            "root_y"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XIQueryPointer_wr",
          "args": [
            "dpy",
            "cd->ptr_id",
            "rootwin",
            "&root_w",
            "&child_w",
            "&root_x",
            "&root_y",
            "&win_x",
            "&win_y",
            "&buttons_return",
            "&modifiers_return",
            "&group_return"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "XIQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1567-1602",
          "snippet": "Bool XIQueryPointer_wr( Display *display,\n                        int deviceid,\n                        Window win,\n                        Window *root_return,\n                        Window *child_return,\n                        double *root_x_return,\n                        double *root_y_return,\n                        double *win_x_return,\n                        double *win_y_return,\n                        XIButtonState *buttons_return,\n                        XIModifierState *modifiers_return,\n                        XIGroupState *group_return)\n{\n  Bool rc;\n  XErrorHandler old_handler;\n\n  if (! display) {\n    return False;\n  }\n\n  /* there can be a race condition where this is called when the XI2 device has not yet been created */\n  old_handler = XSetErrorHandler(trap_xerror);\n  trapped_xerror = 0;\n\n  rc = XIQueryPointer(display, deviceid, win, root_return, child_return,\n                      root_x_return, root_y_return, win_x_return, win_y_return,\n                      buttons_return, modifiers_return, group_return);\n\n  XSetErrorHandler(old_handler);\n  if (trapped_xerror) {\n    trapped_xerror = 0;\n    rc = 0;\n  }\n\n  return rc;\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nBool XIQueryPointer_wr( Display *display,\n                        int deviceid,\n                        Window win,\n                        Window *root_return,\n                        Window *child_return,\n                        double *root_x_return,\n                        double *root_y_return,\n                        double *win_x_return,\n                        double *win_y_return,\n                        XIButtonState *buttons_return,\n                        XIModifierState *modifiers_return,\n                        XIGroupState *group_return)\n{\n  Bool rc;\n  XErrorHandler old_handler;\n\n  if (! display) {\n    return False;\n  }\n\n  /* there can be a race condition where this is called when the XI2 device has not yet been created */\n  old_handler = XSetErrorHandler(trap_xerror);\n  trapped_xerror = 0;\n\n  rc = XIQueryPointer(display, deviceid, win, root_return, child_return,\n                      root_x_return, root_y_return, win_x_return, win_y_return,\n                      buttons_return, modifiers_return, group_return);\n\n  XSetErrorHandler(old_handler);\n  if (trapped_xerror) {\n    trapped_xerror = 0;\n    rc = 0;\n  }\n\n  return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macosx_get_cursor_pos",
          "args": [
            "&root_x",
            "&root_y"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_get_cursor_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "361-368",
          "snippet": "int macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_cursor_pos(int *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor_pos(int *, int *);\n\nint macosx_get_cursor_pos(int *x, int *y) {\n\tmacosxCG_get_cursor_pos(x, y);\n\tif (nofb) {\n\t\t/* good time to poll the pasteboard */\n\t\tmacosxGCS_poll_pb();\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_which_cursor(void);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nint check_x11_pointer(void);\nunsigned long get_cursor_serial(int mode);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\n\nint check_x11_pointer(void) {\n\tWindow root_w, child_w;\n\trfbBool ret = 0;\n\tint root_x, root_y, win_x, win_y;\n\tint x, y, rint;\n\tunsigned int mask;\n\n\tif (unixpw_in_progress) return 0;\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tret = macosx_get_cursor_pos(&root_x, &root_y);\n\t} else {\n\t\tRAWFB_RET(0)\n\t}\n#else\n\n\tRAWFB_RET(0)\n\n#   if NO_X11\n\treturn 0;\n#   endif\n\n#endif\n\n#ifdef HAVE_XI2\n#if ! NO_X11\n\t/* if we are in multipointer mode,\n\t   check the position of all client pointers here */\n\tif(use_multipointer && screen) {\n\t  rfbClientIteratorPtr iter;\n\t  rfbClientPtr cl;\n\t  double root_x, root_y, win_x, win_y;\n\t  XIButtonState buttons_return;\n\t  XIModifierState modifiers_return;\n\t  XIGroupState group_return;\n\n\t  iter = rfbGetClientIterator(screen);\n\t  while( (cl = rfbClientIteratorNext(iter)) ) {\n        ClientData* cd = cl->clientData;\n\t    if (dpy && cd) {\n          X_LOCK;\n          ret = XIQueryPointer_wr(dpy, cd->ptr_id, rootwin, &root_w, &child_w,\n\t\t\t\t   &root_x, &root_y, &win_x, &win_y,\n\t\t\t\t   &buttons_return, &modifiers_return, &group_return);\n\t      X_UNLOCK;\n\t    }\n\n\t    if(!ret)\n\t      continue;\n\n\t    if (debug_pointer)\n\t      rfbLog(\"XIQueryPointer:     x:%4f, y:%4f)\\n\", root_x, root_y);\n\n\t    /* offset subtracted since XIQueryPointer relative to rootwin */\n\t    x = root_x - off_x - coff_x;\n\t    y = root_y - off_y - coff_y;\n\n\t    if (clipshift) {\n\t      static int cnt = 0;\n\t      if (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\tif (cnt++ % 4 != 0) {\n\t\t  if (debug_pointer)\n\t\t    rfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t  continue;\n\t\t}\n\t      }\n\t    }\n\n\t    /* record the cursor position in the rfb screen */\n\t    INPUT_LOCK;\n\t    cursor_position(x, y, cl);\n\t    INPUT_UNLOCK;\n\t  }\n\t  rfbReleaseClientIterator(iter);\n\t}\n#endif\n#endif\n\n\n#if ! NO_X11\n\tif (dpy) {\n\t\tX_LOCK;\n\t\tret = XQueryPointer_wr(dpy, rootwin, &root_w, &child_w, &root_x, &root_y,\n                   &win_x, &win_y, &mask);\n\t\tX_UNLOCK;\n\t}\n#else\n\tif (!mask || !win_y || !win_x || !child_w || !root_w) {}\n#endif\t/* NO_X11 */\n\nif (0) fprintf(stderr, \"check_x11_pointer %d %d\\n\", root_x, root_y);\n\tif (! ret) {\n\t\treturn 0;\n\t}\n\tif (debug_pointer) {\n\t\tstatic int last_x = -1, last_y = -1;\n\t\tif (root_x != last_x || root_y != last_y) {\n\t\t\trfbLog(\"XQueryPointer:     x:%4d, y:%4d)\\n\",\n\t\t\t    root_x, root_y);\n\t\t}\n\t\tlast_x = root_x;\n\t\tlast_y = root_y;\n\t}\n\n\t/* offset subtracted since XQueryPointer relative to rootwin */\n\tx = root_x - off_x - coff_x;\n\ty = root_y - off_y - coff_y;\n\n\tif (clipshift) {\n\t\tstatic int cnt = 0;\n\t\tif (x < 0 || y < 0 || x >= dpy_x || y >= dpy_y)  {\n\t\t\tif (cnt++ % 4 != 0) {\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"Skipping cursor_position() outside our clipshift\\n\");\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* record the cursor position in the rfb screen */\n\tcursor_position(x, y, NULL);\n\n\t/* change the cursor shape if necessary */\n\trint = set_cursor(x, y, get_which_cursor());\n\treturn rint;\n}"
  },
  {
    "function_name": "set_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1963-1979",
    "snippet": "int set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int set_cursor(int x, int y, int which);",
      "static void set_rfb_cursor(int which);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_rfb_cursor",
          "args": [
            "which"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "set_rfb_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1938-1953",
          "snippet": "static void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nstatic void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\n\nint set_cursor(int x, int y, int which) {\n\tstatic int last = -1;\n\tint changed_cursor = 0;\n\n\tif (x || y) {} /* unused vars warning: */\n\n\tif (which < 0) {\n\t\twhich = last;\t\n\t}\n\tif (last < 0 || which != last) {\n\t\tset_rfb_cursor(which);\n\t\tchanged_cursor = 1;\n\t}\n\tlast = which;\n\n\treturn changed_cursor;\n}"
  },
  {
    "function_name": "set_warrow_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1959-1961",
    "snippet": "void set_warrow_cursor(void) {\n\tset_rfb_cursor(CURS_WARROW);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_warrow_cursor(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_rfb_cursor",
          "args": [
            "CURS_WARROW"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "set_rfb_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1938-1953",
          "snippet": "static void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nstatic void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_warrow_cursor(void);\n\nvoid set_warrow_cursor(void) {\n\tset_rfb_cursor(CURS_WARROW);\n}"
  },
  {
    "function_name": "set_no_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1955-1957",
    "snippet": "void set_no_cursor(void) {\n\tset_rfb_cursor(CURS_EMPTY);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_no_cursor(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_rfb_cursor",
          "args": [
            "CURS_EMPTY"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "set_rfb_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1938-1953",
          "snippet": "static void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nstatic void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_no_cursor(void);\n\nvoid set_no_cursor(void) {\n\tset_rfb_cursor(CURS_EMPTY);\n}"
  },
  {
    "function_name": "set_rfb_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1938-1953",
    "snippet": "static void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int set_cursor(int x, int y, int which);",
      "static void set_rfb_cursor(int which);",
      "static cursor_info_t *cursors[CURS_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbSetCursor",
          "args": [
            "screen",
            "cursors[which]->rfb"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"non-existent cursor: which=%d\\n\"",
            "which"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nstatic void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}"
  },
  {
    "function_name": "cursor_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1811-1936",
    "snippet": "void cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void cursor_position(int x, int y, rfbClientPtr client);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cursor_position: set client pos x=%3d y=%d\\n\"",
            "x",
            "y"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "draw_cursor",
          "args": [
            "client"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "draw_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "2182-2323",
          "snippet": "void draw_cursor(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int i,j,x1,x2,y1,y2,i1,j1,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes, w;  \n \n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  w = (c->width+7)/8;\n \n  /* sanity checks */ \n  i1=j1=0; \n\n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { i1=-x1; x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { j1=-y1; y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n\n  if (c->alphaSource) {\n    int rmax, rshift;\n    int gmax, gshift;\n    int bmax, bshift;\n    int amax = 255;\t/* alphaSource is always 8bits of info per pixel */\n    unsigned int rmask, gmask, bmask;\n\n    rmax   = screen->serverFormat.redMax;\n    gmax   = screen->serverFormat.greenMax;\n    bmax   = screen->serverFormat.blueMax;\n    rshift = screen->serverFormat.redShift;\n    gshift = screen->serverFormat.greenShift;\n    bshift = screen->serverFormat.blueShift;\n\n    rmask = (rmax << rshift);\n    gmask = (gmax << gshift);\n    bmask = (bmax << bshift);\n\n    for(j=0;j<y2;j++) {\n      for(i=0;i<x2;i++) {\n\t/*\n\t * we loop over the whole cursor ignoring c->mask[],\n\t * using the extracted alpha value instead.\n\t */\n\tchar *dest;\n\tunsigned char *src, *aptr;\n\tunsigned int val, dval, sval;\n\tint rdst, gdst, bdst;\t\t/* fb RGB */\n\tint asrc, rsrc, gsrc, bsrc;\t/* rich source ARGB */\n\n\tdest = screen->frameBuffer + (j+y1)*rowstride + (i+x1)*bpp;\n\tsrc  = c->richSource  + (j+j1)*c->width*bpp + (i+i1)*bpp;\n\taptr = c->alphaSource + (j+j1)*c->width + (i+i1);\n\n\tasrc = *aptr;\n\tif (!asrc) {\n\t  continue;\n\t}\n\n\tif (bpp == 1) {\n\t  dval = *((unsigned char*) dest);\n\t  sval = *((unsigned char*) src);\n\t} else if (bpp == 2) {\n\t  dval = *((unsigned short*) dest);\n\t  sval = *((unsigned short*) src);\n\t} else if (bpp == 3) {\n\t  unsigned char *dst = (unsigned char *) dest;\n\t  dval = 0;\n\t  dval |= ((*(dst+0)) << 0);\n\t  dval |= ((*(dst+1)) << 8);\n\t  dval |= ((*(dst+2)) << 16);\n\t  sval = 0;\n\t  sval |= ((*(src+0)) << 0);\n\t  sval |= ((*(src+1)) << 8);\n\t  sval |= ((*(src+2)) << 16);\n\t} else if (bpp == 4) {\n\t  dval = *((unsigned int*) dest);\n\t  sval = *((unsigned int*) src);\n\t} else {\n\t  continue;\n\t}\n\n\t/* extract dest and src RGB */\n\trdst = (dval & rmask) >> rshift;\t/* fb */\n\tgdst = (dval & gmask) >> gshift;\n\tbdst = (dval & bmask) >> bshift;\n\n\trsrc = (sval & rmask) >> rshift;\t/* richcursor */\n\tgsrc = (sval & gmask) >> gshift;\n\tbsrc = (sval & bmask) >> bshift;\n\n\t/* blend in fb data. */\n\tif (! c->alphaPreMultiplied) {\n\t  rsrc = (asrc * rsrc)/amax;\n\t  gsrc = (asrc * gsrc)/amax;\n\t  bsrc = (asrc * bsrc)/amax;\n\t}\n\trdst = rsrc + ((amax - asrc) * rdst)/amax;\n\tgdst = gsrc + ((amax - asrc) * gdst)/amax;\n\tbdst = bsrc + ((amax - asrc) * bdst)/amax;\n\n\tval = 0;\n\tval |= (rdst << rshift);\n\tval |= (gdst << gshift);\n\tval |= (bdst << bshift);\n\n\t/* insert the cooked pixel into the fb */\n\tmemcpy(dest, &val, bpp);\n      }\n    }\n  }\n  else {\n    /* no alpha  */\n    for(j=0;j<y2;j++)\n      for(i=0;i<x2;i++)\n\tif((c->mask[(j+j1)*w+(i+i1)/8]<<((i+i1)&7))&0x80)\n\t  memcpy(screen->frameBuffer+(j+y1)*rowstride+(i+x1)*bpp,\n\t\t c->richSource+(j+j1)*c->width*bpp+(i+i1)*bpp,bpp);\n  }\n\n  mark_rect_as_modified(x1, y1, x1+x2, y1+y2, 1);\n\n  UNLOCK(cl->screen->cursorMutex);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void curs_copy(cursor_info_t *dest, cursor_info_t *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src);\n\nvoid draw_cursor(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int i,j,x1,x2,y1,y2,i1,j1,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes, w;  \n \n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  w = (c->width+7)/8;\n \n  /* sanity checks */ \n  i1=j1=0; \n\n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { i1=-x1; x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { j1=-y1; y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n\n  if (c->alphaSource) {\n    int rmax, rshift;\n    int gmax, gshift;\n    int bmax, bshift;\n    int amax = 255;\t/* alphaSource is always 8bits of info per pixel */\n    unsigned int rmask, gmask, bmask;\n\n    rmax   = screen->serverFormat.redMax;\n    gmax   = screen->serverFormat.greenMax;\n    bmax   = screen->serverFormat.blueMax;\n    rshift = screen->serverFormat.redShift;\n    gshift = screen->serverFormat.greenShift;\n    bshift = screen->serverFormat.blueShift;\n\n    rmask = (rmax << rshift);\n    gmask = (gmax << gshift);\n    bmask = (bmax << bshift);\n\n    for(j=0;j<y2;j++) {\n      for(i=0;i<x2;i++) {\n\t/*\n\t * we loop over the whole cursor ignoring c->mask[],\n\t * using the extracted alpha value instead.\n\t */\n\tchar *dest;\n\tunsigned char *src, *aptr;\n\tunsigned int val, dval, sval;\n\tint rdst, gdst, bdst;\t\t/* fb RGB */\n\tint asrc, rsrc, gsrc, bsrc;\t/* rich source ARGB */\n\n\tdest = screen->frameBuffer + (j+y1)*rowstride + (i+x1)*bpp;\n\tsrc  = c->richSource  + (j+j1)*c->width*bpp + (i+i1)*bpp;\n\taptr = c->alphaSource + (j+j1)*c->width + (i+i1);\n\n\tasrc = *aptr;\n\tif (!asrc) {\n\t  continue;\n\t}\n\n\tif (bpp == 1) {\n\t  dval = *((unsigned char*) dest);\n\t  sval = *((unsigned char*) src);\n\t} else if (bpp == 2) {\n\t  dval = *((unsigned short*) dest);\n\t  sval = *((unsigned short*) src);\n\t} else if (bpp == 3) {\n\t  unsigned char *dst = (unsigned char *) dest;\n\t  dval = 0;\n\t  dval |= ((*(dst+0)) << 0);\n\t  dval |= ((*(dst+1)) << 8);\n\t  dval |= ((*(dst+2)) << 16);\n\t  sval = 0;\n\t  sval |= ((*(src+0)) << 0);\n\t  sval |= ((*(src+1)) << 8);\n\t  sval |= ((*(src+2)) << 16);\n\t} else if (bpp == 4) {\n\t  dval = *((unsigned int*) dest);\n\t  sval = *((unsigned int*) src);\n\t} else {\n\t  continue;\n\t}\n\n\t/* extract dest and src RGB */\n\trdst = (dval & rmask) >> rshift;\t/* fb */\n\tgdst = (dval & gmask) >> gshift;\n\tbdst = (dval & bmask) >> bshift;\n\n\trsrc = (sval & rmask) >> rshift;\t/* richcursor */\n\tgsrc = (sval & gmask) >> gshift;\n\tbsrc = (sval & bmask) >> bshift;\n\n\t/* blend in fb data. */\n\tif (! c->alphaPreMultiplied) {\n\t  rsrc = (asrc * rsrc)/amax;\n\t  gsrc = (asrc * gsrc)/amax;\n\t  bsrc = (asrc * bsrc)/amax;\n\t}\n\trdst = rsrc + ((amax - asrc) * rdst)/amax;\n\tgdst = gsrc + ((amax - asrc) * gdst)/amax;\n\tbdst = bsrc + ((amax - asrc) * bdst)/amax;\n\n\tval = 0;\n\tval |= (rdst << rshift);\n\tval |= (gdst << gshift);\n\tval |= (bdst << bshift);\n\n\t/* insert the cooked pixel into the fb */\n\tmemcpy(dest, &val, bpp);\n      }\n    }\n  }\n  else {\n    /* no alpha  */\n    for(j=0;j<y2;j++)\n      for(i=0;i<x2;i++)\n\tif((c->mask[(j+j1)*w+(i+i1)/8]<<((i+i1)&7))&0x80)\n\t  memcpy(screen->frameBuffer+(j+y1)*rowstride+(i+x1)*bpp,\n\t\t c->richSource+(j+j1)*c->width*bpp+(i+i1)*bpp,bpp);\n  }\n\n  mark_rect_as_modified(x1, y1, x1+x2, y1+y2, 1);\n\n  UNLOCK(cl->screen->cursorMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_under_cursor_buffer",
          "args": [
            "client"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "save_under_cursor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "2124-2180",
          "snippet": "void save_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes,\n    bufsize;  \n  rfbBool wasChanged=FALSE;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  bufsize = c->width * c->height * bpp;\n\n  /* make sure the buffer is big enough */\n  if(cd->under_cursor_buffer_len < bufsize) {\n    LOCK(cl->updateMutex);\n    cd->under_cursor_buffer = realloc(cd->under_cursor_buffer, bufsize);\n    cd->under_cursor_buffer_len = bufsize;\n    UNLOCK(cl->updateMutex);\n  }\n\n  /* sanity checks */ \n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->updateMutex);\n  /* save what's under the cursor now */\n  for(j=0;j<y2;j++) {\n    char* dest = cd->under_cursor_buffer+j*x2*bpp;\n    const char* src = screen->frameBuffer+(y1+j)*rowstride+x1*bpp;\n    unsigned int count=x2*bpp;\n    if(wasChanged || memcmp(dest,src,count)) {\n       wasChanged=TRUE;\n       memcpy(dest,src,count);\n    }\n  }\n  UNLOCK(cl->updateMutex);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void curs_copy(cursor_info_t *dest, cursor_info_t *src);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid save_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes,\n    bufsize;  \n  rfbBool wasChanged=FALSE;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c)\n    return;\n\n  bufsize = c->width * c->height * bpp;\n\n  /* make sure the buffer is big enough */\n  if(cd->under_cursor_buffer_len < bufsize) {\n    LOCK(cl->updateMutex);\n    cd->under_cursor_buffer = realloc(cd->under_cursor_buffer, bufsize);\n    cd->under_cursor_buffer_len = bufsize;\n    UNLOCK(cl->updateMutex);\n  }\n\n  /* sanity checks */ \n  x1 = cd->cursor_x - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0) \n    return; /* nothing to do */\n\n  y1 = cd->cursor_y - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0) \n    return; /* nothing to do */\n\n  LOCK(cl->updateMutex);\n  /* save what's under the cursor now */\n  for(j=0;j<y2;j++) {\n    char* dest = cd->under_cursor_buffer+j*x2*bpp;\n    const char* src = screen->frameBuffer+(y1+j)*rowstride+x1*bpp;\n    unsigned int count=x2*bpp;\n    if(wasChanged || memcmp(dest,src,count)) {\n       wasChanged=TRUE;\n       memcpy(dest,src,count);\n    }\n  }\n  UNLOCK(cl->updateMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_under_cursor_buffer",
          "args": [
            "client"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "restore_under_cursor_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "2328-2372",
          "snippet": "void restore_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c) \n    return;\n\n  /* sanity checks */\n  x1 = cd->cursor_x_saved - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0)\n    return; /* nothing to do */\n\n  y1 = cd->cursor_y_saved - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0)\n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n  /* restore framebuffer from saved data */\n  if(cd->under_cursor_buffer_len > 0) {\n    for(j=0;j<y2;j++)\n      memcpy(screen->frameBuffer+(y1+j)*rowstride+x1*bpp,\n\t     cd->under_cursor_buffer+j*x2*bpp,\n\t     x2*bpp);\n\n    /* seems the additional w/2 and h/2 rect extension is needed in threaded mode */\n    mark_rect_as_modified(x1-x2/2, y1-y2/2, x1+x2+x2/2, y1+y2+y2/2, 1);\n  }\n  UNLOCK(cl->screen->cursorMutex);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "unsigned long get_cursor_serial(int mode);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nunsigned long get_cursor_serial(int mode);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\n\nvoid restore_under_cursor_buffer(rfbClientPtr cl)\n{\n  ClientData *cd = (ClientData *) cl->clientData;\n  rfbCursorPtr c;\n  int j,x1,x2,y1,y2,bpp=screen->serverFormat.bitsPerPixel/8,\n    rowstride=screen->paddedWidthInBytes;\n\n  if(!cd)\n    return;\n\n  c = cd->cursor;\n\n  if(!c) \n    return;\n\n  /* sanity checks */\n  x1 = cd->cursor_x_saved - c->xhot;\n  x2 = x1 + c->width;\n  if(x1<0) { x1=0; }\n  if(x2 >= screen->width) x2= screen->width-1;\n  x2 -= x1; /* width */\n  if(x2<=0)\n    return; /* nothing to do */\n\n  y1 = cd->cursor_y_saved - c->yhot;\n  y2 = y1 + c->height;\n  if(y1<0) { y1=0; }\n  if(y2>=screen->height) y2=screen->height-1;\n  y2 -= y1; /* height */\n  if(y2<=0)\n    return; /* nothing to do */\n\n  LOCK(cl->screen->cursorMutex);\n  /* restore framebuffer from saved data */\n  if(cd->under_cursor_buffer_len > 0) {\n    for(j=0;j<y2;j++)\n      memcpy(screen->frameBuffer+(y1+j)*rowstride+x1*bpp,\n\t     cd->under_cursor_buffer+j*x2*bpp,\n\t     x2*bpp);\n\n    /* seems the additional w/2 and h/2 rect extension is needed in threaded mode */\n    mark_rect_as_modified(x1-x2/2, y1-y2/2, x1+x2+x2/2, y1+y2+y2/2, 1);\n  }\n  UNLOCK(cl->screen->cursorMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s disable HCPU\\n\"",
            "client->host"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s disable HCSU\\n\"",
            "client->host"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\"",
            "x",
            "y",
            "cnt"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\"",
            "cursor_x - x",
            "cursor_y - y"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"cursor_position: set screen pos x=%3d y=%d\\n\"",
            "x",
            "y"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y",
            "scaled_y"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid cursor_position(int x, int y, rfbClientPtr client) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint cnt = 0, nonCursorPosUpdates_clients = 0;\n\tint x_in = x, y_in = y;\n\n\t/* x and y are current positions of X11 pointer on the X11 display */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tif (scaling) {\n\t\tx = ((double) x / dpy_x) * scaled_x;\n\t\tx = nfix(x, scaled_x);\n\t\ty = ((double) y / dpy_y) * scaled_y;\n\t\ty = nfix(y, scaled_y);\n\t}\n\n\tif (clipshift) {\n\t\tif (x < 0) x = 0;\n\t\tif (y < 0) y = 0;\n\t\tif (x >= dpy_x) x = dpy_x-1;\n\t\tif (y >= dpy_y) y = dpy_y-1;\n\t}\n\n\n\tif(client == NULL) {\n\t/* handle screen's master cursor */\n        if (debug_pointer)\n\t  rfbLog(\"cursor_position: set screen pos x=%3d y=%d\\n\", x, y);\n\tif (x == screen->cursorX && y == screen->cursorY) {\n\t\treturn;\n\t}\n\n\tLOCK(screen->cursorMutex);\n\tscreen->cursorX = x;\n\tscreen->cursorY = y;\n\tUNLOCK(screen->cursorMutex);\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (! cl->enableCursorPosUpdates) {\n\t\t\tnonCursorPosUpdates_clients++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (! cursor_pos_updates) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl == last_pointer_client) {\n\t\t\t/*\n\t\t\t * special case if this client was the last one to\n\t\t\t * send a pointer position.\n\t\t\t */\n\t\t\tif (x_in == cursor_x && y_in == cursor_y) {\n\t\t\t\tcl->cursorWasMoved = FALSE;\n\t\t\t} else {\n\t\t\t\t/* an X11 app evidently warped the pointer */\n\t\t\t\tif (debug_pointer) {\n\t\t\t\t\trfbLog(\"cursor_position: warp \"\n\t\t\t\t\t    \"detected dx=%3d dy=%3d\\n\",\n\t\t\t\t\t    cursor_x - x, cursor_y - y);\n\t\t\t\t}\n\t\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tcl->cursorWasMoved = TRUE;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (debug_pointer && cnt) {\n\t\trfbLog(\"cursor_position: sent position x=%3d y=%3d to %d\"\n\t\t    \" clients\\n\", x, y, cnt);\n\t}\n       }\n       else {\n\t /* if client is non-NULL, handle client cursor */\n\t ClientData *cd = (ClientData *) client->clientData;\n\t if(cd && use_multipointer) {\n\t   /* make sure we do this while no rfbSendFramebufferUpdate() to this client is running! \n\t      DO NOT REMOVE THE cl->sendMutex LOCKS IN watch_loop() !!!\n\t    */\n\t   {\n\t     /* disable cursor shape updates so the screen's single\n\t\tmaster pointer gets drawn into the frame buffer */\n\t     if (client->enableCursorShapeUpdates) {\n\t       cd->had_cursor_shape_updates = 1;\n\t       client->enableCursorShapeUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCSU\\n\", client->host);\n\t    \n\t     }\n\n\t     /* disable these cause they send the screen's master pointer pos, not the client pointer's */\n\t     if (client->enableCursorPosUpdates) {\n\t       cd->had_cursor_pos_updates = 1;\n\t       client->enableCursorPosUpdates = FALSE;\n\t       if (debug_pointer) \n\t\t rfbLog(\"%s disable HCPU\\n\", client->host);\n\t     }\n\n\t     client->cursorWasChanged = FALSE;\n\t   }\n\n\n\t   /* restore saved under-cursor-buffer */\n\t   if(cd->cursor_x_saved >= 0 && cd->cursor_y_saved >= 0) \n\t     restore_under_cursor_buffer(client);\n  \n\t   /* save maybe new fb region */\n\t   cd->cursor_x = x;\n\t   cd->cursor_y = y;\n\t   save_under_cursor_buffer(client);\n\t   cd->cursor_x_saved = x;\n\t   cd->cursor_y_saved = y;\n\n\t   /* and draw */\n\t   draw_cursor(client);\n\n\t   if (debug_pointer)\n\t     rfbLog(\"cursor_position: set client pos x=%3d y=%d\\n\", x, y);\n\t }\n       }\n}"
  },
  {
    "function_name": "cursor_pos_updates_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1788-1804",
    "snippet": "int cursor_pos_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nint cursor_pos_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}"
  },
  {
    "function_name": "cursor_noshape_updates_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1770-1786",
    "snippet": "int cursor_noshape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (!cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nint cursor_noshape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (!cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}"
  },
  {
    "function_name": "cursor_shape_updates_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1752-1768",
    "snippet": "int cursor_shape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nint cursor_shape_updates_clients(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s) {\n\t\treturn 0;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n\treturn count;\n}"
  },
  {
    "function_name": "disable_cursor_shape_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1711-1750",
    "snippet": "void disable_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd;\n\t\tcd = (ClientData *) cl->clientData;\n\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_shape_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCSU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_pos_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCPU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcl->enableCursorShapeUpdates = FALSE;\n\t\tcl->enableCursorPosUpdates = FALSE;\n\t\tcl->cursorWasChanged = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s disable HCPU\\n\"",
            "cl->host"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s disable HCSU\\n\"",
            "cl->host"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tClientData *cd;\n\t\tcd = (ClientData *) cl->clientData;\n\n\t\tif (cl->enableCursorShapeUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_shape_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCSU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\tif (cl->enableCursorPosUpdates) {\n\t\t\tif (cd) {\n\t\t\t\tcd->had_cursor_pos_updates = 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (debug_pointer) {\n\t\t\t\trfbLog(\"%s disable HCPU\\n\", cl->host);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcl->enableCursorShapeUpdates = FALSE;\n\t\tcl->enableCursorPosUpdates = FALSE;\n\t\tcl->cursorWasChanged = FALSE;\n\t}\n\trfbReleaseClientIterator(iter);\n}"
  },
  {
    "function_name": "restore_cursor_shape_updates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1675-1709",
    "snippet": "void restore_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tint changed = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->had_cursor_shape_updates) {\n\t\t\trfbLog(\"restoring enableCursorShapeUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorShapeUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (cd->had_cursor_pos_updates) {\n\t\t\trfbLog(\"restoring enableCursorPosUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorPosUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (changed) {\n\t\t\tcl->cursorWasChanged = TRUE;\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void cursor_position(int x, int y, rfbClientPtr client);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"restoring enableCursorPosUpdates for client\"\n\t\t\t    \" 0x%x\\n\"",
            "cl"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"restoring enableCursorShapeUpdates for client\"\n\t\t\t    \" 0x%x\\n\"",
            "cl"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid cursor_position(int x, int y, rfbClientPtr client);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\tint count = 0;\n\n\tif (! s || ! s->clientHead) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tint changed = 0;\n\t\tClientData *cd = (ClientData *) cl->clientData;\n\n\t\tif (! cd) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cd->had_cursor_shape_updates) {\n\t\t\trfbLog(\"restoring enableCursorShapeUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorShapeUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (cd->had_cursor_pos_updates) {\n\t\t\trfbLog(\"restoring enableCursorPosUpdates for client\"\n\t\t\t    \" 0x%x\\n\", cl);\n\t\t\tcl->enableCursorPosUpdates = TRUE;\t\n\t\t\tchanged = 1;\n\t\t}\n\t\tif (changed) {\n\t\t\tcl->cursorWasChanged = TRUE;\n\t\t\tcount++;\n\t\t}\n\t}\n\trfbReleaseClientIterator(iter);\n}"
  },
  {
    "function_name": "set_cursor_was_moved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1660-1672",
    "snippet": "static void set_cursor_was_moved(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasMoved = TRUE;\n\t}\n\trfbReleaseClientIterator(iter);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nstatic void set_cursor_was_moved(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasMoved = TRUE;\n\t}\n\trfbReleaseClientIterator(iter);\n}"
  },
  {
    "function_name": "set_cursor_was_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1642-1656",
    "snippet": "static void set_cursor_was_changed(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\tLOCK(screen->cursorMutex);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasChanged = TRUE;\n\t}\n\tUNLOCK(screen->cursorMutex);\n\trfbReleaseClientIterator(iter);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "void save_under_cursor_buffer(rfbClientPtr cl);",
      "void draw_cursor(rfbClientPtr cl);",
      "void restore_under_cursor_buffer(rfbClientPtr cl);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "s"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\tLOCK(screen->cursorMutex);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasChanged = TRUE;\n\t}\n\tUNLOCK(screen->cursorMutex);\n\trfbReleaseClientIterator(iter);\n}"
  },
  {
    "function_name": "get_which_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1512-1640",
    "snippet": "int get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xfixes_present = 0;",
      "int use_xfixes = 1;",
      "int get_which_cursor(void);",
      "int set_cursor(int x, int y, int which);",
      "unsigned long get_cursor_serial(int mode);",
      "static void set_rfb_cursor(int which);",
      "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_which_cursor which: %d\\n\"",
            "which"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "class",
            "\"shelltool\""
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"shelltool\""
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "class",
            "\"cmdtool\""
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"cmdtool\""
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "class",
            "\"onsole\""
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"onsole\""
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "class",
            "\"text\""
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"text\""
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "class",
            "\"term\""
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"term\""
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowercase",
          "args": [
            "winfo.res_class"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "lowercase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "136-146",
          "snippet": "void lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nvoid lowercase(char *str) {\n\tchar *p;\n\tif (str == NULL) {\n\t\treturn;\n\t}\n\tp = str;\n\twhile (*p != '\\0') {\n\t\t*p = tolower((unsigned char) (*p));\n\t\tp++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetGeometry",
          "args": [
            "dpy",
            "win",
            "&r",
            "&x",
            "&y",
            "&w",
            "&h",
            "&bw",
            "&d"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_descend_cursor",
          "args": [
            "&depth",
            "&win",
            "&winfo"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "tree_descend_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "887-990",
          "snippet": "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!depth || !w || !winfo) {}\n\treturn;\n#else\n\tWindow r, c;\n\tint i, rx, ry, wx, wy;\n\tunsigned int mask;\n\tWindow wins[10];\n\tint descend, maxtries = 10;\n\tchar *name, *s = multiple_cursors_mode;\n\tstatic XClassHint *classhint = NULL;\n\tint nm_info = 1;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n\n\tif (!strcmp(s, \"default\") || !strcmp(s, \"X\") || !strcmp(s, \"arrow\")) {\n\t\tnm_info = 0;\n\t}\n\n\t*(winfo->wm_name)   = '\\0';\n\t*(winfo->res_name)  = '\\0';\n\t*(winfo->res_class) = '\\0';\n\n\tfor (i=0; i < maxtries; i++) {\n\t\twins[i] = None;\n\t}\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tc = window;\n\tdescend = -1;\n\n\twhile (c) {\n\t\twins[++descend] = c;\n\t\tif (descend >= maxtries - 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( XTestCompareCurrentCursorWithWindow_wr(dpy, c) ) {\n\t\t\tbreak;\n\t\t}\n\t\t/* TBD: query_pointer() */\n\t\tXQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &mask);\n\t}\n\n\tif (nm_info) {\n\t\tint got_wm_name = 0, got_res_name = 0, got_res_class = 0;\n\n\t\tif (! classhint) {\n\t\t\tclasshint = XAllocClassHint();\n\t\t}\n\n\t\tfor (i = descend; i >=0; i--) {\n\t\t\tc = wins[i];\n\t\t\tif (! c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (! got_wm_name && XFetchName(dpy, c, &name)) {\n\t\t\t\tif (name) {\n\t\t\t\t\tif (*name != '\\0') {\n\t\t\t\t\t\tstrcpy(winfo->wm_name, name);\n\t\t\t\t\t\tgot_wm_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (classhint && (! got_res_name || ! got_res_class)) {\n\t\t\t    if (XGetClassHint(dpy, c, classhint)) {\n\t\t\t\tchar *p;\n\t\t\t\tp = classhint->res_name;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_name) {\n\t\t\t\t\t\tstrcpy(winfo->res_name, p);\n\t\t\t\t\t\tgot_res_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_name = NULL;\n\t\t\t\t}\n\t\t\t\tp = classhint->res_class;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_class) {\n\t\t\t\t\t\tstrcpy(winfo->res_class, p);\n\t\t\t\t\t\tgot_res_class = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_class = NULL;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\t*depth = descend;\n\t*w = wins[descend];\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!depth || !w || !winfo) {}\n\treturn;\n#else\n\tWindow r, c;\n\tint i, rx, ry, wx, wy;\n\tunsigned int mask;\n\tWindow wins[10];\n\tint descend, maxtries = 10;\n\tchar *name, *s = multiple_cursors_mode;\n\tstatic XClassHint *classhint = NULL;\n\tint nm_info = 1;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n\n\tif (!strcmp(s, \"default\") || !strcmp(s, \"X\") || !strcmp(s, \"arrow\")) {\n\t\tnm_info = 0;\n\t}\n\n\t*(winfo->wm_name)   = '\\0';\n\t*(winfo->res_name)  = '\\0';\n\t*(winfo->res_class) = '\\0';\n\n\tfor (i=0; i < maxtries; i++) {\n\t\twins[i] = None;\n\t}\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tc = window;\n\tdescend = -1;\n\n\twhile (c) {\n\t\twins[++descend] = c;\n\t\tif (descend >= maxtries - 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( XTestCompareCurrentCursorWithWindow_wr(dpy, c) ) {\n\t\t\tbreak;\n\t\t}\n\t\t/* TBD: query_pointer() */\n\t\tXQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &mask);\n\t}\n\n\tif (nm_info) {\n\t\tint got_wm_name = 0, got_res_name = 0, got_res_class = 0;\n\n\t\tif (! classhint) {\n\t\t\tclasshint = XAllocClassHint();\n\t\t}\n\n\t\tfor (i = descend; i >=0; i--) {\n\t\t\tc = wins[i];\n\t\t\tif (! c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (! got_wm_name && XFetchName(dpy, c, &name)) {\n\t\t\t\tif (name) {\n\t\t\t\t\tif (*name != '\\0') {\n\t\t\t\t\t\tstrcpy(winfo->wm_name, name);\n\t\t\t\t\t\tgot_wm_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (classhint && (! got_res_name || ! got_res_class)) {\n\t\t\t    if (XGetClassHint(dpy, c, classhint)) {\n\t\t\t\tchar *p;\n\t\t\t\tp = classhint->res_name;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_name) {\n\t\t\t\t\t\tstrcpy(winfo->res_name, p);\n\t\t\t\t\t\tgot_res_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_name = NULL;\n\t\t\t\t}\n\t\t\t\tp = classhint->res_class;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_class) {\n\t\t\t\t\t\tstrcpy(winfo->res_class, p);\n\t\t\t\t\t\tgot_res_class = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_class = NULL;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\t*depth = descend;\n\t*w = wins[descend];\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "1024"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "1024"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "1024"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "multiple_cursors_mode",
            "\"X%d\"",
            "&din"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_exact_cursor",
          "args": [
            "0"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "get_exact_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1255-1351",
          "snippet": "static int get_exact_cursor(int init) {\n\tint which = CURS_ARROW;\n\n\tif (init) {\n\t\t/* zero out our cache (cursors are not freed) */\n\t\tint i;\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcurs_times[i] = 0;\n\t\t\tcurs_index[i] = 0;\n\t\t}\n\t\tlast_cursor = 0;\n\t\tlast_index = 0;\n\t\treturn -1;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_cursor();\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\treturn which;\n\t}\n\tif (xfixes_present && dpy) {\n#if HAVE_LIBXFIXES\n\t\tuint32_t *pixel32 = NULL;\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tXFixesCursorImage *xfc;\n\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\tif (! xfixes_first_initialized) {\n\t\t\treturn which;\n\t\t}\n\n\t\tX_LOCK;\n\t\tif (! got_xfixes_cursor_notify && xfixes_base_event_type) {\n\t\t\t/* try again for XFixesCursorNotify event */\n\t\t\tXEvent xev;\n\t\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t\t    XFixesCursorNotify, &xev)) {\n\t\t\t\tgot_xfixes_cursor_notify++;\n\t\t\t}\n\t\t}\n\t\tif (! got_xfixes_cursor_notify) {\n\t\t\t/* evidently no cursor change, just return last one */\n\t\t\tX_UNLOCK;\n\t\t\treturn which;\n\t\t}\n\t\tgot_xfixes_cursor_notify = 0;\n\n\t\t/* retrieve the cursor info + pixels from server: */\n\t\txfc = XFixesGetCursorImage(dpy);\n\t\tif (xfc) {\n\t\t\t/* 2017-07-09, Stephan Fuhrmann: This fixes an implementation flaw for 64 bit systems.\n\t\t\t * The XFixesCursorImage structure says xfc->pixels is (unsigned long*) in the structure, but\n\t\t\t * the protocol spec says it's 32 bit per pixel\n\t\t\t * (https://www.x.org/releases/X11R7.6/doc/fixesproto/fixesproto.txt).\n\t\t\t * I'm converting the data anyway to 32 bit to be sure. Only necessary for 64 bit systems,\n\t\t\t * but doing it anyway for 32 bit.\n\t\t\t * */\n\t\t\tint x,y;\n\t\t\tpixel32 = malloc(xfc->width * xfc->height * sizeof(uint32_t));\n\t\t\tfor (y = 0; y < xfc->height; y++) {\n\t\t\t\tfor (x = 0; x < xfc->width; x++) {\n\t\t\t\t\tuint32_t ofs = x + y*xfc->width;\n\t\t\t\t\t*(pixel32 + ofs) = *(xfc->pixels + ofs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tX_UNLOCK;\n\t\tif (! xfc) {\n\t\t\t/* failure. */\n\t\t\treturn which;\n\t\t}\n\n\t\twhich = store_cursor(xfc->cursor_serial, pixel32,\n\t\t    xfc->width, xfc->height, 32, xfc->xhot, xfc->yhot);\n\n\t\tif (pixel32 != NULL) {\n\t\t\tfree(pixel32);\n\t\t}\n\n\t\tX_LOCK;\n\t\tXFree_wr(xfc);\n\t\tX_UNLOCK;\n#endif\n\t}\n\treturn(which);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CURS_MAX 32"
          ],
          "globals_used": [
            "int xfixes_present = 0;",
            "int xfixes_first_initialized = 0;",
            "int got_xfixes_cursor_notify = 0;",
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "int set_cursor(int x, int y, int which);",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "static void set_rfb_cursor(int which);",
            "static int get_exact_cursor(int init);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
            "static cursor_info_t *cursors[CURS_MAX];",
            "static unsigned long last_cursor = 0;",
            "static int last_index = 0;",
            "static time_t curs_times[CURS_MAX];",
            "static unsigned long curs_index[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_MAX 32\n\nint xfixes_present = 0;\nint xfixes_first_initialized = 0;\nint got_xfixes_cursor_notify = 0;\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nint set_cursor(int x, int y, int which);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void set_rfb_cursor(int which);\nstatic int get_exact_cursor(int init);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\nstatic time_t curs_times[CURS_MAX];\nstatic unsigned long curs_index[CURS_MAX];\n\nstatic int get_exact_cursor(int init) {\n\tint which = CURS_ARROW;\n\n\tif (init) {\n\t\t/* zero out our cache (cursors are not freed) */\n\t\tint i;\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcurs_times[i] = 0;\n\t\t\tcurs_index[i] = 0;\n\t\t}\n\t\tlast_cursor = 0;\n\t\tlast_index = 0;\n\t\treturn -1;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_cursor();\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\treturn which;\n\t}\n\tif (xfixes_present && dpy) {\n#if HAVE_LIBXFIXES\n\t\tuint32_t *pixel32 = NULL;\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tXFixesCursorImage *xfc;\n\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\tif (! xfixes_first_initialized) {\n\t\t\treturn which;\n\t\t}\n\n\t\tX_LOCK;\n\t\tif (! got_xfixes_cursor_notify && xfixes_base_event_type) {\n\t\t\t/* try again for XFixesCursorNotify event */\n\t\t\tXEvent xev;\n\t\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t\t    XFixesCursorNotify, &xev)) {\n\t\t\t\tgot_xfixes_cursor_notify++;\n\t\t\t}\n\t\t}\n\t\tif (! got_xfixes_cursor_notify) {\n\t\t\t/* evidently no cursor change, just return last one */\n\t\t\tX_UNLOCK;\n\t\t\treturn which;\n\t\t}\n\t\tgot_xfixes_cursor_notify = 0;\n\n\t\t/* retrieve the cursor info + pixels from server: */\n\t\txfc = XFixesGetCursorImage(dpy);\n\t\tif (xfc) {\n\t\t\t/* 2017-07-09, Stephan Fuhrmann: This fixes an implementation flaw for 64 bit systems.\n\t\t\t * The XFixesCursorImage structure says xfc->pixels is (unsigned long*) in the structure, but\n\t\t\t * the protocol spec says it's 32 bit per pixel\n\t\t\t * (https://www.x.org/releases/X11R7.6/doc/fixesproto/fixesproto.txt).\n\t\t\t * I'm converting the data anyway to 32 bit to be sure. Only necessary for 64 bit systems,\n\t\t\t * but doing it anyway for 32 bit.\n\t\t\t * */\n\t\t\tint x,y;\n\t\t\tpixel32 = malloc(xfc->width * xfc->height * sizeof(uint32_t));\n\t\t\tfor (y = 0; y < xfc->height; y++) {\n\t\t\t\tfor (x = 0; x < xfc->width; x++) {\n\t\t\t\t\tuint32_t ofs = x + y*xfc->width;\n\t\t\t\t\t*(pixel32 + ofs) = *(xfc->pixels + ofs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tX_UNLOCK;\n\t\tif (! xfc) {\n\t\t\t/* failure. */\n\t\t\treturn which;\n\t\t}\n\n\t\twhich = store_cursor(xfc->cursor_serial, pixel32,\n\t\t    xfc->width, xfc->height, 32, xfc->xhot, xfc->yhot);\n\n\t\tif (pixel32 != NULL) {\n\t\t\tfree(pixel32);\n\t\t}\n\n\t\tX_LOCK;\n\t\tXFree_wr(xfc);\n\t\tX_UNLOCK;\n#endif\n\t}\n\treturn(which);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_which_cursor call get_exact_cursor\\n\""
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "multiple_cursors_mode",
            "\"most\""
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "multiple_cursors_mode",
            "\"some\""
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "multiple_cursors_mode",
            "\"X\""
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "multiple_cursors_mode",
            "\"default\""
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "multiple_cursors_mode",
            "\"arrow\""
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint use_xfixes = 1;\nint get_which_cursor(void);\nint set_cursor(int x, int y, int which);\nunsigned long get_cursor_serial(int mode);\nstatic void set_rfb_cursor(int which);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\n\nint get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}"
  },
  {
    "function_name": "initialize_cursors_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1470-1510",
    "snippet": "void initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void initialize_cursors_mode(void);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "unsigned long get_cursor_serial(int mode);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
      "static cursor_info_t *cursors[CURS_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cursor_was_changed",
          "args": [
            "screen"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "set_cursor_was_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1642-1656",
          "snippet": "static void set_cursor_was_changed(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\tLOCK(screen->cursorMutex);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasChanged = TRUE;\n\t}\n\tUNLOCK(screen->cursorMutex);\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\tLOCK(screen->cursorMutex);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasChanged = TRUE;\n\t}\n\tUNLOCK(screen->cursorMutex);\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_rfb_cursor",
          "args": [
            "CURS_ARROW"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "set_rfb_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1938-1953",
          "snippet": "static void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nstatic void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"most\""
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"some\""
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"X\""
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "multiple_cursors_mode"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"default\""
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"none\""
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"default\""
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"resetting cursors mode to \\\"default\\\"\\n\""
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"unknown cursors mode: %s\\n\"",
            "s"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known_cursors_mode",
          "args": [
            "s"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "known_cursors_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1452-1468",
          "snippet": "int known_cursors_mode(char *s) {\n/*\n * default:\tsee initialize_cursors_mode() for default behavior.\n * arrow:\tunchanging white arrow.\n * Xn*:\t\tshow X on root background.  Optional n sets treedepth.\n * some:\tdo the heuristics for root, wm, term detection.\n * most:\tif display have overlay or xfixes, show all cursors,\n *\t\totherwise do the same as \"some\"\n * none:\tshow no cursor.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"arrow\") && *s != 'X' &&\n\t    strcmp(s, \"some\") && strcmp(s, \"most\") && strcmp(s, \"none\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void initialize_cursors_mode(void);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid initialize_cursors_mode(void);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nint known_cursors_mode(char *s) {\n/*\n * default:\tsee initialize_cursors_mode() for default behavior.\n * arrow:\tunchanging white arrow.\n * Xn*:\t\tshow X on root background.  Optional n sets treedepth.\n * some:\tdo the heuristics for root, wm, term detection.\n * most:\tif display have overlay or xfixes, show all cursors,\n *\t\totherwise do the same as \"some\"\n * none:\tshow no cursor.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"arrow\") && *s != 'X' &&\n\t    strcmp(s, \"some\") && strcmp(s, \"most\") && strcmp(s, \"none\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid initialize_cursors_mode(void);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nunsigned long get_cursor_serial(int mode);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nvoid initialize_cursors_mode(void) {\n\tchar *s = multiple_cursors_mode;\n\tif (!s || !known_cursors_mode(s)) {\n\t\trfbLog(\"unknown cursors mode: %s\\n\", s);\n\t\trfbLog(\"resetting cursors mode to \\\"default\\\"\\n\");\n\t\tif (multiple_cursors_mode) free(multiple_cursors_mode);\n\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\ts = multiple_cursors_mode;\n\t}\n\tif (!strcmp(s, \"none\")) {\n\t\tshow_cursor = 0;\n\t} else {\n\t\t/* we do NOT set show_cursor = 1, let the caller do that */\n\t}\n\n\tshow_multiple_cursors = 0;\n\tif (show_cursor) {\n\t\tif (!strcmp(s, \"default\")) {\n\t\t\tif(multiple_cursors_mode) free(multiple_cursors_mode);\n\t\t\tmultiple_cursors_mode = strdup(\"X\");\n\t\t\ts = multiple_cursors_mode;\n\t\t}\n\t\tif (*s == 'X' || !strcmp(s, \"some\") || !strcmp(s, \"most\")) {\n\t\t\tshow_multiple_cursors = 1;\n\t\t} else {\n\t\t\tshow_multiple_cursors = 0;\n\t\t\t/* hmmm, some bug going back to arrow mode.. */\n\t\t\tset_rfb_cursor(CURS_ARROW);\n\t\t}\n\t\tif (screen) {\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t} else {\n\t\tif (screen) {\n\t\t\tLOCK(screen->cursorMutex);\n\t\t\tscreen->cursor = NULL;\n\t\t\tUNLOCK(screen->cursorMutex);\n\t\t\tset_cursor_was_changed(screen);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "known_cursors_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1452-1468",
    "snippet": "int known_cursors_mode(char *s) {\n/*\n * default:\tsee initialize_cursors_mode() for default behavior.\n * arrow:\tunchanging white arrow.\n * Xn*:\t\tshow X on root background.  Optional n sets treedepth.\n * some:\tdo the heuristics for root, wm, term detection.\n * most:\tif display have overlay or xfixes, show all cursors,\n *\t\totherwise do the same as \"some\"\n * none:\tshow no cursor.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"arrow\") && *s != 'X' &&\n\t    strcmp(s, \"some\") && strcmp(s, \"most\") && strcmp(s, \"none\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void initialize_cursors_mode(void);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
      "static cursor_info_t *cursors[CURS_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"none\""
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"most\""
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"some\""
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"arrow\""
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"default\""
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid initialize_cursors_mode(void);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nint known_cursors_mode(char *s) {\n/*\n * default:\tsee initialize_cursors_mode() for default behavior.\n * arrow:\tunchanging white arrow.\n * Xn*:\t\tshow X on root background.  Optional n sets treedepth.\n * some:\tdo the heuristics for root, wm, term detection.\n * most:\tif display have overlay or xfixes, show all cursors,\n *\t\totherwise do the same as \"some\"\n * none:\tshow no cursor.\n */\n\tif (strcmp(s, \"default\") && strcmp(s, \"arrow\") && *s != 'X' &&\n\t    strcmp(s, \"some\") && strcmp(s, \"most\") && strcmp(s, \"none\")) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "store_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1353-1450",
    "snippet": "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CURS_DYN_MAX CURS_DYN16",
      "#define CURS_DYN_MIN CURS_DYN1"
    ],
    "globals_used": [
      "int set_cursor(int x, int y, int which);",
      "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
      "static void set_rfb_cursor(int which);",
      "static cursor_info_t *cursors[CURS_MAX];",
      "static unsigned long last_cursor = 0;",
      "static int last_index = 0;",
      "static time_t curs_times[CURS_MAX];",
      "static unsigned long curs_index[CURS_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pixels2curs",
          "args": [
            "data",
            "w",
            "h",
            "xhot",
            "yhot",
            "bpp/8"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "pixels2curs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1008-1238",
          "snippet": "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int alpha_threshold = 240;",
            "double alpha_frac = 0.33;",
            "int alpha_remove = 0;",
            "int alpha_blend = 1;",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint alpha_threshold = 240;\ndouble alpha_frac = 0.33;\nint alpha_remove = 0;\nint alpha_blend = 1;\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);\n\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rotate_coords",
          "args": [
            "xhot",
            "yhot",
            "&tx",
            "&ty",
            "w",
            "h"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_coords_inverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1388-1434",
          "snippet": "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);",
            "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dst"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "dst",
            "w * h * cbpp/8"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rotate_curs",
          "args": [
            "dst",
            "(char *) data",
            "w",
            "h",
            "cbpp/8"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_curs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1540-1614",
          "snippet": "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}"
          ],
          "globals_used": [
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\n#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "w * h * cbpp/8"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sc: %d  %d/%d %d - %d %d\\n\"",
            "serial",
            "w",
            "h",
            "cbpp",
            "xhot",
            "yhot"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_DYN_MAX CURS_DYN16\n#define CURS_DYN_MIN CURS_DYN1\n\nint set_cursor(int x, int y, int which);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\nstatic time_t curs_times[CURS_MAX];\nstatic unsigned long curs_index[CURS_MAX];\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}"
  },
  {
    "function_name": "get_exact_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1255-1351",
    "snippet": "static int get_exact_cursor(int init) {\n\tint which = CURS_ARROW;\n\n\tif (init) {\n\t\t/* zero out our cache (cursors are not freed) */\n\t\tint i;\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcurs_times[i] = 0;\n\t\t\tcurs_index[i] = 0;\n\t\t}\n\t\tlast_cursor = 0;\n\t\tlast_index = 0;\n\t\treturn -1;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_cursor();\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\treturn which;\n\t}\n\tif (xfixes_present && dpy) {\n#if HAVE_LIBXFIXES\n\t\tuint32_t *pixel32 = NULL;\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tXFixesCursorImage *xfc;\n\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\tif (! xfixes_first_initialized) {\n\t\t\treturn which;\n\t\t}\n\n\t\tX_LOCK;\n\t\tif (! got_xfixes_cursor_notify && xfixes_base_event_type) {\n\t\t\t/* try again for XFixesCursorNotify event */\n\t\t\tXEvent xev;\n\t\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t\t    XFixesCursorNotify, &xev)) {\n\t\t\t\tgot_xfixes_cursor_notify++;\n\t\t\t}\n\t\t}\n\t\tif (! got_xfixes_cursor_notify) {\n\t\t\t/* evidently no cursor change, just return last one */\n\t\t\tX_UNLOCK;\n\t\t\treturn which;\n\t\t}\n\t\tgot_xfixes_cursor_notify = 0;\n\n\t\t/* retrieve the cursor info + pixels from server: */\n\t\txfc = XFixesGetCursorImage(dpy);\n\t\tif (xfc) {\n\t\t\t/* 2017-07-09, Stephan Fuhrmann: This fixes an implementation flaw for 64 bit systems.\n\t\t\t * The XFixesCursorImage structure says xfc->pixels is (unsigned long*) in the structure, but\n\t\t\t * the protocol spec says it's 32 bit per pixel\n\t\t\t * (https://www.x.org/releases/X11R7.6/doc/fixesproto/fixesproto.txt).\n\t\t\t * I'm converting the data anyway to 32 bit to be sure. Only necessary for 64 bit systems,\n\t\t\t * but doing it anyway for 32 bit.\n\t\t\t * */\n\t\t\tint x,y;\n\t\t\tpixel32 = malloc(xfc->width * xfc->height * sizeof(uint32_t));\n\t\t\tfor (y = 0; y < xfc->height; y++) {\n\t\t\t\tfor (x = 0; x < xfc->width; x++) {\n\t\t\t\t\tuint32_t ofs = x + y*xfc->width;\n\t\t\t\t\t*(pixel32 + ofs) = *(xfc->pixels + ofs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tX_UNLOCK;\n\t\tif (! xfc) {\n\t\t\t/* failure. */\n\t\t\treturn which;\n\t\t}\n\n\t\twhich = store_cursor(xfc->cursor_serial, pixel32,\n\t\t    xfc->width, xfc->height, 32, xfc->xhot, xfc->yhot);\n\n\t\tif (pixel32 != NULL) {\n\t\t\tfree(pixel32);\n\t\t}\n\n\t\tX_LOCK;\n\t\tXFree_wr(xfc);\n\t\tX_UNLOCK;\n#endif\n\t}\n\treturn(which);\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CURS_MAX 32"
    ],
    "globals_used": [
      "int xfixes_present = 0;",
      "int xfixes_first_initialized = 0;",
      "int got_xfixes_cursor_notify = 0;",
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "int set_cursor(int x, int y, int which);",
      "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
      "static void set_rfb_cursor(int which);",
      "static int get_exact_cursor(int init);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
      "static cursor_info_t *cursors[CURS_MAX];",
      "static unsigned long last_cursor = 0;",
      "static int last_index = 0;",
      "static time_t curs_times[CURS_MAX];",
      "static unsigned long curs_index[CURS_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "xfc"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pixel32"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_cursor",
          "args": [
            "xfc->cursor_serial",
            "pixel32",
            "xfc->width",
            "xfc->height",
            "32",
            "xfc->xhot",
            "xfc->yhot"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "store_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1353-1450",
          "snippet": "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CURS_DYN_MAX CURS_DYN16",
            "#define CURS_DYN_MIN CURS_DYN1"
          ],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];",
            "static unsigned long last_cursor = 0;",
            "static int last_index = 0;",
            "static time_t curs_times[CURS_MAX];",
            "static unsigned long curs_index[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_DYN_MAX CURS_DYN16\n#define CURS_DYN_MIN CURS_DYN1\n\nint set_cursor(int x, int y, int which);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\nstatic time_t curs_times[CURS_MAX];\nstatic unsigned long curs_index[CURS_MAX];\n\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp,\n    int xhot, int yhot) {\n\tint which = CURS_ARROW;\n\tint use, oldest, i;\n\ttime_t oldtime, now;\n\n#if 0\nfprintf(stderr, \"sc: %d  %d/%d %d - %d %d\\n\", serial, w, h, cbpp, xhot, yhot);\n#endif\n\n\toldest = CURS_DYN_MIN;\n\tif (screen && screen->cursor == cursors[oldest]->rfb) {\n\t\toldest++;\n\t}\n\toldtime = curs_times[oldest];\n\tnow = time(NULL);\n\tfor (i = CURS_DYN_MIN; i <= CURS_DYN_MAX; i++) {\n\t\tif (screen && screen->cursor == cursors[i]->rfb) {\n\t\t\t;\n\t\t} else if (curs_times[i] < oldtime) {\n\t\t\t/* watch for oldest one to overwrite */\n\t\t\toldest = i;\n\t\t\toldtime = curs_times[i];\n\t\t}\n\t\tif (serial == (int) curs_index[i]) {\n\t\t\t/*\n\t\t\t * got a hit with an existing cursor,\n\t\t\t * use that one.\n\t\t\t */\n#ifdef MACOSX\n\t\t\tif (now > curs_times[i] + 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tlast_cursor = curs_index[i];\n\t\t\tcurs_times[i] = now;\n\t\t\tlast_index = i;\n\t\t\treturn last_index;\n\t\t}\n\t}\n\n\t/* we need to create the cursor and overwrite oldest */\n\tuse = oldest;\n\tif (cursors[use]->rfb) {\n\t\t/* clean up oldest if it exists */\n\t\tif (cursors[use]->rfb->richSource) {\n\t\t\tfree(cursors[use]->rfb->richSource);\n\t\t\tcursors[use]->rfb->richSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->alphaSource) {\n\t\t\tfree(cursors[use]->rfb->alphaSource);\n\t\t\tcursors[use]->rfb->alphaSource = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->source) {\n\t\t\tfree(cursors[use]->rfb->source);\n\t\t\tcursors[use]->rfb->source = NULL;\n\t\t}\n\t\tif (cursors[use]->rfb->mask) {\n\t\t\tfree(cursors[use]->rfb->mask);\n\t\t\tcursors[use]->rfb->mask = NULL;\n\t\t}\n\t\tfree(cursors[use]->rfb);\n\t\tcursors[use]->rfb = NULL;\n\t}\n\n\tif (rotating && rotating_cursors) {\n\t\tchar *dst;\n\t\tint tx, ty;\n\n\t\tdst = (char *) malloc(w * h * cbpp/8);\n\t\trotate_curs(dst, (char *) data, w, h, cbpp/8);\n\n\t\tmemcpy(data, dst, w * h * cbpp/8);\n\t\tfree(dst);\n\n\t\trotate_coords(xhot, yhot, &tx, &ty, w, h);\n\t\txhot = tx;\n\t\tyhot = ty;\n\t\tif (! rotating_same) {\n\t\t\tint tmp = w;\n\t\t\tw = h;\n\t\t\th = tmp;\n\t\t}\n\t}\n\n\t/* place cursor into our collection */\n\tcursors[use]->rfb = pixels2curs(data, w, h, xhot, yhot, bpp/8);\n\n\t/* update time and serial index: */\n\tcurs_times[use] = now;\n\tcurs_index[use] = serial;\n\tlast_index = use;\n\tlast_cursor = serial;\n\n\twhich = last_index;\n\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "xfc->width * xfc->height * sizeof(uint32_t)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFixesGetCursorImage",
          "args": [
            "dpy"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xfixes_base_event_type +\n\t\t\t    XFixesCursorNotify",
            "&xev"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cursor_serial",
          "args": [
            "1"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "get_cursor_serial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1245-1253",
          "snippet": "unsigned long get_cursor_serial(int mode) {\n\tif (mode == 0) {\n\t\treturn last_cursor;\n\t} else if (mode == 1) {\n\t\treturn (unsigned long) last_index;\n\t} else {\n\t\treturn (unsigned long) last_index;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long get_cursor_serial(int mode);",
            "static unsigned long last_cursor = 0;",
            "static int last_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nunsigned long get_cursor_serial(int mode);\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\n\nunsigned long get_cursor_serial(int mode) {\n\tif (mode == 0) {\n\t\treturn last_cursor;\n\t} else if (mode == 1) {\n\t\treturn (unsigned long) last_index;\n\t} else {\n\t\treturn (unsigned long) last_index;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_get_cursor",
          "args": [],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_get_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "410-412",
          "snippet": "int macosx_get_cursor(void) {\n\treturn macosxCG_get_cursor();\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int macosx_get_cursor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nint macosx_get_cursor(void);\n\nint macosx_get_cursor(void) {\n\treturn macosxCG_get_cursor();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_MAX 32\n\nint xfixes_present = 0;\nint xfixes_first_initialized = 0;\nint got_xfixes_cursor_notify = 0;\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nint set_cursor(int x, int y, int which);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void set_rfb_cursor(int which);\nstatic int get_exact_cursor(int init);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\nstatic time_t curs_times[CURS_MAX];\nstatic unsigned long curs_index[CURS_MAX];\n\nstatic int get_exact_cursor(int init) {\n\tint which = CURS_ARROW;\n\n\tif (init) {\n\t\t/* zero out our cache (cursors are not freed) */\n\t\tint i;\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcurs_times[i] = 0;\n\t\t\tcurs_index[i] = 0;\n\t\t}\n\t\tlast_cursor = 0;\n\t\tlast_index = 0;\n\t\treturn -1;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_cursor();\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\treturn which;\n\t}\n\tif (xfixes_present && dpy) {\n#if HAVE_LIBXFIXES\n\t\tuint32_t *pixel32 = NULL;\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tXFixesCursorImage *xfc;\n\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\tif (! xfixes_first_initialized) {\n\t\t\treturn which;\n\t\t}\n\n\t\tX_LOCK;\n\t\tif (! got_xfixes_cursor_notify && xfixes_base_event_type) {\n\t\t\t/* try again for XFixesCursorNotify event */\n\t\t\tXEvent xev;\n\t\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t\t    XFixesCursorNotify, &xev)) {\n\t\t\t\tgot_xfixes_cursor_notify++;\n\t\t\t}\n\t\t}\n\t\tif (! got_xfixes_cursor_notify) {\n\t\t\t/* evidently no cursor change, just return last one */\n\t\t\tX_UNLOCK;\n\t\t\treturn which;\n\t\t}\n\t\tgot_xfixes_cursor_notify = 0;\n\n\t\t/* retrieve the cursor info + pixels from server: */\n\t\txfc = XFixesGetCursorImage(dpy);\n\t\tif (xfc) {\n\t\t\t/* 2017-07-09, Stephan Fuhrmann: This fixes an implementation flaw for 64 bit systems.\n\t\t\t * The XFixesCursorImage structure says xfc->pixels is (unsigned long*) in the structure, but\n\t\t\t * the protocol spec says it's 32 bit per pixel\n\t\t\t * (https://www.x.org/releases/X11R7.6/doc/fixesproto/fixesproto.txt).\n\t\t\t * I'm converting the data anyway to 32 bit to be sure. Only necessary for 64 bit systems,\n\t\t\t * but doing it anyway for 32 bit.\n\t\t\t * */\n\t\t\tint x,y;\n\t\t\tpixel32 = malloc(xfc->width * xfc->height * sizeof(uint32_t));\n\t\t\tfor (y = 0; y < xfc->height; y++) {\n\t\t\t\tfor (x = 0; x < xfc->width; x++) {\n\t\t\t\t\tuint32_t ofs = x + y*xfc->width;\n\t\t\t\t\t*(pixel32 + ofs) = *(xfc->pixels + ofs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tX_UNLOCK;\n\t\tif (! xfc) {\n\t\t\t/* failure. */\n\t\t\treturn which;\n\t\t}\n\n\t\twhich = store_cursor(xfc->cursor_serial, pixel32,\n\t\t    xfc->width, xfc->height, 32, xfc->xhot, xfc->yhot);\n\n\t\tif (pixel32 != NULL) {\n\t\t\tfree(pixel32);\n\t\t}\n\n\t\tX_LOCK;\n\t\tXFree_wr(xfc);\n\t\tX_UNLOCK;\n#endif\n\t}\n\treturn(which);\n}"
  },
  {
    "function_name": "get_cursor_serial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1245-1253",
    "snippet": "unsigned long get_cursor_serial(int mode) {\n\tif (mode == 0) {\n\t\treturn last_cursor;\n\t} else if (mode == 1) {\n\t\treturn (unsigned long) last_index;\n\t} else {\n\t\treturn (unsigned long) last_index;\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long get_cursor_serial(int mode);",
      "static unsigned long last_cursor = 0;",
      "static int last_index = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nunsigned long get_cursor_serial(int mode);\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\n\nunsigned long get_cursor_serial(int mode) {\n\tif (mode == 0) {\n\t\treturn last_cursor;\n\t} else if (mode == 1) {\n\t\treturn (unsigned long) last_index;\n\t} else {\n\t\treturn (unsigned long) last_index;\n\t}\n}"
  },
  {
    "function_name": "pixels2curs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "1008-1238",
    "snippet": "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int alpha_threshold = 240;",
      "double alpha_frac = 0.33;",
      "int alpha_remove = 0;",
      "int alpha_blend = 1;",
      "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
      "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "alpha"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbMakeXCursor",
          "args": [
            "w",
            "h",
            "bitmap",
            "bitmap"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1*len",
            "1"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "Bpp*len",
            "1"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len+1"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale_round",
          "args": [
            "yhot",
            "scale_cursor_fac_y"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "scale_round",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2983-2991",
          "snippet": "int scale_round(int len, double fac) {\n\tdouble eps = 0.000001;\n\t\n\tlen = (int) (len * fac + eps);\n\tif (len < 1) {\n\t\tlen = 1;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int scale_round(int len, double fac);",
            "rfbBool vnc_reflect_send_cuttext(char *str, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nint scale_round(int len, double fac);\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\n\nint scale_round(int len, double fac) {\n\tdouble eps = 0.000001;\n\t\n\tlen = (int) (len * fac + eps);\n\tif (len < 1) {\n\t\tlen = 1;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_rect",
          "args": [
            "scale_cursor_fac_x",
            "scale_cursor_fac_y",
            "scaling_cursor_blend",
            "scaling_cursor_interpolate",
            "4",
            "pixels_use",
            "4*W",
            "pixels_new",
            "4*w",
            "W",
            "H",
            "w",
            "h",
            "0",
            "0",
            "W",
            "H",
            "0"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "scale_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "777-1229",
          "snippet": "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);",
            "void scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);",
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);",
            "void nap_sleep(int ms, int split);",
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark);\nvoid scale_and_mark_rect(int X1, int Y1, int X2, int Y2, int mark);\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\nvoid nap_sleep(int ms, int split);\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid scale_rect(double factor_x, double factor_y, int blend, int interpolate, int Bpp,\n    char *src_fb, int src_bytes_per_line, char *dst_fb, int dst_bytes_per_line,\n    int Nx, int Ny, int nx, int ny, int X1, int Y1, int X2, int Y2, int mark) {\n/*\n * Notation:\n * \"i\" an x pixel index in the destination (scaled) framebuffer\n * \"j\" a  y pixel index in the destination (scaled) framebuffer\n * \"I\" an x pixel index in the source (un-scaled, i.e. main) framebuffer\n * \"J\" a  y pixel index in the source (un-scaled, i.e. main) framebuffer\n *\n *  Similarly for nx, ny, Nx, Ny, etc.  Lowercase: dest, Uppercase: source.\n */\n\tint i, j, i1, i2, j1, j2;\t/* indices for scaled fb (dest) */\n\tint I, J, I1, I2, J1, J2;\t/* indices for main fb   (source) */\n\n\tdouble w, wx, wy, wtot;\t/* pixel weights */\n\n\tdouble x1, y1, x2, y2;\t/* x-y coords for destination pixels edges */\n\tdouble dx, dy;\t\t/* size of destination pixel */\n\tdouble ddx=0, ddy=0;\t/* for interpolation expansion */\n\n\tchar *src, *dest;\t/* pointers to the two framebuffers */\n\n\n\tunsigned short us = 0;\n\tunsigned char  uc = 0;\n\tunsigned int   ui = 0;\n\n\tint use_noblend_shortcut = 1;\n\tint shrink;\t\t/* whether shrinking or expanding */\n\tstatic int constant_weights = -1, mag_int = -1;\n\tstatic int last_Nx = -1, last_Ny = -1, cnt = 0;\n\tstatic double last_factor = -1.0;\n\tint b, k;\n\tdouble pixave[4];\t/* for averaging pixel values */\n\n\tif (factor_x <= 1.0 && factor_y <= 1.0) {\n\t\tshrink = 1;\n\t} else {\n\t\tshrink = 0;\n\t}\n\n\t/*\n\t * N.B. width and height (real numbers) of a scaled pixel.\n\t * both are > 1   (e.g. 1.333 for -scale 3/4)\n\t * they should also be equal but we don't assume it.\n\t *\n\t * This new way is probably the best we can do, take the inverse\n\t * of the scaling factor to double precision.\n\t */\n\tdx = 1.0/factor_x;\n\tdy = 1.0/factor_y;\n\n\t/*\n\t * There is some speedup if the pixel weights are constant, so\n\t * let's special case these.\n\t *\n\t * If scale = 1/n and n divides Nx and Ny, the pixel weights\n\t * are constant (e.g. 1/2 => equal on 2x2 square).\n\t */\n\tif (factor_x != last_factor || Nx != last_Nx || Ny != last_Ny) {\n\t\tconstant_weights = -1;\n\t\tmag_int = -1;\n\t\tlast_Nx = Nx;\n\t\tlast_Ny = Ny;\n\t\tlast_factor = factor_x;\n\t}\n\tif (constant_weights < 0 && factor_x != factor_y) {\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t} else if (constant_weights < 0) {\n\t\tint n = 0;\n\n\t\tconstant_weights = 0;\n\t\tmag_int = 0;\n\n\t\tfor (i = 2; i<=128; i++) {\n\t\t\tdouble test = ((double) 1)/ i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend || ! shrink || interpolate) {\n\t\t\t;\n\t\t} else if (n != 0) {\n\t\t\tif (Nx % n == 0 && Ny % n == 0) {\n\t\t\t\tstatic int didmsg = 0;\n\t\t\t\tif (mark && ! didmsg) {\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t\trfbLog(\"scale_and_mark_rect: using \"\n\t\t\t\t\t    \"constant pixel weight speedup \"\n\t\t\t\t\t    \"for 1/%d\\n\", n);\n\t\t\t\t}\n\t\t\t\tconstant_weights = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = 0;\n\t\tfor (i = 2; i<=32; i++) {\n\t\t\tdouble test = (double) i;\n\t\t\tdouble diff, eps = 1.0e-7;\n\t\t\tdiff = factor_x - test;\n\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\tn = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! blend && factor_x > 1.0 && n) {\n\t\t\tmag_int = n;\n\t\t}\n\t}\n\n\tif (mark && factor_x > 1.0 && blend) {\n\t\t/*\n\t\t * kludge: correct for interpolating blurring leaking\n\t\t * up or left 1 destination pixel.\n\t\t */\n\t\tif (X1 > 0) X1--;\n\t\tif (Y1 > 0) Y1--;\n\t}\n\n\t/*\n\t * find the extent of the change the input rectangle induces in\n\t * the scaled framebuffer.\n\t */\n\n\t/* Left edges: find largest i such that i * dx <= X1  */\n\ti1 = FLOOR(X1/dx);\n\n\t/* Right edges: find smallest i such that (i+1) * dx >= X2+1  */\n\ti2 = CEIL( (X2+1)/dx ) - 1;\n\n\t/* To be safe, correct any overflows: */\n\ti1 = nfix(i1, nx);\n\ti2 = nfix(i2, nx) + 1;\t/* add 1 to make a rectangle upper boundary */\n\n\t/* Repeat above for y direction: */\n\tj1 = FLOOR(Y1/dy);\n\tj2 = CEIL( (Y2+1)/dy ) - 1;\n\n\tj1 = nfix(j1, ny);\n\tj2 = nfix(j2, ny) + 1;\n\n\t/*\n\t * special case integer magnification with no blending.\n\t * vision impaired magnification usage is interested in this case.\n\t */\n\tif (mark && ! blend && mag_int && Bpp != 3) {\n\t\tint jmin, jmax, imin, imax;\n\n\t\t/* outer loop over *source* pixels */\n\t\tfor (J=Y1; J < Y2; J++) {\n\t\t    jmin = J * mag_int;\n\t\t    jmax = jmin + mag_int;\n\t\t    for (I=X1; I < X2; I++) {\n\t\t\t/* extract value */\n\t\t\tsrc = src_fb + J*src_bytes_per_line + I*Bpp;\n\t\t\tif (Bpp == 4) {\n\t\t\t\tui = *((unsigned int *)src);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\tus = *((unsigned short *)src);\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\tuc = *((unsigned char *)src);\n\t\t\t}\n\t\t\timin = I * mag_int;\n\t\t\timax = imin + mag_int;\n\t\t\t/* inner loop over *dest* pixels */\n\t\t\tfor (j=jmin; j<jmax; j++) {\n\t\t\t    dest = dst_fb + j*dst_bytes_per_line + imin*Bpp;\n\t\t\t    for (i=imin; i<imax; i++) {\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest) = ui;\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest) = us;\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*((unsigned char *)dest) = uc;\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tgoto markit;\n\t}\n\n\t/* set these all to 1.0 to begin with */\n\twx = 1.0;\n\twy = 1.0;\n\tw  = 1.0;\n\n\t/*\n\t * Loop over destination pixels in scaled fb:\n\t */\n\tfor (j=j1; j<j2; j++) {\n\t\ty1 =  j * dy;\t/* top edge */\n\t\tif (y1 > Ny - 1) {\n\t\t\t/* can go over with dy = 1/scale_fac */\n\t\t\ty1 = Ny - 1;\n\t\t}\n\t\ty2 = y1 + dy;\t/* bottom edge */\n\n\t\t/* Find main fb indices covered by this dest pixel: */\n\t\tJ1 = (int) FLOOR(y1);\n\t\tJ1 = nfix(J1, Ny);\n\n\t\tif (shrink && ! interpolate) {\n\t\t\tJ2 = (int) CEIL(y2) - 1;\n\t\t\tJ2 = nfix(J2, Ny);\n\t\t} else {\n\t\t\tJ2 = J1 + 1;\t/* simple interpolation */\n\t\t\tddy = y1 - J1;\n\t\t}\n\n\t\t/* destination char* pointer: */\n\t\tdest = dst_fb + j*dst_bytes_per_line + i1*Bpp;\n\t\t\n\t\tfor (i=i1; i<i2; i++) {\n\n\t\t\tx1 =  i * dx;\t/* left edge */\n\t\t\tif (x1 > Nx - 1) {\n\t\t\t\t/* can go over with dx = 1/scale_fac */\n\t\t\t\tx1 = Nx - 1;\n\t\t\t}\n\t\t\tx2 = x1 + dx;\t/* right edge */\n\n\t\t\tcnt++;\n\n\t\t\t/* Find main fb indices covered by this dest pixel: */\n\t\t\tI1 = (int) FLOOR(x1);\n\t\t\tif (I1 >= Nx) I1 = Nx - 1;\n\n\t\t\tif (! blend && use_noblend_shortcut) {\n\t\t\t\t/*\n\t\t\t\t * The noblend case involves no weights,\n\t\t\t\t * and 1 pixel, so just copy the value\n\t\t\t\t * directly.\n\t\t\t\t */\n\t\t\t\tsrc = src_fb + J1*src_bytes_per_line + I1*Bpp;\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t*((unsigned int *)dest)\n\t\t\t\t\t    = *((unsigned int *)src);\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t*((unsigned short *)dest)\n\t\t\t\t\t    = *((unsigned short *)src);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\t*(dest) = *(src);\n\t\t\t\t} else if (Bpp == 3) {\n\t\t\t\t\t/* rare case */\n\t\t\t\t\tfor (k=0; k<=2; k++) {\n\t\t\t\t\t\t*(dest+k) = *(src+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdest += Bpp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (shrink && ! interpolate) {\n\t\t\t\tI2 = (int) CEIL(x2) - 1;\n\t\t\t\tif (I2 >= Nx) I2 = Nx - 1;\n\t\t\t} else {\n\t\t\t\tI2 = I1 + 1;\t/* simple interpolation */\n\t\t\t\tddx = x1 - I1;\n\t\t\t}\n\n\t\t\t/* Zero out accumulators for next pixel average: */\n\t\t\tfor (b=0; b<4; b++) {\n\t\t\t\tpixave[b] = 0.0; /* for RGB weighted sums */\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * wtot is for accumulating the total weight.\n\t\t\t * It should always sum to 1/(scale_fac * scale_fac).\n\t\t\t */\n\t\t\twtot = 0.0;\n\n\t\t\t/*\n\t\t\t * Loop over source pixels covered by this dest pixel.\n\t\t\t * \n\t\t\t * These \"extra\" loops over \"J\" and \"I\" make\n\t\t\t * the cache/cacheline performance unclear.\n\t\t\t * For example, will the data brought in from\n\t\t\t * src for j, i, and J=0 still be in the cache\n\t\t\t * after the J > 0 data have been accessed and\n\t\t\t * we are at j, i+1, J=0?  The stride in J is\n\t\t\t * main_bytes_per_line, and so ~4 KB.\n\t\t\t *\n\t\t\t * Typical case when shrinking are 2x2 loop, so\n\t\t\t * just two lines to worry about.\n\t\t\t */\n\t\t\tfor (J=J1; J<=J2; J++) {\n\t\t\t    /* see comments for I, x1, x2, etc. below */\n\t\t\t    if (constant_weights) {\n\t\t\t\t;\n\t\t\t    } else if (! blend) {\n\t\t\t\tif (J != J1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twy = 1.0;\n\n\t\t\t\t/* interpolation scheme: */\n\t\t\t    } else if (! shrink || interpolate) {\n\t\t\t\tif (J >= Ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (J == J1) {\n\t\t\t\t\twy = 1.0 - ddy;\n\t\t\t\t} else if (J != J1) {\n\t\t\t\t\twy = ddy;\n\t\t\t\t}\n\n\t\t\t\t/* integration scheme: */\n\t\t\t    } else if (J < y1) {\n\t\t\t\twy = J+1 - y1;\n\t\t\t    } else if (J+1 > y2) {\n\t\t\t\twy = y2 - J;\n\t\t\t    } else {\n\t\t\t\twy = 1.0;\n\t\t\t    }\n\n\t\t\t    src = src_fb + J*src_bytes_per_line + I1*Bpp;\n\n\t\t\t    for (I=I1; I<=I2; I++) {\n\n\t\t\t\t/* Work out the weight: */\n\n\t\t\t\tif (constant_weights) {\n\t\t\t\t\t;\n\t\t\t\t} else if (! blend) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ugh, PseudoColor colormap is\n\t\t\t\t\t * bad news, to avoid random\n\t\t\t\t\t * colors just take the first\n\t\t\t\t\t * pixel.  Or user may have\n\t\t\t\t\t * specified :nb to fraction.\n\t\t\t\t\t * The :fb will force blending\n\t\t\t\t\t * for this case.\n\t\t\t\t\t */\n\t\t\t\t\tif (I != I1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twx = 1.0;\n\n\t\t\t\t\t/* interpolation scheme: */\n\t\t\t\t} else if (! shrink || interpolate) {\n\t\t\t\t\tif (I >= Nx) {\n\t\t\t\t\t\tcontinue;\t/* off edge */\n\t\t\t\t\t} else if (I == I1) {\n\t\t\t\t\t\twx = 1.0 - ddx;\n\t\t\t\t\t} else if (I != I1) {\n\t\t\t\t\t\twx = ddx;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* integration scheme: */\n\t\t\t\t} else if (I < x1) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source left edge (I) to the\n\t\t\t\t\t * left of dest left edge (x1):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = I+1 - x1;\n\t\t\t\t} else if (I+1 > x2) {\n\t\t\t\t\t/* \n\t\t\t\t\t * source right edge (I+1) to the\n\t\t\t\t\t * right of dest right edge (x2):\n\t\t\t\t\t * fractional weight\n\t\t\t\t\t */\n\t\t\t\t\twx = x2 - I;\n\t\t\t\t} else {\n\t\t\t\t\t/* \n\t\t\t\t\t * source edges (I and I+1) completely\n\t\t\t\t\t * inside dest edges (x1 and x2):\n\t\t\t\t\t * full weight\n\t\t\t\t\t */\n\t\t\t\t\twx = 1.0;\n\t\t\t\t}\n\n\t\t\t\tw = wx * wy;\n\t\t\t\twtot += w;\n\n\t\t\t\t/* \n\t\t\t\t * We average the unsigned char value\n\t\t\t\t * instead of char value: otherwise\n\t\t\t\t * the minimum (char 0) is right next\n\t\t\t\t * to the maximum (char -1)!  This way\n\t\t\t\t * they are spread between 0 and 255.\n\t\t\t\t */\n\t\t\t\tif (Bpp == 4) {\n\t\t\t\t\t/* unroll the loops, can give 20% */\n\t\t\t\t\tpixave[0] += w * ((unsigned char) *(src  ));\n\t\t\t\t\tpixave[1] += w * ((unsigned char) *(src+1));\n\t\t\t\t\tpixave[2] += w * ((unsigned char) *(src+2));\n\t\t\t\t\tpixave[3] += w * ((unsigned char) *(src+3));\n\t\t\t\t} else if (Bpp == 2) {\n\t\t\t\t\t/*\n\t\t\t\t\t * 16bpp: trickier with green\n\t\t\t\t\t * split over two bytes, so we\n\t\t\t\t\t * use the masks:\n\t\t\t\t\t */\n\t\t\t\t\tus = *((unsigned short *) src);\n\t\t\t\t\tpixave[0] += w*(us & main_red_mask);\n\t\t\t\t\tpixave[1] += w*(us & main_green_mask);\n\t\t\t\t\tpixave[2] += w*(us & main_blue_mask);\n\t\t\t\t} else if (Bpp == 1) {\n\t\t\t\t\tpixave[0] += w *\n\t\t\t\t\t    ((unsigned char) *(src));\n\t\t\t\t} else {\n\t\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t\tpixave[b] += w *\n\t\t\t\t\t\t    ((unsigned char) *(src+b));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc += Bpp;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (wtot <= 0.0) {\n\t\t\t\twtot = 1.0;\n\t\t\t}\n\t\t\twtot = 1.0/wtot;\t/* normalization factor */\n\n\t\t\t/* place weighted average pixel in the scaled fb: */\n\t\t\tif (Bpp == 4) {\n\t\t\t\t*(dest  ) = (char) (wtot * pixave[0]);\n\t\t\t\t*(dest+1) = (char) (wtot * pixave[1]);\n\t\t\t\t*(dest+2) = (char) (wtot * pixave[2]);\n\t\t\t\t*(dest+3) = (char) (wtot * pixave[3]);\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t/* 16bpp / 565 case: */\n\t\t\t\tpixave[0] *= wtot;\n\t\t\t\tpixave[1] *= wtot;\n\t\t\t\tpixave[2] *= wtot;\n\t\t\t\tus =  (main_red_mask   & (int) pixave[0])\n\t\t\t\t    | (main_green_mask & (int) pixave[1])\n\t\t\t\t    | (main_blue_mask  & (int) pixave[2]);\n\t\t\t\t*( (unsigned short *) dest ) = us;\n\t\t\t} else if (Bpp == 1) {\n\t\t\t\t*(dest) = (char) (wtot * pixave[0]);\n\t\t\t} else {\n\t\t\t\tfor (b=0; b<Bpp; b++) {\n\t\t\t\t\t*(dest+b) = (char) (wtot * pixave[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdest += Bpp;\n\t\t}\n\t}\n\tmarkit:\n\tif (mark) {\n\t\tmark_rect_as_modified(i1, j1, i2, j2, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "4*w*h"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WhitePixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint alpha_threshold = 240;\ndouble alpha_frac = 0.33;\nint alpha_remove = 0;\nint alpha_blend = 1;\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);\n\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}"
  },
  {
    "function_name": "initialize_xfixes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "992-1006",
    "snippet": "void initialize_xfixes(void) {\n#if HAVE_LIBXFIXES\n\tif (xfixes_present) {\n\t\tX_LOCK;\n\t\tif (use_xfixes) {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin,\n\t\t\t\tXFixesDisplayCursorNotifyMask);\n\t\t} else {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n\t\txfixes_first_initialized = 1;\n\t}\n#endif\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xfixes_present = 0;",
      "int xfixes_first_initialized = 0;",
      "int use_xfixes = 1;",
      "void initialize_xfixes(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFixesSelectCursorInput",
          "args": [
            "dpy",
            "rootwin",
            "0"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFixesSelectCursorInput",
          "args": [
            "dpy",
            "rootwin",
            "XFixesDisplayCursorNotifyMask"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint xfixes_first_initialized = 0;\nint use_xfixes = 1;\nvoid initialize_xfixes(void);\n\nvoid initialize_xfixes(void) {\n#if HAVE_LIBXFIXES\n\tif (xfixes_present) {\n\t\tX_LOCK;\n\t\tif (use_xfixes) {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin,\n\t\t\t\tXFixesDisplayCursorNotifyMask);\n\t\t} else {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n\t\txfixes_first_initialized = 1;\n\t}\n#endif\n}"
  },
  {
    "function_name": "tree_descend_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "887-990",
    "snippet": "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!depth || !w || !winfo) {}\n\treturn;\n#else\n\tWindow r, c;\n\tint i, rx, ry, wx, wy;\n\tunsigned int mask;\n\tWindow wins[10];\n\tint descend, maxtries = 10;\n\tchar *name, *s = multiple_cursors_mode;\n\tstatic XClassHint *classhint = NULL;\n\tint nm_info = 1;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n\n\tif (!strcmp(s, \"default\") || !strcmp(s, \"X\") || !strcmp(s, \"arrow\")) {\n\t\tnm_info = 0;\n\t}\n\n\t*(winfo->wm_name)   = '\\0';\n\t*(winfo->res_name)  = '\\0';\n\t*(winfo->res_class) = '\\0';\n\n\tfor (i=0; i < maxtries; i++) {\n\t\twins[i] = None;\n\t}\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tc = window;\n\tdescend = -1;\n\n\twhile (c) {\n\t\twins[++descend] = c;\n\t\tif (descend >= maxtries - 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( XTestCompareCurrentCursorWithWindow_wr(dpy, c) ) {\n\t\t\tbreak;\n\t\t}\n\t\t/* TBD: query_pointer() */\n\t\tXQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &mask);\n\t}\n\n\tif (nm_info) {\n\t\tint got_wm_name = 0, got_res_name = 0, got_res_class = 0;\n\n\t\tif (! classhint) {\n\t\t\tclasshint = XAllocClassHint();\n\t\t}\n\n\t\tfor (i = descend; i >=0; i--) {\n\t\t\tc = wins[i];\n\t\t\tif (! c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (! got_wm_name && XFetchName(dpy, c, &name)) {\n\t\t\t\tif (name) {\n\t\t\t\t\tif (*name != '\\0') {\n\t\t\t\t\t\tstrcpy(winfo->wm_name, name);\n\t\t\t\t\t\tgot_wm_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (classhint && (! got_res_name || ! got_res_class)) {\n\t\t\t    if (XGetClassHint(dpy, c, classhint)) {\n\t\t\t\tchar *p;\n\t\t\t\tp = classhint->res_name;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_name) {\n\t\t\t\t\t\tstrcpy(winfo->res_name, p);\n\t\t\t\t\t\tgot_res_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_name = NULL;\n\t\t\t\t}\n\t\t\t\tp = classhint->res_class;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_class) {\n\t\t\t\t\t\tstrcpy(winfo->res_class, p);\n\t\t\t\t\t\tgot_res_class = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_class = NULL;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\t*depth = descend;\n\t*w = wins[descend];\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int known_cursors_mode(char *s);",
      "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
      "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
      "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
      "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
      "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);",
      "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "p"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "winfo->res_class",
            "p"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "winfo->res_name",
            "p"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetClassHint",
          "args": [
            "dpy",
            "c",
            "classhint"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "winfo->wm_name",
            "name"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFetchName",
          "args": [
            "dpy",
            "c",
            "&name"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XAllocClassHint",
          "args": [],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "c",
            "&r",
            "&c",
            "&rx",
            "&ry",
            "&wx",
            "&wy",
            "&mask"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTestCompareCurrentCursorWithWindow_wr",
          "args": [
            "dpy",
            "c"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "XTestCompareCurrentCursorWithWindow_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1198-1210",
          "snippet": "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w) {\n\tif (! xtest_present) {\n\t\treturn False;\n\t}\n\tRAWFB_RET(False)\n\n#if HAVE_XTEST\n\treturn XTestCompareCurrentCursorWithWindow(dpy, w);\n#else\n\tif (!w) {}\n\treturn False;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xtest_present = 0;",
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint xtest_present = 0;\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nvoid XTestDiscard_wr(Display *dpy);\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w) {\n\tif (! xtest_present) {\n\t\treturn False;\n\t}\n\tRAWFB_RET(False)\n\n#if HAVE_XTEST\n\treturn XTestCompareCurrentCursorWithWindow(dpy, w);\n#else\n\tif (!w) {}\n\treturn False;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!depth || !w || !winfo) {}\n\treturn;\n#else\n\tWindow r, c;\n\tint i, rx, ry, wx, wy;\n\tunsigned int mask;\n\tWindow wins[10];\n\tint descend, maxtries = 10;\n\tchar *name, *s = multiple_cursors_mode;\n\tstatic XClassHint *classhint = NULL;\n\tint nm_info = 1;\n\tXErrorHandler old_handler;\n\n\tRAWFB_RET_VOID\n\n\tif (!strcmp(s, \"default\") || !strcmp(s, \"X\") || !strcmp(s, \"arrow\")) {\n\t\tnm_info = 0;\n\t}\n\n\t*(winfo->wm_name)   = '\\0';\n\t*(winfo->res_name)  = '\\0';\n\t*(winfo->res_class) = '\\0';\n\n\tfor (i=0; i < maxtries; i++) {\n\t\twins[i] = None;\n\t}\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tc = window;\n\tdescend = -1;\n\n\twhile (c) {\n\t\twins[++descend] = c;\n\t\tif (descend >= maxtries - 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif ( XTestCompareCurrentCursorWithWindow_wr(dpy, c) ) {\n\t\t\tbreak;\n\t\t}\n\t\t/* TBD: query_pointer() */\n\t\tXQueryPointer_wr(dpy, c, &r, &c, &rx, &ry, &wx, &wy, &mask);\n\t}\n\n\tif (nm_info) {\n\t\tint got_wm_name = 0, got_res_name = 0, got_res_class = 0;\n\n\t\tif (! classhint) {\n\t\t\tclasshint = XAllocClassHint();\n\t\t}\n\n\t\tfor (i = descend; i >=0; i--) {\n\t\t\tc = wins[i];\n\t\t\tif (! c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (! got_wm_name && XFetchName(dpy, c, &name)) {\n\t\t\t\tif (name) {\n\t\t\t\t\tif (*name != '\\0') {\n\t\t\t\t\t\tstrcpy(winfo->wm_name, name);\n\t\t\t\t\t\tgot_wm_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (classhint && (! got_res_name || ! got_res_class)) {\n\t\t\t    if (XGetClassHint(dpy, c, classhint)) {\n\t\t\t\tchar *p;\n\t\t\t\tp = classhint->res_name;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_name) {\n\t\t\t\t\t\tstrcpy(winfo->res_name, p);\n\t\t\t\t\t\tgot_res_name = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_name = NULL;\n\t\t\t\t}\n\t\t\t\tp = classhint->res_class;\n\t\t\t\tif (p) {\n\t\t\t\t\tif (*p != '\\0' && ! got_res_class) {\n\t\t\t\t\t\tstrcpy(winfo->res_class, p);\n\t\t\t\t\t\tgot_res_class = 1;\n\t\t\t\t\t}\n\t\t\t\t\tXFree_wr(p);\n\t\t\t\t\tclasshint->res_class = NULL;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\t*depth = descend;\n\t*w = wins[descend];\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "setup_cursors_and_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "876-879",
    "snippet": "void setup_cursors_and_push(void) {\n\tsetup_cursors();\n\tfirst_cursor();\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void first_cursor(void);",
      "void setup_cursors_and_push(void);",
      "static void setup_cursors(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_cursor",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "first_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "576-589",
          "snippet": "void first_cursor(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (! show_cursor) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t\tUNLOCK(screen->cursorMutex);\n\t} else {\n\t\tgot_xfixes_cursor_notify++;\n\t\tset_rfb_cursor(get_which_cursor());\n\t\tset_cursor_was_changed(screen);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int got_xfixes_cursor_notify = 0;",
            "void first_cursor(void);",
            "int get_which_cursor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint got_xfixes_cursor_notify = 0;\nvoid first_cursor(void);\nint get_which_cursor(void);\n\nvoid first_cursor(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (! show_cursor) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t\tUNLOCK(screen->cursorMutex);\n\t} else {\n\t\tgot_xfixes_cursor_notify++;\n\t\tset_rfb_cursor(get_which_cursor());\n\t\tset_cursor_was_changed(screen);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_cursors",
          "args": [],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "setup_cursors_and_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "876-879",
          "snippet": "void setup_cursors_and_push(void) {\n\tsetup_cursors();\n\tfirst_cursor();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid first_cursor(void);\nvoid setup_cursors_and_push(void);\nstatic void setup_cursors(void);\n\nvoid setup_cursors_and_push(void) {\n\tsetup_cursors();\n\tfirst_cursor();\n}"
  },
  {
    "function_name": "setup_cursors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "591-874",
    "snippet": "static void setup_cursors(void) {\n\trfbCursorPtr rfb_curs;\n\tchar *scale = NULL;\n\tint i, j, n = 0;\n\tint w_in = 0, h_in = 0;\n\tstatic int first = 1;\n\n\tif (verbose || use_threads) {\n\t\trfbLog(\"setting up %d cursors...\\n\", CURS_MAX);\n\t}\n\n\tif (first) {\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcursors[i] = NULL;\n\t\t}\n\t}\n\tfirst = 0;\n\n\tif (screen) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t}\n\n\tfor (i=0; i<CURS_MAX; i++) {\n\t\tcursor_info_t *ci;\n\t\tif (cursors[i]) {\n\t\t\t/* clear out any existing ones: */\n\t\t\tci = cursors[i];\n\t\t\tif (ci->rfb) {\n\t\t\t\t/* this is the rfbCursor part: */\n\t\t\t\tif (ci->rfb->richSource) {\n\t\t\t\t\tfree(ci->rfb->richSource);\n\t\t\t\t\tci->rfb->richSource = NULL;\n\t\t\t\t}\n\t\t\t\tif (ci->rfb->source) {\n\t\t\t\t\tfree(ci->rfb->source);\n\t\t\t\t\tci->rfb->source = NULL;\n\t\t\t\t}\n\t\t\t\tif (ci->rfb->mask) {\n\t\t\t\t\tfree(ci->rfb->mask);\n\t\t\t\t\tci->rfb->mask = NULL;\n\t\t\t\t}\n\t\t\t\tfree(ci->rfb);\n\t\t\t\tci->rfb = NULL;\n\t\t\t}\n\t\t\tif (ci->data) {\n\t\t\t\tfree(ci->data);\n\t\t\t\tci->data = NULL;\n\t\t\t}\n\t\t\tif (ci->mask) {\n\t\t\t\tfree(ci->mask);\n\t\t\t\tci->mask = NULL;\n\t\t\t}\n\t\t\tfree(ci);\n\t\t\tci = NULL;\n\t\t}\n\n\t\t/* create new struct: */\n\t\tci = (cursor_info_t *) malloc(sizeof(cursor_info_t));\n\t\tci->data = NULL; \n\t\tci->mask = NULL; \n\t\tci->wx = 0;\n\t\tci->wy = 0;\n\t\tci->sx = 0;\n\t\tci->sy = 0;\n\t\tci->reverse = 0;\n\t\tci->rfb = NULL;\n\t\tcursors[i] = ci;\n\t}\n\n\t/* clear any xfixes cursor cache (no freeing is done) */\n\tget_exact_cursor(1);\n\n\t/* manually fill in the data+masks: */\n\tcur_empty.data\t= curs_empty_data;\n\tcur_empty.mask\t= curs_empty_mask;\n\n\tcur_dot.data\t= curs_dot_data;\n\tcur_dot.mask\t= curs_dot_mask;\n\n\tcur_arrow.data\t= curs_arrow_data;\n\tcur_arrow.mask\t= curs_arrow_mask;\n\tcur_arrow2.data\t= curs_arrow2_data;\n\tcur_arrow2.mask\t= curs_arrow2_mask;\n\tcur_arrow3.data\t= curs_arrow3_data;\n\tcur_arrow3.mask\t= curs_arrow3_mask;\n\tcur_arrow4.data\t= curs_arrow4_data;\n\tcur_arrow4.mask\t= curs_arrow4_mask;\n\tcur_arrow5.data\t= curs_arrow5_data;\n\tcur_arrow5.mask\t= curs_arrow5_mask;\n\tcur_arrow6.data\t= curs_arrow6_data;\n\tcur_arrow6.mask\t= curs_arrow6_mask;\n\n\tcur_root.data\t= curs_root_data;\n\tcur_root.mask\t= curs_root_mask;\n\n\tcur_plus.data\t= curs_plus_data;\n\tcur_plus.mask\t= curs_plus_mask;\n\n\tcur_fleur.data\t= curs_fleur_data;\n\tcur_fleur.mask\t= curs_fleur_mask;\n\n\tcur_xterm.data\t= curs_xterm_data;\n\tcur_xterm.mask\t= curs_xterm_mask;\n\n\tcurs_copy(cursors[CURS_EMPTY], &cur_empty);\tn++;\n\tcurs_copy(cursors[CURS_DOT],   &cur_dot);\tn++;\n\n\tif (alt_arrow < 1 || alt_arrow > alt_arrow_max) {\n\t\talt_arrow = 1;\n\t}\n\tif (alt_arrow == 1) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow);\tn++;\n\t} else if (alt_arrow == 2) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow2);\tn++;\n\t} else if (alt_arrow == 3) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow3);\tn++;\n\t} else if (alt_arrow == 4) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow4);\tn++;\n\t} else if (alt_arrow == 5) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow5);\tn++;\n\t} else if (alt_arrow == 6) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow6);\tn++;\n\t} else {\n\t\talt_arrow = 1;\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow);\tn++;\n\t}\n\tcurs_copy(cursors[CURS_WARROW], &cur_arrow2);\tn++;\n\n\tcurs_copy(cursors[CURS_ROOT], &cur_root);\tn++;\n\tcurs_copy(cursors[CURS_WM],   &cur_fleur);\tn++;\n\tcurs_copy(cursors[CURS_TERM], &cur_xterm);\tn++;\n\tcurs_copy(cursors[CURS_PLUS], &cur_plus);\tn++;\n\n\tif (scale_cursor_str) {\n\t\tscale = scale_cursor_str;\n\t} else if (scaling && scale_str) {\n\t\tscale = scale_str;\n\t}\n\tif (scale && sscanf(scale, \"%dx%d\", &i, &j) == 2) {\n\t\tif (wdpy_x > 0) {\n\t\t\tw_in = wdpy_x; \n\t\t\th_in = wdpy_y; \n\t\t} else {\n\t\t\tw_in = dpy_x; \n\t\t\th_in = dpy_y; \n\t\t}\n\t}\n\n\t/* scale = NULL zeroes everything */\n\tparse_scale_string(scale, &scale_cursor_fac_x, &scale_cursor_fac_y, &scaling_cursor,\n\t    &scaling_cursor_blend, &j, &j, &scaling_cursor_interpolate,\n\t    &scale_cursor_numer, &scale_cursor_denom, w_in, h_in);\n\n\tfor (i=0; i<n; i++) {\n\t\t/* create rfbCursors for the special cursors: */\n\n\t\tcursor_info_t *ci = cursors[i];\n\n\t\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\t\tint w, h, x, y, k;\n\t\t\tuint32_t *pixels;\n\n\t\t\tw = ci->wx;\n\t\t\th = ci->wy;\n\n\t\t\tpixels = (uint32_t *) malloc(w * h\n\t\t\t    * sizeof(uint32_t));\n\n\t\t\tk = 0;\n\t\t\tfor (y=0; y<h; y++) {\n\t\t\t\tfor (x=0; x<w; x++) {\n\t\t\t\t\tchar d = ci->data[k];\n\t\t\t\t\tchar m = ci->mask[k];\n\t\t\t\t\tuint32_t *p;\n\n\t\t\t\t\tp = pixels + k;\n\n\t\t\t\t\t/* set alpha on */\n\t\t\t\t\t*p = 0xff000000;\n\n\t\t\t\t\tif (d == ' ' && m == ' ') {\n\t\t\t\t\t\t/* alpha off */\n\t\t\t\t\t\t*p = 0x00000000;\n\t\t\t\t\t} else if (d != ' ') {\n\t\t\t\t\t\t/* body */\n\t\t\t\t\t\tif (ci->reverse) {\n\t\t\t\t\t\t\t*p |= 0x00000000;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*p |= 0x00ffffff;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (m != ' ') {\n\t\t\t\t\t\t/* edge */\n\t\t\t\t\t\tif (ci->reverse) {\n\t\t\t\t\t\t\t*p |= 0x00ffffff;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*p |= 0x00000000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trfb_curs = pixels2curs(pixels, w, h, ci->sx, ci->sy,\n\t\t\t    bpp/8);\n\n\t\t\tfree(pixels);\n\n\t\t} else {\n\n\t\t\t/* standard X cursor */\n\t\t\trfb_curs = rfbMakeXCursor(ci->wx, ci->wy,\n\t\t\t    ci->data, ci->mask);\n\n\t\t\tif (ci->reverse) {\n\t\t\t\trfb_curs->foreRed   = 0x0000;\n\t\t\t\trfb_curs->foreGreen = 0x0000;\n\t\t\t\trfb_curs->foreBlue  = 0x0000;\n\t\t\t\trfb_curs->backRed   = 0xffff;\n\t\t\t\trfb_curs->backGreen = 0xffff;\n\t\t\t\trfb_curs->backBlue  = 0xffff;\n\t\t\t}\n\t\t\trfb_curs->alphaSource = NULL;\n\n\t\t\trfb_curs->xhot = ci->sx;\n\t\t\trfb_curs->yhot = ci->sy;\n\t\t\trfb_curs->cleanup = FALSE;\n\t\t\trfb_curs->cleanupSource = FALSE;\n\t\t\trfb_curs->cleanupMask = FALSE;\n\t\t\trfb_curs->cleanupRichSource = FALSE;\n\n\t\t\tif (bpp == 8 && indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * use richsource in PseudoColor for better\n\t\t\t\t * looking cursors (i.e. two-color).\n\t\t\t\t */\n\t\t\t\tint x, y, k = 0, bw;\n\t\t\t\tint black = 0, white = 1;\n\t\t\t\tchar d, m;\n\n\t\t\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\t\t\tblack = BlackPixel(dpy, scr);\n\t\t\t\t\twhite = WhitePixel(dpy, scr);\n\t\t\t\t}\n\n\t\t\t\trfb_curs->richSource = (unsigned char *)\n\t\t\t\t    calloc(ci->wx * ci->wy, 1);\n\n\t\t\t\tfor (y = 0; y < ci->wy; y++) {\n\t\t\t\t    for (x = 0; x < ci->wx; x++) {\n\t\t\t\t\td = *(ci->data + k);\n\t\t\t\t\tm = *(ci->mask + k);\n\t\t\t\t\tif (d == ' ' && m == ' ') {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (m != ' ' && d == ' ') {\n\t\t\t\t\t\tbw = black;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbw = white;\n\t\t\t\t\t}\n\t\t\t\t\tif (ci->reverse) {\n\t\t\t\t\t\tif (bw == black) {\n\t\t\t\t\t\t\tbw = white;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbw = black;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*(rfb_curs->richSource+k) =\n\t\t\t\t\t    (unsigned char) bw;\n\t\t\t\t\tk++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tci->rfb = rfb_curs;\n\t}\n\tif (screen) {\n\t\tUNLOCK(screen->cursorMutex);\n\t}\n\tif (verbose) {\n\t\trfbLog(\"  done.\\n\");\n\t}\n\trfbLog(\"\\n\");\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CURS_MAX 32"
    ],
    "globals_used": [
      "int alt_arrow = 1;",
      "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
      "static void setup_cursors(void);",
      "static char* curs_empty_data =\n\"  \"\n\"  \";",
      "static char* curs_empty_mask =\n\"  \"\n\"  \";",
      "static cursor_info_t cur_empty = {NULL, NULL, 2, 2, 0, 0, 0, NULL};",
      "static char* curs_dot_data =\n\"  \"\n\" x\";",
      "static char* curs_dot_mask =\n\"  \"\n\" x\";",
      "static cursor_info_t cur_dot = {NULL, NULL, 2, 2, 0, 0, 0, NULL};",
      "static char* curs_arrow_data =\n\"                  \"\n\" x                \"\n\" xx               \"\n\" xxx              \"\n\" xxxx             \"\n\" xxxxx            \"\n\" xxxxxx           \"\n\" xxxxxxx          \"\n\" xxxxxxxx         \"\n\" xxxxx            \"\n\" xx xx            \"\n\" x   xx           \"\n\"     xx           \"\n\"      xx          \"\n\"      xx          \"\n\"                  \"\n\"                  \"\n\"                  \";",
      "static char* curs_arrow_mask =\n\"xx                \"\n\"xxx               \"\n\"xxxx              \"\n\"xxxxx             \"\n\"xxxxxx            \"\n\"xxxxxxx           \"\n\"xxxxxxxx          \"\n\"xxxxxxxxx         \"\n\"xxxxxxxxxx        \"\n\"xxxxxxxxxx        \"\n\"xxxxxxx           \"\n\"xxx xxxx          \"\n\"xx  xxxx          \"\n\"     xxxx         \"\n\"     xxxx         \"\n\"      xx          \"\n\"                  \"\n\"                  \";",
      "static cursor_info_t cur_arrow = {NULL, NULL, 18, 18, 0, 0, 1, NULL};",
      "static char* curs_arrow2_data =\n\"                  \"\n\" x                \"\n\" xx               \"\n\" xxx              \"\n\" xxxx             \"\n\" xxxxx            \"\n\" xxxxxx           \"\n\" xxxxxxx          \"\n\" xxxxxxxx         \"\n\" xxxxx            \"\n\" xx xx            \"\n\" x   xx           \"\n\"     xx           \"\n\"      xx          \"\n\"      xx          \"\n\"                  \"\n\"                  \"\n\"                  \";",
      "static char* curs_arrow2_mask =\n\"xx                \"\n\"xxx               \"\n\"xxxx              \"\n\"xxxxx             \"\n\"xxxxxx            \"\n\"xxxxxxx           \"\n\"xxxxxxxx          \"\n\"xxxxxxxxx         \"\n\"xxxxxxxxxx        \"\n\"xxxxxxxxxx        \"\n\"xxxxxxx           \"\n\"xxx xxxx          \"\n\"xx  xxxx          \"\n\"     xxxx         \"\n\"     xxxx         \"\n\"      xx          \"\n\"                  \"\n\"                  \";",
      "static cursor_info_t cur_arrow2 = {NULL, NULL, 18, 18, 0, 0, 0, NULL};",
      "static char* curs_arrow3_data = \n\"                \"\n\" xx             \"\n\" xxxx           \"\n\"  xxxxx         \"\n\"  xxxxxxx       \"\n\"   xxxxxxxx     \"\n\"   xxxxxxxxxx   \"\n\"    xxxxx       \"\n\"    xxxxx       \"\n\"     xx  x      \"\n\"     xx   x     \"\n\"      x    x    \"\n\"      x     x   \"\n\"             x  \"\n\"              x \"\n\"                \";",
      "static char* curs_arrow3_mask = \n\"xxx             \"\n\"xxxxx           \"\n\"xxxxxxx         \"\n\" xxxxxxxx       \"\n\" xxxxxxxxxx     \"\n\"  xxxxxxxxxxxx  \"\n\"  xxxxxxxxxxxx  \"\n\"   xxxxxxxxxxx  \"\n\"   xxxxxxx      \"\n\"    xxxxxxx     \"\n\"    xxxx xxx    \"\n\"     xxx  xxx   \"\n\"     xxx   xxx  \"\n\"     xxx    xxx \"\n\"             xxx\"\n\"              xx\";",
      "static cursor_info_t cur_arrow3 = {NULL, NULL, 16, 16, 0, 0, 1, NULL};",
      "static char* curs_arrow4_data = \n\"                \"\n\" xx             \"\n\" xxxx           \"\n\"  xxxxx         \"\n\"  xxxxxxx       \"\n\"   xxxxxxxx     \"\n\"   xxxxxxxxxx   \"\n\"    xxxxx       \"\n\"    xxxxx       \"\n\"     xx  x      \"\n\"     xx   x     \"\n\"      x    x    \"\n\"      x     x   \"\n\"             x  \"\n\"              x \"\n\"                \";",
      "static char* curs_arrow4_mask = \n\"xxx             \"\n\"xxxxx           \"\n\"xxxxxxx         \"\n\" xxxxxxxx       \"\n\" xxxxxxxxxx     \"\n\"  xxxxxxxxxxxx  \"\n\"  xxxxxxxxxxxx  \"\n\"   xxxxxxxxxxx  \"\n\"   xxxxxxx      \"\n\"    xxxxxxx     \"\n\"    xxxx xxx    \"\n\"     xxx  xxx   \"\n\"     xxx   xxx  \"\n\"     xxx    xxx \"\n\"             xxx\"\n\"              xx\";",
      "static cursor_info_t cur_arrow4 = {NULL, NULL, 16, 16, 0, 0, 0, NULL};",
      "static char* curs_arrow5_data = \n\"x              \"\n\" xx            \"\n\" xxxx          \"\n\"  xxxxx        \"\n\"  xxxxxxx      \"\n\"   xxx         \"\n\"   xx x        \"\n\"    x  x       \"\n\"    x   x      \"\n\"         x     \"\n\"          x    \"\n\"           x   \"\n\"            x  \"\n\"             x \"\n\"              x\";",
      "static char* curs_arrow5_mask = \n\"xx             \"\n\"xxxx           \"\n\" xxxxx         \"\n\" xxxxxxx       \"\n\"  xxxxxxxx     \"\n\"  xxxxxxxx     \"\n\"   xxxxx       \"\n\"   xxxxxx      \"\n\"    xx xxx     \"\n\"     x  xxx    \"\n\"         xxx   \"\n\"          xxx  \"\n\"           xxx \"\n\"            xxx\"\n\"             xx\";",
      "static cursor_info_t cur_arrow5 = {NULL, NULL, 15, 15, 0, 0, 1, NULL};",
      "static char* curs_arrow6_data = \n\"x              \"\n\" xx            \"\n\" xxxx          \"\n\"  xxxxx        \"\n\"  xxxxxxx      \"\n\"   xxx         \"\n\"   xx x        \"\n\"    x  x       \"\n\"    x   x      \"\n\"         x     \"\n\"          x    \"\n\"           x   \"\n\"            x  \"\n\"             x \"\n\"              x\";",
      "static char* curs_arrow6_mask = \n\"xx             \"\n\"xxxx           \"\n\" xxxxx         \"\n\" xxxxxxx       \"\n\"  xxxxxxxx     \"\n\"  xxxxxxxx     \"\n\"   xxxxx       \"\n\"   xxxxxx      \"\n\"    xx xxx     \"\n\"     x  xxx    \"\n\"         xxx   \"\n\"          xxx  \"\n\"           xxx \"\n\"            xxx\"\n\"             xx\";",
      "static cursor_info_t cur_arrow6 = {NULL, NULL, 15, 15, 0, 0, 0, NULL};",
      "int alt_arrow_max = 6;",
      "static char* curs_root_data =\n\"                  \"\n\"                  \"\n\"  xxx        xxx  \"\n\"  xxxx      xxxx  \"\n\"  xxxxx    xxxxx  \"\n\"   xxxxx  xxxxx   \"\n\"    xxxxxxxxxx    \"\n\"     xxxxxxxx     \"\n\"      xxxxxx      \"\n\"      xxxxxx      \"\n\"     xxxxxxxx     \"\n\"    xxxxxxxxxx    \"\n\"   xxxxx  xxxxx   \"\n\"  xxxxx    xxxxx  \"\n\"  xxxx      xxxx  \"\n\"  xxx        xxx  \"\n\"                  \"\n\"                  \";",
      "static char* curs_root_mask =\n\"                  \"\n\" xxxx        xxxx \"\n\" xxxxx      xxxxx \"\n\" xxxxxx    xxxxxx \"\n\" xxxxxxx  xxxxxxx \"\n\"  xxxxxxxxxxxxxx  \"\n\"   xxxxxxxxxxxx   \"\n\"    xxxxxxxxxx    \"\n\"     xxxxxxxx     \"\n\"     xxxxxxxx     \"\n\"    xxxxxxxxxx    \"\n\"   xxxxxxxxxxxx   \"\n\"  xxxxxxxxxxxxxx  \"\n\" xxxxxxx  xxxxxxx \"\n\" xxxxxx    xxxxxx \"\n\" xxxxx      xxxxx \"\n\" xxxx        xxxx \"\n\"                  \";",
      "static cursor_info_t cur_root = {NULL, NULL, 18, 18, 8, 8, 1, NULL};",
      "static char* curs_fleur_data = \n\"                \"\n\"       xx       \"\n\"      xxxx      \"\n\"     xxxxxx     \"\n\"       xx       \"\n\"   x   xx   x   \"\n\"  xx   xx   xx  \"\n\" xxxxxxxxxxxxxx \"\n\" xxxxxxxxxxxxxx \"\n\"  xx   xx   xx  \"\n\"   x   xx   x   \"\n\"       xx       \"\n\"     xxxxxx     \"\n\"      xxxx      \"\n\"       xx       \"\n\"                \";",
      "static char* curs_fleur_mask = \n\"      xxxx      \"\n\"      xxxxx     \"\n\"     xxxxxx     \"\n\"    xxxxxxxx    \"\n\"   x xxxxxx x   \"\n\"  xxx xxxx xxx  \"\n\"xxxxxxxxxxxxxxxx\"\n\"xxxxxxxxxxxxxxxx\"\n\"xxxxxxxxxxxxxxxx\"\n\"xxxxxxxxxxxxxxxx\"\n\"  xxx xxxx xxx  \"\n\"   x xxxxxx x   \"\n\"    xxxxxxxx    \"\n\"     xxxxxx     \"\n\"      xxxx      \"\n\"      xxxx      \";",
      "static cursor_info_t cur_fleur = {NULL, NULL, 16, 16, 8, 8, 1, NULL};",
      "static char* curs_plus_data = \n\"            \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\" xxxxxxxxxx \"\n\" xxxxxxxxxx \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\"            \";",
      "static char* curs_plus_mask = \n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \"\n\"xxxxxxxxxxxx\"\n\"xxxxxxxxxxxx\"\n\"xxxxxxxxxxxx\"\n\"xxxxxxxxxxxx\"\n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \";",
      "static cursor_info_t cur_plus = {NULL, NULL, 12, 12, 5, 6, 1, NULL};",
      "static char* curs_xterm_data = \n\"                \"\n\"     xxx xxx    \"\n\"       xxx      \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"       xxx      \"\n\"     xxx xxx    \"\n\"                \";",
      "static char* curs_xterm_mask = \n\"    xxxx xxxx   \"\n\"    xxxxxxxxx   \"\n\"    xxxxxxxxx   \"\n\"      xxxxx     \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"      xxxxx     \"\n\"    xxxxxxxxx   \"\n\"    xxxxxxxxx   \"\n\"    xxxx xxxx   \";",
      "static cursor_info_t cur_xterm = {NULL, NULL, 16, 16, 8, 8, 1, NULL};",
      "static cursor_info_t *cursors[CURS_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  done.\\n\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "ci->wx * ci->wy",
            "1"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WhitePixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlackPixel",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbMakeXCursor",
          "args": [
            "ci->wx",
            "ci->wy",
            "ci->data",
            "ci->mask"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pixels"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pixels2curs",
          "args": [
            "pixels",
            "w",
            "h",
            "ci->sx",
            "ci->sy",
            "bpp/8"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "pixels2curs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1008-1238",
          "snippet": "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int alpha_threshold = 240;",
            "double alpha_frac = 0.33;",
            "int alpha_remove = 0;",
            "int alpha_blend = 1;",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "rfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint alpha_threshold = 240;\ndouble alpha_frac = 0.33;\nint alpha_remove = 0;\nint alpha_blend = 1;\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h, int xhot, int yhot, int Bpp);\n\nrfbCursorPtr pixels2curs(uint32_t *pixels, int w, int h,\n    int xhot, int yhot, int Bpp) {\n\trfbCursorPtr c;\n\tstatic uint32_t black = 0, white = 1;\n\tstatic int first = 1;\n\tchar *bitmap, *rich, *alpha;\n\tchar *pixels_new = NULL;\n\tint n_opaque, n_trans, n_alpha, len, histo[256];\n\tint send_alpha = 0, alpha_shift = 0, thresh;\n\tint i, x, y;\n\tif (first && dpy) {\t/* raw_fb hack */\n\t\tX_LOCK;\n\t\tblack = BlackPixel(dpy, scr);\n\t\twhite = WhitePixel(dpy, scr);\n\t\tX_UNLOCK;\n\t\tfirst = 0;\n\t}\n\n\tif (cmap8to24 && cmap8to24_fb && depth <= 16) {\n\t\tif (Bpp <= 2) {\n\t\t\tBpp = 4;\n\t\t}\n\t}\n\n\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\tint W, H;\n\t\tchar *pixels_use = (char *) pixels;\n\n\t\tW = w;\n\t\tH = h;\n\n\t\tw = scale_round(W, scale_cursor_fac_x);\n\t\th = scale_round(H, scale_cursor_fac_y);\n\n\t\tpixels_new = (char *) malloc(4*w*h);\n\n\t\tscale_rect(scale_cursor_fac_x, scale_cursor_fac_y, scaling_cursor_blend,\n\t\t    scaling_cursor_interpolate,\n\t\t    4, pixels_use, 4*W, pixels_new, 4*w,\n\t\t    W, H, w, h, 0, 0, W, H, 0);\n\t\t\t\n\t\tpixels = (uint32_t *) pixels_new;\n\n\t\txhot = scale_round(xhot, scale_cursor_fac_x);\n\t\tyhot = scale_round(yhot, scale_cursor_fac_y);\n\t}\n\n\tlen = w * h;\n\t/* for bitmap data */\n\tbitmap = (char *) malloc(len+1);\n\tbitmap[len] = '\\0';\n\n\t/* for rich cursor pixel data */\n\trich  = (char *)calloc(Bpp*len, 1);\n\talpha = (char *)calloc(1*len, 1);\n\n\tn_opaque = 0;\n\tn_trans = 0;\n\tn_alpha = 0;\n\tfor (i=0; i<256; i++) {\n\t\thisto[i] = 0;\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t a;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\t\t\tif (a > 0) {\n\t\t\t\tn_alpha++;\n\t\t\t}\n\t\t\thisto[a]++;\n\t\t\tif (a < (unsigned int) alpha_threshold) {\n\t\t\t\tn_trans++;\n\t\t\t} else {\n\t\t\t\tn_opaque++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tif (alpha_blend) {\n\t\tsend_alpha = 0;\n\t\tif (Bpp == 4) {\n\t\t\tsend_alpha = 1;\n\t\t}\n\t\talpha_shift = 24;\n\t\tif (main_red_shift == 24 || main_green_shift == 24 ||\n\t\t    main_blue_shift == 24)  {\n\t\t\talpha_shift = 0;\t/* XXX correct? */\n\t\t}\n\t}\n\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\tthresh = alpha_threshold;\n\t} else {\n\t\tn_opaque = 0;\n\t\tfor (i=255; i>=0; i--) {\n\t\t\tn_opaque += histo[i];\n\t\t\tthresh = i;\n\t\t\tif (n_opaque >= alpha_frac * n_alpha) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (y = 0; y < h; y++) {\n\t\tfor (x = 0; x < w; x++) {\n\t\t\tuint32_t r, g, b, a;\n\t\t\tuint32_t ui;\n\t\t\tchar *p;\n\n\t\t\ta = 0xff000000 & (*(pixels+i));\n\t\t\ta = a >> 24;\t/* alpha channel */\n\n\t\t\tif (a < (unsigned int) thresh) {\n\t\t\t\tbitmap[i] = ' ';\n\t\t\t} else {\n\t\t\t\tbitmap[i] = 'x';\n\t\t\t}\n\n\t\t\tr = 0x00ff0000 & (*(pixels+i));\n\t\t\tg = 0x0000ff00 & (*(pixels+i));\n\t\t\tb = 0x000000ff & (*(pixels+i));\n\t\t\tr = r >> 16;\t/* red */\n\t\t\tg = g >> 8;\t/* green */\n\t\t\tb = b >> 0;\t/* blue */\n\n\t\t\tif (alpha_remove && a != 0) {\n\t\t\t\tr = (255 * r) / a;\n\t\t\t\tg = (255 * g) / a;\n\t\t\t\tb = (255 * b) / a;\n\t\t\t\tif (r > 255) r = 255;\n\t\t\t\tif (g > 255) g = 255;\n\t\t\t\tif (b > 255) b = 255;\n\t\t\t}\n\n\t\t\tif (indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * Choose black or white for\n\t\t\t\t * PseudoColor case.\n\t\t\t\t */\n\t\t\t\tint value = (r+g+b)/3;\n\t\t\t\tif (value > 127) {\n\t\t\t\t\tui = white;\n\t\t\t\t} else {\n\t\t\t\t\tui = black;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Otherwise map the RGB data onto\n\t\t\t\t * the framebuffer format:\n\t\t\t\t */\n\t\t\t\tr = (main_red_max   * r)/255;\n\t\t\t\tg = (main_green_max * g)/255;\n\t\t\t\tb = (main_blue_max  * b)/255;\n\t\t\t\tui = 0;\n\t\t\t\tui |= (r << main_red_shift);\n\t\t\t\tui |= (g << main_green_shift);\n\t\t\t\tui |= (b << main_blue_shift);\n\t\t\t\tif (send_alpha) {\n\t\t\t\t\tui |= (a << alpha_shift);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert value into rich source: */\n\t\t\tp = rich + Bpp*i;\n\n\t\t\tif (Bpp == 1) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ui;\n\t\t\t} else if (Bpp == 2) {\n\t\t\t\t*((unsigned short *)p)\n\t\t\t\t= (unsigned short) ui;\n\t\t\t} else if (Bpp == 3) {\n\t\t\t\t*((unsigned char *)p)\n\t\t\t\t= (unsigned char) ((ui & 0x0000ff) >> 0);\n\t\t\t\t*((unsigned char *)(p+1))\n\t\t\t\t= (unsigned char) ((ui & 0x00ff00) >> 8);\n\t\t\t\t*((unsigned char *)(p+2))\n\t\t\t\t= (unsigned char) ((ui & 0xff0000) >> 16);\n\t\t\t} else if (Bpp == 4) {\n\t\t\t\t*((unsigned int *)p)\n\t\t\t\t= (unsigned int) ui;\n\t\t\t}\n\n\t\t\t/* insert alpha value into alpha source: */\n\t\t\tp = alpha + i;\n\t\t\t*((unsigned char *)p) = (unsigned char) a;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* create the cursor with the bitmap: */\n\tc = rfbMakeXCursor(w, h, bitmap, bitmap);\n\tfree(bitmap);\n\n\tif (pixels_new) {\n\t\tfree(pixels_new);\n\t}\n\n\t/* set up the cursor parameters: */\n\tc->xhot = xhot;\n\tc->yhot = yhot;\n\tc->cleanup = FALSE;\n\tc->cleanupSource = FALSE;\n\tc->cleanupMask = FALSE;\n\tc->cleanupRichSource = FALSE;\n\tc->richSource = (unsigned char *) rich;\n\n\t/* zeroes mean interpolate the rich cursor somehow and use B+W */\n\tc->foreRed   = 0;\n\tc->foreGreen = 0;\n\tc->foreBlue  = 0;\n\tc->backRed   = 0;\n\tc->backGreen = 0;\n\tc->backBlue  = 0;\n\n\tc->source = NULL;\n\n\tif (alpha_blend && !indexed_color) {\n\t\tc->alphaSource = (unsigned char *) alpha;\n\t\tc->alphaPreMultiplied = TRUE;\n\t} else {\n\t\tfree(alpha);\n\t\tc->alphaSource = NULL;\n\t}\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "w * h\n\t\t\t    * sizeof(uint32_t)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_scale_string",
          "args": [
            "scale",
            "&scale_cursor_fac_x",
            "&scale_cursor_fac_y",
            "&scaling_cursor",
            "&scaling_cursor_blend",
            "&j",
            "&j",
            "&scaling_cursor_interpolate",
            "&scale_cursor_numer",
            "&scale_cursor_denom",
            "w_in",
            "h_in"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "parse_scale_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "2831-2952",
          "snippet": "void parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in) {\n\n\tint m, n;\n\tchar *p, *tstr;\n\tdouble f, f2;\n\n\t*factor_x = 1.0;\n\t*factor_y = 1.0;\n\t*scaling = 0;\n\t*blend = 1;\n\t*nomult4 = 0;\n\t*pad = 0;\n\t*interpolate = 0;\n\t*numer = 0, *denom = 0;\n\n\tif (str == NULL || str[0] == '\\0') {\n\t\treturn;\n\t}\n\ttstr = strdup(str);\n\t\n\tif ( (p = strchr(tstr, ':')) != NULL) {\n\t\t/* options */\n\t\tif (strstr(p+1, \"nb\") != NULL) {\n\t\t\t*blend = 0;\n\t\t}\n\t\tif (strstr(p+1, \"fb\") != NULL) {\n\t\t\t*blend = 2;\n\t\t}\n\t\tif (strstr(p+1, \"n4\") != NULL) {\n\t\t\t*nomult4 = 1;\n\t\t}\n\t\tif (strstr(p+1, \"in\") != NULL) {\n\t\t\t*interpolate = 1;\n\t\t}\n\t\tif (strstr(p+1, \"pad\") != NULL) {\n\t\t\t*pad = 1;\n\t\t}\n\t\tif (strstr(p+1, \"nocr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 0;\n\t\t} else if (strstr(p+1, \"cr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 1;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (strchr(tstr, '.') != NULL) {\n\t\tdouble test, diff, eps = 1.0e-7;\n\t\tif (sscanf(tstr, \"%lfx%lf\", &f, &f2) == 2) {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f2;\n\t\t} else if (sscanf(tstr, \"%lf\", &f) != 1) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f;\n\t\t}\n\t\t/* look for common fractions from small ints: */\n\t\tif (*factor_x == *factor_y) {\n\t\t\tfor (n=2; n<=10; n++) {\n\t\t\t\tfor (m=1; m<n; m++) {\n\t\t\t\t\ttest = ((double) m)/ n;\n\t\t\t\t\tdiff = *factor_x - test;\n\t\t\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\t\t\t*numer = m;\n\t\t\t\t\t\t*denom = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*denom) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*factor_x < 0.01) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t} else if (sscanf(tstr, \"%dx%d\", &m, &n) == 2 && w_in > 0 && h_in > 0) {\n\t\t*factor_x = ((double) m) / ((double) w_in);\n\t\t*factor_y = ((double) n) / ((double) h_in);\n\t} else {\n\t\tif (sscanf(tstr, \"%d/%d\", &m, &n) != 2) {\n\t\t\tif (sscanf(tstr, \"%d\", &m) != 1) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\t\tclean_up_exit(1);\n\t\t\t} else {\n\t\t\t\t/* e.g. -scale 1 or -scale 2 */\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\tif (n <= 0 || m <=0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*factor_x = ((double) m)/ n;\n\t\t*factor_y = ((double) m)/ n;\n\t\tif (*factor_x < 0.01) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*numer = m;\n\t\t*denom = n;\n\t}\n\tif (*factor_x == 1.0 && *factor_y == 1.0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"scaling disabled for factor %f %f\\n\", *factor_x, *factor_y);\n\t\t}\n\t} else {\n\t\t*scaling = 1;\n\t}\n\tfree(tstr);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);",
            "static void set_visual(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\nstatic void set_visual(char *str);\n\nvoid parse_scale_string(char *str, double *factor_x, double *factor_y, int *scaling, int *blend,\n    int *nomult4, int *pad, int *interpolate, int *numer, int *denom, int w_in, int h_in) {\n\n\tint m, n;\n\tchar *p, *tstr;\n\tdouble f, f2;\n\n\t*factor_x = 1.0;\n\t*factor_y = 1.0;\n\t*scaling = 0;\n\t*blend = 1;\n\t*nomult4 = 0;\n\t*pad = 0;\n\t*interpolate = 0;\n\t*numer = 0, *denom = 0;\n\n\tif (str == NULL || str[0] == '\\0') {\n\t\treturn;\n\t}\n\ttstr = strdup(str);\n\t\n\tif ( (p = strchr(tstr, ':')) != NULL) {\n\t\t/* options */\n\t\tif (strstr(p+1, \"nb\") != NULL) {\n\t\t\t*blend = 0;\n\t\t}\n\t\tif (strstr(p+1, \"fb\") != NULL) {\n\t\t\t*blend = 2;\n\t\t}\n\t\tif (strstr(p+1, \"n4\") != NULL) {\n\t\t\t*nomult4 = 1;\n\t\t}\n\t\tif (strstr(p+1, \"in\") != NULL) {\n\t\t\t*interpolate = 1;\n\t\t}\n\t\tif (strstr(p+1, \"pad\") != NULL) {\n\t\t\t*pad = 1;\n\t\t}\n\t\tif (strstr(p+1, \"nocr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 0;\n\t\t} else if (strstr(p+1, \"cr\") != NULL) {\n\t\t\t/* global */\n\t\t\tscaling_copyrect = 1;\n\t\t}\n\t\t*p = '\\0';\n\t}\n\n\tif (strchr(tstr, '.') != NULL) {\n\t\tdouble test, diff, eps = 1.0e-7;\n\t\tif (sscanf(tstr, \"%lfx%lf\", &f, &f2) == 2) {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f2;\n\t\t} else if (sscanf(tstr, \"%lf\", &f) != 1) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\t*factor_x = (double) f;\n\t\t\t*factor_y = (double) f;\n\t\t}\n\t\t/* look for common fractions from small ints: */\n\t\tif (*factor_x == *factor_y) {\n\t\t\tfor (n=2; n<=10; n++) {\n\t\t\t\tfor (m=1; m<n; m++) {\n\t\t\t\t\ttest = ((double) m)/ n;\n\t\t\t\t\tdiff = *factor_x - test;\n\t\t\t\t\tif (-eps < diff && diff < eps) {\n\t\t\t\t\t\t*numer = m;\n\t\t\t\t\t\t*denom = n;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (*denom) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*factor_x < 0.01) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t} else if (sscanf(tstr, \"%dx%d\", &m, &n) == 2 && w_in > 0 && h_in > 0) {\n\t\t*factor_x = ((double) m) / ((double) w_in);\n\t\t*factor_y = ((double) n) / ((double) h_in);\n\t} else {\n\t\tif (sscanf(tstr, \"%d/%d\", &m, &n) != 2) {\n\t\t\tif (sscanf(tstr, \"%d\", &m) != 1) {\n\t\t\t\trfbLogEnable(1);\n\t\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\t\tclean_up_exit(1);\n\t\t\t} else {\n\t\t\t\t/* e.g. -scale 1 or -scale 2 */\n\t\t\t\tn = 1;\n\t\t\t}\n\t\t}\n\t\tif (n <= 0 || m <=0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"invalid -scale arg: %s\\n\", tstr);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*factor_x = ((double) m)/ n;\n\t\t*factor_y = ((double) m)/ n;\n\t\tif (*factor_x < 0.01) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"-scale factor too small: %f\\n\", *factor_x);\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t*numer = m;\n\t\t*denom = n;\n\t}\n\tif (*factor_x == 1.0 && *factor_y == 1.0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"scaling disabled for factor %f %f\\n\", *factor_x, *factor_y);\n\t\t}\n\t} else {\n\t\t*scaling = 1;\n\t}\n\tfree(tstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "scale",
            "\"%dx%d\"",
            "&i",
            "&j"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curs_copy",
          "args": [
            "cursors[CURS_PLUS]",
            "&cur_plus"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "curs_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "106-136",
          "snippet": "static void curs_copy(cursor_info_t *dest, cursor_info_t *src) {\n\tif (src->data != NULL) {\n\t\tdest->data = strdup(src->data);\n\t} else {\n\t\tdest->data = NULL;\n\t}\n\tif (src->mask != NULL) {\n\t\tdest->mask = strdup(src->mask);\n\t} else {\n\t\tdest->mask = NULL;\n\t}\n\tdest->wx = src->wx;\n\tdest->wy = src->wy;\n\tdest->sx = src->sx;\n\tdest->sy = src->sy;\n\tdest->reverse = src->reverse;\n\tdest->rfb = src->rfb;\n\n\tif (rotating && rotating_cursors && dest->data != NULL) {\n\t\tint tx, ty;\n\t\trotate_curs(dest->data, src->data, src->wx, src->wy, 1);\n\t\trotate_curs(dest->mask, src->mask, src->wx, src->wy, 1);\n\t\trotate_coords(dest->sx, dest->sy, &tx, &ty, src->wx, src->wy);\n\t\tdest->sx = tx;\n\t\tdest->sy = ty;\n\t\tif (! rotating_same) {\n\t\t\tdest->wx = src->wy;\n\t\t\tdest->wy = src->wx;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void curs_copy(cursor_info_t *dest, cursor_info_t *src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src);\n\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src) {\n\tif (src->data != NULL) {\n\t\tdest->data = strdup(src->data);\n\t} else {\n\t\tdest->data = NULL;\n\t}\n\tif (src->mask != NULL) {\n\t\tdest->mask = strdup(src->mask);\n\t} else {\n\t\tdest->mask = NULL;\n\t}\n\tdest->wx = src->wx;\n\tdest->wy = src->wy;\n\tdest->sx = src->sx;\n\tdest->sy = src->sy;\n\tdest->reverse = src->reverse;\n\tdest->rfb = src->rfb;\n\n\tif (rotating && rotating_cursors && dest->data != NULL) {\n\t\tint tx, ty;\n\t\trotate_curs(dest->data, src->data, src->wx, src->wy, 1);\n\t\trotate_curs(dest->mask, src->mask, src->wx, src->wy, 1);\n\t\trotate_coords(dest->sx, dest->sy, &tx, &ty, src->wx, src->wy);\n\t\tdest->sx = tx;\n\t\tdest->sy = ty;\n\t\tif (! rotating_same) {\n\t\t\tdest->wx = src->wy;\n\t\t\tdest->wy = src->wx;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_exact_cursor",
          "args": [
            "1"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "get_exact_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1255-1351",
          "snippet": "static int get_exact_cursor(int init) {\n\tint which = CURS_ARROW;\n\n\tif (init) {\n\t\t/* zero out our cache (cursors are not freed) */\n\t\tint i;\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcurs_times[i] = 0;\n\t\t\tcurs_index[i] = 0;\n\t\t}\n\t\tlast_cursor = 0;\n\t\tlast_index = 0;\n\t\treturn -1;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_cursor();\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\treturn which;\n\t}\n\tif (xfixes_present && dpy) {\n#if HAVE_LIBXFIXES\n\t\tuint32_t *pixel32 = NULL;\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tXFixesCursorImage *xfc;\n\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\tif (! xfixes_first_initialized) {\n\t\t\treturn which;\n\t\t}\n\n\t\tX_LOCK;\n\t\tif (! got_xfixes_cursor_notify && xfixes_base_event_type) {\n\t\t\t/* try again for XFixesCursorNotify event */\n\t\t\tXEvent xev;\n\t\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t\t    XFixesCursorNotify, &xev)) {\n\t\t\t\tgot_xfixes_cursor_notify++;\n\t\t\t}\n\t\t}\n\t\tif (! got_xfixes_cursor_notify) {\n\t\t\t/* evidently no cursor change, just return last one */\n\t\t\tX_UNLOCK;\n\t\t\treturn which;\n\t\t}\n\t\tgot_xfixes_cursor_notify = 0;\n\n\t\t/* retrieve the cursor info + pixels from server: */\n\t\txfc = XFixesGetCursorImage(dpy);\n\t\tif (xfc) {\n\t\t\t/* 2017-07-09, Stephan Fuhrmann: This fixes an implementation flaw for 64 bit systems.\n\t\t\t * The XFixesCursorImage structure says xfc->pixels is (unsigned long*) in the structure, but\n\t\t\t * the protocol spec says it's 32 bit per pixel\n\t\t\t * (https://www.x.org/releases/X11R7.6/doc/fixesproto/fixesproto.txt).\n\t\t\t * I'm converting the data anyway to 32 bit to be sure. Only necessary for 64 bit systems,\n\t\t\t * but doing it anyway for 32 bit.\n\t\t\t * */\n\t\t\tint x,y;\n\t\t\tpixel32 = malloc(xfc->width * xfc->height * sizeof(uint32_t));\n\t\t\tfor (y = 0; y < xfc->height; y++) {\n\t\t\t\tfor (x = 0; x < xfc->width; x++) {\n\t\t\t\t\tuint32_t ofs = x + y*xfc->width;\n\t\t\t\t\t*(pixel32 + ofs) = *(xfc->pixels + ofs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tX_UNLOCK;\n\t\tif (! xfc) {\n\t\t\t/* failure. */\n\t\t\treturn which;\n\t\t}\n\n\t\twhich = store_cursor(xfc->cursor_serial, pixel32,\n\t\t    xfc->width, xfc->height, 32, xfc->xhot, xfc->yhot);\n\n\t\tif (pixel32 != NULL) {\n\t\t\tfree(pixel32);\n\t\t}\n\n\t\tX_LOCK;\n\t\tXFree_wr(xfc);\n\t\tX_UNLOCK;\n#endif\n\t}\n\treturn(which);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CURS_MAX 32"
          ],
          "globals_used": [
            "int xfixes_present = 0;",
            "int xfixes_first_initialized = 0;",
            "int got_xfixes_cursor_notify = 0;",
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "int set_cursor(int x, int y, int which);",
            "int store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);",
            "static void set_rfb_cursor(int which);",
            "static int get_exact_cursor(int init);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);",
            "static cursor_info_t *cursors[CURS_MAX];",
            "static unsigned long last_cursor = 0;",
            "static int last_index = 0;",
            "static time_t curs_times[CURS_MAX];",
            "static unsigned long curs_index[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_MAX 32\n\nint xfixes_present = 0;\nint xfixes_first_initialized = 0;\nint got_xfixes_cursor_notify = 0;\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nint set_cursor(int x, int y, int which);\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void set_rfb_cursor(int which);\nstatic int get_exact_cursor(int init);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\nstatic cursor_info_t *cursors[CURS_MAX];\nstatic unsigned long last_cursor = 0;\nstatic int last_index = 0;\nstatic time_t curs_times[CURS_MAX];\nstatic unsigned long curs_index[CURS_MAX];\n\nstatic int get_exact_cursor(int init) {\n\tint which = CURS_ARROW;\n\n\tif (init) {\n\t\t/* zero out our cache (cursors are not freed) */\n\t\tint i;\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcurs_times[i] = 0;\n\t\t\tcurs_index[i] = 0;\n\t\t}\n\t\tlast_cursor = 0;\n\t\tlast_index = 0;\n\t\treturn -1;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_get_cursor();\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\treturn which;\n\t}\n\tif (xfixes_present && dpy) {\n#if HAVE_LIBXFIXES\n\t\tuint32_t *pixel32 = NULL;\n\t\tint last_idx = (int) get_cursor_serial(1);\n\t\tXFixesCursorImage *xfc;\n\n\t\tif (last_idx) {\n\t\t\twhich = last_idx;\n\t\t}\n\t\tif (! xfixes_first_initialized) {\n\t\t\treturn which;\n\t\t}\n\n\t\tX_LOCK;\n\t\tif (! got_xfixes_cursor_notify && xfixes_base_event_type) {\n\t\t\t/* try again for XFixesCursorNotify event */\n\t\t\tXEvent xev;\n\t\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t\t    XFixesCursorNotify, &xev)) {\n\t\t\t\tgot_xfixes_cursor_notify++;\n\t\t\t}\n\t\t}\n\t\tif (! got_xfixes_cursor_notify) {\n\t\t\t/* evidently no cursor change, just return last one */\n\t\t\tX_UNLOCK;\n\t\t\treturn which;\n\t\t}\n\t\tgot_xfixes_cursor_notify = 0;\n\n\t\t/* retrieve the cursor info + pixels from server: */\n\t\txfc = XFixesGetCursorImage(dpy);\n\t\tif (xfc) {\n\t\t\t/* 2017-07-09, Stephan Fuhrmann: This fixes an implementation flaw for 64 bit systems.\n\t\t\t * The XFixesCursorImage structure says xfc->pixels is (unsigned long*) in the structure, but\n\t\t\t * the protocol spec says it's 32 bit per pixel\n\t\t\t * (https://www.x.org/releases/X11R7.6/doc/fixesproto/fixesproto.txt).\n\t\t\t * I'm converting the data anyway to 32 bit to be sure. Only necessary for 64 bit systems,\n\t\t\t * but doing it anyway for 32 bit.\n\t\t\t * */\n\t\t\tint x,y;\n\t\t\tpixel32 = malloc(xfc->width * xfc->height * sizeof(uint32_t));\n\t\t\tfor (y = 0; y < xfc->height; y++) {\n\t\t\t\tfor (x = 0; x < xfc->width; x++) {\n\t\t\t\t\tuint32_t ofs = x + y*xfc->width;\n\t\t\t\t\t*(pixel32 + ofs) = *(xfc->pixels + ofs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tX_UNLOCK;\n\t\tif (! xfc) {\n\t\t\t/* failure. */\n\t\t\treturn which;\n\t\t}\n\n\t\twhich = store_cursor(xfc->cursor_serial, pixel32,\n\t\t    xfc->width, xfc->height, 32, xfc->xhot, xfc->yhot);\n\n\t\tif (pixel32 != NULL) {\n\t\t\tfree(pixel32);\n\t\t}\n\n\t\tX_LOCK;\n\t\tXFree_wr(xfc);\n\t\tX_UNLOCK;\n#endif\n\t}\n\treturn(which);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(cursor_info_t)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"setting up %d cursors...\\n\"",
            "CURS_MAX"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define CURS_MAX 32\n\nint alt_arrow = 1;\nint store_cursor(int serial, uint32_t *data, int w, int h, int cbpp, int xhot, int yhot);\nstatic void setup_cursors(void);\nstatic char* curs_empty_data =\n\"  \"\n\"  \";\nstatic char* curs_empty_mask =\n\"  \"\n\"  \";\nstatic cursor_info_t cur_empty = {NULL, NULL, 2, 2, 0, 0, 0, NULL};\nstatic char* curs_dot_data =\n\"  \"\n\" x\";\nstatic char* curs_dot_mask =\n\"  \"\n\" x\";\nstatic cursor_info_t cur_dot = {NULL, NULL, 2, 2, 0, 0, 0, NULL};\nstatic char* curs_arrow_data =\n\"                  \"\n\" x                \"\n\" xx               \"\n\" xxx              \"\n\" xxxx             \"\n\" xxxxx            \"\n\" xxxxxx           \"\n\" xxxxxxx          \"\n\" xxxxxxxx         \"\n\" xxxxx            \"\n\" xx xx            \"\n\" x   xx           \"\n\"     xx           \"\n\"      xx          \"\n\"      xx          \"\n\"                  \"\n\"                  \"\n\"                  \";\nstatic char* curs_arrow_mask =\n\"xx                \"\n\"xxx               \"\n\"xxxx              \"\n\"xxxxx             \"\n\"xxxxxx            \"\n\"xxxxxxx           \"\n\"xxxxxxxx          \"\n\"xxxxxxxxx         \"\n\"xxxxxxxxxx        \"\n\"xxxxxxxxxx        \"\n\"xxxxxxx           \"\n\"xxx xxxx          \"\n\"xx  xxxx          \"\n\"     xxxx         \"\n\"     xxxx         \"\n\"      xx          \"\n\"                  \"\n\"                  \";\nstatic cursor_info_t cur_arrow = {NULL, NULL, 18, 18, 0, 0, 1, NULL};\nstatic char* curs_arrow2_data =\n\"                  \"\n\" x                \"\n\" xx               \"\n\" xxx              \"\n\" xxxx             \"\n\" xxxxx            \"\n\" xxxxxx           \"\n\" xxxxxxx          \"\n\" xxxxxxxx         \"\n\" xxxxx            \"\n\" xx xx            \"\n\" x   xx           \"\n\"     xx           \"\n\"      xx          \"\n\"      xx          \"\n\"                  \"\n\"                  \"\n\"                  \";\nstatic char* curs_arrow2_mask =\n\"xx                \"\n\"xxx               \"\n\"xxxx              \"\n\"xxxxx             \"\n\"xxxxxx            \"\n\"xxxxxxx           \"\n\"xxxxxxxx          \"\n\"xxxxxxxxx         \"\n\"xxxxxxxxxx        \"\n\"xxxxxxxxxx        \"\n\"xxxxxxx           \"\n\"xxx xxxx          \"\n\"xx  xxxx          \"\n\"     xxxx         \"\n\"     xxxx         \"\n\"      xx          \"\n\"                  \"\n\"                  \";\nstatic cursor_info_t cur_arrow2 = {NULL, NULL, 18, 18, 0, 0, 0, NULL};\nstatic char* curs_arrow3_data = \n\"                \"\n\" xx             \"\n\" xxxx           \"\n\"  xxxxx         \"\n\"  xxxxxxx       \"\n\"   xxxxxxxx     \"\n\"   xxxxxxxxxx   \"\n\"    xxxxx       \"\n\"    xxxxx       \"\n\"     xx  x      \"\n\"     xx   x     \"\n\"      x    x    \"\n\"      x     x   \"\n\"             x  \"\n\"              x \"\n\"                \";\nstatic char* curs_arrow3_mask = \n\"xxx             \"\n\"xxxxx           \"\n\"xxxxxxx         \"\n\" xxxxxxxx       \"\n\" xxxxxxxxxx     \"\n\"  xxxxxxxxxxxx  \"\n\"  xxxxxxxxxxxx  \"\n\"   xxxxxxxxxxx  \"\n\"   xxxxxxx      \"\n\"    xxxxxxx     \"\n\"    xxxx xxx    \"\n\"     xxx  xxx   \"\n\"     xxx   xxx  \"\n\"     xxx    xxx \"\n\"             xxx\"\n\"              xx\";\nstatic cursor_info_t cur_arrow3 = {NULL, NULL, 16, 16, 0, 0, 1, NULL};\nstatic char* curs_arrow4_data = \n\"                \"\n\" xx             \"\n\" xxxx           \"\n\"  xxxxx         \"\n\"  xxxxxxx       \"\n\"   xxxxxxxx     \"\n\"   xxxxxxxxxx   \"\n\"    xxxxx       \"\n\"    xxxxx       \"\n\"     xx  x      \"\n\"     xx   x     \"\n\"      x    x    \"\n\"      x     x   \"\n\"             x  \"\n\"              x \"\n\"                \";\nstatic char* curs_arrow4_mask = \n\"xxx             \"\n\"xxxxx           \"\n\"xxxxxxx         \"\n\" xxxxxxxx       \"\n\" xxxxxxxxxx     \"\n\"  xxxxxxxxxxxx  \"\n\"  xxxxxxxxxxxx  \"\n\"   xxxxxxxxxxx  \"\n\"   xxxxxxx      \"\n\"    xxxxxxx     \"\n\"    xxxx xxx    \"\n\"     xxx  xxx   \"\n\"     xxx   xxx  \"\n\"     xxx    xxx \"\n\"             xxx\"\n\"              xx\";\nstatic cursor_info_t cur_arrow4 = {NULL, NULL, 16, 16, 0, 0, 0, NULL};\nstatic char* curs_arrow5_data = \n\"x              \"\n\" xx            \"\n\" xxxx          \"\n\"  xxxxx        \"\n\"  xxxxxxx      \"\n\"   xxx         \"\n\"   xx x        \"\n\"    x  x       \"\n\"    x   x      \"\n\"         x     \"\n\"          x    \"\n\"           x   \"\n\"            x  \"\n\"             x \"\n\"              x\";\nstatic char* curs_arrow5_mask = \n\"xx             \"\n\"xxxx           \"\n\" xxxxx         \"\n\" xxxxxxx       \"\n\"  xxxxxxxx     \"\n\"  xxxxxxxx     \"\n\"   xxxxx       \"\n\"   xxxxxx      \"\n\"    xx xxx     \"\n\"     x  xxx    \"\n\"         xxx   \"\n\"          xxx  \"\n\"           xxx \"\n\"            xxx\"\n\"             xx\";\nstatic cursor_info_t cur_arrow5 = {NULL, NULL, 15, 15, 0, 0, 1, NULL};\nstatic char* curs_arrow6_data = \n\"x              \"\n\" xx            \"\n\" xxxx          \"\n\"  xxxxx        \"\n\"  xxxxxxx      \"\n\"   xxx         \"\n\"   xx x        \"\n\"    x  x       \"\n\"    x   x      \"\n\"         x     \"\n\"          x    \"\n\"           x   \"\n\"            x  \"\n\"             x \"\n\"              x\";\nstatic char* curs_arrow6_mask = \n\"xx             \"\n\"xxxx           \"\n\" xxxxx         \"\n\" xxxxxxx       \"\n\"  xxxxxxxx     \"\n\"  xxxxxxxx     \"\n\"   xxxxx       \"\n\"   xxxxxx      \"\n\"    xx xxx     \"\n\"     x  xxx    \"\n\"         xxx   \"\n\"          xxx  \"\n\"           xxx \"\n\"            xxx\"\n\"             xx\";\nstatic cursor_info_t cur_arrow6 = {NULL, NULL, 15, 15, 0, 0, 0, NULL};\nint alt_arrow_max = 6;\nstatic char* curs_root_data =\n\"                  \"\n\"                  \"\n\"  xxx        xxx  \"\n\"  xxxx      xxxx  \"\n\"  xxxxx    xxxxx  \"\n\"   xxxxx  xxxxx   \"\n\"    xxxxxxxxxx    \"\n\"     xxxxxxxx     \"\n\"      xxxxxx      \"\n\"      xxxxxx      \"\n\"     xxxxxxxx     \"\n\"    xxxxxxxxxx    \"\n\"   xxxxx  xxxxx   \"\n\"  xxxxx    xxxxx  \"\n\"  xxxx      xxxx  \"\n\"  xxx        xxx  \"\n\"                  \"\n\"                  \";\nstatic char* curs_root_mask =\n\"                  \"\n\" xxxx        xxxx \"\n\" xxxxx      xxxxx \"\n\" xxxxxx    xxxxxx \"\n\" xxxxxxx  xxxxxxx \"\n\"  xxxxxxxxxxxxxx  \"\n\"   xxxxxxxxxxxx   \"\n\"    xxxxxxxxxx    \"\n\"     xxxxxxxx     \"\n\"     xxxxxxxx     \"\n\"    xxxxxxxxxx    \"\n\"   xxxxxxxxxxxx   \"\n\"  xxxxxxxxxxxxxx  \"\n\" xxxxxxx  xxxxxxx \"\n\" xxxxxx    xxxxxx \"\n\" xxxxx      xxxxx \"\n\" xxxx        xxxx \"\n\"                  \";\nstatic cursor_info_t cur_root = {NULL, NULL, 18, 18, 8, 8, 1, NULL};\nstatic char* curs_fleur_data = \n\"                \"\n\"       xx       \"\n\"      xxxx      \"\n\"     xxxxxx     \"\n\"       xx       \"\n\"   x   xx   x   \"\n\"  xx   xx   xx  \"\n\" xxxxxxxxxxxxxx \"\n\" xxxxxxxxxxxxxx \"\n\"  xx   xx   xx  \"\n\"   x   xx   x   \"\n\"       xx       \"\n\"     xxxxxx     \"\n\"      xxxx      \"\n\"       xx       \"\n\"                \";\nstatic char* curs_fleur_mask = \n\"      xxxx      \"\n\"      xxxxx     \"\n\"     xxxxxx     \"\n\"    xxxxxxxx    \"\n\"   x xxxxxx x   \"\n\"  xxx xxxx xxx  \"\n\"xxxxxxxxxxxxxxxx\"\n\"xxxxxxxxxxxxxxxx\"\n\"xxxxxxxxxxxxxxxx\"\n\"xxxxxxxxxxxxxxxx\"\n\"  xxx xxxx xxx  \"\n\"   x xxxxxx x   \"\n\"    xxxxxxxx    \"\n\"     xxxxxx     \"\n\"      xxxx      \"\n\"      xxxx      \";\nstatic cursor_info_t cur_fleur = {NULL, NULL, 16, 16, 8, 8, 1, NULL};\nstatic char* curs_plus_data = \n\"            \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\" xxxxxxxxxx \"\n\" xxxxxxxxxx \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\"     xx     \"\n\"            \";\nstatic char* curs_plus_mask = \n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \"\n\"xxxxxxxxxxxx\"\n\"xxxxxxxxxxxx\"\n\"xxxxxxxxxxxx\"\n\"xxxxxxxxxxxx\"\n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \"\n\"    xxxx    \";\nstatic cursor_info_t cur_plus = {NULL, NULL, 12, 12, 5, 6, 1, NULL};\nstatic char* curs_xterm_data = \n\"                \"\n\"     xxx xxx    \"\n\"       xxx      \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"        x       \"\n\"       xxx      \"\n\"     xxx xxx    \"\n\"                \";\nstatic char* curs_xterm_mask = \n\"    xxxx xxxx   \"\n\"    xxxxxxxxx   \"\n\"    xxxxxxxxx   \"\n\"      xxxxx     \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"       xxx      \"\n\"      xxxxx     \"\n\"    xxxxxxxxx   \"\n\"    xxxxxxxxx   \"\n\"    xxxx xxxx   \";\nstatic cursor_info_t cur_xterm = {NULL, NULL, 16, 16, 8, 8, 1, NULL};\nstatic cursor_info_t *cursors[CURS_MAX];\n\nstatic void setup_cursors(void) {\n\trfbCursorPtr rfb_curs;\n\tchar *scale = NULL;\n\tint i, j, n = 0;\n\tint w_in = 0, h_in = 0;\n\tstatic int first = 1;\n\n\tif (verbose || use_threads) {\n\t\trfbLog(\"setting up %d cursors...\\n\", CURS_MAX);\n\t}\n\n\tif (first) {\n\t\tfor (i=0; i<CURS_MAX; i++) {\n\t\t\tcursors[i] = NULL;\n\t\t}\n\t}\n\tfirst = 0;\n\n\tif (screen) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t}\n\n\tfor (i=0; i<CURS_MAX; i++) {\n\t\tcursor_info_t *ci;\n\t\tif (cursors[i]) {\n\t\t\t/* clear out any existing ones: */\n\t\t\tci = cursors[i];\n\t\t\tif (ci->rfb) {\n\t\t\t\t/* this is the rfbCursor part: */\n\t\t\t\tif (ci->rfb->richSource) {\n\t\t\t\t\tfree(ci->rfb->richSource);\n\t\t\t\t\tci->rfb->richSource = NULL;\n\t\t\t\t}\n\t\t\t\tif (ci->rfb->source) {\n\t\t\t\t\tfree(ci->rfb->source);\n\t\t\t\t\tci->rfb->source = NULL;\n\t\t\t\t}\n\t\t\t\tif (ci->rfb->mask) {\n\t\t\t\t\tfree(ci->rfb->mask);\n\t\t\t\t\tci->rfb->mask = NULL;\n\t\t\t\t}\n\t\t\t\tfree(ci->rfb);\n\t\t\t\tci->rfb = NULL;\n\t\t\t}\n\t\t\tif (ci->data) {\n\t\t\t\tfree(ci->data);\n\t\t\t\tci->data = NULL;\n\t\t\t}\n\t\t\tif (ci->mask) {\n\t\t\t\tfree(ci->mask);\n\t\t\t\tci->mask = NULL;\n\t\t\t}\n\t\t\tfree(ci);\n\t\t\tci = NULL;\n\t\t}\n\n\t\t/* create new struct: */\n\t\tci = (cursor_info_t *) malloc(sizeof(cursor_info_t));\n\t\tci->data = NULL; \n\t\tci->mask = NULL; \n\t\tci->wx = 0;\n\t\tci->wy = 0;\n\t\tci->sx = 0;\n\t\tci->sy = 0;\n\t\tci->reverse = 0;\n\t\tci->rfb = NULL;\n\t\tcursors[i] = ci;\n\t}\n\n\t/* clear any xfixes cursor cache (no freeing is done) */\n\tget_exact_cursor(1);\n\n\t/* manually fill in the data+masks: */\n\tcur_empty.data\t= curs_empty_data;\n\tcur_empty.mask\t= curs_empty_mask;\n\n\tcur_dot.data\t= curs_dot_data;\n\tcur_dot.mask\t= curs_dot_mask;\n\n\tcur_arrow.data\t= curs_arrow_data;\n\tcur_arrow.mask\t= curs_arrow_mask;\n\tcur_arrow2.data\t= curs_arrow2_data;\n\tcur_arrow2.mask\t= curs_arrow2_mask;\n\tcur_arrow3.data\t= curs_arrow3_data;\n\tcur_arrow3.mask\t= curs_arrow3_mask;\n\tcur_arrow4.data\t= curs_arrow4_data;\n\tcur_arrow4.mask\t= curs_arrow4_mask;\n\tcur_arrow5.data\t= curs_arrow5_data;\n\tcur_arrow5.mask\t= curs_arrow5_mask;\n\tcur_arrow6.data\t= curs_arrow6_data;\n\tcur_arrow6.mask\t= curs_arrow6_mask;\n\n\tcur_root.data\t= curs_root_data;\n\tcur_root.mask\t= curs_root_mask;\n\n\tcur_plus.data\t= curs_plus_data;\n\tcur_plus.mask\t= curs_plus_mask;\n\n\tcur_fleur.data\t= curs_fleur_data;\n\tcur_fleur.mask\t= curs_fleur_mask;\n\n\tcur_xterm.data\t= curs_xterm_data;\n\tcur_xterm.mask\t= curs_xterm_mask;\n\n\tcurs_copy(cursors[CURS_EMPTY], &cur_empty);\tn++;\n\tcurs_copy(cursors[CURS_DOT],   &cur_dot);\tn++;\n\n\tif (alt_arrow < 1 || alt_arrow > alt_arrow_max) {\n\t\talt_arrow = 1;\n\t}\n\tif (alt_arrow == 1) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow);\tn++;\n\t} else if (alt_arrow == 2) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow2);\tn++;\n\t} else if (alt_arrow == 3) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow3);\tn++;\n\t} else if (alt_arrow == 4) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow4);\tn++;\n\t} else if (alt_arrow == 5) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow5);\tn++;\n\t} else if (alt_arrow == 6) {\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow6);\tn++;\n\t} else {\n\t\talt_arrow = 1;\n\t\tcurs_copy(cursors[CURS_ARROW], &cur_arrow);\tn++;\n\t}\n\tcurs_copy(cursors[CURS_WARROW], &cur_arrow2);\tn++;\n\n\tcurs_copy(cursors[CURS_ROOT], &cur_root);\tn++;\n\tcurs_copy(cursors[CURS_WM],   &cur_fleur);\tn++;\n\tcurs_copy(cursors[CURS_TERM], &cur_xterm);\tn++;\n\tcurs_copy(cursors[CURS_PLUS], &cur_plus);\tn++;\n\n\tif (scale_cursor_str) {\n\t\tscale = scale_cursor_str;\n\t} else if (scaling && scale_str) {\n\t\tscale = scale_str;\n\t}\n\tif (scale && sscanf(scale, \"%dx%d\", &i, &j) == 2) {\n\t\tif (wdpy_x > 0) {\n\t\t\tw_in = wdpy_x; \n\t\t\th_in = wdpy_y; \n\t\t} else {\n\t\t\tw_in = dpy_x; \n\t\t\th_in = dpy_y; \n\t\t}\n\t}\n\n\t/* scale = NULL zeroes everything */\n\tparse_scale_string(scale, &scale_cursor_fac_x, &scale_cursor_fac_y, &scaling_cursor,\n\t    &scaling_cursor_blend, &j, &j, &scaling_cursor_interpolate,\n\t    &scale_cursor_numer, &scale_cursor_denom, w_in, h_in);\n\n\tfor (i=0; i<n; i++) {\n\t\t/* create rfbCursors for the special cursors: */\n\n\t\tcursor_info_t *ci = cursors[i];\n\n\t\tif (scaling_cursor && (scale_cursor_fac_x != 1.0 || scale_cursor_fac_y != 1.0)) {\n\t\t\tint w, h, x, y, k;\n\t\t\tuint32_t *pixels;\n\n\t\t\tw = ci->wx;\n\t\t\th = ci->wy;\n\n\t\t\tpixels = (uint32_t *) malloc(w * h\n\t\t\t    * sizeof(uint32_t));\n\n\t\t\tk = 0;\n\t\t\tfor (y=0; y<h; y++) {\n\t\t\t\tfor (x=0; x<w; x++) {\n\t\t\t\t\tchar d = ci->data[k];\n\t\t\t\t\tchar m = ci->mask[k];\n\t\t\t\t\tuint32_t *p;\n\n\t\t\t\t\tp = pixels + k;\n\n\t\t\t\t\t/* set alpha on */\n\t\t\t\t\t*p = 0xff000000;\n\n\t\t\t\t\tif (d == ' ' && m == ' ') {\n\t\t\t\t\t\t/* alpha off */\n\t\t\t\t\t\t*p = 0x00000000;\n\t\t\t\t\t} else if (d != ' ') {\n\t\t\t\t\t\t/* body */\n\t\t\t\t\t\tif (ci->reverse) {\n\t\t\t\t\t\t\t*p |= 0x00000000;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*p |= 0x00ffffff;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (m != ' ') {\n\t\t\t\t\t\t/* edge */\n\t\t\t\t\t\tif (ci->reverse) {\n\t\t\t\t\t\t\t*p |= 0x00ffffff;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*p |= 0x00000000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trfb_curs = pixels2curs(pixels, w, h, ci->sx, ci->sy,\n\t\t\t    bpp/8);\n\n\t\t\tfree(pixels);\n\n\t\t} else {\n\n\t\t\t/* standard X cursor */\n\t\t\trfb_curs = rfbMakeXCursor(ci->wx, ci->wy,\n\t\t\t    ci->data, ci->mask);\n\n\t\t\tif (ci->reverse) {\n\t\t\t\trfb_curs->foreRed   = 0x0000;\n\t\t\t\trfb_curs->foreGreen = 0x0000;\n\t\t\t\trfb_curs->foreBlue  = 0x0000;\n\t\t\t\trfb_curs->backRed   = 0xffff;\n\t\t\t\trfb_curs->backGreen = 0xffff;\n\t\t\t\trfb_curs->backBlue  = 0xffff;\n\t\t\t}\n\t\t\trfb_curs->alphaSource = NULL;\n\n\t\t\trfb_curs->xhot = ci->sx;\n\t\t\trfb_curs->yhot = ci->sy;\n\t\t\trfb_curs->cleanup = FALSE;\n\t\t\trfb_curs->cleanupSource = FALSE;\n\t\t\trfb_curs->cleanupMask = FALSE;\n\t\t\trfb_curs->cleanupRichSource = FALSE;\n\n\t\t\tif (bpp == 8 && indexed_color) {\n\t\t\t\t/*\n\t\t\t\t * use richsource in PseudoColor for better\n\t\t\t\t * looking cursors (i.e. two-color).\n\t\t\t\t */\n\t\t\t\tint x, y, k = 0, bw;\n\t\t\t\tint black = 0, white = 1;\n\t\t\t\tchar d, m;\n\n\t\t\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\t\t\tblack = BlackPixel(dpy, scr);\n\t\t\t\t\twhite = WhitePixel(dpy, scr);\n\t\t\t\t}\n\n\t\t\t\trfb_curs->richSource = (unsigned char *)\n\t\t\t\t    calloc(ci->wx * ci->wy, 1);\n\n\t\t\t\tfor (y = 0; y < ci->wy; y++) {\n\t\t\t\t    for (x = 0; x < ci->wx; x++) {\n\t\t\t\t\td = *(ci->data + k);\n\t\t\t\t\tm = *(ci->mask + k);\n\t\t\t\t\tif (d == ' ' && m == ' ') {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (m != ' ' && d == ' ') {\n\t\t\t\t\t\tbw = black;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbw = white;\n\t\t\t\t\t}\n\t\t\t\t\tif (ci->reverse) {\n\t\t\t\t\t\tif (bw == black) {\n\t\t\t\t\t\t\tbw = white;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbw = black;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*(rfb_curs->richSource+k) =\n\t\t\t\t\t    (unsigned char) bw;\n\t\t\t\t\tk++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tci->rfb = rfb_curs;\n\t}\n\tif (screen) {\n\t\tUNLOCK(screen->cursorMutex);\n\t}\n\tif (verbose) {\n\t\trfbLog(\"  done.\\n\");\n\t}\n\trfbLog(\"\\n\");\n}"
  },
  {
    "function_name": "first_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "576-589",
    "snippet": "void first_cursor(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (! show_cursor) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t\tUNLOCK(screen->cursorMutex);\n\t} else {\n\t\tgot_xfixes_cursor_notify++;\n\t\tset_rfb_cursor(get_which_cursor());\n\t\tset_cursor_was_changed(screen);\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int got_xfixes_cursor_notify = 0;",
      "void first_cursor(void);",
      "int get_which_cursor(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cursor_was_changed",
          "args": [
            "screen"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "set_cursor_was_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1642-1656",
          "snippet": "static void set_cursor_was_changed(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\tLOCK(screen->cursorMutex);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasChanged = TRUE;\n\t}\n\tUNLOCK(screen->cursorMutex);\n\trfbReleaseClientIterator(iter);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int known_cursors_mode(char *s);",
            "void restore_cursor_shape_updates(rfbScreenInfoPtr s);",
            "void disable_cursor_shape_updates(rfbScreenInfoPtr s);",
            "int cursor_shape_updates_clients(rfbScreenInfoPtr s);",
            "int cursor_pos_updates_clients(rfbScreenInfoPtr s);",
            "void save_under_cursor_buffer(rfbClientPtr cl);",
            "void draw_cursor(rfbClientPtr cl);",
            "void restore_under_cursor_buffer(rfbClientPtr cl);",
            "static void set_cursor_was_changed(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint known_cursors_mode(char *s);\nvoid restore_cursor_shape_updates(rfbScreenInfoPtr s);\nvoid disable_cursor_shape_updates(rfbScreenInfoPtr s);\nint cursor_shape_updates_clients(rfbScreenInfoPtr s);\nint cursor_pos_updates_clients(rfbScreenInfoPtr s);\nvoid save_under_cursor_buffer(rfbClientPtr cl);\nvoid draw_cursor(rfbClientPtr cl);\nvoid restore_under_cursor_buffer(rfbClientPtr cl);\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s);\n\nstatic void set_cursor_was_changed(rfbScreenInfoPtr s) {\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl;\n\n\tif (! s) {\n\t\treturn;\n\t}\n\titer = rfbGetClientIterator(s);\n\tLOCK(screen->cursorMutex);\n\twhile( (cl = rfbClientIteratorNext(iter)) ) {\n\t\tcl->cursorWasChanged = TRUE;\n\t}\n\tUNLOCK(screen->cursorMutex);\n\trfbReleaseClientIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rfb_cursor",
          "args": [
            "get_which_cursor()"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "set_rfb_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1938-1953",
          "snippet": "static void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int set_cursor(int x, int y, int which);",
            "static void set_rfb_cursor(int which);",
            "static cursor_info_t *cursors[CURS_MAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint set_cursor(int x, int y, int which);\nstatic void set_rfb_cursor(int which);\nstatic cursor_info_t *cursors[CURS_MAX];\n\nstatic void set_rfb_cursor(int which) {\n\n\tif (! show_cursor) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\treturn;\n\t}\n\t\n\tif (!cursors[which] || !cursors[which]->rfb) {\n\t\trfbLog(\"non-existent cursor: which=%d\\n\", which);\n\t\treturn;\n\t} else {\n\t\trfbSetCursor(screen, cursors[which]->rfb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_which_cursor",
          "args": [],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "get_which_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "1512-1640",
          "snippet": "int get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int use_xfixes = 1;",
            "int get_which_cursor(void);",
            "int set_cursor(int x, int y, int which);",
            "unsigned long get_cursor_serial(int mode);",
            "static void set_rfb_cursor(int which);",
            "static void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint use_xfixes = 1;\nint get_which_cursor(void);\nint set_cursor(int x, int y, int which);\nunsigned long get_cursor_serial(int mode);\nstatic void set_rfb_cursor(int which);\nstatic void tree_descend_cursor(int *depth, Window *w, win_str_info_t *winfo);\n\nint get_which_cursor(void) {\n\tint which = CURS_ARROW;\n\tint db = 0;\n\n\tif (show_multiple_cursors) {\n\t\tint depth = 0, rint;\n\t\tstatic win_str_info_t winfo;\n\t\tstatic int first = 1, depth_cutoff = -1;\n\t\tWindow win = None;\n\t\tXErrorHandler old_handler;\n\t\tint mode = 0;\n\n\t\tif (drag_in_progress || button_mask) {\n\t\t\t/* XXX not exactly what we want for menus */\n\t\t\tif (! cursor_drag_changes) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(multiple_cursors_mode, \"arrow\")) {\n\t\t\t/* should not happen... */\n\t\t\treturn CURS_ARROW;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"default\")) {\n\t\t\tmode = 0;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"X\")) {\n\t\t\tmode = 1;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"some\")) {\n\t\t\tmode = 2;\n\t\t} else if (!strcmp(multiple_cursors_mode, \"most\")) {\n\t\t\tmode = 3;\n\t\t}\n\n\t\tif (rawfb_vnc_reflect && mode > -1) {\n\t\t\trint = get_exact_cursor(0);\n\t\t\treturn rint;\n\t\t}\n\t\tif (mode == 3) {\n\t\t\tif ((xfixes_present && use_xfixes) || macosx_console) {\n\t\t\t\tif (db) fprintf(stderr, \"get_which_cursor call get_exact_cursor\\n\");\n\t\t\t\trint = get_exact_cursor(0);\n\t\t\t\treturn rint;\n\t\t\t}\n\t\t}\n\n\t\tif (depth_cutoff < 0) {\n\t\t\tint din;\n\t\t\tif (sscanf(multiple_cursors_mode, \"X%d\", &din) == 1) {\n\t\t\t\tdepth_cutoff = din;\n\t\t\t} else {\n\t\t\t\tdepth_cutoff = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (first) {\n\t\t\twinfo.wm_name   = (char *) malloc(1024);\n\t\t\twinfo.res_name  = (char *) malloc(1024);\n\t\t\twinfo.res_class = (char *) malloc(1024);\n\t\t}\n\t\tfirst = 0;\n\t\t\n\t\tX_LOCK;\n\t\ttree_descend_cursor(&depth, &win, &winfo);\n\t\tX_UNLOCK;\n\n\t\tif (depth <= depth_cutoff && !subwin) {\n\t\t\twhich = CURS_ROOT;\n\n\t\t} else if (mode == 2 || mode == 3) {\n\t\t\tint which0 = which;\n\n\t\t\t/* apply crude heuristics to choose a cursor... */\n\t\t\tif (win && dpy) {\n\t\t\t\tint ratio = 10, x, y;\n\t\t\t\tunsigned int w, h, bw, d;  \n\t\t\t\tWindow r;\n\n#if !NO_X11\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tX_LOCK;\n\t\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t\t\t/* \"narrow\" windows are WM */\n\t\t\t\tif (XGetGeometry(dpy, win, &r, &x, &y, &w, &h,\n\t\t\t\t    &bw, &d)) {\n\t\t\t\t\tif (w > ratio * h || h > ratio * w) {\n\t\t\t\t\t\twhich = CURS_WM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\tX_UNLOCK;\n\t\t\t\ttrapped_xerror = 0;\n#else\n\t\t\t\tif (!r || !d || !bw || !h || !w || !y || !x || !ratio || !old_handler) {}\n#endif\t/* NO_X11 */\n\t\t\t}\n\t\t\tif (which == which0) {\n\t\t\t\t/* the string \"term\" means I-beam. */\n\t\t\t\tchar *name, *class;\n\t\t\t\tlowercase(winfo.res_name);\n\t\t\t\tlowercase(winfo.res_class);\n\t\t\t\tname  = winfo.res_name;\n\t\t\t\tclass = winfo.res_class;\n\t\t\t\tif (strstr(name, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"term\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"text\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"onsole\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"cmdtool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(name,  \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t} else if (strstr(class, \"shelltool\")) {\n\t\t\t\t\twhich = CURS_TERM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (db) fprintf(stderr, \"get_which_cursor which: %d\\n\", which);\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UNLOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "screen->cursorMutex"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint got_xfixes_cursor_notify = 0;\nvoid first_cursor(void);\nint get_which_cursor(void);\n\nvoid first_cursor(void) {\n\tif (! screen) {\n\t\treturn;\n\t}\n\tif (! show_cursor) {\n\t\tLOCK(screen->cursorMutex);\n\t\tscreen->cursor = NULL;\n\t\tUNLOCK(screen->cursorMutex);\n\t} else {\n\t\tgot_xfixes_cursor_notify++;\n\t\tset_rfb_cursor(get_which_cursor());\n\t\tset_cursor_was_changed(screen);\n\t}\n}"
  },
  {
    "function_name": "curs_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
    "lines": "106-136",
    "snippet": "static void curs_copy(cursor_info_t *dest, cursor_info_t *src) {\n\tif (src->data != NULL) {\n\t\tdest->data = strdup(src->data);\n\t} else {\n\t\tdest->data = NULL;\n\t}\n\tif (src->mask != NULL) {\n\t\tdest->mask = strdup(src->mask);\n\t} else {\n\t\tdest->mask = NULL;\n\t}\n\tdest->wx = src->wx;\n\tdest->wy = src->wy;\n\tdest->sx = src->sx;\n\tdest->sy = src->sy;\n\tdest->reverse = src->reverse;\n\tdest->rfb = src->rfb;\n\n\tif (rotating && rotating_cursors && dest->data != NULL) {\n\t\tint tx, ty;\n\t\trotate_curs(dest->data, src->data, src->wx, src->wy, 1);\n\t\trotate_curs(dest->mask, src->mask, src->wx, src->wy, 1);\n\t\trotate_coords(dest->sx, dest->sy, &tx, &ty, src->wx, src->wy);\n\t\tdest->sx = tx;\n\t\tdest->sy = ty;\n\t\tif (! rotating_same) {\n\t\t\tdest->wx = src->wy;\n\t\t\tdest->wy = src->wx;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xi2_devices.h\"",
      "#include \"macosx.h\"",
      "#include \"unixpw.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void curs_copy(cursor_info_t *dest, cursor_info_t *src);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotate_coords",
          "args": [
            "dest->sx",
            "dest->sy",
            "&tx",
            "&ty",
            "src->wx",
            "src->wy"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_coords_inverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1388-1434",
          "snippet": "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);",
            "void rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid rotate_coords(int x, int y, int *xo, int *yo, int dxi, int dyi);\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi);\n\nvoid rotate_coords_inverse(int x, int y, int *xo, int *yo, int dxi, int dyi) {\n\tint xi = x, yi = y;\n\n\tint Dx, Dy;\n\n\tif (dxi >= 0) {\n\t\tDx = dxi;\n\t\tDy = dyi;\n\t} else if (scaling) {\n\t\tDx = scaled_x;\n\t\tDy = scaled_y;\n\t} else {\n\t\tDx = dpy_x;\n\t\tDy = dpy_y;\n\t}\n\tif (! rotating_same) {\n\t\tint t = Dx;\n\t\tDx = Dy;\n\t\tDy = t;\n\t}\n\n\tif (rotating == ROTATE_NONE) {\n\t\t*xo = xi;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_X) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = yi;\n\t} else if (rotating == ROTATE_Y) {\n\t\t*xo = xi;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_XY) {\n\t\t*xo = Dx - xi - 1;\n\t\t*yo = Dy - yi - 1;\n\t} else if (rotating == ROTATE_90) {\n\t\t*xo = yi;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_90X) {\n\t\t*xo = yi;\n\t\t*yo = xi;\n\t} else if (rotating == ROTATE_90Y) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = Dx - xi - 1;\n\t} else if (rotating == ROTATE_270) {\n\t\t*xo = Dy - yi - 1;\n\t\t*yo = xi;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rotate_curs",
          "args": [
            "dest->mask",
            "src->mask",
            "src->wx",
            "src->wy",
            "1"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "rotate_curs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1540-1614",
          "snippet": "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}"
          ],
          "globals_used": [
            "void rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\n#define ROT_COPY \\\n\tsrc = src_0 + fbl*y  + Bpp*x;  \\\n\tdst = dst_0 + rbl*yn + Bpp*xn; \\\n\tif (Bpp == 1) { \\\n\t\t*(dst) = *(src);\t \\\n\t} else if (Bpp == 2) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t} else if (Bpp == 3) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t} else if (Bpp == 4) { \\\n\t\t*(dst+0) = *(src+0);\t \\\n\t\t*(dst+1) = *(src+1);\t \\\n\t\t*(dst+2) = *(src+2);\t \\\n\t\t*(dst+3) = *(src+3);\t \\\n\t}\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp);\n\nvoid rotate_curs(char *dst_0, char *src_0, int Dx, int Dy, int Bpp) {\n\tint x, y, xn, yn;\n\tchar *src, *dst;\n\tint fbl, rbl;\n\n\tif (! rotating) {\n\t\treturn;\n\t}\n\n\tfbl = Dx * Bpp;\n\tif (rotating_same) {\n\t\trbl = Dx * Bpp;\n\t} else {\n\t\trbl = Dy * Bpp;\n\t}\n\n\tif (rotating == ROTATE_X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = y;\n\t\t\t\tROT_COPY\nif (0) fprintf(stderr, \"rcurs: %d %d  %d %d\\n\", x, y, xn, yn);\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = x;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_XY) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dx - x - 1;\n\t\t\t\tyn = Dy - y - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90X) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = x;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_90Y) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = Dy - y - 1;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t} else if (rotating == ROTATE_270) {\n\t\tfor (y = 0; y < Dy; y++)  {\n\t\t\tfor (x = 0; x < Dx; x++)  {\n\t\t\t\txn = y;\n\t\t\t\tyn = Dx - x - 1;\n\t\t\t\tROT_COPY\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "src->mask"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "src->data"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src);\n\nstatic void curs_copy(cursor_info_t *dest, cursor_info_t *src) {\n\tif (src->data != NULL) {\n\t\tdest->data = strdup(src->data);\n\t} else {\n\t\tdest->data = NULL;\n\t}\n\tif (src->mask != NULL) {\n\t\tdest->mask = strdup(src->mask);\n\t} else {\n\t\tdest->mask = NULL;\n\t}\n\tdest->wx = src->wx;\n\tdest->wy = src->wy;\n\tdest->sx = src->sx;\n\tdest->sy = src->sy;\n\tdest->reverse = src->reverse;\n\tdest->rfb = src->rfb;\n\n\tif (rotating && rotating_cursors && dest->data != NULL) {\n\t\tint tx, ty;\n\t\trotate_curs(dest->data, src->data, src->wx, src->wy, 1);\n\t\trotate_curs(dest->mask, src->mask, src->wx, src->wy, 1);\n\t\trotate_coords(dest->sx, dest->sy, &tx, &ty, src->wx, src->wy);\n\t\tdest->sx = tx;\n\t\tdest->sy = ty;\n\t\tif (! rotating_same) {\n\t\t\tdest->wx = src->wy;\n\t\t\tdest->wy = src->wx;\n\t\t}\n\t}\n}"
  }
]