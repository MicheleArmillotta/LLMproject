[
  {
    "function_name": "get_file_transfer_permitted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "2151-2173",
    "snippet": "int get_file_transfer_permitted(rfbClientPtr cl) {\n\tallowed_input_t input;\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"get_file_transfer_permitted: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn FALSE;\n\t}\nif (0) fprintf(stderr, \"get_file_transfer_permitted called\\n\");\n\tif (view_only) {\n\t\treturn FALSE;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn FALSE;\n\t}\n\tget_allowed_input(cl, &input);\n\tif (!input.files) {\n\t\treturn FALSE;\n\t}\n\tif (screen->permitFileTransfer) {\n\t\tsaw_ultra_file = 1;\n\t}\n\treturn screen->permitFileTransfer;\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xcut_receive(char *text, int len, rfbClientPtr cl);",
      "void kbd_release_all_keys(rfbClientPtr cl);",
      "int get_file_transfer_permitted(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_allowed_input",
          "args": [
            "cl",
            "&input"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "get_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2791-2847",
          "snippet": "void get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\n\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_file_transfer_permitted called\\n\""
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "cl"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_file_transfer_permitted: unixpw_in_progress, dropping client.\\n\""
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl);\nvoid kbd_release_all_keys(rfbClientPtr cl);\nint get_file_transfer_permitted(rfbClientPtr cl);\n\nint get_file_transfer_permitted(rfbClientPtr cl) {\n\tallowed_input_t input;\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"get_file_transfer_permitted: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn FALSE;\n\t}\nif (0) fprintf(stderr, \"get_file_transfer_permitted called\\n\");\n\tif (view_only) {\n\t\treturn FALSE;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn FALSE;\n\t}\n\tget_allowed_input(cl, &input);\n\tif (!input.files) {\n\t\treturn FALSE;\n\t}\n\tif (screen->permitFileTransfer) {\n\t\tsaw_ultra_file = 1;\n\t}\n\treturn screen->permitFileTransfer;\n}"
  },
  {
    "function_name": "get_keyboard_led_state_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "2143-2150",
    "snippet": "int get_keyboard_led_state_hook(rfbScreenInfoPtr s) {\n\tif (s) {}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"get_keyboard_led_state_hook: unixpw_in_progress, skipping.\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_keyboard_led_state_hook: unixpw_in_progress, skipping.\\n\""
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\n\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s) {\n\tif (s) {}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"get_keyboard_led_state_hook: unixpw_in_progress, skipping.\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_text_chat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "2083-2141",
    "snippet": "void set_text_chat(rfbClientPtr cl, int len, char *txt) {\n\tint dochat = 1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl2;\n\tunsigned int ulen = (unsigned int) len;\n\n\tif (no_ultra_ext || ! dochat) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_text_chat: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAS_TEXTCHAT\n\n\tif (chat_window && chat_window_client == NULL && ulen == rfbTextChatOpen) {\n\t\ttry_local_chat_window();\n\t}\n\n\tsaw_ultra_chat = 1;\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl2 = rfbClientIteratorNext(iter)) ) {\n\t\tunsigned int ulen = (unsigned int) len;\n\t\tif (cl2 == cl) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl2->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tSEND_LOCK(cl2);\n\n\t\tif (ulen == rfbTextChatOpen) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatOpen, \"\");\n\t\t} else if (ulen == rfbTextChatClose) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatClose, \"\");\n\t\t\t/* not clear what is going on WRT close and finished... */\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (ulen == rfbTextChatFinished) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (len <= rfbTextMaxSize) {\n\t\t\trfbSendTextChatMessage(cl2, len, txt);\n\t\t}\n\n\t\tSEND_UNLOCK(cl2);\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (ulen == rfbTextChatClose && cl != NULL) {\n\t\t/* not clear what is going on WRT close and finished... */\n\t\tSEND_LOCK(cl);\n\t\trfbSendTextChatMessage(cl, rfbTextChatFinished, \"\");\n\t\tSEND_UNLOCK(cl);\n\t}\n#endif\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xcut_receive(char *text, int len, rfbClientPtr cl);",
      "void kbd_release_all_keys(rfbClientPtr cl);",
      "int get_file_transfer_permitted(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEND_UNLOCK",
          "args": [
            "cl"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendTextChatMessage",
          "args": [
            "cl",
            "rfbTextChatFinished",
            "\"\""
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEND_LOCK",
          "args": [
            "cl"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbReleaseClientIterator",
          "args": [
            "iter"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEND_UNLOCK",
          "args": [
            "cl2"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendTextChatMessage",
          "args": [
            "cl2",
            "len",
            "txt"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendTextChatMessage",
          "args": [
            "cl2",
            "rfbTextChatFinished",
            "\"\""
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendTextChatMessage",
          "args": [
            "cl2",
            "rfbTextChatFinished",
            "\"\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendTextChatMessage",
          "args": [
            "cl2",
            "rfbTextChatClose",
            "\"\""
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbSendTextChatMessage",
          "args": [
            "cl2",
            "rfbTextChatOpen",
            "\"\""
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEND_LOCK",
          "args": [
            "cl2"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientIteratorNext",
          "args": [
            "iter"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbGetClientIterator",
          "args": [
            "screen"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_local_chat_window",
          "args": [],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "try_local_chat_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1972-2081",
          "snippet": "static void try_local_chat_window(void) {\n\tint i, port, lsock;\n\tchar cmd[100];\n\tstruct sockaddr_in addr;\n\tpid_t pid = -1;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tfor (i = 0; i < 90; i++)  {\n\t\t/* find an open port */\n\t\tport = 7300 + i;\n\t\t/* XXX ::1 fallback */\n\t\tlsock = listen_tcp(port, htonl(INADDR_LOOPBACK), 0);\n\t\tif (lsock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tport = 0;\n\t}\n\n\tif (port == 0) {\n\t\treturn;\n\t}\n\n\t/* have ssvncvncviewer connect back to us (n.b. sockpair fails) */\n\n\tsprintf(cmd, \"ssvnc -cmd VNC://localhost:%d -chatonly\", port);\n\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n#endif\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t} else if (pid == 0) {\n\t\tchar *args[4];\n\t\tint d;\n\t\targs[0] = \"/bin/sh\";\n\t\targs[1] = \"-c\";\n\t\t/* \"ssvnc -cmd VNC://fd=0 -chatonly\"; not working */\n\t\targs[2] = cmd;\n\t\targs[3] = NULL;\n\n\t\tset_env(\"VNCVIEWER_PASSWORD\", \"moo\");\n#if !NO_X11\n\t\tif (dpy != NULL) {\n\t\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t\t}\n#endif\n\t\tfor (d = 3; d < 256; d++) {\n\t\t\tclose(d);\n\t\t}\n\n\t\texecvp(args[0], args);\n\t\tperror(\"exec\");\n\t\texit(1);\n\t} else {\n\t\tint i, sock = -1;\n\t\trfbNewClientHookPtr new_save;\n\n\t\tsignal(SIGALRM, wsock_timeout);\n\t\twsock_timeout_sock = lsock;\n\t\t\n\t\talarm(10);\n\t\tsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tsignal(SIGALRM, SIG_DFL);\n\t\tclose(lsock);\n\n\t\tif (sock < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* mutex */\n\t\tnew_save = screen->newClientHook;\n\t\tscreen->newClientHook = new_client_chat_helper;\n\n\t\tchat_window_client = create_new_client(sock, 1);\n\n\t\tscreen->newClientHook = new_save;\n\n\t\tif (chat_window_client != NULL) {\n\t\t\trfbPasswordCheckProcPtr pwchk_save = screen->passwordCheck;\n\t\t\trfbBool save_shared1 = screen->alwaysShared;\n\t\t\trfbBool save_shared2 = screen->neverShared;\n\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared  = FALSE;\n\n\t\t\tscreen->passwordCheck = password_check_chat_helper;\n\t\t\tfor (i=0; i<30; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t\tif (!chat_window_client) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chat_window_client->state == RFB_NORMAL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscreen->passwordCheck = pwchk_save;\n\t\t\tscreen->alwaysShared  = save_shared1;\n\t\t\tscreen->neverShared   = save_shared2;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void try_local_chat_window(void) {\n\tint i, port, lsock;\n\tchar cmd[100];\n\tstruct sockaddr_in addr;\n\tpid_t pid = -1;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tfor (i = 0; i < 90; i++)  {\n\t\t/* find an open port */\n\t\tport = 7300 + i;\n\t\t/* XXX ::1 fallback */\n\t\tlsock = listen_tcp(port, htonl(INADDR_LOOPBACK), 0);\n\t\tif (lsock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tport = 0;\n\t}\n\n\tif (port == 0) {\n\t\treturn;\n\t}\n\n\t/* have ssvncvncviewer connect back to us (n.b. sockpair fails) */\n\n\tsprintf(cmd, \"ssvnc -cmd VNC://localhost:%d -chatonly\", port);\n\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n#endif\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t} else if (pid == 0) {\n\t\tchar *args[4];\n\t\tint d;\n\t\targs[0] = \"/bin/sh\";\n\t\targs[1] = \"-c\";\n\t\t/* \"ssvnc -cmd VNC://fd=0 -chatonly\"; not working */\n\t\targs[2] = cmd;\n\t\targs[3] = NULL;\n\n\t\tset_env(\"VNCVIEWER_PASSWORD\", \"moo\");\n#if !NO_X11\n\t\tif (dpy != NULL) {\n\t\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t\t}\n#endif\n\t\tfor (d = 3; d < 256; d++) {\n\t\t\tclose(d);\n\t\t}\n\n\t\texecvp(args[0], args);\n\t\tperror(\"exec\");\n\t\texit(1);\n\t} else {\n\t\tint i, sock = -1;\n\t\trfbNewClientHookPtr new_save;\n\n\t\tsignal(SIGALRM, wsock_timeout);\n\t\twsock_timeout_sock = lsock;\n\t\t\n\t\talarm(10);\n\t\tsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tsignal(SIGALRM, SIG_DFL);\n\t\tclose(lsock);\n\n\t\tif (sock < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* mutex */\n\t\tnew_save = screen->newClientHook;\n\t\tscreen->newClientHook = new_client_chat_helper;\n\n\t\tchat_window_client = create_new_client(sock, 1);\n\n\t\tscreen->newClientHook = new_save;\n\n\t\tif (chat_window_client != NULL) {\n\t\t\trfbPasswordCheckProcPtr pwchk_save = screen->passwordCheck;\n\t\t\trfbBool save_shared1 = screen->alwaysShared;\n\t\t\trfbBool save_shared2 = screen->neverShared;\n\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared  = FALSE;\n\n\t\t\tscreen->passwordCheck = password_check_chat_helper;\n\t\t\tfor (i=0; i<30; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t\tif (!chat_window_client) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chat_window_client->state == RFB_NORMAL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscreen->passwordCheck = pwchk_save;\n\t\t\tscreen->alwaysShared  = save_shared1;\n\t\t\tscreen->neverShared   = save_shared2;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "cl"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_text_chat: unixpw_in_progress, dropping client.\\n\""
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl);\nvoid kbd_release_all_keys(rfbClientPtr cl);\nint get_file_transfer_permitted(rfbClientPtr cl);\n\nvoid set_text_chat(rfbClientPtr cl, int len, char *txt) {\n\tint dochat = 1;\n\trfbClientIteratorPtr iter;\n\trfbClientPtr cl2;\n\tunsigned int ulen = (unsigned int) len;\n\n\tif (no_ultra_ext || ! dochat) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_text_chat: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n#if LIBVNCSERVER_HAS_TEXTCHAT\n\n\tif (chat_window && chat_window_client == NULL && ulen == rfbTextChatOpen) {\n\t\ttry_local_chat_window();\n\t}\n\n\tsaw_ultra_chat = 1;\n\n\titer = rfbGetClientIterator(screen);\n\twhile( (cl2 = rfbClientIteratorNext(iter)) ) {\n\t\tunsigned int ulen = (unsigned int) len;\n\t\tif (cl2 == cl) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (cl2->state != RFB_NORMAL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tSEND_LOCK(cl2);\n\n\t\tif (ulen == rfbTextChatOpen) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatOpen, \"\");\n\t\t} else if (ulen == rfbTextChatClose) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatClose, \"\");\n\t\t\t/* not clear what is going on WRT close and finished... */\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (ulen == rfbTextChatFinished) {\n\t\t\trfbSendTextChatMessage(cl2, rfbTextChatFinished, \"\");\n\t\t} else if (len <= rfbTextMaxSize) {\n\t\t\trfbSendTextChatMessage(cl2, len, txt);\n\t\t}\n\n\t\tSEND_UNLOCK(cl2);\n\t}\n\trfbReleaseClientIterator(iter);\n\n\tif (ulen == rfbTextChatClose && cl != NULL) {\n\t\t/* not clear what is going on WRT close and finished... */\n\t\tSEND_LOCK(cl);\n\t\trfbSendTextChatMessage(cl, rfbTextChatFinished, \"\");\n\t\tSEND_UNLOCK(cl);\n\t}\n#endif\n}"
  },
  {
    "function_name": "try_local_chat_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1972-2081",
    "snippet": "static void try_local_chat_window(void) {\n\tint i, port, lsock;\n\tchar cmd[100];\n\tstruct sockaddr_in addr;\n\tpid_t pid = -1;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tfor (i = 0; i < 90; i++)  {\n\t\t/* find an open port */\n\t\tport = 7300 + i;\n\t\t/* XXX ::1 fallback */\n\t\tlsock = listen_tcp(port, htonl(INADDR_LOOPBACK), 0);\n\t\tif (lsock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tport = 0;\n\t}\n\n\tif (port == 0) {\n\t\treturn;\n\t}\n\n\t/* have ssvncvncviewer connect back to us (n.b. sockpair fails) */\n\n\tsprintf(cmd, \"ssvnc -cmd VNC://localhost:%d -chatonly\", port);\n\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n#endif\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t} else if (pid == 0) {\n\t\tchar *args[4];\n\t\tint d;\n\t\targs[0] = \"/bin/sh\";\n\t\targs[1] = \"-c\";\n\t\t/* \"ssvnc -cmd VNC://fd=0 -chatonly\"; not working */\n\t\targs[2] = cmd;\n\t\targs[3] = NULL;\n\n\t\tset_env(\"VNCVIEWER_PASSWORD\", \"moo\");\n#if !NO_X11\n\t\tif (dpy != NULL) {\n\t\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t\t}\n#endif\n\t\tfor (d = 3; d < 256; d++) {\n\t\t\tclose(d);\n\t\t}\n\n\t\texecvp(args[0], args);\n\t\tperror(\"exec\");\n\t\texit(1);\n\t} else {\n\t\tint i, sock = -1;\n\t\trfbNewClientHookPtr new_save;\n\n\t\tsignal(SIGALRM, wsock_timeout);\n\t\twsock_timeout_sock = lsock;\n\t\t\n\t\talarm(10);\n\t\tsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tsignal(SIGALRM, SIG_DFL);\n\t\tclose(lsock);\n\n\t\tif (sock < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* mutex */\n\t\tnew_save = screen->newClientHook;\n\t\tscreen->newClientHook = new_client_chat_helper;\n\n\t\tchat_window_client = create_new_client(sock, 1);\n\n\t\tscreen->newClientHook = new_save;\n\n\t\tif (chat_window_client != NULL) {\n\t\t\trfbPasswordCheckProcPtr pwchk_save = screen->passwordCheck;\n\t\t\trfbBool save_shared1 = screen->alwaysShared;\n\t\t\trfbBool save_shared2 = screen->neverShared;\n\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared  = FALSE;\n\n\t\t\tscreen->passwordCheck = password_check_chat_helper;\n\t\t\tfor (i=0; i<30; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t\tif (!chat_window_client) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chat_window_client->state == RFB_NORMAL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscreen->passwordCheck = pwchk_save;\n\t\t\tscreen->alwaysShared  = save_shared1;\n\t\t\tscreen->neverShared   = save_shared2;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsock_timeout_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_client",
          "args": [
            "sock",
            "1"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3826-3845",
          "snippet": "rfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "rfbClientPtr create_new_client(int sock, int start_thread);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nrfbClientPtr create_new_client(int sock, int start_thread);\n\nrfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lsock"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "lsock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "wsock_timeout"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"exec\""
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "args[0]",
            "args"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"DISPLAY\"",
            "DisplayString(dpy)"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"fork\""
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"ssvnc -cmd VNC://localhost:%d -chatonly\"",
            "port"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen_tcp",
          "args": [
            "port",
            "htonl(INADDR_LOOPBACK)",
            "0"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "listen_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "895-938",
          "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);",
            "int listen_tcp(int port, in_addr_t iface, int try6);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void try_local_chat_window(void) {\n\tint i, port, lsock;\n\tchar cmd[100];\n\tstruct sockaddr_in addr;\n\tpid_t pid = -1;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\n\tfor (i = 0; i < 90; i++)  {\n\t\t/* find an open port */\n\t\tport = 7300 + i;\n\t\t/* XXX ::1 fallback */\n\t\tlsock = listen_tcp(port, htonl(INADDR_LOOPBACK), 0);\n\t\tif (lsock >= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tport = 0;\n\t}\n\n\tif (port == 0) {\n\t\treturn;\n\t}\n\n\t/* have ssvncvncviewer connect back to us (n.b. sockpair fails) */\n\n\tsprintf(cmd, \"ssvnc -cmd VNC://localhost:%d -chatonly\", port);\n\n#if LIBVNCSERVER_HAVE_FORK\n\tpid = fork();\n#endif\n\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\treturn;\n\t} else if (pid == 0) {\n\t\tchar *args[4];\n\t\tint d;\n\t\targs[0] = \"/bin/sh\";\n\t\targs[1] = \"-c\";\n\t\t/* \"ssvnc -cmd VNC://fd=0 -chatonly\"; not working */\n\t\targs[2] = cmd;\n\t\targs[3] = NULL;\n\n\t\tset_env(\"VNCVIEWER_PASSWORD\", \"moo\");\n#if !NO_X11\n\t\tif (dpy != NULL) {\n\t\t\tset_env(\"DISPLAY\", DisplayString(dpy));\n\t\t}\n#endif\n\t\tfor (d = 3; d < 256; d++) {\n\t\t\tclose(d);\n\t\t}\n\n\t\texecvp(args[0], args);\n\t\tperror(\"exec\");\n\t\texit(1);\n\t} else {\n\t\tint i, sock = -1;\n\t\trfbNewClientHookPtr new_save;\n\n\t\tsignal(SIGALRM, wsock_timeout);\n\t\twsock_timeout_sock = lsock;\n\t\t\n\t\talarm(10);\n\t\tsock = accept(lsock, (struct sockaddr *)&addr, &addrlen);\n\t\talarm(0);\n\n\t\tsignal(SIGALRM, SIG_DFL);\n\t\tclose(lsock);\n\n\t\tif (sock < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* mutex */\n\t\tnew_save = screen->newClientHook;\n\t\tscreen->newClientHook = new_client_chat_helper;\n\n\t\tchat_window_client = create_new_client(sock, 1);\n\n\t\tscreen->newClientHook = new_save;\n\n\t\tif (chat_window_client != NULL) {\n\t\t\trfbPasswordCheckProcPtr pwchk_save = screen->passwordCheck;\n\t\t\trfbBool save_shared1 = screen->alwaysShared;\n\t\t\trfbBool save_shared2 = screen->neverShared;\n\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared  = FALSE;\n\n\t\t\tscreen->passwordCheck = password_check_chat_helper;\n\t\t\tfor (i=0; i<30; i++) {\n\t\t\t\trfbPE(-1);\n\t\t\t\tif (!chat_window_client) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chat_window_client->state == RFB_NORMAL) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscreen->passwordCheck = pwchk_save;\n\t\t\tscreen->alwaysShared  = save_shared1;\n\t\t\tscreen->neverShared   = save_shared2;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "wsock_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1964-1970",
    "snippet": "static void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsock_timeout_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "wsock_timeout_sock"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sig: %d, wsock_timeout.\\n\"",
            "sig"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}"
  },
  {
    "function_name": "set_server_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1923-1960",
    "snippet": "void set_server_input(rfbClientPtr cl, int grab) {\n\tif (no_ultra_ext) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_server_input: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\tif (grab) {\n\t\tif (!no_ultra_dpms) {\n\t\t\tset_dpms_mode(\"enable\");\n\t\t\tset_dpms_mode(\"off\");\n\t\t\tforce_dpms = 1;\n\t\t}\n\n\t\tprocess_remote_cmd(\"cmd=grabkbd\", 0);\n\t\tprocess_remote_cmd(\"cmd=grabptr\", 0);\n\n\t} else {\n\t\tprocess_remote_cmd(\"cmd=nograbkbd\", 0);\n\t\tprocess_remote_cmd(\"cmd=nograbptr\", 0);\n\n\t\tif (!no_ultra_dpms) {\n\t\t\tforce_dpms = 0;\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xcut_receive(char *text, int len, rfbClientPtr cl);",
      "void kbd_release_all_keys(rfbClientPtr cl);",
      "int get_file_transfer_permitted(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_remote_cmd",
          "args": [
            "\"cmd=nograbptr\"",
            "0"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "process_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "843-6324",
          "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}",
            "#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}"
          ],
          "globals_used": [
            "int send_remote_cmd(char *cmd, int query, int wait);",
            "void check_black_fb(void);",
            "int check_httpdir(void);",
            "void http_connections(int on);",
            "int remote_control_access_ok(void);",
            "char *process_remote_cmd(char *cmd, int stringonly);",
            "static void if_8bpp_do_new_fb(void);",
            "int rc_npieces = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\nint send_remote_cmd(char *cmd, int query, int wait);\nvoid check_black_fb(void);\nint check_httpdir(void);\nvoid http_connections(int on);\nint remote_control_access_ok(void);\nchar *process_remote_cmd(char *cmd, int stringonly);\nstatic void if_8bpp_do_new_fb(void);\nint rc_npieces = 0;\n\nchar *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_dpms_mode",
          "args": [
            "\"off\""
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "set_dpms_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pm.c",
          "lines": "150-205",
          "snippet": "void set_dpms_mode(char *mode) {\n#if NO_X11\n\treturn;\n#else\n\tRAWFB_RET_VOID\n#if HAVE_DPMS\n\tif (dpy && DPMSCapable(dpy)) {\n\t\tCARD16 level;\n\t\tCARD16 want;\n\t\tBOOL enabled;\n\t\tif (!strcmp(mode, \"off\")) {\n\t\t\twant = DPMSModeOff;\n\t\t} else if (!strcmp(mode, \"on\")) {\n\t\t\twant = DPMSModeOn;\n\t\t} else if (!strcmp(mode, \"standby\")) {\n\t\t\twant = DPMSModeStandby;\n\t\t} else if (!strcmp(mode, \"suspend\")) {\n\t\t\twant = DPMSModeSuspend;\n\t\t} else if (!strcmp(mode, \"enable\")) {\n\t\t\tDPMSEnable(dpy);\n\t\t\treturn;\n\t\t} else if (!strcmp(mode, \"disable\")) {\n\t\t\tDPMSDisable(dpy);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\t\tchar *from = \"unk\";\n\t\t\tif (enabled && level != want) {\n\t\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\t\ttrapped_xerror = 0;\n\n\t\t\t\trfbLog(\"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\t\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t\t} else if (level == DPMSModeOn) {\n\t\t\t\t\tfrom = \"DPMSModeOn\";\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"switching DPMS state from %s to %s\\n\", from, mode);\n\t\t\t\t\n\t\t\t\tDPMSForceLevel(dpy, want);\n\t\t\t\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n#endif\n}",
          "includes": [
            "#include <X11/extensions/dpms.h>",
            "#include <X11/extensions/fbpm.h>",
            "#include <X11/Xmd.h>",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_dpms_mode(char *mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/dpms.h>\n#include <X11/extensions/fbpm.h>\n#include <X11/Xmd.h>\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid set_dpms_mode(char *mode);\n\nvoid set_dpms_mode(char *mode) {\n#if NO_X11\n\treturn;\n#else\n\tRAWFB_RET_VOID\n#if HAVE_DPMS\n\tif (dpy && DPMSCapable(dpy)) {\n\t\tCARD16 level;\n\t\tCARD16 want;\n\t\tBOOL enabled;\n\t\tif (!strcmp(mode, \"off\")) {\n\t\t\twant = DPMSModeOff;\n\t\t} else if (!strcmp(mode, \"on\")) {\n\t\t\twant = DPMSModeOn;\n\t\t} else if (!strcmp(mode, \"standby\")) {\n\t\t\twant = DPMSModeStandby;\n\t\t} else if (!strcmp(mode, \"suspend\")) {\n\t\t\twant = DPMSModeSuspend;\n\t\t} else if (!strcmp(mode, \"enable\")) {\n\t\t\tDPMSEnable(dpy);\n\t\t\treturn;\n\t\t} else if (!strcmp(mode, \"disable\")) {\n\t\t\tDPMSDisable(dpy);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (DPMSInfo(dpy, &level, &enabled)) {\n\t\t\tchar *from = \"unk\";\n\t\t\tif (enabled && level != want) {\n\t\t\t\tXErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t\t\t\ttrapped_xerror = 0;\n\n\t\t\t\trfbLog(\"DPMSInfo level: %d enabled: %d\\n\", level, enabled);\n\t\t\t\tif (level == DPMSModeStandby) {\n\t\t\t\t\tfrom = \"DPMSModeStandby\";\n\t\t\t\t} else if (level == DPMSModeSuspend) {\n\t\t\t\t\tfrom = \"DPMSModeSuspend\";\n\t\t\t\t} else if (level == DPMSModeOff) {\n\t\t\t\t\tfrom = \"DPMSModeOff\";\n\t\t\t\t} else if (level == DPMSModeOn) {\n\t\t\t\t\tfrom = \"DPMSModeOn\";\n\t\t\t\t}\n\n\t\t\t\trfbLog(\"switching DPMS state from %s to %s\\n\", from, mode);\n\t\t\t\t\n\t\t\t\tDPMSForceLevel(dpy, want);\n\t\t\t\n\t\t\t\tXSetErrorHandler(old_handler);\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "cl"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_server_input: unixpw_in_progress, dropping client.\\n\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl);\nvoid kbd_release_all_keys(rfbClientPtr cl);\nint get_file_transfer_permitted(rfbClientPtr cl);\n\nvoid set_server_input(rfbClientPtr cl, int grab) {\n\tif (no_ultra_ext) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_server_input: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\tif (grab) {\n\t\tif (!no_ultra_dpms) {\n\t\t\tset_dpms_mode(\"enable\");\n\t\t\tset_dpms_mode(\"off\");\n\t\t\tforce_dpms = 1;\n\t\t}\n\n\t\tprocess_remote_cmd(\"cmd=grabkbd\", 0);\n\t\tprocess_remote_cmd(\"cmd=grabptr\", 0);\n\n\t} else {\n\t\tprocess_remote_cmd(\"cmd=nograbkbd\", 0);\n\t\tprocess_remote_cmd(\"cmd=nograbptr\", 0);\n\n\t\tif (!no_ultra_dpms) {\n\t\t\tforce_dpms = 0;\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "set_single_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1875-1922",
    "snippet": "void set_single_window(rfbClientPtr cl, int x, int y) {\n\tint ok = 0;\n\tif (no_ultra_ext) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_single_window: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\tif (x==1 && y==1) {\n\t\tif (subwin) {\n\t\t\tsubwin = 0x0;\n\t\t\tok = 1;\n\t\t}\n\t} else {\n\t\tWindow r, c;\n\t\tint rootx, rooty, wx, wy;\n\t\tunsigned int mask;\n\n\t\tupdate_x11_pointer_position(x, y, cl);\n\t\tXSync(dpy, False);\n\n\t\tif (XQueryPointer_wr(dpy, rootwin, &r, &c, &rootx, &rooty,\n\t\t    &wx, &wy, &mask)) {\n\t\t\tif (c != None) {\n\t\t\t\tsubwin = c;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tcheck_black_fb();\n\t\tdo_new_fb(1);\t\n\t}\n#endif\n\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xcut_receive(char *text, int len, rfbClientPtr cl);",
      "void kbd_release_all_keys(rfbClientPtr cl);",
      "void set_single_window(rfbClientPtr cl, int x, int y);",
      "int get_file_transfer_permitted(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_new_fb",
          "args": [
            "1"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "do_new_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1008-1068",
          "snippet": "void do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_new_fb(int reset_mem);",
            "void free_old_fb(void);",
            "XImage *initialize_xdisplay_fb(void);",
            "int parse_rotate_string(char *str, int *mode);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid do_new_fb(int reset_mem);\nvoid free_old_fb(void);\nXImage *initialize_xdisplay_fb(void);\nint parse_rotate_string(char *str, int *mode);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid do_new_fb(int reset_mem) {\n\tXImage *fb;\n\n\t/* for threaded we really should lock libvncserver out. */\n\tif (use_threads) {\n\t\tint ms = 1000;\n\t\tif (getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\")) {\n\t\t\tms = atoi(getenv(\"X11VNC_THREADS_NEW_FB_SLEEP\"));\n\t\t} else if (subwin) {\n\t\t\tms = 500;\n\t\t} else {\n\t\t\tms = 1000;\n\t\t}\n\t\trfbLog(\"Warning: changing framebuffers in threaded mode may be unstable.\\n\");\n\t\tthreads_drop_input = 1;\n\t\tusleep(ms * 1000);\n\t}\n\n\tINPUT_LOCK;\n\tlock_client_sends(1);\n\n\tif (use_threads) {\n\t\tsettle_clients(1);\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\tif (reset_mem == 1) {\n\t\t/* reset_mem == 2 is a hack for changing users... */\n\t\tclean_shm(0);\n\t\tfree_tiles();\n\t}\n\n\tfree_old_fb();\n\n\tfb = initialize_xdisplay_fb();\n\n\tinitialize_screen(NULL, NULL, fb);\n\n\tif (reset_mem) {\n\t\tinitialize_tiles();\n\t\tinitialize_blackouts_and_xinerama();\n\t\tinitialize_polling_images();\n\t}\n\tif (ncache) {\n\t\tcheck_ncache(1, 0);\n\t}\n\n\tprep_clients_for_new_fb();\n\tlock_client_sends(0);\n\tINPUT_UNLOCK;\n\n\tif (use_threads) {\n\t\t/* need to let things settle... */\n\t\tsettle_clients(0);\n\t\tthreads_drop_input = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_black_fb",
          "args": [],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "check_black_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "337-347",
          "snippet": "void check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_black_fb(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid check_black_fb(void);\n\nvoid check_black_fb(void) {\n\tif (!screen) {\n\t\treturn;\n\t}\n\tif (new_fb_size_clients(screen) != client_count) {\n\t\trfbLog(\"trying to send a black fb for non-newfbsize\"\n\t\t    \" clients %d != %d\\n\", client_count,\n\t\t    new_fb_size_clients(screen));\n\t\tpush_black_screen(4);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryPointer_wr",
          "args": [
            "dpy",
            "rootwin",
            "&r",
            "&c",
            "&rootx",
            "&rooty",
            "&wx",
            "&wy",
            "&mask"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryPointer_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1522-1564",
          "snippet": "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Bool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);",
            "static unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);",
            "static unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);",
            "static unsigned int last_local_button_mask = 0;",
            "static unsigned int last_local_mod_mask = 0;",
            "static int last_local_x = 0;",
            "static int last_local_y = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return);\nstatic unsigned int Bmask = (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);\nstatic unsigned int Mmask = (ShiftMask|LockMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask);\nstatic unsigned int last_local_button_mask = 0;\nstatic unsigned int last_local_mod_mask = 0;\nstatic int last_local_x = 0;\nstatic int last_local_y = 0;\n\nBool XQueryPointer_wr(Display *display, Window w, Window *root_return,\n    Window *child_return, int *root_x_return, int *root_y_return,\n    int *win_x_return, int *win_y_return, unsigned int *mask_return) {\n#if NO_X11\n\tif (!display || !w || !root_return || !child_return || !root_x_return\n\t    || !root_y_return || !win_x_return || !win_y_return || !mask_return) {}\n\treturn False;\n#else\n\tBool rc;\n\tXErrorHandler old_handler;\n\n\n\tif (! display) {\n\t\treturn False;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\trc = XQueryPointer(display, w, root_return, child_return,\n\t    root_x_return, root_y_return, win_x_return, win_y_return,\n\t    mask_return);\n\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\tif (rc) {\n\t\tdisplay_button_mask = (*mask_return) & Bmask;\n\t\tdisplay_mod_mask    = (*mask_return) & Mmask;\n\t\tif (last_local_button_mask != display_button_mask) {\n\t\t\tgot_local_pointer_input++;\n\t\t} else if (*root_x_return != last_local_x ||\n\t\t    *root_y_return != last_local_y) {\n\t\t\tgot_local_pointer_input++;\n\t\t}\n\t\tlast_local_button_mask = display_button_mask;\n\t\tlast_local_mod_mask = display_mod_mask;\n\t\tlast_local_x = *root_x_return;\n\t\tlast_local_y = *root_y_return;\n\t}\n\treturn rc;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_x11_pointer_position",
          "args": [
            "x",
            "y",
            "cl"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "update_x11_pointer_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/pointer.c",
          "lines": "340-387",
          "snippet": "void update_x11_pointer_position(int x, int y, rfbClientPtr client) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!x || !y) {}\n\treturn;\n#else\n\tint rc;\n\n\tint ptr_id = -1;\n\n\tRAWFB_RET_VOID\n\n\tif(client && client->clientData)\n\t  ptr_id = ((ClientData*)client->clientData)->ptr_id;\n\n\tX_LOCK;\n\tif (!always_inject && cursor_x == x && cursor_y == y) {\n\t\t;\n\t} else if (use_xwarppointer) {\n\t\t/*\n\t\t * off_x and off_y not needed with XWarpPointer since\n\t\t * window is used:\n\t\t */\n#ifdef HAVE_XI2\n                if(use_multipointer)\n                  XIWarpPointer_wr(dpy, ptr_id, None, window, 0, 0, 0, 0, x + coff_x, y + coff_y);\n                else\n#endif\n                  XWarpPointer(dpy, None, window, 0, 0, 0, 0, x + coff_x, y + coff_y);\n\t} else {\n\t         XTestFakeMotionEvent_wr(dpy, ptr_id, scr, x + off_x + coff_x, y + off_y + coff_y, CurrentTime);\n\t}\n\tX_UNLOCK;\n\n\tif (cursor_x != x || cursor_y != y) {\n\t\tlast_pointer_motion_time = dnow();\n\t}\n\n\tcursor_x = x;\n\tcursor_y = y;\n\n\t/* change the cursor shape if necessary */\n\trc = set_cursor(x, y, get_which_cursor());\n\tcursor_changes += rc;\n\n\tlast_event = last_input = last_pointer_input = time(NULL);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"scan.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrecord.h\"",
            "#include \"xinerama.h\"",
            "#include \"keyboard.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void do_button_mask_change(int mask, int button, rfbClientPtr client);",
            "void pointer_event(int mask, int x, int y, rfbClientPtr client);",
            "void update_x11_pointer_position(int x, int y, rfbClientPtr client);",
            "static void update_x11_pointer_mask(int mask, rfbClientPtr client);",
            "static void pipe_pointer(int mask, int x, int y, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"scan.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"win_utils.h\"\n#include \"xrecord.h\"\n#include \"xinerama.h\"\n#include \"keyboard.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid do_button_mask_change(int mask, int button, rfbClientPtr client);\nvoid pointer_event(int mask, int x, int y, rfbClientPtr client);\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client);\nstatic void update_x11_pointer_mask(int mask, rfbClientPtr client);\nstatic void pipe_pointer(int mask, int x, int y, rfbClientPtr client);\n\nvoid update_x11_pointer_position(int x, int y, rfbClientPtr client) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!x || !y) {}\n\treturn;\n#else\n\tint rc;\n\n\tint ptr_id = -1;\n\n\tRAWFB_RET_VOID\n\n\tif(client && client->clientData)\n\t  ptr_id = ((ClientData*)client->clientData)->ptr_id;\n\n\tX_LOCK;\n\tif (!always_inject && cursor_x == x && cursor_y == y) {\n\t\t;\n\t} else if (use_xwarppointer) {\n\t\t/*\n\t\t * off_x and off_y not needed with XWarpPointer since\n\t\t * window is used:\n\t\t */\n#ifdef HAVE_XI2\n                if(use_multipointer)\n                  XIWarpPointer_wr(dpy, ptr_id, None, window, 0, 0, 0, 0, x + coff_x, y + coff_y);\n                else\n#endif\n                  XWarpPointer(dpy, None, window, 0, 0, 0, 0, x + coff_x, y + coff_y);\n\t} else {\n\t         XTestFakeMotionEvent_wr(dpy, ptr_id, scr, x + off_x + coff_x, y + off_y + coff_y, CurrentTime);\n\t}\n\tX_UNLOCK;\n\n\tif (cursor_x != x || cursor_y != y) {\n\t\tlast_pointer_motion_time = dnow();\n\t}\n\n\tcursor_x = x;\n\tcursor_y = y;\n\n\t/* change the cursor shape if necessary */\n\trc = set_cursor(x, y, get_which_cursor());\n\tcursor_changes += rc;\n\n\tlast_event = last_input = last_pointer_input = time(NULL);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "cl"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set_single_window: unixpw_in_progress, dropping client.\\n\""
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl);\nvoid kbd_release_all_keys(rfbClientPtr cl);\nvoid set_single_window(rfbClientPtr cl, int x, int y);\nint get_file_transfer_permitted(rfbClientPtr cl);\n\nvoid set_single_window(rfbClientPtr cl, int x, int y) {\n\tint ok = 0;\n\tif (no_ultra_ext) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"set_single_window: unixpw_in_progress, dropping client.\\n\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\tif (x==1 && y==1) {\n\t\tif (subwin) {\n\t\t\tsubwin = 0x0;\n\t\t\tok = 1;\n\t\t}\n\t} else {\n\t\tWindow r, c;\n\t\tint rootx, rooty, wx, wy;\n\t\tunsigned int mask;\n\n\t\tupdate_x11_pointer_position(x, y, cl);\n\t\tXSync(dpy, False);\n\n\t\tif (XQueryPointer_wr(dpy, rootwin, &r, &c, &rootx, &rooty,\n\t\t    &wx, &wy, &mask)) {\n\t\t\tif (c != None) {\n\t\t\t\tsubwin = c;\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok) {\n\t\tcheck_black_fb();\n\t\tdo_new_fb(1);\t\n\t}\n#endif\n\n}"
  },
  {
    "function_name": "kbd_release_all_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1848-1873",
    "snippet": "void kbd_release_all_keys(rfbClientPtr cl) {\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"kbd_release_all_keys: unixpw_in_progress, skipping.\\n\");\n\t\treturn;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\tif (use_threads) {\n\t\tX_LOCK;\n\t}\n\n\tclear_keys();\n\tclear_modifiers(0);\n\n\tif (use_threads) {\n\t\tX_UNLOCK;\n\t}\n#endif\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xcut_receive(char *text, int len, rfbClientPtr cl);",
      "void kbd_release_all_keys(rfbClientPtr cl);",
      "int get_file_transfer_permitted(rfbClientPtr cl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_modifiers",
          "args": [
            "0"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "clear_modifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "125-197",
          "snippet": "void clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_modifiers(int init);",
            "int add_keysym(KeySym keysym);",
            "char *short_kmbcf(char *str);",
            "static void add_dead_keysyms(char *str);",
            "static char modifiers[0x100];",
            "static KeyCode keycodes[0x100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_modifiers(int init);\nint add_keysym(KeySym keysym);\nchar *short_kmbcf(char *str);\nstatic void add_dead_keysyms(char *str);\nstatic char modifiers[0x100];\nstatic KeyCode keycodes[0x100];\n\nvoid clear_modifiers(int init) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!init) {}\n\treturn;\n#else\n\tstatic KeyCode keycodes[256];\n\tstatic KeySym  keysyms[256];\n\tstatic char *keystrs[256];\n\tstatic int kcount = 0, first = 1;\n\tint keystate[256];\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tKeySym *keymap;\n\tKeySym keysym;\n\tKeyCode keycode;\n\n\tRAWFB_RET_VOID\n\n\t/* n.b. caller decides to X_LOCK or not. */\n\tif (first) {\n\t\t/*\n\t\t * we store results in static arrays, to aid interrupted\n\t\t * case, but modifiers could have changed during session...\n\t\t */\n\t\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\t\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t\t    &syms_per_keycode);\n\n\t\tfor (i = minkey; i <= maxkey; i++) {\n\t\t    for (j = 0; j < syms_per_keycode; j++) {\n\t\t\tchar *str;\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif (keysym == NoSymbol || ! ismodkey(keysym)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycode = XKeysymToKeycode(dpy, keysym);\n\t\t\tif (keycode == NoSymbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeycodes[kcount] = keycode;\n\t\t\tkeysyms[kcount]  = keysym;\n\t\t\tstr = XKeysymToString(keysym);\n\t\t\tif (! str) str = \"null\";\n\t\t\tkeystrs[kcount]  = strdup(str);\n\t\t\tkcount++;\n\t\t    }\n\t\t}\n\t\tXFree_wr((void *) keymap);\n\t\tfirst = 0;\n\t}\n\tif (init) {\n\t\treturn;\n\t}\n\t\n\tget_keystate(keystate);\n\tfor (i=0; i < kcount; i++) {\n\t\tkeysym  = keysyms[i];\n\t\tkeycode = keycodes[i];\n\n\t\tif (! keystate[(int) keycode]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clear_mods) {\n\t\t\trfbLog(\"clear_modifiers: up: %-10s (0x%x) \"\n\t\t\t    \"keycode=0x%x\\n\", keystrs[i], keysym, keycode);\n\t\t}\n\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime); /* multipointer FIXME? */\n\t}\n\tXFlush_wr(dpy);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_keys",
          "args": [],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "clear_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "271-286",
          "snippet": "void clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);",
            "void clear_keys(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\nvoid clear_keys(void);\n\nvoid clear_keys(void) {\n\tint k, keystate[256];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tget_keystate(keystate);\n\tfor (k=0; k<256; k++) {\n\t\tif (keystate[k]) {\n\t\t\tKeyCode keycode = (KeyCode) k;\n\t\t\trfbLog(\"clear_keys: keycode=%d\\n\", keycode);\n\t\t\tXTestFakeKeyEvent_wr(dpy, -1, keycode, False, CurrentTime);/* multipointer FIXME? */\n\t\t}\n\t}\n\tXFlush_wr(dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"kbd_release_all_keys: unixpw_in_progress, skipping.\\n\""
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl);\nvoid kbd_release_all_keys(rfbClientPtr cl);\nint get_file_transfer_permitted(rfbClientPtr cl);\n\nvoid kbd_release_all_keys(rfbClientPtr cl) {\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"kbd_release_all_keys: unixpw_in_progress, skipping.\\n\");\n\t\treturn;\n\t}\n\tif (cl->viewOnly) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\tif (use_threads) {\n\t\tX_LOCK;\n\t}\n\n\tclear_keys();\n\tclear_modifiers(0);\n\n\tif (use_threads) {\n\t\tX_UNLOCK;\n\t}\n#endif\n}"
  },
  {
    "function_name": "xcut_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1681-1846",
    "snippet": "void xcut_receive(char *text, int len, rfbClientPtr cl) {\n\tallowed_input_t input;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"xcut_receive: unixpw_in_progress, skipping.\\n\");\n\t\treturn;\n\t}\n\n\tif (!watch_selection) {\n\t\treturn;\n\t}\n\tif (view_only) {\n\t\treturn;\n\t}\n\tif (text == NULL || len == 0) {\n\t\treturn;\n\t}\n\tget_allowed_input(cl, &input);\n\tif (!input.clipboard) {\n\t\treturn;\n\t}\n\tINPUT_LOCK;\n\n\tif (remote_prefix != NULL && strstr(text, remote_prefix) == text) {\n\t\tchar *result, *rcmd = text + strlen(remote_prefix);\n\t\tchar *tmp = (char *) calloc(len + 8, 1);\n\n\t\tif (strstr(rcmd, \"cmd=\") != rcmd && strstr(rcmd, \"qry=\") != rcmd) {\n\t\t\tstrcat(tmp, \"qry=\");\n\t\t}\n\t\tstrncat(tmp, rcmd, len - strlen(remote_prefix));\n\t\trfbLog(\"remote_prefix command: '%s'\\n\", tmp);\n\n\t\tif (use_threads) {\n\t\t\tif (client_connect_file) {\n\t\t\t\tFILE *f = fopen(client_connect_file, \"w\");\n\t\t\t\tif (f) {\n\t\t\t\t\tfprintf(f, \"%s\\n\", tmp);\n\t\t\t\t\tfclose(f);\n\t\t\t\t\tfree(tmp);\n\t\t\t\t\tINPUT_UNLOCK;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vnc_connect) {\n\t\t\t\tsprintf(x11vnc_remote_str, \"%s\", tmp);\n\t\t\t\tfree(tmp);\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tINPUT_UNLOCK;\n\n\n\t\tresult = process_remote_cmd(tmp, 1);\n\t\tif (result == NULL ) {\n\t\t\tresult = strdup(\"null\");\n\t\t} else if (!strcmp(result, \"\")) {\n\t\t\tfree(result);\n\t\t\tresult = strdup(\"none\");\n\t\t}\n\t\trfbLog(\"remote_prefix result:  '%s'\\n\", result);\n\n\t\tfree(tmp);\n\t\ttmp = (char *) calloc(strlen(remote_prefix) + strlen(result) + 1, 1);\n\n\t\tstrcat(tmp, remote_prefix);\n\t\tstrcat(tmp, result);\n\t\tfree(result);\n\n\t\trfbSendServerCutText(screen, tmp, strlen(tmp));\n\t\tfree(tmp);\n\n\t\treturn;\n\t}\n\n\tif (! check_sel_direction(\"recv\", \"xcut_receive\", text, len)) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_set_sel(text, len);\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tvnc_reflect_send_cuttext(text, len);\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\tINPUT_UNLOCK;\n\treturn;\n#else\n\n\tX_LOCK;\n\n\t/* associate this text with PRIMARY (and SECONDARY...) */\n\tif (set_primary && ! own_primary && selwin != None) {\n\t\town_primary = 1;\n\t\t/* we need to grab the PRIMARY selection */\n\t\tXSetSelectionOwner(dpy, XA_PRIMARY, selwin, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Own PRIMARY.\\n\");\n\t\t}\n\t}\n\n\tif (set_clipboard && ! own_clipboard && clipboard_atom != None && selwin != None) {\n\t\town_clipboard = 1;\n\t\t/* we need to grab the CLIPBOARD selection */\n\t\tXSetSelectionOwner(dpy, clipboard_atom, selwin, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Own CLIPBOARD.\\n\");\n\t\t}\n\t}\n\n\t/* duplicate the text string for our own use. */\n\tif (set_primary) {\n\t\tif (xcut_str_primary != NULL) {\n\t\t\tfree(xcut_str_primary);\n\t\t\txcut_str_primary = NULL;\n\t\t}\n\t\txcut_str_primary = (char *) malloc((size_t) (len+1));\n\t\tstrncpy(xcut_str_primary, text, len);\n\t\txcut_str_primary[len] = '\\0';\t/* make sure null terminated */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Set PRIMARY   '%s'\\n\", xcut_str_primary);\n\t\t}\n\t}\n\tif (set_clipboard) {\n\t\tif (xcut_str_clipboard != NULL) {\n\t\t\tfree(xcut_str_clipboard);\n\t\t\txcut_str_clipboard = NULL;\n\t\t}\n\t\txcut_str_clipboard = (char *) malloc((size_t) (len+1));\n\t\tstrncpy(xcut_str_clipboard, text, len);\n\t\txcut_str_clipboard[len] = '\\0';\t/* make sure null terminated */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Set CLIPBOARD '%s'\\n\", xcut_str_clipboard);\n\t\t}\n\t}\n\n\t/* copy this text to CUT_BUFFER0 as well: */\n\tXChangeProperty(dpy, rootwin, XA_CUT_BUFFER0, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *) text, len);\n\tXFlush_wr(dpy);\n\n\tX_UNLOCK;\n\tINPUT_UNLOCK;\n\n\tset_cutbuffer = 1;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xcut_receive(char *text, int len, rfbClientPtr cl);",
      "void kbd_release_all_keys(rfbClientPtr cl);",
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
      "int get_file_transfer_permitted(rfbClientPtr cl);",
      "void get_prop(char *str, int len, Atom prop, Window w);",
      "extern int rawfb_vnc_reflect;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rootwin",
            "XA_CUT_BUFFER0",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *) text",
            "len"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Set CLIPBOARD '%s'\\n\"",
            "xcut_str_clipboard"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "xcut_str_clipboard",
            "text",
            "len"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (len+1)"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xcut_str_clipboard"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Set PRIMARY   '%s'\\n\"",
            "xcut_str_primary"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "xcut_str_primary",
            "text",
            "len"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (len+1)"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Own CLIPBOARD.\\n\""
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetSelectionOwner",
          "args": [
            "dpy",
            "clipboard_atom",
            "selwin",
            "CurrentTime"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Own PRIMARY.\\n\""
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetSelectionOwner",
          "args": [
            "dpy",
            "XA_PRIMARY",
            "selwin",
            "CurrentTime"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vnc_reflect_send_cuttext",
          "args": [
            "text",
            "len"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "vnc_reflect_send_cuttext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "1600-1602",
          "snippet": "rfbBool vnc_reflect_send_cuttext(char *str, int len) {\n\treturn SendClientCutText(client, str, len);\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "rfbBool vnc_reflect_send_cuttext(char *str, int len);",
            "static void set_visual(char *str);",
            "static rfbClient* client = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nrfbBool vnc_reflect_send_cuttext(char *str, int len);\nstatic void set_visual(char *str);\nstatic rfbClient* client = NULL;\n\nrfbBool vnc_reflect_send_cuttext(char *str, int len) {\n\treturn SendClientCutText(client, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "macosx_set_sel",
          "args": [
            "text",
            "len"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "macosx_set_sel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/macosx.c",
          "lines": "392-408",
          "snippet": "void macosx_set_sel(char *str, int len) {\n\tif (screen && all_clients_initialized()) {\n\t\tif (cutlen <= len) {\n\t\t\tif (cuttext) {\n\t\t\t\tfree(cuttext);\n\t\t\t}\n\t\t\tcutlen = 2*(len+1);\n\t\t\tcuttext = (char *) calloc(cutlen, 1);\n\t\t}\n\t\tmemcpy(cuttext, str, (size_t) len);\n\t\tcuttext[len] = '\\0';\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"macosx_set_sel: %d\\n\", len);\n\t\t}\n\t\tmacosxGCS_set_pasteboard(str, len);\n\t}\n}",
          "includes": [
            "#include \"macosxCGS.h\"",
            "#include \"macosxCGP.h\"",
            "#include \"macosxCG.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void macosx_set_sel(char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"macosxCGS.h\"\n#include \"macosxCGP.h\"\n#include \"macosxCG.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"allowed_input_t.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include \"config.h\"\n\nvoid macosx_set_sel(char *, int);\n\nvoid macosx_set_sel(char *str, int len) {\n\tif (screen && all_clients_initialized()) {\n\t\tif (cutlen <= len) {\n\t\t\tif (cuttext) {\n\t\t\t\tfree(cuttext);\n\t\t\t}\n\t\t\tcutlen = 2*(len+1);\n\t\t\tcuttext = (char *) calloc(cutlen, 1);\n\t\t}\n\t\tmemcpy(cuttext, str, (size_t) len);\n\t\tcuttext[len] = '\\0';\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"macosx_set_sel: %d\\n\", len);\n\t\t}\n\t\tmacosxGCS_set_pasteboard(str, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_sel_direction",
          "args": [
            "\"recv\"",
            "\"xcut_receive\"",
            "text",
            "len"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "check_sel_direction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
          "lines": "259-290",
          "snippet": "int check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int check_sel_direction(char *dir, char *label, char *sel, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint check_sel_direction(char *dir, char *label, char *sel, int len);\n\nint check_sel_direction(char *dir, char *label, char *sel, int len) {\n\tint db = 0, ok = 1;\n\tif (debug_sel) {\n\t\tdb = 1;\n\t}\n\tif (sel_direction) {\n\t\tif (strstr(sel_direction, \"debug\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tif (strcmp(sel_direction, \"debug\")) {\n\t\t\tif (strstr(sel_direction, dir) == NULL) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (db) {\n\t\tchar str[40];\n\t\tint n = 40;\n\t\tstrncpy(str, sel, n);\n\t\tstr[n-1] = '\\0';\n\t\tif (len < n) {\n\t\t\tstr[len] = '\\0';\n\t\t}\n\t\trfbLog(\"%s: '%s'\\n\", label, str);\n\t\tif (ok) {\n\t\t\trfbLog(\"%s: %s-ing it.\\n\", label, dir);\n\t\t} else {\n\t\t\trfbLog(\"%s: NOT %s-ing it.\\n\", label, dir);\n\t\t}\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbSendServerCutText",
          "args": [
            "screen",
            "tmp",
            "strlen(tmp)"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "result"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "remote_prefix"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "strlen(remote_prefix) + strlen(result) + 1",
            "1"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "result"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remote_prefix"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_prefix result:  '%s'\\n\"",
            "result"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"none\""
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "result",
            "\"\""
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"null\""
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_remote_cmd",
          "args": [
            "tmp",
            "1"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "process_remote_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/remote.c",
          "lines": "843-6324",
          "snippet": "char *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}",
          "includes": [
            "#include \"sslhelper.h\"",
            "#include \"avahi.h\"",
            "#include \"userinput.h\"",
            "#include \"uinput.h\"",
            "#include \"unixpw.h\"",
            "#include \"selection.h\"",
            "#include \"keyboard.h\"",
            "#include \"userinput.h\"",
            "#include \"cursor.h\"",
            "#include \"pointer.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"screen.h\"",
            "#include \"win_utils.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xinerama.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}",
            "#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}"
          ],
          "globals_used": [
            "int send_remote_cmd(char *cmd, int query, int wait);",
            "void check_black_fb(void);",
            "int check_httpdir(void);",
            "void http_connections(int on);",
            "int remote_control_access_ok(void);",
            "char *process_remote_cmd(char *cmd, int stringonly);",
            "static void if_8bpp_do_new_fb(void);",
            "int rc_npieces = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sslhelper.h\"\n#include \"avahi.h\"\n#include \"userinput.h\"\n#include \"uinput.h\"\n#include \"unixpw.h\"\n#include \"selection.h\"\n#include \"keyboard.h\"\n#include \"userinput.h\"\n#include \"cursor.h\"\n#include \"pointer.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"screen.h\"\n#include \"win_utils.h\"\n#include \"xkb_bell.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xinerama.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\nint send_remote_cmd(char *cmd, int query, int wait);\nvoid check_black_fb(void);\nint check_httpdir(void);\nvoid http_connections(int on);\nint remote_control_access_ok(void);\nchar *process_remote_cmd(char *cmd, int stringonly);\nstatic void if_8bpp_do_new_fb(void);\nint rc_npieces = 0;\n\nchar *process_remote_cmd(char *cmd, int stringonly) {\n#if REMOTE_CONTROL\n\tchar *p = cmd;\n\tchar *co = \"\";\n\tchar buf[X11VNC_REMOTE_MAX]; \n\tint bufn = X11VNC_REMOTE_MAX;\n\tint query = 0;\n\tstatic char *prev_cursors_mode = NULL;\n\n\tif (!query_default && !accept_remote_cmds) {\n\t\trfbLog(\"remote commands disabled: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"skip remote command: %s unixpw_in_progress.\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (!query_default && priv_remote) {\n\t\tif (! remote_control_access_ok()) {\n\t\t\trfbLog(\"** Disabling remote commands in -privremote \"\n\t\t\t    \"mode.\\n\");\n\t\t\taccept_remote_cmds = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\n\tstrcpy(buf, \"\");\n\tif (strstr(cmd, \"cmd=\") == cmd) {\n\t\tp += strlen(\"cmd=\");\n\t\tif (strstr(p, \"script:\") == p) {\n\t\t\tchar *s, *q, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0, dp = 1;\n\n\t\t\tp += strlen(\"script:\");\n\n\t\t\tif (strstr(p, \"file=\") == p) {\n\t\t\t\tFILE *f;\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tp += strlen(\"file=\");\n\n\t\t\t\trfbLog(\"reading script from file '%s'\\n\", p);\n\n\t\t\t\tif (stat(p, &sbuf) != 0) {\n\t\t\t\t\trfbLogPerror(\"stat\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tf = fopen(p, \"r\");\n\t\t\t\tif (f == NULL) {\n\t\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tp = (char *) calloc(sbuf.st_size + 1, 1);\n\t\t\t\tdp = 0;\n\t\t\t\twhile (fgets(tmp, 1024, f) != NULL) {\n\t\t\t\t\tchar *c = strchr(tmp, '#');\n\t\t\t\t\tif (c) *c = '\\0';\n\t\t\t\t\tif (strlen(p) + strlen(tmp) > (size_t) sbuf.st_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstrcat(p, tmp);\n\t\t\t\t}\n\t\t\t\tfclose(f);\n\t\t\t}\n\n\t\t\tpieces = (char **) malloc(strlen(p) * sizeof(char *));\n\t\t\tif (dp) {\n\t\t\t\ts = strdup(p);\n\t\t\t} else {\n\t\t\t\ts = p;\n\t\t\t}\n\t\t\tq = strtok(s, \";\"); \n\n\t\t\twhile (q) {\n\t\t\t\tchar *t = lblanks(q);\n\t\t\t\tif (strstr(t, \"cmd=\") != t && strstr(t, \"qry=\") != t) {\n\t\t\t\t\tstrcpy(tmp, \"cmd=\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(tmp, \"\");\n\t\t\t\t}\n\t\t\t\tstrncat(tmp, t, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \";\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tchar *c = pieces[k];\n\t\t\t\tchar *t = c + strlen(c) - 1;\t/* shortest is \"cmd=\" */\n\t\t\t\twhile (isspace((unsigned char) (*t))) {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t\tif (t <= c) break;\n\t\t\t\t\tt--;\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tprocess_remote_cmd(c, 1);\n\t\t\t\t} else {\n\t\t\t\t\tprocess_remote_cmd(c, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (strstr(cmd, \"qry=\") == cmd) {\n\t\tquery = 1;\n\t\tif (strchr(cmd, ',')) {\n\t\t\t/* comma separated batch mode */\n\t\t\tchar *s, *q, *res, **pieces, tmp[1024];\n\t\t\tint k = 0, n = 0;\n\n\t\t\tpieces = (char **) malloc(strlen(cmd) * sizeof(char *));\n\t\t\ts = strdup(cmd + strlen(\"qry=\"));\n\t\t\tq = strtok(s, \",\"); \n\n\t\t\twhile (q) {\n\t\t\t\tstrcpy(tmp, \"qry=\");\n\t\t\t\tstrncat(tmp, q, 1000);\n\t\t\t\tpieces[n] = strdup(tmp);\n\t\t\t\tn++;\n\t\t\t\tq = strtok(NULL, \",\");\n\t\t\t}\n\t\t\tfree(s);\n\n\t\t\trc_npieces = n;\n\t\t\tstrcpy(buf, \"\");\n\t\t\tfor (k=0; k < n; k++) {\n\t\t\t\tres = process_remote_cmd(pieces[k], 1);\n\t\t\t\tif (res && strlen(buf)+strlen(res)\n\t\t\t\t    >= X11VNC_REMOTE_MAX - 1) {\n\t\t\t\t\trfbLog(\"overflow in process_remote_cmd:\"\n\t\t\t\t\t    \" %s -- %s\\n\", buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (res) {\n\t\t\t\t\tstrcat(buf, res);\n\t\t\t\t\tfree(res);\n\t\t\t\t}\n\t\t\t\tif (k < n - 1) {\n\t\t\t\t\tstrcat(buf, \",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k=0; k<n; k++) {\n\t\t\t\tfree(pieces[k]);\n\t\t\t}\n\t\t\tfree(pieces);\n\t\t\trc_npieces = 0;\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"qry=\");\n\t} else {\n\t\trfbLog(\"ignoring malformed command: %s\\n\", cmd);\n\t\tgoto done;\n\t}\n\n\t/* allow var=val usage */\n\tif (!strchr(p, ':')) {\n\t\tchar *q = strchr(p, '=');\n\t\tif (q) *q = ':';\n\t}\n\n\t/* always call like: COLON_CHECK(\"foobar:\") */\n#define COLON_CHECK(str) \\\n\tif (strstr(p, str) != p) { \\\n\t\tco = \":\"; \\\n\t\tif (! query) { \\\n\t\t\tgoto done; \\\n\t\t} \\\n\t} else { \\\n\t\tchar *q = strchr(p, ':'); \\\n\t\tif (query && q != NULL) { \\\n\t\t\t*(q+1) = '\\0'; \\\n\t\t} \\\n\t}\n\n#define NOTAPP \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n#define NOTAPPRO \\\n\tif (query) { \\\n\t\tif (strchr(p, ':')) { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%sN/A\", p); \\\n\t\t} else { \\\n\t\t\tsnprintf(buf, bufn, \"aro=%s:N/A\", p); \\\n\t\t} \\\n\t\tgoto qry; \\\n\t}\n\n/*\n * Maybe add: passwdfile logfile bg rfbauth passwd...\n */\n\tif (!strcmp(p, \"\")) {\t/* skip-cmd-list */\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: empty command.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"CR:\") == p) {\t/* skip-cmd-list */\n\t\t/* CR:WxH+X+Y,dx,dy */\n\t\tint w, h, x, y, dx, dy;\n\t\tNOTAPP\n\t\tif (sscanf(p+3, \"%dx%d+%d+%d,%d,%d\", &w, &h, &x, &y, &dx, &dy) == 6) {\n\t\t\tsraRegionPtr r;\n\t\t\trfbLog(\"rfbDoCopyRect(screen, %d, %d, %d, %d, %d, %d)\\n\", x, y, x+w, y+h, dx, dy);\n\t\t\tr = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tdo_copyregion(r, dx, dy, 0);\n\t\t\tfb_push();\n\t\t\tsraRgnDestroy(r);\n\t\t\trfbLog(\"did\\n\");\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad CR string: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"stop\") || !strcmp(p, \"quit\") ||\n\t    !strcmp(p, \"exit\") || !strcmp(p, \"shutdown\")) {\n\t\tNOTAPP\n\t\tif (client_connect_file) {\n\t\t\tFILE *in = fopen(client_connect_file, \"w\");\n\t\t\tif (in) {\n\t\t\t\tfprintf(in, \"cmd=noop\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"remote_cmd: setting shut_down flag\\n\");\n\t\tshut_down = 1;\n\t\tclose_all_clients();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ping\")\n\t    || strstr(p, \"ping:\") == p) { /* skip-cmd-list */\n\t\tquery = 1;\n\t\tif (rfb_desktop_name) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, rfb_desktop_name);\n\t\t} else {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p, \"unknown\");\n\t\t}\n\t\tgoto qry;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_cutbuffer\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"cutbuffer\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_clipboard\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"clipboard\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"resend_primary\")) {\n\t\tNOTAPP\n\t\tresend_selection(\"primary\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"blacken\") || !strcmp(p, \"zero\")) {\n\t\tNOTAPP\n\t\tpush_black_screen(4);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"refresh\")) {\n\t\tNOTAPP\n\t\trefresh_screen(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset\")) {\n\t\tNOTAPP\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"zero:\") == p) { /* skip-cmd-list */\n\t\tint x1, y1, x2, y2;\n\t\tNOTAPP\n\t\tp += strlen(\"zero:\");\n\t\tif (sscanf(p, \"%d,%d,%d,%d\", &x1, &y1, &x2, &y2) == 4)  {\n\t\t\tint mark = 1;\n\t\t\trfbLog(\"zeroing rect: %s\\n\", p);\n\t\t\tif (x1 < 0 || x2 < 0) {\n\t\t\t\tx1 = nabs(x1);\n\t\t\t\tx2 = nabs(x2);\n\t\t\t\tmark = 0;\t/* hack for testing */\n\t\t\t}\n\n\t\t\tzero_fb(x1, y1, x2, y2);\n\t\t\tif (mark) {\n\t\t\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\t\t}\n\t\t\tpush_sleep(4);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"damagefb:\") == p) { /* skip-cmd-list */\n\t\tint delay;\n\t\tNOTAPP\n\t\tp += strlen(\"damagefb:\");\n\t\tif (sscanf(p, \"%d\", &delay) == 1)  {\n\t\t\trfbLog(\"damaging client fb's for %d secs \"\n\t\t\t    \"(by not marking rects.)\\n\", delay);\n\t\t\tdamage_time = time(NULL);\n\t\t\tdamage_delay = delay;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"close\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"close:\")\n\t\tp += strlen(\"close:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"disconnect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"disconnect:\")\n\t\tp += strlen(\"disconnect:\");\n\t\tclose_clients(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id_cmd\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"id_cmd:\")\n\t\tp += strlen(\"id_cmd:\");\n\t\tid_cmd(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"id\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"id:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"id:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-id pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-id: skipping incorrect hex/dec number:\"\n\t\t\t    \" %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 0;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sid\") == p) {\n\t\tint ok = 0;\n\t\tWindow twin;\n\t\tCOLON_CHECK(\"sid:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s0x%lx\", p, co,\n\t\t\t    !rootshift ? 0 : subwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sid:\");\n\t\tif (*p == '\\0' || !strcmp(\"root\", p)) { /* skip-cmd-list */\n\t\t\t/* back to root win */\n\t\t\ttwin = 0x0;\n\t\t\tok = 1;\n\t\t} else if (!strcmp(\"pick\", p)) {\n\t\t\ttwin = 0x0;\n\t\t\tif (safe_remote_only) {\n\t\t\t\trfbLog(\"unsafe: '-sid pick'\\n\");\n\t\t\t} else if (pick_windowid(&twin)) {\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t} else if (! scan_hexdec(p, &twin)) {\n\t\t\trfbLog(\"-sid: skipping incorrect hex/dec number: %s\\n\", p);\n\t\t} else {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok) {\n\t\t\tX_LOCK;\n\t\t\tif (twin && ! valid_window(twin, NULL, 0)) {\n\t\t\t\trfbLog(\"skipping invalid sub-window: 0x%lx\\n\", twin);\n\t\t\t\tX_UNLOCK;\n\t\t\t} else {\n\t\t\t\tsubwin = twin;\n\t\t\t\trootshift = 1;\n\t\t\t\tX_UNLOCK;\n\t\t\t\tcheck_black_fb();\n\t\t\t\tdo_new_fb(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"waitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"nowaitmapped\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !subwin_wait_mapped);\n\t\t\tgoto qry;\n\t\t}\n\t\tsubwin_wait_mapped = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clip\") ||\n\t    strstr(p, \"clip:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"clip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(clip_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"clip:\");\n\t\tif (clip_str) {\n\t\t\tint w, h, x, y;\n\t\t\tfree(clip_str);\n\t\t\t/* try to handle easy case where WxH is unchanged: */\n\t\t\tif (parse_geom(p, &w, &h, &x, &y, wdpy_x, wdpy_y)) {\n\t\t\t\tif (cdpy_x == w && cdpy_y == h) {\n\t\t\t\t\tif (x >= 0 && y >= 0) {\n\t\t\t\t\t\tif (x + w <= wdpy_x && y + h <= wdpy_y) {\n\t\t\t\t\t\t\tcoff_x = x;\n\t\t\t\t\t\t\tcoff_y = y;\n\t\t\t\t\t\t\tclip_str = strdup(p);\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclip_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flashcmap mode.\\n\");\n\t\tflash_cmap = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflashcmap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flash_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flashcmap mode.\\n\");\n\t\tflash_cmap = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"shiftcmap\") == p) {\n\t\tCOLON_CHECK(\"shiftcmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, shift_cmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"shiftcmap:\");\n\t\tshift_cmap = atoi(p);\n\t\trfbLog(\"remote_cmd: set -shiftcmap %d\\n\", shift_cmap);\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"truecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off notruecolor mode.\\n\");\n\t\tforce_indexed_color = 0;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notruecolor\")) {\n\t\tint orig = force_indexed_color;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    force_indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on notruecolor mode.\\n\");\n\t\tforce_indexed_color = 1;\n\t\tif (orig != force_indexed_color) {\n\t\t\tif_8bpp_do_new_fb();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -overlay mode.\\n\");\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"skipping: overlay extension not present.\\n\");\n\t\t} else if (overlay) {\n\t\t\trfbLog(\"skipping: already in -overlay mode.\\n\");\n\t\t} else {\n\t\t\tint reset_mem = 0;\n\t\t\t/* here we go... */\n\t\t\tif (using_shm) {\n\t\t\t\trfbLog(\"setting -noshm mode.\\n\");\n\t\t\t\tusing_shm = 0;\n\t\t\t\treset_mem = 1;\n\t\t\t}\n\t\t\toverlay = 1;\n\t\t\tdo_new_fb(reset_mem);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay\")) {\n\t\tint orig = overlay;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay mode\\n\");\n\t\toverlay = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!orig) {\n\t\t\trfbLog(\"skipping: already not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\t/* here we go... */\n\t\t\tdo_new_fb(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"overlay_cursor\") ||\n\t    !strcmp(p, \"overlay_yescursor\") ||\n\t    !strcmp(p, \"nooverlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on overlay_cursor mode.\\n\");\n\t\toverlay_cursor = 1;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R noshow_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:none to disable any extra \"\n\t\t\t    \"cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nooverlay_cursor\") ||\n\t    !strcmp(p, \"nooverlay_yescursor\") ||\n\t    !strcmp(p, \"overlay_nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !overlay_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off overlay_cursor mode\\n\");\n\t\toverlay_cursor = 0;\n\t\tif (!overlay_present) {\n\t\t\trfbLog(\"warning: overlay extension not present.\\n\");\n\t\t} else if (!overlay) {\n\t\t\trfbLog(\"warning: not in -overlay mode.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"You may want to run -R show_cursor or\\n\");\n\t\t\trfbLog(\" -R cursor:... to re-enable any cursors.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -8to24 mode.\\n\");\n\t\tcmap8to24 = 1;\n\t\tif (overlay) {\n\t\t\trfbLog(\"disabling -overlay in -8to24 mode.\\n\");\n\t\t\toverlay = 0;\n\t\t}\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no8to24\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cmap8to24);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -8to24 mode.\\n\");\n\t\tcmap8to24 = 0;\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"8to24_opts\") == p) {\n\t\tCOLON_CHECK(\"8to24_opts:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(cmap8to24_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"8to24_opts:\");\n\t\tif (cmap8to24_str) {\n\t\t\tfree(cmap8to24_str);\n\t\t}\n\t\tcmap8to24_str = strdup(p);\n\t\tif (*p == '\\0') {\n\t\t\tcmap8to24 = 0;\n\t\t} else {\n\t\t\tcmap8to24 = 1;\n\t\t}\n\t\trfbLog(\"remote_cmd: set cmap8to24_str to: %s\\n\", cmap8to24_str);\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -24to32 mode.\\n\");\n\t\txform24to32 = 1;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no24to32\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xform24to32);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -24to32 mode.\\n\");\n\t\tif (set_visual_str_to_something) {\n\t\t\tif (visual_str) {\n\t\t\t\trfbLog(\"unsetting: %d %d/%d\\n\", visual_str,\n\t\t\t\t    (int) visual_id, visual_depth);\n\t\t\t\tfree(visual_str);\n\t\t\t}\n\t\t\tvisual_str = NULL;\n\t\t\tvisual_id = (VisualID) 0;\n\t\t\tvisual_depth = 0;\n\t\t}\n\t\txform24to32 = 0;\n\t\tdo_new_fb(1);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"visual\") == p) {\n\t\tCOLON_CHECK(\"visual:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(visual_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"visual:\");\n\t\tif (visual_str) free(visual_str);\n\t\tvisual_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale\") ||\n\t\t    strstr(p, \"scale:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale:\");\n\t\tif (scale_str) free(scale_str);\n\t\tscale_str = strdup(p);\n\n\t\t/* OK, this requires a new fb... */\n\t\tcheck_black_fb();\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scale_cursor\") ||\n\t\t    strstr(p, \"scale_cursor:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scale_cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scale_cursor_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scale_cursor:\");\n\t\tif (scale_cursor_str) free(scale_cursor_str);\n\t\tif (*p == '\\0') {\n\t\t\tscale_cursor_str = NULL;\n\t\t} else {\n\t\t\tscale_cursor_str = strdup(p);\n\t\t}\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"viewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable viewonly mode.\\n\");\n\t\tview_only = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noviewonly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !view_only);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable viewonly mode.\\n\");\n\t\tview_only = 0;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable sharing.\\n\");\n\t\tshared = 1;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = TRUE;\n\t\t\tscreen->neverShared = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshared\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !shared); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable sharing.\\n\");\n\t\tshared = 0;\n\t\tif (screen) {\n\t\t\t/* mutex */\n\t\t\tscreen->alwaysShared = FALSE;\n\t\t\tscreen->neverShared = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forever\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1-connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -forever mode.\\n\");\n\t\tconnect_once = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforever\") || !strcmp(p, \"once\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, connect_once);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -forever mode.\\n\");\n\t\tconnect_once = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"timeout\") == p) {\n\t\tint to;\n\t\tCOLON_CHECK(\"timeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    first_conn_timeout);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"timeout:\");\n\t\tto = atoi(p);\n\t\tif (to > 0 ) {\n\t\t\tto = -to;\n\t\t}\n\t\tfirst_conn_timeout = to;\n\t\trfbLog(\"remote_cmd: set -timeout to %d\\n\", -to);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"tightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (! tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 1;\n\t\t\trfbLog(\"rfbRegisterTightVNCFileTransferExtension: 4\\n\");\n\t\t\trfbRegisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"notightfilexfer\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !tightfilexfer);\n\t\t\tgoto qry;\n\t\t}\n#ifdef LIBVNCSERVER_WITH_TIGHTVNC_FILETRANSFER\n\t\tif (tightfilexfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -tightfilexfer for *NEW* clients.\\n\");\n\t\t\ttightfilexfer = 0;\n\t\t\trfbLog(\"rfbUnregisterTightVNCFileTransferExtension: 2\\n\");\n\t\t\trfbUnregisterTightVNCFileTransferExtension();\n\t\t}\n#else\n\t\trfbLog(\"remote_cmd: -tightfilexfer not supported in this binary.\\n\");\n#endif\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == TRUE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 0);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: enabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = TRUE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultrafilexfer\")) {\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, screen->permitFileTransfer == FALSE);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, 1);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->permitFileTransfer) {\n\t\t\trfbLog(\"remote_cmd: disabling -ultrafilexfer for clients.\\n\");\n\t\t\t/* mutex */\n\t\t\tscreen->permitFileTransfer = FALSE;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbversion\") == p) {\n\t\tint maj, min;\n\t\tCOLON_CHECK(\"rfbversion:\")\n\t\tif (query) {\n\t\t\tif (screen) {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, screen->protocolMajorVersion, screen->protocolMinorVersion);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"ans=%s:%d.%d\", p, 3, 8);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbversion:\");\n\n\t\tif (sscanf(p, \"%d.%d\", &maj, &min) == 2) {\n\t\t\t/* mutex */\n\t\t\tscreen->protocolMajorVersion = maj;\n\t\t\tscreen->protocolMinorVersion = min;\n\t\t\trfbLog(\"remote_cmd: set rfbversion to: %d.%d\\n\", maj, min);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: invalid rfbversion: %s\\n\", p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"deny\") || !strcmp(p, \"lock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: denying new connections.\\n\");\n\t\tdeny_all = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodeny\") || !strcmp(p, \"unlock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !deny_all);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: allowing new connections.\\n\");\n\t\tdeny_all = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"avahi\") || !strcmp(p, \"mdns\") || !strcmp(p, \"zeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -avahi mDNS mode.\\n\");\n\t\tif (!avahi) {\n\t\t\tchar *host = this_host();\n\t\t\tavahi = 1;\n\t\t\tavahi_initialise();\n\t\t\tavahi_advertise(vnc_desktop_name, host, screen->port);\n\t\t\tfree(host);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noavahi\") || !strcmp(p, \"nomdns\") || !strcmp(p, \"nozeroconf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !avahi);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -avahi mDNS mode.\\n\");\n\t\tif (avahi) {\n\t\t\tavahi = 0;\n\t\t\tavahi_reset();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"connect\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"connect:\")\n\t\tp += strlen(\"connect:\");\n\t\t/* this is a reverse connection */\n\t\treverse_connect(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"proxy\") == p) {\n\t\tCOLON_CHECK(\"proxy:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(connect_proxy));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"proxy:\");\n\t\tif (connect_proxy) {\n\t\t\tfree(connect_proxy);\n\t\t\tconnect_proxy = NULL;\n\t\t}\n\t\tif (!strcmp(p, \"\") || !strcasecmp(p, \"none\")) { /* skip-cmd-list */\n\t\t\trfbLog(\"remote_cmd: disabled -proxy\\n\");\n\t\t} else {\n\t\t\tconnect_proxy = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set -proxy %s\\n\", connect_proxy);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allowonce\") == p) {\n\t\tCOLON_CHECK(\"allowonce:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_once));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"allowonce:\");\n\t\tallow_once = strdup(p);\n\t\trfbLog(\"remote_cmd: set allow_once %s\\n\", allow_once);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"allow\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"allow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allow_list));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change allow in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tp += strlen(\"allow:\");\n\t\tif (allow_list && strchr(allow_list, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use allow:host\\n\");\n\t\t\trfbLog(\"in '-allow %s' mode.\\n\", allow_list);\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\n\t\told = allow_list;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tallow_list = add_item(allow_list, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tallow_list = delete_item(allow_list, p);\n\t\t} else {\n\t\t\tallow_list = strdup(p);\n\t\t}\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv6);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv6 mode for future sockets.\\n\");\n\t\tnoipv6 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ipv4\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noipv4);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -noipv4 mode for future sockets.\\n\");\n\t\tnoipv4 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"no6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ipv6_listen) {\n\t\t\tipv6_listen = 0;\n\t\t\trfbLog(\"disabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"6\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ipv6_listen);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!ipv6_listen) {\n\t\t\tipv6_listen = 1;\n\t\t\trfbLog(\"enabling -6 IPv6 listening mode.\\n\");\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tif (https_port_num > 0) {\n\t\t\t\thttps_port(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"localhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"127.0.0.1\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = strdup(\"localhost\");\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\trfbLog(\"listening on loopback network only.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolocalhost\")) {\n\t\tchar *before, *old;\n\t\tif (query) {\n\t\t\tint state = 0;\n\t\t\tchar *s = allow_list;\n\t\t\tif (s && (!strcmp(s, \"127.0.0.1\") ||\n\t\t\t    !strcmp(s, \"localhost\"))) {\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !state);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change localhost in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (allow_list) {\n\t\t\tbefore = strdup(allow_list);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = allow_list;\n\n\t\tallow_list = strdup(\"\");\n\n\t\tif (strcmp(before, allow_list)) {\n\t\t\trfbLog(\"remote_cmd: modified allow_list:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", allow_list);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\n\t\tif (listen_str) {\n\t\t\tfree(listen_str);\n\t\t}\n\t\tlisten_str = NULL;\n\n\t\t/* mutex */\n\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\trfbLog(\"listening on ALL network interfaces.\\n\");\n\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\treset_rfbport(-1, screen->port);\n\t\treset_httpport(-1, screen->httpPort);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"listen\") == p) {\n\t\tchar *before;\n\t\tint ok, mod = 0;\n\n\t\tCOLON_CHECK(\"listen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(listen_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (unixpw) {\n\t\t\trfbLog(\"remote_cmd: cannot change listen in -unixpw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (listen_str) {\n\t\t\tbefore = strdup(listen_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\tp += strlen(\"listen:\");\n\n\t\tlisten_str = strdup(p);\n\n\t\tif (strcmp(before, listen_str)) {\n\t\t\trfbLog(\"remote_cmd: modified listen_str:\\n\");\n\t\t\trfbLog(\" from: \\\"%s\\\"\\n\", before);\n\t\t\trfbLog(\" to:   \\\"%s\\\"\\n\", listen_str);\n\t\t\tmod = 1;\n\t\t}\n\n\t\tok = 1;\n\t\t/* mutex */\n\t\tif (listen_str == NULL || *listen_str == '\\0' ||\n\t\t    !strcmp(listen_str, \"any\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_ANY);\n\t\t} else if (!strcmp(listen_str, \"localhost\")) {\n\t\t\tscreen->listenInterface = htonl(INADDR_LOOPBACK);\n\t\t} else {\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t iface = inet_addr(listen_str);\n\t\t\tif (iface == htonl(INADDR_NONE)) {\n\t\t\t\tif (!host_lookup) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else if (!(hp = gethostbyname(listen_str))) {\n\t\t\t\t\tok = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiface = *(unsigned long *)hp->h_addr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tscreen->listenInterface = iface;\n\t\t\t}\n\t\t}\n\n\t\tif (ok && mod) {\n\t\t\tint is_loopback = 0;\n\t\t\tin_addr_t iface = screen->listenInterface;\n\n\t\t\tif (allow_list) {\n\t\t\t\tif (!strcmp(allow_list, \"127.0.0.1\") ||\n\t\t\t\t    !strcmp(allow_list, \"localhost\")) {\n\t\t\t\t\tis_loopback = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iface != htonl(INADDR_LOOPBACK)) {\n\t\t\t    if (is_loopback) {\n\t\t\t\trfbLog(\"re-setting -allow list to all \"\n\t\t\t\t   \"hosts for non-loopback listening.\\n\");\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\tallow_list = NULL;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    if (!is_loopback) {\n\t\t\t\tif (allow_list) {\n\t\t\t\t\tfree(allow_list);\n\t\t\t\t}\n\t\t\t\trfbLog(\"setting -allow list to 127.0.0.1\\n\");\n\t\t\t\tallow_list = strdup(\"127.0.0.1\");\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\trfbLog(\"allow list is: '%s'\\n\", NONUL(allow_list));\n\t\t\treset_rfbport(-1, screen->port);\n\t\t\treset_httpport(-1, screen->httpPort);\n\t\t\tfree(before);\n\t\t} else {\n\t\t\trfbLog(\"invalid listen string: %s\\n\", listen_str);\n\t\t\tfree(listen_str);\n\t\t\tlisten_str = before;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"lookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling hostname lookup.\\n\");\n\t\thost_lookup = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nolookup\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !host_lookup);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling hostname lookup.\\n\");\n\t\thost_lookup = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"accept\") == p) {\n\t\tint doit = 1, safe = 0;\n\t\tCOLON_CHECK(\"accept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(accept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"accept:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t\tdoit = 0;\n\t\t}\n\n\t\tif (doit) {\n\t\t\tif (accept_cmd) free(accept_cmd);\n\t\t\taccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"afteraccept\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"afteraccept:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(afteraccept_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"afteraccept:\");\n\t\tif (!strcmp(p, \"\")) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (afteraccept_cmd) free(afteraccept_cmd);\n\t\t\tafteraccept_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gone\") == p) {\n\t\tint safe = 0;\n\t\tCOLON_CHECK(\"gone:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(gone_cmd));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gone:\");\n\t\tif (!strcmp(p, \"\") || strstr(p, \"popup\") == p) { /* skip-cmd-list */\n\t\t\tsafe = 1;\n\t\t}\n\t\tif (safe_remote_only && ! safe) {\n\t\t\trfbLog(\"unsafe: %s\\n\", p);\n\t\t} else {\n\t\t\tif (gone_cmd) free(gone_cmd);\n\t\t\tgone_cmd = strdup(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"shm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off noshm mode.\\n\");\n\t\tusing_shm = 1;\n\t\tif (raw_fb) set_raw_fb_params(0);\n\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in shm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshm\")) {\n\t\tint orig = using_shm;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on noshm mode.\\n\");\n\t\tusing_shm = 0;\n\t\tif (orig != using_shm) {\n\t\t\tdo_new_fb(1);\n\t\t} else {\n\t\t\trfbLog(\" already in noshm mode.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"flipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 1;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noflipbyteorder\")) {\n\t\tint orig = flip_byte_order;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !flip_byte_order);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off flipbyteorder mode.\\n\");\n\t\tflip_byte_order = 0;\n\t\tif (orig != flip_byte_order) {\n\t\t\tif (! using_shm || xform24to32) {\n\t\t\t\tdo_new_fb(1);\n\t\t\t} else {\n\t\t\t\trfbLog(\"  using shm, not resetting fb\\n\");\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"onetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -onetile mode.\\n\");\n\t\tsingle_copytile = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noonetile\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !single_copytile);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -onetile mode.\\n\");\n\t\tif (tile_shm_count < ntiles_x) {\n\t\t\trfbLog(\" this has no effect: tile_shm_count=%d\"\n\t\t\t    \" ntiles_x=%d\\n\", tile_shm_count, ntiles_x);\n\t\t\t\n\t\t}\n\t\tsingle_copytile = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"solid_color\") == p) {\n\t\t/*\n\t\t * n.b. this solid stuff perhaps should reflect\n\t\t * safe_remote_only but at least the command names\n\t\t * are fixed.\n\t\t */\n\t\tchar *newc;\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"solid_color:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(solid_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"solid_color:\");\n\t\tif (*p != '\\0') {\n\t\t\tnewc = strdup(p);\n\t\t} else {\n\t\t\tnewc = strdup(solid_default);\n\t\t}\n\t\trfbLog(\"remote_cmd: solid %s -> %s\\n\", NONUL(solid_str), newc);\n\n\t\tif (solid_str) {\n\t\t\tif (!strcmp(solid_str, newc)) {\n\t\t\t\tdoit = 0;\n\t\t\t}\n\t\t\tfree(solid_str);\n\t\t}\n\t\tsolid_str = newc;\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\n\t\tif (doit && client_count) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"solid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable -solid mode\\n\");\n\t\tif (! solid_str) {\n\t\t\tsolid_str = strdup(solid_default);\n\t\t}\n\t\tuse_solid_bg = 1;\n\t\tif (raw_fb && !macosx_console) set_raw_fb_params(0);\n\t\tif (client_count && !orig) {\n\t\t\tsolid_bg(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosolid\")) {\n\t\tint orig = use_solid_bg;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_solid_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable -solid mode\\n\");\n\t\tuse_solid_bg = 0;\n\t\tif (client_count && orig) {\n\t\t\tsolid_bg(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"blackout\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"blackout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(blackout_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"blackout:\");\n\t\tif (blackout_str) {\n\t\t\tbefore = strdup(blackout_str);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = blackout_str;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tblackout_str = add_item(blackout_str, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tblackout_str = delete_item(blackout_str, p);\n\t\t} else {\n\t\t\tblackout_str = strdup(p);\n\t\t}\n\t\tif (strcmp(before, blackout_str)) {\n\t\t\trfbLog(\"remote_cmd: changing -blackout\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", blackout_str);\n\t\t\tif (0 && !strcmp(blackout_str, \"\") &&\n\t\t\t    single_copytile_orig != single_copytile) {\n\t\t\t\trfbLog(\"resetting single_copytile to: %d\\n\",\n\t\t\t\t    single_copytile_orig);\n\t\t\t\tsingle_copytile = single_copytile_orig;\n\t\t\t}\n\t\t\tinitialize_blackouts_and_xinerama();\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 1;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxinerama\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xinerama);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xinerama mode. (if applicable).\\n\");\n\t\txinerama = 0;\n\t\tinitialize_blackouts_and_xinerama();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (! xtrap_input) {\n\t\t\txtrap_input = 1;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxtrap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xtrap_input);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable xtrap input mode.\"\n\t\t    \"(if applicable).\\n\");\n\t\tif (xtrap_input) {\n\t\t\txtrap_input = 0;\n\t\t\tdisable_grabserver(dpy, 1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, xrandr); goto qry;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\txrandr = 1;\n\t\t\tif (raw_fb) set_raw_fb_params(0);\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrandr\")) {\n\t\tint orig = xrandr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !xrandr); goto qry;\n\t\t}\n\t\txrandr = 0;\n\t\txrandr_maybe = 0;\n\t\tif (xrandr_present) {\n\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrandr_mode\") == p) {\n\t\tint orig = xrandr;\n\t\tCOLON_CHECK(\"xrandr_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(xrandr_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrandr_mode:\");\n\t\tif (!strcmp(\"none\", p)) {\n\t\t\txrandr = 0;\n\t\t\txrandr_maybe = 0;\n\t\t} else {\n\t\t\tif (known_xrandr_mode(p)) {\n\t\t\t\tif (xrandr_mode) free(xrandr_mode);\n\t\t\t\txrandr_mode = strdup(p);\n\t\t\t} else {\n\t\t\t\trfbLog(\"skipping unknown xrandr mode: %s\\n\", p);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\txrandr = 1;\n\t\t}\n\t\tif (xrandr_present) {\n\t\t\tif (xrandr) {\n\t\t\t\trfbLog(\"remote_cmd: enable xrandr mode.\\n\");\n\t\t\t} else {\n\t\t\t\trfbLog(\"remote_cmd: disable xrandr mode.\\n\");\n\t\t\t}\n\t\t\tif (! xrandr_mode) {\n\t\t\t\txrandr_mode = strdup(\"default\");\n\t\t\t}\n\t\t\tif (orig != xrandr) {\n\t\t\t\tinitialize_xrandr();\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: XRANDR ext. not present.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rotate\") == p) {\n\t\tCOLON_CHECK(\"rotate:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rotating_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rotate:\");\n\t\tif (rotating_str) free(rotating_str);\n\t\trotating_str = strdup(p);\n\t\trfbLog(\"remote_cmd: set rotate to \\\"%s\\\"\\n\", rotating_str);\n\n\t\tdo_new_fb(0);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"padgeom\") == p) {\n\t\tCOLON_CHECK(\"padgeom:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pad_geometry));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"padgeom:\");\n\t\tif (!strcmp(\"force\", p) || !strcmp(\"do\",p) || !strcmp(\"go\",p)) {\n\t\t\trfbLog(\"remote_cmd: invoking install_padded_fb()\\n\");\n\t\t\tinstall_padded_fb(pad_geometry);\n\t\t} else {\n\t\t\tif (pad_geometry) free(pad_geometry);\n\t\t\tpad_geometry = strdup(p);\n\t\t\trfbLog(\"remote_cmd: set padgeom to: %s\\n\",\n\t\t\t    pad_geometry);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"quiet\") || !strcmp(p, \"q\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on quiet mode.\\n\");\n\t\tquiet = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noquiet\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !quiet); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off quiet mode.\\n\");\n\t\tquiet = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"modtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -modtweak mode.\\n\");\n\t\tif (! use_modifier_tweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomodtweak\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !use_modifier_tweak);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nomodtweak mode.\\n\");\n\t\tgot_nomodtweak = 1;\n\t\tuse_modifier_tweak = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xkb modtweak mode\"\n\t\t    \" (if supported).\\n\");\n\t\tif (! use_modifier_tweak || ! use_xkb_modtweak) {\n\t\t\tuse_modifier_tweak = 1;\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tinitialize_modtweak();\n\t\t}\n\t\tuse_modifier_tweak = 1;\n\t\tuse_xkb_modtweak = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxkb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xkb_modtweak);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: cannot disable -xkb \"\n\t\t\t    \"modtweak mode (not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xkb modtweak mode.\\n\");\n\t\tuse_xkb_modtweak = 0;\n\t\tgot_noxkb = 1;\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"capslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -capslock mode\\n\");\n\t\twatch_capslock = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocapslock\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_capslock);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -capslock mode\\n\");\n\t\twatch_capslock = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_lockkeys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !skip_lockkeys);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_lockkeys mode\\n\");\n\t\tskip_lockkeys = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"skip_keycodes\") == p) {\n\t\tCOLON_CHECK(\"skip_keycodes:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(skip_keycodes));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"skip_keycodes:\");\n\t\trfbLog(\"remote_cmd: setting xkb -skip_keycodes\"\n\t\t    \" to:\\n\\t'%s'\\n\", p);\n\t\tif (! xkb_present) {\n\t\t\trfbLog(\"remote_cmd: warning xkb not present\\n\");\n\t\t} else if (! use_xkb_modtweak) {\n\t\t\trfbLog(\"remote_cmd: turning on xkb.\\n\");\n\t\t\tuse_xkb_modtweak = 1;\n\t\t\tif (! use_modifier_tweak) {\n\t\t\t\trfbLog(\"remote_cmd: turning on modtweak.\\n\");\n\t\t\t\tuse_modifier_tweak = 1;\n\t\t\t}\n\t\t}\n\t\tif (skip_keycodes) free(skip_keycodes);\n\t\tskip_keycodes = strdup(p);\n\t\tinitialize_modtweak();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys += 1;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosloppy_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sloppy_keys);\n\t\t\tgoto qry;\n\t\t}\n\t\tsloppy_keys = 0;\n\t\trfbLog(\"remote_cmd: set sloppy_keys to: %d\\n\", sloppy_keys);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"skip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noskip_dups\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !skip_duplicate_key_events);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -skip_dups mode\\n\");\n\t\tskip_duplicate_key_events = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"add_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noadd_keysyms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !add_keysyms);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -add_keysyms mode.\\n\");\n\t\tadd_keysyms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, clear_mods == 1);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_mods mode.\\n\");\n\t\tclear_mods = 1;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_modifiers(0);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_mods\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 1));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_mods mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 2);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -clear_keys mode.\\n\");\n\t\tclear_mods = 2;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclear_keys\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !(clear_mods == 2));\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -clear_keys mode.\\n\");\n\t\tclear_mods = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_all\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    clear_mods == 3);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: doing clear_all action.\\n\");\n\t\tclear_mods = 3;\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_keys();\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clear_locks\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: doing clear_locks action.\\n\");\n\t\tif (use_threads) {X_LOCK;}\n\t\tclear_locks();\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"keystate\")) {\n\t\tint i, state[256];\n\t\tNOTAPP\n\t\tfor (i=0; i<256; i++) {\n\t\t\tstate[i] = 0;\n\t\t}\n\t\tif (use_threads) {X_LOCK;}\n\t\tget_keystate(state);\n\t\tif (use_threads) {X_UNLOCK;}\n\t\tfor (i=0; i<256; i++) {\n\t\t\tfprintf(stderr, \"keystate[%03d] %d\\n\", i, state[i]);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"remap\") == p) {\n\t\tchar *before, *old;\n\t\tCOLON_CHECK(\"remap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(remap_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"remap:\");\n\t\tif ((*p == '+' || *p == '-') && remap_file &&\n\t\t    strchr(remap_file, '/')) {\n\t\t\trfbLog(\"remote_cmd: cannot use remap:+/-\\n\");\n\t\t\trfbLog(\"in '-remap %s' mode.\\n\", remap_file);\n\t\t\tgoto done;\n\t\t}\n\t\tif (remap_file) {\n\t\t\tbefore = strdup(remap_file);\n\t\t} else {\n\t\t\tbefore = strdup(\"\");\n\t\t}\n\t\told = remap_file;\n\t\tif (*p == '+') {\n\t\t\tp++;\n\t\t\tremap_file = add_item(remap_file, p);\n\t\t} else if (*p == '-') {\n\t\t\tp++;\n\t\t\tremap_file = delete_item(remap_file, p);\n\t\t\tif (! strchr(remap_file, '-')) {\n\t\t\t\t*remap_file = '\\0';\n\t\t\t}\n\t\t} else {\n\t\t\tremap_file = strdup(p);\n\t\t}\n\t\tif (strcmp(before, remap_file)) {\n\t\t\trfbLog(\"remote_cmd: changed -remap\\n\");\n\t\t\trfbLog(\" from: %s\\n\", before);\n\t\t\trfbLog(\" to:   %s\\n\", remap_file);\n\t\t\tinitialize_remap(remap_file);\n\t\t}\n\t\tif (old) free(old);\n\t\tfree(before);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"repeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -repeat mode.\\n\");\n\t\tautorepeat(1, 0);\t/* restore initial setting */\n\t\tno_autorepeat = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"norepeat\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_autorepeat);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -norepeat mode.\\n\");\n\t\tno_autorepeat = 1;\n\t\tif (no_repeat_countdown >= 0) {\n\t\t\tno_repeat_countdown = 2;\n\t\t}\n\t\tif (client_count && ! view_only) {\n\t\t\tautorepeat(0, 0);\t/* disable if any clients */\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (nofb) {\n\t\t\trfbLog(\"remote_cmd: disabling nofb mode.\\n\");\n\t\t\trfbLog(\"  you may need to these turn back on:\\n\");\n\t\t\trfbLog(\"     xfixes, xdamage, solid, flashcmap\\n\");\n\t\t\trfbLog(\"     overlay, shm, noonetile, nap, cursor\\n\");\n\t\t\trfbLog(\"     cursorpos, cursorshape, bell.\\n\");\n\t\t\tnofb = 0;\n\t\t\tset_nofb_params(1);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofb\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, nofb);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!nofb) {\n\t\t\trfbLog(\"remote_cmd: enabling nofb mode.\\n\");\n\t\t\tif (main_fb) {\n\t\t\t\tpush_black_screen(4);\n\t\t\t}\n\t\t\tnofb = 1;\n\t\t\tsound_bell = 0;\n\t\t\tinitialize_watch_bell();\n\t\t\tset_nofb_params(0);\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"bell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling bell (if supported).\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nobell\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !sound_bell);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling bell.\\n\");\n\t\tinitialize_watch_bell();\n\t\tsound_bell = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sendbell\")) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: sendbell.\\n\");\n\t\tif (screen && client_count) {\n\t\t\trfbSendBell(screen);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch selection+primary.\\n\");\n\t\twatch_selection = 1;\n\t\twatch_primary = 1;\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_selection);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch selection+primary.\\n\");\n\t\twatch_selection = 0;\n\t\twatch_primary = 0;\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"primary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_primary.\\n\");\n\t\twatch_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_primary.\\n\");\n\t\twatch_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_primary.\\n\");\n\t\tset_primary = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetprimary\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_primary);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_primary.\\n\");\n\t\tset_primary = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling watch_clipboard.\\n\");\n\t\twatch_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"setclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling set_clipboard.\\n\");\n\t\tset_clipboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosetclipboard\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !set_clipboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling set_clipboard.\\n\");\n\t\tset_clipboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"seldir\") == p) {\n\t\tCOLON_CHECK(\"seldir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(sel_direction));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"seldir:\");\n\t\trfbLog(\"remote_cmd: setting -seldir to %s\\n\", p);\n\t\tif (sel_direction) free(sel_direction);\n\t\tsel_direction = strdup(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"set_no_cursor\")) { /* skip-cmd-list */\n\t\trfbLog(\"remote_cmd: calling set_no_cursor()\\n\");\n\t\tset_no_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorshape\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorshape mode.\\n\");\n\n\t\tset_no_cursor();\n\t\tcursor_shape_updates = 1;\n\t\trestore_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorshape\")) {\n\t\tint i, max = 5;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_shape_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorshape mode.\\n\");\n\t\t\n\t\tset_no_cursor();\n\t\tfor (i=0; i<max; i++) {\n\t\t\t/* XXX: try to force empty cursor back to client */\n\t\t\trfbPE(-1);\n\t\t}\n\t\tcursor_shape_updates = 0;\n\t\tdisable_cursor_shape_updates(screen);\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursorpos\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !cursor_pos_updates);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off cursorpos mode.\\n\");\n\t\tcursor_pos_updates = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"cursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 1;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nocursor_drag\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !cursor_drag_changes);\n\t\t\tgoto qry;\n\t\t}\n\t\tcursor_drag_changes = 0;\n\t\trfbLog(\"remote_cmd: setting cursor_drag_changes: %d.\\n\", cursor_drag_changes);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"cursor\") == p) {\n\t\tCOLON_CHECK(\"cursor:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(multiple_cursors_mode));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"cursor:\");\n\t\tif (multiple_cursors_mode) {\n\t\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\t\t\tfree(multiple_cursors_mode);\n\t\t}\n\t\tmultiple_cursors_mode = strdup(p);\n\n\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\n\t\tif (strcmp(multiple_cursors_mode, \"none\") && !show_cursor) {\n\t\t\tshow_cursor = 1;\n\t\t\trfbLog(\"remote_cmd: changed show_cursor \"\n\t\t\t    \"to: %d\\n\", show_cursor);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"show_cursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling show_cursor.\\n\");\n\t\tshow_cursor = 1;\n\t\tif (multiple_cursors_mode && !strcmp(multiple_cursors_mode,\n\t\t    \"none\")) {\n\t\t\tfree(multiple_cursors_mode);\n\t\t\tif (prev_cursors_mode) {\n\t\t\t\tmultiple_cursors_mode =\n\t\t\t\t    strdup(prev_cursors_mode);\n\t\t\t} else {\n\t\t\t\tmultiple_cursors_mode = strdup(\"default\");\n\t\t\t}\n\t\t\trfbLog(\"remote_cmd: changed -cursor mode \"\n\t\t\t    \"to: %s\\n\", multiple_cursors_mode);\n\t\t}\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noshow_cursor\") || !strcmp(p, \"nocursor\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_cursor);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (prev_cursors_mode) free(prev_cursors_mode);\n\t\tprev_cursors_mode = strdup(multiple_cursors_mode);\n\n\t\trfbLog(\"remote_cmd: disabling show_cursor.\\n\");\n\t\tshow_cursor = 0;\n\t\tinitialize_cursors_mode();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"arrow\") == p) {\n\t\tCOLON_CHECK(\"arrow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, alt_arrow);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"arrow:\");\n\t\talt_arrow = atoi(p);\n\t\trfbLog(\"remote_cmd: setting alt_arrow: %d.\\n\", alt_arrow);\n\t\tsetup_cursors_and_push();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xfixes \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -xfixes\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xfixes = 1;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxfixes\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xfixes);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xfixes_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xfixes  \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling -xfixes.\\n\");\n\t\tuse_xfixes = 0;\n\t\tinitialize_xfixes();\n\t\tfirst_cursor();\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: cannot enable xdamage hints \"\n\t\t\t    \"(not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling xdamage hints\"\n\t\t    \" (if supported).\\n\");\n\t\tuse_xdamage = 1;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tcreate_xdamage_if_needed(0);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxdamage\")) {\n\t\tint orig = use_xdamage;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (! xdamage_present) {\n\t\t\trfbLog(\"remote_cmd: disabling xdamage hints \"\n\t\t\t    \"(but not supported on X display)\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling xdamage hints.\\n\");\n\t\tuse_xdamage = 0;\n\t\tif (use_xdamage != orig) {\n\t\t\tinitialize_xdamage();\n\t\t\tdestroy_xdamage_if_needed();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_area\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"xd_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    xdamage_max_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_area:\");\n\t\ta = atoi(p);\n\t\tif (a >= 0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_max_area \"\n\t\t\t    \"%d -> %d.\\n\", xdamage_max_area, a);\n\t\t\txdamage_max_area = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xd_mem\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"xd_mem:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.3f\", p, co,\n\t\t\t    xdamage_memory);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xd_mem:\");\n\t\ta = atof(p);\n\t\tif (a >= 0.0) {\n\t\t\trfbLog(\"remote_cmd: setting xdamage_memory \"\n\t\t\t    \"%.3f -> %.3f.\\n\", xdamage_memory, a);\n\t\t\txdamage_memory = a;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphacut\") == p) {\n\t\tint a;\n\t\tCOLON_CHECK(\"alphacut:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    alpha_threshold);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphacut:\");\n\t\ta = atoi(p);\n\t\tif (a < 0) a = 0;\n\t\tif (a > 256) a = 256;\t/* allow 256 for testing. */\n\t\tif (alpha_threshold != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphacut \"\n\t\t\t    \"%d -> %d.\\n\", alpha_threshold, a);\n\t\t\tif (a == 256) {\n\t\t\t\trfbLog(\"note: alphacut=256 leads to completely\"\n\t\t\t\t    \" transparent cursors.\\n\");\n\t\t\t}\n\t\t\talpha_threshold = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphafrac\") == p) {\n\t\tdouble a;\n\t\tCOLON_CHECK(\"alphafrac:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co,\n\t\t\t    alpha_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"alphafrac:\");\n\t\ta = atof(p);\n\t\tif (a < 0.0) a = 0.0;\n\t\tif (a > 1.0) a = 1.0;\n\t\tif (alpha_frac != a) {\n\t\t\trfbLog(\"remote_cmd: setting alphafrac \"\n\t\t\t    \"%f -> %f.\\n\", alpha_frac, a);\n\t\t\talpha_frac = a;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: enable alpharemove\\n\");\n\t\t\talpha_remove = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalpharemove\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_remove);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_remove) {\n\t\t\trfbLog(\"remote_cmd: disable alpharemove\\n\");\n\t\t\talpha_remove = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"alphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: enable alphablend\\n\");\n\t\t\talpha_remove = 0;\n\t\t\talpha_blend = 1;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalphablend\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !alpha_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (alpha_blend) {\n\t\t\trfbLog(\"remote_cmd: disable alphablend\\n\");\n\t\t\talpha_blend = 0;\n\t\t\tsetup_cursors_and_push();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xwarppointer\") == p || strstr(p, \"xwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noxwarppointer\") == p ||\n\t\t    strstr(p, \"noxwarp\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_xwarppointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off xwarppointer mode.\\n\");\n\t\tuse_xwarppointer = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"always_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on always_inject mode.\\n\");\n\t\talways_inject = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noalways_inject\") == p) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !always_inject);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off always_inject mode.\\n\");\n\t\talways_inject = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"buttonmap\") == p) {\n\t\tCOLON_CHECK(\"buttonmap:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(pointer_remap));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"buttonmap:\");\n\t\tif (pointer_remap) free(pointer_remap);\n\t\tpointer_remap = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -buttonmap to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_pointer_map(p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse dragging mode.\\n\");\n\t\tshow_dragging = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodragging\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !show_dragging);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling mouse nodragging mode.\\n\");\n\t\tshow_dragging = 0;\n\t\tgoto done;\n\t}\n#ifndef NO_NCACHE\n\tif (!strcmp(p, \"ncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_cr %d\\n\", ncache_copyrect);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_cr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_copyrect);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_copyrect = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_cr %d\\n\", ncache_copyrect);\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_moveraise\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_wf_raises);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_wf_raises = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_moveraise\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_dtchange\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_dt_change);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_dt_change = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_dt_change\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 0;\n\t\trfbLog(\"remote_cmd: set -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_no_rootpixmap\")) {\n\t\tint orig = ncache_xrootpmap;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_xrootpmap = 1;\n\t\trfbLog(\"remote_cmd: disabled -ncache_no_rootpixmap\\n\");\n\t\tif (orig != ncache_xrootpmap) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_reset_rootpixmap\") || !strcmp(p, \"ncrp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_xrootpmap);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (ncache_xrootpmap) {\n\t\t\trfbLog(\"remote_cmd: resetting root pixmap.\\n\");\n\t\t\tset_ncache_xrootpmap();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tkde_no_animate(0);\n\t\tncache_keep_anims = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_keep_anims\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_keep_anims);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_keep_anims = 0;\n\t\tkde_no_animate(1);\n\t\trfbLog(\"remote_cmd: disabled -ncache_keep_anims\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 1;\n\t\trfbLog(\"remote_cmd: set -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache_old_wm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache_old_wm);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache_old_wm = 0;\n\t\trfbLog(\"remote_cmd: disabled -ncache_old_wm\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_pad\") == p) {\n\t\tint orig = ncache_pad, n;\n\t\tCOLON_CHECK(\"ncache_pad:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_pad:\");\n\t\tn = atoi(p);\n\n\t\trfbLog(\"remote_cmd: setting ncache_pad %d to: %d\\n\", orig, n);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !!ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = ncache0;\n\t\trfbLog(\"remote_cmd: set ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tncache = 0;\n\t\trfbLog(\"remote_cmd: disabled ncache %d\\n\", ncache);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ncache_size\") == p) {\n\t\tint orig = ncache, n;\n\t\tCOLON_CHECK(\"ncache_size:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ncache);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ncache_size:\");\n\t\tn = atoi(p);\n\n\t\tif (n >= 0 && n != ncache) {\n\t\t\trfbLog(\"remote_cmd: setting ncache %d to: %d\\n\", orig, ncache);\n\t\t\tncache = n;\n\t\t\tdo_new_fb(1);\n\t\t\tif (client_count) {\n\t\t\t\tcheck_ncache(1,0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 1;\n\t\trfbLog(\"remote_cmd: enabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_ncache\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ncdb);\n\t\t\tgoto qry;\n\t\t}\n\t\tncdb = 0;\n\t\trfbLog(\"remote_cmd: disabled debug_ncache\\n\");\n\t\tgoto done;\n\t}\n#endif\n\tif (strstr(p, \"wireframe_mode\") == p) {\n\t\tCOLON_CHECK(\"wireframe_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    wireframe_str ? wireframe_str : WIREFRAME_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe_mode:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wireframe:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wireframe:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wf:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"wf:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wf:\");\n\t\tif (*p) {\n\t\t\tif (wireframe_str) {\n\t\t\t\tfree(wireframe_str);\n\t\t\t}\n\t\t\twireframe_str = strdup(p);\n\t\t\tparse_wireframe();\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframe\") || !strcmp(p, \"wf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframe mode.\\n\");\n\t\twireframe = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframe\") || !strcmp(p, \"nowf\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframe mode.\\n\");\n\t\twireframe = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wireframelocal\") || !strcmp(p, \"wfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -wireframelocal mode.\\n\");\n\t\twireframe_local = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowireframelocal\") || !strcmp(p, \"nowfl\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wireframe_local);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling -nowireframelocal mode.\\n\");\n\t\twireframe_local = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wirecopyrect\") == p) {\n\t\tCOLON_CHECK(\"wirecopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wirecopyrect:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wcr\") == p) {\n\t\tCOLON_CHECK(\"wcr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wcr:\");\n\n\t\tset_wirecopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgot_wirecopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowirecopyrect\") || !strcmp(p, \"nowcr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(wireframe_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_wirecopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -wirecopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(wireframe_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_area\") == p) {\n\t\tCOLON_CHECK(\"scr_area:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    scrollcopyrect_min_area);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_area:\");\n\n\t\tscrollcopyrect_min_area = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -scr_area to: %d\\n\",\n\t\t    scrollcopyrect_min_area);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_skip\") == p) {\n\t\tchar *s = scroll_skip_str;\n\t\tCOLON_CHECK(\"scr_skip:\")\n\t\tif (!s || *s == '\\0') s = scroll_skip_str0;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_skip:\");\n\t\tif (scroll_skip_str) {\n\t\t\tfree(scroll_skip_str);\n\t\t}\n\n\t\tscroll_skip_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_skip to: %s\\n\",\n\t\t    scroll_skip_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_inc\") == p) {\n\t\tchar *s = scroll_good_str;\n\t\tif (!s || *s == '\\0') s = scroll_good_str0;\n\t\tCOLON_CHECK(\"scr_inc:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_inc:\");\n\t\tif (scroll_good_str) {\n\t\t\tfree(scroll_good_str);\n\t\t}\n\n\t\tscroll_good_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_inc to: %s\\n\",\n\t\t    scroll_good_str);\n\t\tinitialize_scroll_matches();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keys\") == p) {\n\t\tCOLON_CHECK(\"scr_keys:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_key_list_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keys:\");\n\t\tif (scroll_key_list_str) {\n\t\t\tfree(scroll_key_list_str);\n\t\t}\n\n\t\tscroll_key_list_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keys to: %s\\n\",\n\t\t    scroll_key_list_str);\n\t\tinitialize_scroll_keys();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_term\") == p) {\n\t\tchar *s = scroll_term_str;\n\t\tif (!s || *s == '\\0') s = scroll_term_str0;\n\t\tCOLON_CHECK(\"scr_term:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_term:\");\n\t\tif (scroll_term_str) {\n\t\t\tfree(scroll_term_str);\n\t\t}\n\n\t\tscroll_term_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_term to: %s\\n\",\n\t\t    scroll_term_str);\n\t\tinitialize_scroll_term();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_keyrepeat\") == p) {\n\t\tchar *s = max_keyrepeat_str;\n\t\tif (!s || *s == '\\0') s = max_keyrepeat_str0;\n\t\tCOLON_CHECK(\"scr_keyrepeat:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_keyrepeat:\");\n\t\tif (max_keyrepeat_str) {\n\t\t\tfree(max_keyrepeat_str);\n\t\t}\n\n\t\tmax_keyrepeat_str = strdup(p);\n\t\trfbLog(\"remote_cmd: changed -scr_keyrepeat to: %s\\n\",\n\t\t    max_keyrepeat_str);\n\t\tinitialize_max_keyrepeat();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scr_parms\") == p) {\n\t\tCOLON_CHECK(\"scr_parms:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    scroll_copyrect_str ? scroll_copyrect_str\n\t\t\t    : SCROLL_COPYRECT_PARMS);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr_parms:\");\n\t\tif (*p) {\n\t\t\tif (scroll_copyrect_str) {\n\t\t\t\tfree(scroll_copyrect_str);\n\t\t\t}\n\t\t\tset_scrollcopyrect_mode(\"always\");\n\t\t\tscroll_copyrect_str = strdup(p);\n\t\t\tparse_scroll_copyrect();\n\t\t}\n\t\trfbLog(\"remote_cmd: set -scr_parms %s.\\n\",\n\t\t    NONUL(scroll_copyrect_str));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"scrollcopyrect\") == p) {\n\t\tCOLON_CHECK(\"scrollcopyrect:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scrollcopyrect:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"scr\") ||\n\t    strstr(p, \"scr:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"scr:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"scr:\");\n\n\t\tset_scrollcopyrect_mode(p);\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgot_scrollcopyrect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noscrollcopyrect\") || !strcmp(p, \"noscr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%s\", p,\n\t\t\t    NONUL(scroll_copyrect));\n\t\t\tgoto qry;\n\t\t}\n\n\t\tset_scrollcopyrect_mode(\"never\");\n\t\trfbLog(\"remote_cmd: changed -scrollcopyrect mode \"\n\t\t    \"to: %s\\n\", NONUL(scroll_copyrect));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fixscreen\") == p) {\n\t\tCOLON_CHECK(\"fixscreen:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(screen_fixup_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fixscreen:\");\n\t\tif (screen_fixup_str) {\n\t\t\tfree(screen_fixup_str);\n\t\t}\n\t\tscreen_fixup_str = strdup(p);\n\t\tparse_fixscreen();\n\t\trfbLog(\"remote_cmd: set -fixscreen %s.\\n\",\n\t\t    NONUL(screen_fixup_str));\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noxrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 1;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tshutdown_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"xrecord\")) {\n\t\tint orig = noxrecord;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !noxrecord);\n\t\t\tgoto qry;\n\t\t}\n\t\tnoxrecord = 0;\n\t\trfbLog(\"set noxrecord to: %d\\n\", noxrecord);\n\t\tif (orig != noxrecord) {\n\t\t\tinitialize_xrecord();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"reset_record\")) {\n\t\tNOTAPP\n\t\tif (use_xrecord) {\n\t\t\trfbLog(\"resetting RECORD\\n\");\n\t\t\tcheck_xrecord_reset(1);\n\t\t} else {\n\t\t\trfbLog(\"RECORD is disabled, not resetting.\\n\");\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pointer_mode\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pointer_mode:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pointer_mode:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"pm\") == p) {\n\t\tint pm;\n\t\tCOLON_CHECK(\"pm:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, pointer_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"pm:\");\n\t\tpm = atoi(p);\n\t\tif (pm < 0 || pm > pointer_mode_max) {\n\t\t\trfbLog(\"remote_cmd: pointer_mode out of range:\"\n\t\t\t   \" 1-%d: %d\\n\", pointer_mode_max, pm);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: setting pointer_mode %d\\n\", pm);\n\t\t\tpointer_mode = pm;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input_skip\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"input_skip:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, ui_skip);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input_skip:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting input_skip %d\\n\", is);\n\t\tui_skip = is;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"allinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 1;\n\t\trfbLog(\"enabled allinput\\n\");\n\t\tif (handle_events_eagerly) {\n\t\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\t\thandle_events_eagerly = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noallinput\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !all_input);\n\t\t\tgoto qry;\n\t\t}\n\t\tall_input = 0;\n\t\trfbLog(\"disabled allinput\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"input_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 1;\n\t\trfbLog(\"enabled input_eagerly\\n\");\n\t\tif (all_input) {\n\t\t\trfbLog(\"disabled allinput\\n\");\n\t\t\tall_input = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noinput_eagerly\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !handle_events_eagerly);\n\t\t\tgoto qry;\n\t\t}\n\t\thandle_events_eagerly = 0;\n\t\trfbLog(\"disabled input_eagerly\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"input\") == p) {\n\t\tint doit = 1;\n\t\tCOLON_CHECK(\"input:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(allowed_input_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"input:\");\n\t\tif (allowed_input_str && !strcmp(p, allowed_input_str)) { /* skip-cmd-list */\n\t\t\tdoit = 0;\n\t\t}\n\t\trfbLog(\"remote_cmd: setting input %s\\n\", p);\n\t\tif (allowed_input_str) free(allowed_input_str);\n\t\tif (*p == '\\0') {\n\t\t\tallowed_input_str = NULL;\n\t\t} else {\n\t\t\tallowed_input_str = strdup(p);\n\t\t}\n\t\tif (doit) {\n\t\t\tinitialize_allowed_input();\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabkbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_kbd\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbkbd\")) {\n\t\tint orig = grab_kbd;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_kbd);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_kbd = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_kbd\\n\");\n\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabptr\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tif (grab_always) {\n\t\t\tadjust_grabs(1, 0);\n\t\t}\n\t\trfbLog(\"enabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 1;\n\t\trfbLog(\"enabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noungrabboth\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !ungrab_both);\n\t\t\tgoto qry;\n\t\t}\n\t\tungrab_both = 0;\n\t\trfbLog(\"disabled ungrab_both\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbptr\")) {\n\t\tint orig = grab_ptr;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_ptr);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\trfbLog(\"disabled grab_ptr\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"grabalways\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 1;\n\t\tgrab_kbd = 1;\n\t\tgrab_always = 1;\n\t\tadjust_grabs(1, 0);\n\t\trfbLog(\"enabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nograbalways\")) {\n\t\tint orig = grab_always;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !grab_always);\n\t\t\tgoto qry;\n\t\t}\n\t\tgrab_ptr = 0;\n\t\tgrab_kbd = 0;\n\t\tgrab_always = 0;\n\t\tif (orig && dpy) {\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\t\tXUngrabPointer(dpy, CurrentTime);\n\t\t\tX_UNLOCK;\n#endif\n\t\t}\n\t\tadjust_grabs(0, 0);\n\t\trfbLog(\"disabled grab_always\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grablocal\") == p) {\n\t\tCOLON_CHECK(\"grablocal:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    grab_local);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grablocal:\");\n\n\t\tgrab_local = atoi(p);\n\t\trfbLog(\"remote_cmd: changed -grablocal to: %d\\n\",\n\t\t    grab_local);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_input\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"client_input:\")\n\t\tp += strlen(\"client_input:\");\n\t\tset_client_input(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ssltimeout\") == p) {\n\t\tint is;\n\t\tCOLON_CHECK(\"ssltimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    ssl_timeout_secs);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"ssltimeout:\");\n\t\tis = atoi(p);\n\t\trfbLog(\"remote_cmd: setting ssltimeout: %d\\n\", is);\n\t\tssl_timeout_secs = is;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"speeds\") == p) {\n\t\tCOLON_CHECK(\"speeds:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(speeds_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"speeds:\");\n\t\tif (speeds_str) free(speeds_str);\n\t\tspeeds_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -speeds to:\\n\\t'%s'\\n\", p);\n\t\tinitialize_speeds();\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wmdt\") == p) {\n\t\tCOLON_CHECK(\"wmdt:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(wmdt_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wmdt:\");\n\t\tif (wmdt_str) free(wmdt_str);\n\t\twmdt_str = strdup(p);\n\n\t\trfbLog(\"remote_cmd: setting -wmdt to: %s\\n\", p);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_pointer\") || !strcmp(p, \"dp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_pointer.\\n\");\n\t\tdebug_pointer = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_pointer\") || !strcmp(p, \"nodp\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_pointer);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_pointer.\\n\");\n\t\tdebug_pointer = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_keyboard\") || !strcmp(p, \"dk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on debug_keyboard.\\n\");\n\t\tdebug_keyboard = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_keyboard\") || !strcmp(p, \"nodk\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_keyboard);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off debug_keyboard.\\n\");\n\t\tdebug_keyboard = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keycode\") == p) {\n\t\tint kc, down = -1;\n\t\tchar *c;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keycode:\")\n\t\tp += strlen(\"keycode:\");\n\t\tkc = atoi(p);\n\t\tif (kc < 0) kc = 0;\n\t\tkc = kc % 256;\n\t\tc = strchr(p, ',');\n\t\tif (c) down = atoi(c+1);\n\t\trfbLog(\"remote_cmd: insert keycode %d down=%d\\n\", kc, down);\n\n\t\tif (macosx_console) {\n#ifdef MACOSX\n\t\t\tif (down == -1) {\n\t\t\t\tmacosxCG_keycode_inject(1, kc);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tmacosxCG_keycode_inject(0, kc);\n\t\t\t} else {\n\t\t\t\tmacosxCG_keycode_inject(down, kc);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tX_LOCK;\n\t\t\tif (down == -1) {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, 1, CurrentTime);\n\t\t\t\tusleep(50*1000);\n\t\t\t\tXTestFakeKeyEvent_wr(dpy, -1, kc, 0, CurrentTime);\n\t\t\t} else {\n\t\t\t        XTestFakeKeyEvent_wr(dpy, -1, kc, down, CurrentTime);\n\t\t\t}\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"keysym\") == p) {\n\t\tint down = -1;\n\t\tunsigned int in;\n\t\tKeySym ks;\n\t\tchar *c, *str;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"keysym:\")\n\t\tp += strlen(\"keysym:\");\n\n\t\tc = strchr(p, ',');\n\t\tif (c) {\n\t\t\tdown = atoi(c+1);\n\t\t\t*c = '\\0';\n\t\t}\n\n\t\tif (sscanf(p, \"0x%x\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if (sscanf(p, \"%u\", &in) == 1) {\n\t\t\tks = (KeySym) in;\n\t\t} else if ((ks = XStringToKeysym(p)) != NoSymbol) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad keysym: %s\\n\", p);\n\t\t\tgoto done;\n\t\t}\n\t\tstr = XKeysymToString(ks);\n\t\tstr = str ? str : \"NoSymbol\";\n\t\trfbLog(\"remote_cmd: insert keysym %s 0x%x '%s' down=%d\\n\", p, ks, str, down);\n\t\tif (down == -1) {\n\t\t\tkeyboard(1, ks, NULL);\n\t\t\tusleep(50*1000);\n\t\t\tkeyboard(0, ks, NULL);\n\t\t} else {\n\t\t\tkeyboard(down, ks, NULL);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"ptr\") == p) {\n\t\tint x, y, m = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"ptr:\")\n\t\tp += strlen(\"ptr:\");\n\t\trfbLog(\"remote_cmd: insert pointer event: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d,%d\", &x, &y, &m) == 3) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else if (sscanf(p, \"%d,%d\", &x, &y) == 2) {\n\t\t\tpointer_event(m, x, y, NULL);\n\t\t} else {\n\t\t\trfbLog(\"remote_cmd: bad ptr:x,y,mask\\n\");\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fakebuttonevent\") == p) {\n\t\tint mb, down = 0;\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"fakebuttonevent:\")\n\t\tp += strlen(\"fakebuttonevent:\");\n\t\trfbLog(\"remote_cmd: insert fakebuttonevent: %s\\n\", p);\n\t\tif (sscanf(p, \"%d,%d\", &mb, &down) == 2) {\n\t\t\tX_LOCK;\n\t\t\trfbLog(\"remote_cmd: XTestFakeButtonEvent(mb=%d, down=%d)\\n\", mb, down);\n\t\t\tXTestFakeButtonEvent_wr(dpy, -1, mb, down ? True : False, CurrentTime);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sleep\") == p) {\n\t\tNOTAPP\n\t\tCOLON_CHECK(\"sleep:\")\n\t\tp += strlen(\"sleep:\");\n\t\trfbLog(\"remote_cmd: sleeping: %s\\n\", p);\n\t\tusleep((int) (1.0e+6 * atof(p)));\n\t\trfbLog(\"remote_cmd: done sleeping.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"get_xprop\") == p) {\n\t\tchar *res;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in get_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"get_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"get_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tres = get_xprop(p, win);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=get_xprop:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"set_xprop\") == p) {\n\t\tchar *q;\n\t\tint rc = -2;\n\t\tunsigned long id;\n\t\tWindow win = None;\t/* None implies root in set_xprop() */\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"set_xprop:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"set_xprop:\");\n\n\t\tif (strstr(p, \"id=\") == p) {\t/* skip-cmd-list */\n\t\t\tp += strlen(\"id=\");\n\t\t\tif (scan_hexdec(p, &id)) {\n\t\t\t\twin = (Window) id;\n\t\t\t}\n\t\t\tif (strchr(p, ':')) {\n\t\t\t\tp = strchr(p, ':') + 1;\n\t\t\t}\n\t\t}\n\n\t\tq = strchr(p, ':');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t\trc = set_xprop(p, win, q+1);\n\t\t\t*q = ':';\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=set_xprop:%s:%d\", p, rc);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"wininfo\") == p) {\n\t\tchar *res, *t = \"\";\n\t\tunsigned long id;\n\t\tWindow win = None;\n\t\tint show_children = 0;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"wininfo:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wininfo:\");\n\n\t\tif (p[0] == '+') {\n\t\t\tshow_children = 1;\n\t\t\tt = \"+\";\n\t\t\tp++;\n\t\t}\n\t\tif (!strcmp(p, \"root\")) { /* skip-cmd-list */\n\t\t\twin = rootwin;\n\t\t} else if (scan_hexdec(p, &id)) {\n\t\t\twin = (Window) id;\n\t\t}\n\n\t\tres = wininfo(win, show_children);\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t}\n\t\tsnprintf(buf, bufn, \"ans=wininfo:%s%s:%s\", t, p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"bcx_xattach\") == p) {\n\t\tchar *res;\n\t\tint pg_init = -1, kg_init = -1;\n\t\tint try = 0, max_tries = 4;\n\n\t\t/* note we force query and assume the colon is there. */\n\t\tquery = 1;\n\t\tif (strstr(p, \"bcx_xattach:\") != p) { /* skip-cmd-list */\n\t\t\tsnprintf(buf, bufn, \"ans=%s:N/A\", p);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"bcx_xattach:\");\n\n\t\tif (strstr(p, \"retry=\")) { /* skip-cmd-list */\n\t\t\tint n;\n\t\t\tchar *q = strstr(p, \"retry=\"); /* skip-cmd-list */\n\t\t\tif (sscanf(q, \"retry=%d\", &n) == 1) {\n\t\t\t\tif (n < 0) n = 0;\n\t\t\t\tmax_tries = 1 + n;\n\t\t\t}\n\t\t}\n\n\t\ttry_again:\n\n\t\tres = bcx_xattach(p, &pg_init, &kg_init);\n\t\ttry++;\n\t\tif (res == NULL) {\n\t\t\tres = strdup(\"NULL\");\n\t\t} else if (strstr(res, \"GRAB_FAIL_INIT\")) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Final state OK, not Retrying.\\n\", p, res);\n\t\t} else if (strstr(res, \"GRAB_FAIL\") && try < max_tries) {\n\t\t\trfbLog(\"bcx_xattach: failed grab check for '%s': %s.  Retrying[%d]...\\n\", p, res, try);\n\t\t\tfree(res);\n\t\t\tpointer_event(0, dpy_x/2 + try, dpy_y/2 + try, NULL);\n#if !NO_X11\n\t\t\tX_LOCK;\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (dpy) {\n\t\t\t\tif (try == 2) {\n\t\t\t\t\tXSync(dpy, False);\n\t\t\t\t} else if (try == 3) {\n\t\t\t\t\tXSync(dpy, True);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX_UNLOCK;\n#endif\n\t\t\tif (try == 1) {\n\t\t\t\tusleep(250*1000);\n\t\t\t} else if (try <= 4) {\n\t\t\t\tusleep(try*400*1000);\n\t\t\t} else {\n\t\t\t\tusleep(4*500*1000);\n\t\t\t}\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tsnprintf(buf, bufn, \"ans=bcx_xattach:%s:%s\", p, res);\n\t\tfree(res);\n\n\t\tgoto qry;\n\t}\n\tif (strstr(p, \"deferupdate\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"deferupdate:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"deferupdate:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"defer\") == p) {\n\t\tint d;\n\t\tCOLON_CHECK(\"defer:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\td = defer_update;\n\t\t\t} else {\n\t\t\t\td = screen->deferUpdateTime;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, d);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"defer:\");\n\t\td = atoi(p);\n\t\tif (d < 0) d = 0;\n\t\trfbLog(\"remote_cmd: setting defer to %d ms.\\n\", d);\n\t\tdefer_update = d;\n\t\t/* mutex */\n\t\tscreen->deferUpdateTime = d;\n\t\tgot_defer = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"setdefer\") == p) {\n\t\tCOLON_CHECK(\"setdefer:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, set_defer);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"setdefer:\");\n\t\tset_defer = atoi(p);\n\t\trfbLog(\"remote_cmd: setting set_defer to %d\\n\", set_defer);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"extra_fbur\") == p) {\n\t\tCOLON_CHECK(\"extra_fbur:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, extra_fbur);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"extra_fbur:\");\n\t\textra_fbur = atoi(p);\n\t\trfbLog(\"remote_cmd: setting extra_fbur to %d\\n\", extra_fbur);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait_ui\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"wait_ui:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, wait_ui);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait_ui:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 1.0;\n\t\trfbLog(\"remote_cmd: setting wait_ui factor %.2f -> %.2f\\n\",\n\t\t    wait_ui, w);\n\t\twait_ui = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"wait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 1;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nowait_bog\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !wait_bog);\n\t\t\tgoto qry;\n\t\t}\n\t\twait_bog = 0;\n\t\trfbLog(\"remote_cmd: setting wait_bog to %d\\n\", wait_bog);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"slow_fb\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"slow_fb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, slow_fb);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"slow_fb:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting slow_fb factor %.2f -> %.2f\\n\",\n\t\t    slow_fb, w);\n\t\tslow_fb = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"xrefresh\") == p) {\n\t\tdouble w;\n\t\tCOLON_CHECK(\"xrefresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%.2f\", p, co, xrefresh);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"xrefresh:\");\n\t\tw = atof(p);\n\t\tif (w <= 0) w = 0.0;\n\t\trfbLog(\"remote_cmd: setting xrefresh delay %.2f -> %.2f\\n\",\n\t\t    xrefresh, w);\n\t\txrefresh = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"wait\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"wait:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, waitms);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"wait:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting wait %d -> %d ms.\\n\", waitms, w);\n\t\twaitms = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"readtimeout\") == p) {\n\t\tint w, orig = rfbMaxClientWait;\n\t\tCOLON_CHECK(\"readtimeout:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    rfbMaxClientWait/1000);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"readtimeout:\");\n\t\tw = atoi(p) * 1000;\n\t\tif (w <= 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting rfbMaxClientWait %d -> \"\n\t\t    \"%d msec.\\n\", orig, w);\n\t\trfbMaxClientWait = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on nap mode.\\n\");\n\t\ttake_naps = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nonap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !take_naps);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off nap mode.\\n\");\n\t\ttake_naps = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"sb\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"sb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"sb:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"screen_blank\") == p) {\n\t\tint w;\n\t\tCOLON_CHECK(\"screen_blank:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, screen_blank);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"screen_blank:\");\n\t\tw = atoi(p);\n\t\tif (w < 0) w = 0;\n\t\trfbLog(\"remote_cmd: setting screen_blank %d -> %d sec.\\n\",\n\t\t    screen_blank, w);\n\t\tscreen_blank = w;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"fbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nofbpm mode.\\n\");\n\t\twatch_fbpm = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nofbpm\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_fbpm);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nofbpm mode.\\n\");\n\t\twatch_fbpm = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -nodpms mode.\\n\");\n\t\twatch_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, watch_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -nodpms mode.\\n\");\n\t\twatch_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"clientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -clientdpms mode.\\n\");\n\t\tclient_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noclientdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !client_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -clientdpms mode.\\n\");\n\t\tclient_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"forcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -forcedpms mode.\\n\");\n\t\tforce_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noforcedpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !force_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -forcedpms mode.\\n\");\n\t\tforce_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noserverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"serverdpms\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_dpms);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noserverdpms mode.\\n\");\n\t\tno_ultra_dpms = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on -noultraext mode.\\n\");\n\t\tno_ultra_ext = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"ultraext\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !no_ultra_ext);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off -noultraext mode.\\n\");\n\t\tno_ultra_ext = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enabling the local chat window.\\n\");\n\t\tchat_window = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nochatwindow\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !chat_window);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling the local chat window.\\n\");\n\t\tchat_window = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chaton\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client != NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window on.\\n\");\n\t\tchat_window = 1;\n\t\tset_text_chat(NULL, rfbTextChatOpen, \"\");\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"chatoff\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (chat_window_client == NULL));\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning local chat window off.\\n\");\n\t\tset_text_chat(NULL, rfbTextChatClose, \"\");\n\t\tset_text_chat(NULL, rfbTextChatFinished, \"\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fs\") == p) {\n\t\tCOLON_CHECK(\"fs:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%f\", p, co, fs_frac);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fs:\");\n\t\tfs_frac = atof(p);\n\t\trfbLog(\"remote_cmd: setting -fs frac to %f\\n\", fs_frac);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"gaps\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"gaps:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, gaps_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"gaps:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting gaps_fill %d -> %d.\\n\",\n\t\t    gaps_fill, g);\n\t\tgaps_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"grow\") == p) {\n\t\tint g;\n\t\tCOLON_CHECK(\"grow:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, grow_fill);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"grow:\");\n\t\tg = atoi(p);\n\t\tif (g < 0) g = 0;\n\t\trfbLog(\"remote_cmd: setting grow_fill %d -> %d.\\n\",\n\t\t    grow_fill, g);\n\t\tgrow_fill = g;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"fuzz\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"fuzz:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, tile_fuzz);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"fuzz:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting tile_fuzz %d -> %d.\\n\",\n\t\t    tile_fuzz, f);\n\t\tgrow_fill = f;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"snapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning on snapfb mode.\\n\");\n\t\tuse_snapfb = 1;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nosnapfb\")) {\n\t\tint orig = use_snapfb;\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !use_snapfb);\n\t\t\t    goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turning off snapfb mode.\\n\");\n\t\tuse_snapfb = 0;\n\t\tif (orig != use_snapfb) {\n\t\t\tdo_new_fb(1);\n\t\t}\n\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rawfb\") == p) {\n\t\tCOLON_CHECK(\"rawfb:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(raw_fb_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rawfb:\");\n\t\tif (raw_fb_str) free(raw_fb_str);\n\t\traw_fb_str = strdup(p);\n\t\tif (safe_remote_only && strstr(p, \"setup:\") == p) { /* skip-cmd-list */\n\t\t\t/* n.b. we still allow filename, shm, of rawfb */\n\t\t\tfprintf(stderr, \"unsafe rawfb setup: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\n\t\trfbLog(\"remote_cmd: setting -rawfb to:\\n\\t'%s'\\n\", p);\n\n\t\tif (*raw_fb_str == '\\0') {\n\t\t\tfree(raw_fb_str);\n\t\t\traw_fb_str = NULL;\n\t\t\tif (raw_fb_mmap) {\n\t\t\t\tmunmap(raw_fb_addr, raw_fb_mmap);\n\t\t\t}\n\t\t\tif (raw_fb_fd >= 0) {\n\t\t\t\tclose(raw_fb_fd);\n\t\t\t}\n\t\t\traw_fb_fd = -1;\n\t\t\traw_fb = NULL;\n\t\t\traw_fb_addr = NULL;\n\t\t\traw_fb_offset = 0;\n\t\t\traw_fb_shm = 0;\n\t\t\traw_fb_mmap = 0;\n\t\t\traw_fb_seek = 0;\n\t\t\trfbLog(\"restoring per-rawfb settings...\\n\");\n\t\t\tset_raw_fb_params(1);\n\t\t}\n\t\trfbLog(\"hang on tight, here we go...\\n\");\n\t\traw_fb_back_to_X = 1;\n\t\tdo_new_fb(1);\n\t\traw_fb_back_to_X = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_accel\") == p) {\n\t\tCOLON_CHECK(\"uinput_accel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_accel()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_accel:\");\n\t\trfbLog(\"set_uinput_accel: %s\\n\", p);\n\t\tset_uinput_accel(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_thresh\") == p) {\n\t\tCOLON_CHECK(\"uinput_thresh:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(get_uinput_thresh()));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_thresh:\");\n\t\trfbLog(\"set_uinput_thresh: %s\\n\", p);\n\t\tset_uinput_thresh(p);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_reset\") == p) {\n\t\tCOLON_CHECK(\"uinput_reset:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_reset());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_reset:\");\n\t\trfbLog(\"set_uinput_reset: %s\\n\", p);\n\t\tset_uinput_reset(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"uinput_always\") == p) {\n\t\tCOLON_CHECK(\"uinput_always:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    get_uinput_always());\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"uinput_always:\");\n\t\trfbLog(\"set_uinput_always: %s\\n\", p);\n\t\tset_uinput_always(atoi(p));\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"progressive\") == p) {\n\t\tint f;\n\t\tCOLON_CHECK(\"progressive:\")\n\t\tif (query) {\n\t\t\tif (!screen) {\n\t\t\t\tf = 0;\n\t\t\t} else {\n\t\t\t\tf = screen->progressiveSliceHeight;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, f);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"progressive:\");\n\t\tf = atoi(p);\n\t\tif (f < 0) f = 0;\n\t\trfbLog(\"remote_cmd: setting progressive %d -> %d.\\n\",\n\t\t    screen->progressiveSliceHeight, f);\n\t\t/* mutex */\n\t\tscreen->progressiveSliceHeight = f;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"rfbport\") == p) {\n\t\tint rp, orig = screen ? screen->port : 5900;\n\t\tCOLON_CHECK(\"rfbport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"rfbport:\");\n\t\trp = atoi(p);\n\t\treset_rfbport(orig, rp);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"http\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, (ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock > -1 || ipv6_http_fd > -1) {\n\t\t\trfbLog(\"already listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning on listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nohttp\")) {\n\t\tif (query) {\n\t\t\tint ls = screen ? screen->httpListenSock : -1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !(ls > -1));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (screen->httpListenSock < 0 && ipv6_http_fd < 0) {\n\t\t\trfbLog(\"already not listening for http connections.\\n\");\n\t\t} else {\n\t\t\trfbLog(\"turning off listening for http connections.\\n\");\n\t\t\tif (check_httpdir()) {\n\t\t\t\thttp_connections(0);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpport\") == p) {\n\t\tint hp, orig = screen ? screen->httpPort : 0;\n\t\tCOLON_CHECK(\"httpport:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, orig);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpport:\");\n\t\thp = atoi(p);\n\t\treset_httpport(orig, hp);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"httpdir\") == p) {\n\t\tCOLON_CHECK(\"httpdir:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(http_dir));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"httpdir:\");\n\t\tif (http_dir && !strcmp(http_dir, p)) {\n\t\t\trfbLog(\"no change in httpdir: %s\\n\", http_dir);\n\t\t} else {\n\t\t\tif (http_dir) {\n\t\t\t\tfree(http_dir);\n\t\t\t}\n\t\t\thttp_dir = strdup(p);\n\t\t\thttp_connections(0);\n\t\t\tif (*p != '\\0') {\n\t\t\t\thttp_connections(1);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"enablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on enablehttpproxy.\\n\");\n\t\t/* mutex */\n\t\tscreen->httpEnableProxyConnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noenablehttpproxy\")) {\n\t\tif (query) {\n\t\t\tint ht = screen ? screen->httpEnableProxyConnect : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, ht == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off enablehttpproxy.\\n\");\n\t\tscreen->httpEnableProxyConnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"alwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->alwaysShared : 0;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off alwaysshared.\\n\");\n\t\tscreen->alwaysShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nevershared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on nevershared.\\n\");\n\t\tscreen->neverShared = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noalwaysshared\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->neverShared : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off nevershared.\\n\");\n\t\tscreen->neverShared = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t != 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning on dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodontdisconnect\")) {\n\t\tif (query) {\n\t\t\tint t = screen ? screen->dontDisconnect : 1;\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, t == 0);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"turning off dontdisconnect.\\n\");\n\t\tscreen->dontDisconnect = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"desktop\") ||\n\t    strstr(p, \"desktop:\") == p) {\t/* skip-cmd-list */\n\t\tCOLON_CHECK(\"desktop:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%s\", p, co,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"desktop:\");\n\t\tif (rfb_desktop_name) {\n\t\t\tfree(rfb_desktop_name);\n\t\t}\n\t\trfb_desktop_name = strdup(p);\n\t\t/* mutex */\n\t\tscreen->desktopName = rfb_desktop_name;\n\t\trfbLog(\"remote_cmd: setting desktop name to %s\\n\",\n\t\t    rfb_desktop_name);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 1;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xevents\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xevents = 0;\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xevents\") == p) {\n\t\tCOLON_CHECK(\"debug_xevents:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xevents);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xevents:\");\n\t\tdebug_xevents = atoi(p);\n\t\trfbLog(\"set debug_xevents to: %d\\n\", debug_xevents);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 1;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_xdamage\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_xdamage = 0;\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_xdamage\") == p) {\n\t\tCOLON_CHECK(\"debug_xdamage:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, debug_xdamage);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_xdamage:\");\n\t\tdebug_xdamage = atoi(p);\n\t\trfbLog(\"set debug_xdamage to: %d\\n\", debug_xdamage);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 1;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_wireframe\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_wireframe = 0;\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_wireframe\") == p) {\n\t\tCOLON_CHECK(\"debug_wireframe:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_wireframe);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_wireframe:\");\n\t\tdebug_wireframe = atoi(p);\n\t\trfbLog(\"set debug_wireframe to: %d\\n\", debug_wireframe);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 1;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_scroll\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_scroll = 0;\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_scroll\") == p) {\n\t\tCOLON_CHECK(\"debug_scroll:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_scroll);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_scroll:\");\n\t\tdebug_scroll = atoi(p);\n\t\trfbLog(\"set debug_scroll to: %d\\n\", debug_scroll);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_tiles\") || !strcmp(p, \"dbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 1;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_tiles\") || !strcmp(p, \"nodbt\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_tiles = 0;\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"debug_tiles\") == p) {\n\t\tCOLON_CHECK(\"debug_tiles:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co,\n\t\t\t    debug_tiles);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"debug_tiles:\");\n\t\tdebug_tiles = atoi(p);\n\t\trfbLog(\"set debug_tiles to: %d\\n\", debug_tiles);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 1;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_grabs\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_grabs);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_grabs = 0;\n\t\trfbLog(\"set debug_grabs to: %d\\n\", debug_grabs);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"debug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 1;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodebug_sel\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !debug_sel);\n\t\t\tgoto qry;\n\t\t}\n\t\tdebug_sel = 0;\n\t\trfbLog(\"set debug_sel to: %d\\n\", debug_sel);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"dbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 1;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nodbg\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !crash_debug);\n\t\t\tgoto qry;\n\t\t}\n\t\tcrash_debug = 0;\n\t\trfbLog(\"set crash_debug to: %d\\n\", crash_debug);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn on macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macsaver\") || !strcmp(p, \"nomacnosaver\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_noscreensaver); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: turn off macnosaver.\\n\");\n\t\tmacosx_noscreensaver = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macwait\") || !strcmp(p, \"nomacnowait\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_wait_for_switch); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_wait_for_switch.\\n\");\n\t\tmacosx_wait_for_switch = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"macwheel\") == p) {\n\t\tCOLON_CHECK(\"macwheel:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_mouse_wheel_speed);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"macwheel:\");\n\t\tmacosx_mouse_wheel_speed = atoi(p);\n\t\trfbLog(\"set macosx_mouse_wheel_speed to: %d\\n\", macosx_mouse_wheel_speed);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macswap\") || !strcmp(p, \"nomacnoswap\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_swap23); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_swap23.\\n\");\n\t\tmacosx_swap23 = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_resize.\\n\");\n\t\tmacosx_resize = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macresize\") || !strcmp(p, \"nomacnoresize\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_resize); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_resize.\\n\");\n\t\tmacosx_resize = 1;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"maciconanim\") == p) {\n\t\tCOLON_CHECK(\"maciconanim:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, macosx_icon_anim_time);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"maciconanim:\");\n\t\tmacosx_icon_anim_time = atoi(p);\n\t\trfbLog(\"set macosx_icon_anim_time to: %d\\n\", macosx_icon_anim_time);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macnomenu\") || !strcmp(p, \"nomacmenu\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_ncache_macmenu); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_ncache_macmenu.\\n\");\n\t\tmacosx_ncache_macmenu = 0;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"macuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: enable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 1;\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"nomacuskbd\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p, !macosx_us_kbd); goto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disable macosx_us_kbd.\\n\");\n\t\tmacosx_us_kbd = 0;\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"hack\") == p) { /* skip-cmd-list */\n\t\tCOLON_CHECK(\"hack:\")\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s%s%d\", p, co, hack_val);\n\t\t\tgoto qry;\n\t\t}\n\t\tp += strlen(\"hack:\");\n\t\thack_val = atoi(p);\n\t\trfbLog(\"set hack_val to: %d\\n\", hack_val);\n\t\tgoto done;\n\t}\n\tif (!strcmp(p, \"noremote\")) {\n\t\tif (query) {\n\t\t\tsnprintf(buf, bufn, \"ans=%s:%d\", p,\n\t\t\t    !accept_remote_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\trfbLog(\"remote_cmd: disabling remote commands.\\n\");\n\t\taccept_remote_cmds = 0; /* cannot be turned back on. */\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"client_info_sock\") == p) { /* skip-cmd-list */\n\t\tNOTAPP\n\t\tp += strlen(\"client_info_sock:\");\n\t\tif (*p != '\\0') {\n\t\t\tstart_client_info_sock(p);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"noop\") == p) {\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: noop\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"passwd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\n\t\tCOLON_CHECK(\"passwd:\")\n\t\tp += strlen(\"passwd:\");\n\n\t\tpasswds_new[0] = strdup(p);\n\n\t\t/* mutex */\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[1] = passwds_old[1];\n\t\t} else {\n\t\t\tpasswds_new[1] = NULL;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\tif (*p == '\\0') {\n\t\t\tscreen->authPasswdData = (void*) NULL;\n\t\t}\n\t\trfbLog(\"remote_cmd: changed full access passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (icon_mode && !query && strstr(p, \"viewpasswd\") == p) { /* skip-cmd-list */\n\t\tchar **passwds_new = (char **) malloc(3*sizeof(char *));\n\t\tchar **passwds_old = (char **) screen->authPasswdData;\n\t\t\n\t\tCOLON_CHECK(\"viewpasswd:\")\n\t\tp += strlen(\"viewpasswd:\");\n\n\t\tpasswds_new[1] = strdup(p);\n\n\t\tif (screen->authPasswdData &&\n\t\t    screen->passwordCheck == rfbCheckPasswordByList) {\n\t\t\t\tpasswds_new[0] = passwds_old[0];\n\t\t} else {\n\t\t\tchar *tmp = (char *) malloc(4 + CHALLENGESIZE);\n\t\t\trfbRandomBytes((unsigned char*)tmp);\n\t\t\tpasswds_new[0] = tmp;\n\t\t\tscreen->passwordCheck = rfbCheckPasswordByList;\n\t\t}\n\t\tpasswds_new[2] = NULL;\n\n\t\tif (*p == '\\0') {\n\t\t\tpasswds_new[1] = NULL;\n\t\t}\n\n\t\tscreen->authPasswdData = (void*) passwds_new;\n\t\trfbLog(\"remote_cmd: changed view only passwd.\\n\");\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayembed:\")\n\t\tp += strlen(\"trayembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 0;\n\t\t\trfbLog(\"remote_cmd: will try to embed 0x%x in\"\n\t\t\t    \" the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (strstr(p, \"trayunembed\") == p) { /* skip-cmd-list */\n\t\tunsigned long id;\n\t\tNOTAPP\n\n\t\tCOLON_CHECK(\"trayunembed:\")\n\t\tp += strlen(\"trayunembed:\");\n\t\tif (scan_hexdec(p, &id)) {\n\t\t\ttray_request = (Window) id;\n\t\t\ttray_unembed = 1;\n\t\t\trfbLog(\"remote_cmd: will try to unembed 0x%x out\"\n\t\t\t    \" of the system tray.\\n\", id);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (query) {\n\t\t/* read-only variables that can only be queried: */\n\n\t\tif (!strcmp(p, \"display\")) {\n\t\t\tif (raw_fb) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:rawfb:%p\",\n\t\t\t\t    p, raw_fb_addr);\n\t\t\t} else if (! dpy) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else {\n\t\t\t\tchar *d;\n\t\t\t\td = DisplayString(dpy);\n\t\t\t\tif (! d) d = \"unknown\";\n\t\t\t\tif (*d == ':') {\n\t\t\t\t\tchar *host = this_host();\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s%s\", p,\n\t\t\t\t\t    host, d);\n\t\t\t\t\tfree(host);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"vncdisplay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(vnc_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"icon_mode\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, icon_mode);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"autoport\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, auto_port);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"loop\") || !strcmp(p, \"loopbg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, 0);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"desktopname\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(rfb_desktop_name));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_desktop\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(guess_desktop()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"guess_dbus\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(dbus_session()));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"http_url\")) {\n\t\t\tif (!screen) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:\", p);\n\t\t\t} else if (screen->httpListenSock > -1) {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:http://%s:%d\", p,\n\t\t\t\t    NONUL(screen->thisHost), screen->httpPort);\n\t\t\t} else {\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t\t    \"http_not_active\");\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"auth\") || !strcmp(p, \"xauth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(auth_file));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"users\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(users_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, rootshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clipshift\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, clipshift);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_str\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(scale_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaled_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaled_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_numer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_numer);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_denom\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scale_denom);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scale_fac_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%f\", p, scale_fac_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_blend\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_blend);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_nomult4\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_nomult4);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_pad\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, scaling_pad);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"scaling_interpolate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p,\n\t\t\t    scaling_interpolate);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"inetd\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, inetd);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"privremote\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, priv_remote);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unsafe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !safe_remote_only);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"safer\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, more_safe);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"nocmds\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, no_external_cmds);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwdfile\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(passwdfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_nis\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, unixpw_nis);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"unixpw_list\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(unixpw_list));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_openssl);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ssl_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(openssl_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sslverify\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(ssl_verify));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_stunnel);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"stunnel_pem\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(stunnel_pem));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"https\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_num);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"httpsredir\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, https_port_redir);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"usepw\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, usepw);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"using_shm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, !using_shm);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"logfile\") || !strcmp(p, \"o\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(logfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"flag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rmflag\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(rm_flagfile));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rc\")) {\n\t\t\tchar *s = rc_rcfile;\n\t\t\tif (rc_rcfile_default) {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(s));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"norc\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, got_norc);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"h\") || !strcmp(p, \"help\") ||\n\t\t    !strcmp(p, \"V\") || !strcmp(p, \"version\") ||\n\t\t    !strcmp(p, \"lastmod\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(lastmod));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bg\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, opts_bg);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"sigpipe\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, NONUL(sigpipe));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"threads\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, use_threads);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"readrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_read_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netrate\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_rate());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"netlatency\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, get_net_latency());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pipeinput\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p,\n\t\t\t    NONUL(pipeinput_str));\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"clients\")) {\n\t\t\tchar *str = list_clients();\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%s\", p, str);\n\t\t\tfree(str);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"client_count\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, client_count);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pid\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, (int) getpid());\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtest\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtest_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xtrap\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xtrap_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrecord\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrecord_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xkb\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xkb_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xshm\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xshm_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xinerama\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xinerama_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_overlay\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, overlay_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xfixes\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xfixes_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xdamage\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xdamage_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"ext_xrandr\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, xrandr_present);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rootwin\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p,\n\t\t\t    (unsigned int) rootwin);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"num_buttons\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, num_buttons);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"button_mask\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, button_mask);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"mouse_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cursor_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"grab_state\")) {\n\t\t\tint ptr_grabbed, kbd_grabbed;\n\n\t\t\tgrab_state(&ptr_grabbed, &kbd_grabbed);\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, ptr_grabbed, kbd_grabbed);\n\t\t\tif (dpy && rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: ptr,kbd: %s\\n\", buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"pointer_pos\") || !strcmp(p, \"pointer_x\") || !strcmp(p, \"pointer_y\") || !strcmp(p, \"pointer_same\") || !strcmp(p, \"pointer_root\") || !strcmp(p, \"pointer_mask\")) {\n\t\t\tint px = -1, py = -1; \n\t\t\tint wx, wy;\n\t\t\tunsigned int m = 0;\n\t\t\tWindow r, c;\n\t\t\tBool same_screen = True;\n\t\t\t\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) rootwin);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (!dpy) {\n\t\t\t\tgoto qry;\n\t\t\t}\n#if NO_X11\n\t\t\tgoto qry;\n#else\n\t\t\tX_LOCK;\n\t\t\tsame_screen = XQueryPointer_wr(dpy, rootwin, &r, &c, &px, &py, &wx, &wy, &m);\n\t\t\tX_UNLOCK;\n#endif\n\n\t\t\tif (!strcmp(p, \"pointer_pos\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d,%d\", p, px, py);\n\t\t\t} else if (!strcmp(p, \"pointer_x\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, px);\n\t\t\t} else if (!strcmp(p, \"pointer_y\")) {\t\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, py);\n\t\t\t} else if (!strcmp(p, \"pointer_same\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, same_screen);\n\t\t\t} else if (!strcmp(p, \"pointer_root\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, (unsigned int) r);\n\t\t\t} else if (!strcmp(p, \"pointer_mask\")) {\t\t/* skip-cmd-list */\n\t\t\t\tsnprintf(buf, bufn, \"aro=%s:0x%x\", p, m);\n\t\t\t} \n\t\t\tif (rc_npieces < 10) {\n\t\t\t\trfbLog(\"remote_cmd: %s: %s\\n\", p, buf);\n\t\t\t}\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"bpp\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, bpp);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"depth\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, depth);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"indexed_color\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, indexed_color);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"dpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, dpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"wdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, wdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"off_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, off_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"cdpy_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, cdpy_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_x\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_x);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"coff_y\")) {\n\t\t\tsnprintf(buf, bufn, \"aro=%s:%d\", p, coff_y);\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"rfbauth\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"passwd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (!strcmp(p, \"viewpasswd\")) {\n\t\t\tNOTAPPRO\n\t\t\tgoto qry;\n\t\t}\n\t\tif (1) {\n\t\t\tNOTAPP\n\t\t\tgoto qry;\n\t\t}\n\t\tgoto done;\n\t}\n\tif (1) {\n\t\tchar tmp[100];\n\t\tNOTAPP\n\t\trfbLog(\"remote_cmd: warning unknown\\n\");\n\t\tstrncpy(tmp, p, 90);\n\t\trfbLog(\"command \\\"%s\\\"\\n\", tmp);\n\t\tgoto done;\n\t}\n\n\tdone:\n\n\tif (*buf == '\\0') {\n\t\tsprintf(buf, \"%s\", \"ack=1\");\n\t}\n\n\tqry:\n\n\tif (stringonly) {\n\t\treturn strdup(buf);\n\t} else if (client_connect_file) {\n\t\tFILE *out = fopen(client_connect_file, \"w\");\n\t\tif (out != NULL) {\n\t\t\tfprintf(out, \"%s\\n\", buf);\n\t\t\tfclose(out);\n\t\t\tusleep(20*1000);\n\t\t}\n\t} else {\n\t\tif (dpy) {\t/* raw_fb hack */\n\t\t\tX_LOCK;\n\t\t\tset_x11vnc_remote_prop(buf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tX_UNLOCK;\n\t\t}\n\t}\n#endif\t/* REMOTE_CONTROL */\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "x11vnc_remote_str",
            "\"%s\"",
            "tmp"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%s\\n\"",
            "tmp"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "client_connect_file",
            "\"w\""
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"remote_prefix command: '%s'\\n\"",
            "tmp"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "tmp",
            "rcmd",
            "len - strlen(remote_prefix)"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remote_prefix"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tmp",
            "\"qry=\""
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcmd",
            "\"qry=\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcmd",
            "\"cmd=\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len + 8",
            "1"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remote_prefix"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "text",
            "remote_prefix"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_allowed_input",
          "args": [
            "cl",
            "&input"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "get_allowed_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2791-2847",
          "snippet": "void get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *short_kmbcf(char *str);",
            "void get_allowed_input(rfbClientPtr client, allowed_input_t *input);",
            "void keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);",
            "static void add_dead_keysyms(char *str);",
            "static void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);",
            "static void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nchar *short_kmbcf(char *str);\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input);\nvoid keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\nstatic void add_dead_keysyms(char *str);\nstatic void xkb_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void modifier_tweak_keyboard(rfbBool down, rfbKeySym keysym,\n    rfbClientPtr client);\nstatic void pipe_keyboard(rfbBool down, rfbKeySym keysym, rfbClientPtr client);\n\nvoid get_allowed_input(rfbClientPtr client, allowed_input_t *input) {\n\tClientData *cd;\n\tchar *str;\n\n\tinput->keystroke = 0;\n\tinput->motion    = 0;\n\tinput->button    = 0;\n\tinput->clipboard = 0;\n\tinput->files     = 0;\n\n\tif (! client) {\n\t\tinput->keystroke = 1;\n\t\tinput->motion    = 1;\n\t\tinput->button    = 1;\n\t\tinput->clipboard = 1;\n\t\tinput->files     = 1;\n\t\treturn;\n\t}\n\n\tcd = (ClientData *) client->clientData;\n\n\tif (! cd) {\n\t\treturn;\n\t}\n\t\n\tif (cd->input[0] != '-') {\n\t\tstr = cd->input;\n\t} else if (client->viewOnly) {\n\t\tif (allowed_input_view_only) {\n\t\t\tstr = allowed_input_view_only;\n\t\t} else {\n\t\t\tstr = \"\";\n\t\t}\n\t} else {\n\t\tif (allowed_input_normal) {\n\t\t\tstr = allowed_input_normal;\n\t\t} else {\n\t\t\tstr = \"KMBCF\";\n\t\t}\n\t}\nif (0) fprintf(stderr, \"GAI: %s - %s\\n\", str, cd->input);\n\n\twhile (*str) {\n\t\tif (*str == 'K') {\n\t\t\tinput->keystroke = 1;\n\t\t} else if (*str == 'M') {\n\t\t\tinput->motion = 1;\n\t\t} else if (*str == 'B') {\n\t\t\tinput->button = 1;\n\t\t} else if (*str == 'C') {\n\t\t\tinput->clipboard = 1;\n\t\t} else if (*str == 'F') {\n\t\t\tinput->files = 1;\n\t\t}\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"xcut_receive: unixpw_in_progress, skipping.\\n\""
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl);\nvoid kbd_release_all_keys(rfbClientPtr cl);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nint get_file_transfer_permitted(rfbClientPtr cl);\nvoid get_prop(char *str, int len, Atom prop, Window w);\nextern int rawfb_vnc_reflect;\n\nvoid xcut_receive(char *text, int len, rfbClientPtr cl) {\n\tallowed_input_t input;\n\n\tif (threads_drop_input) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) {\n\t\trfbLog(\"xcut_receive: unixpw_in_progress, skipping.\\n\");\n\t\treturn;\n\t}\n\n\tif (!watch_selection) {\n\t\treturn;\n\t}\n\tif (view_only) {\n\t\treturn;\n\t}\n\tif (text == NULL || len == 0) {\n\t\treturn;\n\t}\n\tget_allowed_input(cl, &input);\n\tif (!input.clipboard) {\n\t\treturn;\n\t}\n\tINPUT_LOCK;\n\n\tif (remote_prefix != NULL && strstr(text, remote_prefix) == text) {\n\t\tchar *result, *rcmd = text + strlen(remote_prefix);\n\t\tchar *tmp = (char *) calloc(len + 8, 1);\n\n\t\tif (strstr(rcmd, \"cmd=\") != rcmd && strstr(rcmd, \"qry=\") != rcmd) {\n\t\t\tstrcat(tmp, \"qry=\");\n\t\t}\n\t\tstrncat(tmp, rcmd, len - strlen(remote_prefix));\n\t\trfbLog(\"remote_prefix command: '%s'\\n\", tmp);\n\n\t\tif (use_threads) {\n\t\t\tif (client_connect_file) {\n\t\t\t\tFILE *f = fopen(client_connect_file, \"w\");\n\t\t\t\tif (f) {\n\t\t\t\t\tfprintf(f, \"%s\\n\", tmp);\n\t\t\t\t\tfclose(f);\n\t\t\t\t\tfree(tmp);\n\t\t\t\t\tINPUT_UNLOCK;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vnc_connect) {\n\t\t\t\tsprintf(x11vnc_remote_str, \"%s\", tmp);\n\t\t\t\tfree(tmp);\n\t\t\t\tINPUT_UNLOCK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tINPUT_UNLOCK;\n\n\n\t\tresult = process_remote_cmd(tmp, 1);\n\t\tif (result == NULL ) {\n\t\t\tresult = strdup(\"null\");\n\t\t} else if (!strcmp(result, \"\")) {\n\t\t\tfree(result);\n\t\t\tresult = strdup(\"none\");\n\t\t}\n\t\trfbLog(\"remote_prefix result:  '%s'\\n\", result);\n\n\t\tfree(tmp);\n\t\ttmp = (char *) calloc(strlen(remote_prefix) + strlen(result) + 1, 1);\n\n\t\tstrcat(tmp, remote_prefix);\n\t\tstrcat(tmp, result);\n\t\tfree(result);\n\n\t\trfbSendServerCutText(screen, tmp, strlen(tmp));\n\t\tfree(tmp);\n\n\t\treturn;\n\t}\n\n\tif (! check_sel_direction(\"recv\", \"xcut_receive\", text, len)) {\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_set_sel(text, len);\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n#endif\n\n\tif (rawfb_vnc_reflect) {\n\t\tvnc_reflect_send_cuttext(text, len);\n\t\tINPUT_UNLOCK;\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\tINPUT_UNLOCK;\n\treturn;\n#else\n\n\tX_LOCK;\n\n\t/* associate this text with PRIMARY (and SECONDARY...) */\n\tif (set_primary && ! own_primary && selwin != None) {\n\t\town_primary = 1;\n\t\t/* we need to grab the PRIMARY selection */\n\t\tXSetSelectionOwner(dpy, XA_PRIMARY, selwin, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Own PRIMARY.\\n\");\n\t\t}\n\t}\n\n\tif (set_clipboard && ! own_clipboard && clipboard_atom != None && selwin != None) {\n\t\town_clipboard = 1;\n\t\t/* we need to grab the CLIPBOARD selection */\n\t\tXSetSelectionOwner(dpy, clipboard_atom, selwin, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Own CLIPBOARD.\\n\");\n\t\t}\n\t}\n\n\t/* duplicate the text string for our own use. */\n\tif (set_primary) {\n\t\tif (xcut_str_primary != NULL) {\n\t\t\tfree(xcut_str_primary);\n\t\t\txcut_str_primary = NULL;\n\t\t}\n\t\txcut_str_primary = (char *) malloc((size_t) (len+1));\n\t\tstrncpy(xcut_str_primary, text, len);\n\t\txcut_str_primary[len] = '\\0';\t/* make sure null terminated */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Set PRIMARY   '%s'\\n\", xcut_str_primary);\n\t\t}\n\t}\n\tif (set_clipboard) {\n\t\tif (xcut_str_clipboard != NULL) {\n\t\t\tfree(xcut_str_clipboard);\n\t\t\txcut_str_clipboard = NULL;\n\t\t}\n\t\txcut_str_clipboard = (char *) malloc((size_t) (len+1));\n\t\tstrncpy(xcut_str_clipboard, text, len);\n\t\txcut_str_clipboard[len] = '\\0';\t/* make sure null terminated */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"Set CLIPBOARD '%s'\\n\", xcut_str_clipboard);\n\t\t}\n\t}\n\n\t/* copy this text to CUT_BUFFER0 as well: */\n\tXChangeProperty(dpy, rootwin, XA_CUT_BUFFER0, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *) text, len);\n\tXFlush_wr(dpy);\n\n\tX_UNLOCK;\n\tINPUT_UNLOCK;\n\n\tset_cutbuffer = 1;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "check_xevents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1203-1675",
    "snippet": "void check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define DEBUG_XEVENTS 1"
    ],
    "globals_used": [
      "int sync_tod_delay = 20;",
      "void sync_tod_with_servertime(void);",
      "void set_prop_atom(Atom atom);",
      "void check_xevents(int reset);",
      "void set_server_input(rfbClientPtr cl, int s);",
      "void set_text_chat(rfbClientPtr cl, int l, char *t);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
      "static void initialize_xevents(int reset);",
      "static void print_xevent_bases(void);",
      "static void bust_grab(int reset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XNextEvent",
          "args": [
            "gdpy_ctrl",
            "&xev"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "gdpy_ctrl",
            "QueuedAlready"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XNextEvent",
          "args": [
            "rdpy_ctrl",
            "&xev"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "rdpy_ctrl",
            "QueuedAlready"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "True"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\""
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\"",
            "qlen"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "dpy",
            "QueuedAlready"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XPutBackEvent",
          "args": [
            "dpy",
            "xevs+k"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\"",
            "n",
            "(n >= ev_size) ? \"+\" : \"\"",
            "i"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "i",
            "xevs+n"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Total events queued: %d\\n\"",
            "tot"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_xevent_bases",
          "args": [],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "print_xevent_bases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "436-446",
          "snippet": "static void print_xevent_bases(void) {\n\tfprintf(stderr, \"X event bases: xkb=%d, xtest=%d, xrandr=%d, \"\n\t    \"xfixes=%d, xdamage=%d, xtrap=%d\\n\", xkb_base_event_type,\n\t    xtest_base_event_type, xrandr_base_event_type,\n\t    xfixes_base_event_type, xdamage_base_event_type,\n\t    xtrap_base_event_type);\n\tfprintf(stderr, \"  MapNotify=%d, ClientMsg=%d PropNotify=%d \"\n\t    \"SelNotify=%d, SelRequest=%d\\n\", MappingNotify, ClientMessage,\n\t    PropertyNotify, SelectionNotify, SelectionRequest);\n\tfprintf(stderr, \"  SelClear=%d, Expose=%d\\n\", SelectionClear, Expose);\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void print_xevent_bases(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void print_xevent_bases(void);\n\nstatic void print_xevent_bases(void) {\n\tfprintf(stderr, \"X event bases: xkb=%d, xtest=%d, xrandr=%d, \"\n\t    \"xfixes=%d, xdamage=%d, xtrap=%d\\n\", xkb_base_event_type,\n\t    xtest_base_event_type, xrandr_base_event_type,\n\t    xfixes_base_event_type, xdamage_base_event_type,\n\t    xtrap_base_event_type);\n\tfprintf(stderr, \"  MapNotify=%d, ClientMsg=%d PropNotify=%d \"\n\t    \"SelNotify=%d, SelRequest=%d\\n\", MappingNotify, ClientMessage,\n\t    PropertyNotify, SelectionNotify, SelectionRequest);\n\tfprintf(stderr, \"  SelClear=%d, Expose=%d\\n\", SelectionClear, Expose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "dpy",
            "QueuedAlready"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_REMINDER_RATE\")"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REMINDER_RATE\""
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REMINDER_RATE\""
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tray_embed",
          "args": [
            "tray_request",
            "tray_unembed"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "tray_embed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/gui.c",
          "lines": "107-214",
          "snippet": "int tray_embed(Window iconwin, int remove) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!iconwin || !remove) {}\n\treturn 0;\n#else\n\tXEvent ev;\n\tXErrorHandler old_handler;\n\tWindow manager;\n\tAtom xembed_info;\n\tAtom tatom;\n\tXWindowAttributes attr;\n\tlong info[2] = {XEMBED_VERSION, XEMBED_MAPPED};\n\tlong data = 0;\n\n\tRAWFB_RET(0)\n\n\tif (remove) {\n\t\tif (!valid_window(iconwin, &attr, 1)) {\n\t\t\treturn 0;\n\t\t}\n\t\ticonwin = tweak_tk_window_id(iconwin);\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t/*\n\t\t * unfortunately no desktops seem to obey this\n\t\t * part of the XEMBED spec yet...\n\t\t */\n\t\tXReparentWindow(dpy, iconwin, rootwin, 0, 0);\n\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ttrapped_xerror = 0;\n\t\treturn 1;\n\t}\n\n\txembed_info = XInternAtom(dpy, \"_XEMBED_INFO\", False);\n\tif (xembed_info == None) {\n\t\treturn 0;\n\t}\n\n\tif (!tray_manager_running(dpy, &manager)) {\n\t\treturn 0;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.xclient.type = ClientMessage;\n\tev.xclient.window = manager;\n\tev.xclient.message_type = XInternAtom(dpy, \"_NET_SYSTEM_TRAY_OPCODE\",\n\t    False);\n\tev.xclient.format = 32;\n\tev.xclient.data.l[0] = CurrentTime;\n\tev.xclient.data.l[1] = SYSTEM_TRAY_REQUEST_DOCK;\n\tev.xclient.data.l[2] = iconwin;\n\tev.xclient.data.l[3] = 0;\n\tev.xclient.data.l[4] = 0;\n\n\tif (!valid_window(iconwin, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\ticonwin = tweak_tk_window_id(iconwin);\n\tev.xclient.data.l[2] = iconwin;\n\n\tXUnmapWindow(dpy, iconwin);\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tXSendEvent(dpy, manager, False, NoEventMask, &ev);\n\tXSync(dpy, False);\n\n\tif (trapped_xerror) {\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\n\tXChangeProperty(dpy, iconwin, xembed_info, xembed_info, 32,\n\t    PropModeReplace, (unsigned char *)&info, 2);\n\n#if 0\n{\nXSizeHints *xszh = XAllocSizeHints();\nxszh->flags = PMinSize;\nxszh->min_width = 24;\nxszh->min_height = 24;\nXSetWMNormalHints(dpy, iconwin, xszh);\n}\n#endif\n\n\t/* kludge for KDE evidently needed... */\n\ttatom = XInternAtom(dpy, \"KWM_DOCKWINDOW\", False);\n\tXChangeProperty(dpy, iconwin, tatom, tatom, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\ttatom = XInternAtom(dpy, \"_KDE_NET_WM_SYSTEM_TRAY_WINDOW_FOR\", False);\n\tXChangeProperty(dpy, iconwin, tatom, XA_WINDOW, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"tkx11vnc.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"remote.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define XEMBED_MAPPED  (1 << 0)",
            "#define XEMBED_VERSION 0",
            "#define SYSTEM_TRAY_REQUEST_DOCK    0"
          ],
          "globals_used": [
            "int tray_embed(Window iconwin, int remove);",
            "static int tray_manager_running(Display *d, Window *manager);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tkx11vnc.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"remote.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define XEMBED_MAPPED  (1 << 0)\n#define XEMBED_VERSION 0\n#define SYSTEM_TRAY_REQUEST_DOCK    0\n\nint tray_embed(Window iconwin, int remove);\nstatic int tray_manager_running(Display *d, Window *manager);\n\nint tray_embed(Window iconwin, int remove) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!iconwin || !remove) {}\n\treturn 0;\n#else\n\tXEvent ev;\n\tXErrorHandler old_handler;\n\tWindow manager;\n\tAtom xembed_info;\n\tAtom tatom;\n\tXWindowAttributes attr;\n\tlong info[2] = {XEMBED_VERSION, XEMBED_MAPPED};\n\tlong data = 0;\n\n\tRAWFB_RET(0)\n\n\tif (remove) {\n\t\tif (!valid_window(iconwin, &attr, 1)) {\n\t\t\treturn 0;\n\t\t}\n\t\ticonwin = tweak_tk_window_id(iconwin);\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\t/*\n\t\t * unfortunately no desktops seem to obey this\n\t\t * part of the XEMBED spec yet...\n\t\t */\n\t\tXReparentWindow(dpy, iconwin, rootwin, 0, 0);\n\n\t\tXSetErrorHandler(old_handler);\n\t\tif (trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\treturn 0;\n\t\t}\n\t\ttrapped_xerror = 0;\n\t\treturn 1;\n\t}\n\n\txembed_info = XInternAtom(dpy, \"_XEMBED_INFO\", False);\n\tif (xembed_info == None) {\n\t\treturn 0;\n\t}\n\n\tif (!tray_manager_running(dpy, &manager)) {\n\t\treturn 0;\n\t}\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.xclient.type = ClientMessage;\n\tev.xclient.window = manager;\n\tev.xclient.message_type = XInternAtom(dpy, \"_NET_SYSTEM_TRAY_OPCODE\",\n\t    False);\n\tev.xclient.format = 32;\n\tev.xclient.data.l[0] = CurrentTime;\n\tev.xclient.data.l[1] = SYSTEM_TRAY_REQUEST_DOCK;\n\tev.xclient.data.l[2] = iconwin;\n\tev.xclient.data.l[3] = 0;\n\tev.xclient.data.l[4] = 0;\n\n\tif (!valid_window(iconwin, &attr, 1)) {\n\t\treturn 0;\n\t}\n\n\ticonwin = tweak_tk_window_id(iconwin);\n\tev.xclient.data.l[2] = iconwin;\n\n\tXUnmapWindow(dpy, iconwin);\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tXSendEvent(dpy, manager, False, NoEventMask, &ev);\n\tXSync(dpy, False);\n\n\tif (trapped_xerror) {\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\n\tXChangeProperty(dpy, iconwin, xembed_info, xembed_info, 32,\n\t    PropModeReplace, (unsigned char *)&info, 2);\n\n#if 0\n{\nXSizeHints *xszh = XAllocSizeHints();\nxszh->flags = PMinSize;\nxszh->min_width = 24;\nxszh->min_height = 24;\nXSetWMNormalHints(dpy, iconwin, xszh);\n}\n#endif\n\n\t/* kludge for KDE evidently needed... */\n\ttatom = XInternAtom(dpy, \"KWM_DOCKWINDOW\", False);\n\tXChangeProperty(dpy, iconwin, tatom, tatom, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\ttatom = XInternAtom(dpy, \"_KDE_NET_WM_SYSTEM_TRAY_WINDOW_FOR\", False);\n\tXChangeProperty(dpy, iconwin, tatom, XA_WINDOW, 32, PropModeReplace,\n\t    (unsigned char *)&data, 1);\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_bell_event",
          "args": [],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "check_bell_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xkb_bell.c",
          "lines": "145-145",
          "snippet": "void check_bell_event(void) {}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_bell_event(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_bell_event(void);\n\nvoid check_bell_event(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Released CLIPBOARD.\\n\""
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xcut_str_clipboard"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Released PRIMARY.\\n\""
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "SelectionClear",
            "&xev"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selection_request",
          "args": [
            "&xev",
            "\"CLIPBOARD\""
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "selection_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
          "lines": "90-257",
          "snippet": "void selection_request(XEvent *ev, char *type) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev || !type) {}\n\treturn;\n#else\n\tXSelectionEvent notify_event;\n\tXSelectionRequestEvent *req_event;\n\tXErrorHandler old_handler;\n\tchar *str;\n\tunsigned int length;\n\tunsigned char *data;\n\tstatic Atom xa_targets = None;\n\tstatic int sync_it = -1;\n# ifndef XA_LENGTH\n\tunsigned long XA_LENGTH;\n# endif\n\tRAWFB_RET_VOID\n\n# ifndef XA_LENGTH\n\tXA_LENGTH = XInternAtom(dpy, \"LENGTH\", True);\n# endif\n\n\tif (sync_it < 0) {\n\t\tif (getenv(\"X11VNC_SENDEVENT_SYNC\")) {\n\t\t\tsync_it = 1;\n\t\t} else {\n\t\t\tsync_it = 0;\n\t\t}\n\t}\n\n\treq_event = &(ev->xselectionrequest);\n\tnotify_event.type \t= SelectionNotify;\n\tnotify_event.display\t= req_event->display;\n\tnotify_event.requestor\t= req_event->requestor;\n\tnotify_event.selection\t= req_event->selection;\n\tnotify_event.target\t= req_event->target;\n\tnotify_event.time\t= req_event->time;\n\n\tif (req_event->property == None) {\n\t\tnotify_event.property = req_event->target;\n\t} else {\n\t\tnotify_event.property = req_event->property;\n\t}\n\n\tif (!strcmp(type, \"PRIMARY\")) {\n\t\tstr = xcut_str_primary;\n\t} else if (!strcmp(type, \"CLIPBOARD\")) {\n\t\tstr = xcut_str_clipboard;\n\t} else {\n\t\treturn;\n\t}\n\tif (str) {\n\t\tlength = strlen(str);\n\t} else {\n\t\tlength = 0;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"%s\\trequest event:   owner=0x%x requestor=0x%x sel=%03d targ=%d prop=%d\\n\",\n\t\t\ttype, req_event->owner, req_event->requestor, req_event->selection,\n\t\t\treq_event->target, req_event->property);\n\t}\n\n\tif (xa_targets == None) {\n\t\txa_targets = XInternAtom(dpy, \"TARGETS\", False);\n\t}\n\n\t/* the window may have gone away, so trap errors */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (ev->xselectionrequest.target == XA_LENGTH) {\n\t\t/* length request */\n\t\tint ret;\n\t\tlong llength = (long) length;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) &llength, 1);\t/* had sizeof(unsigned int) = 4 before... */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"LENGTH: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\n\t} else if (xa_targets != None && ev->xselectionrequest.target == xa_targets) {\n\t\t/* targets request */\n\t\tint ret;\n\t\tAtom targets[2];\n\t\ttargets[0] = (Atom) xa_targets;\n\t\ttargets[1] = (Atom) XA_STRING;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) targets, 2);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"TARGETS: XChangeProperty() -> %d -- sz1: %d  sz2: %d\\n\",\n\t\t\t    ret, sizeof(targets[0]), sizeof(targets)/sizeof(targets[0]));\n\t\t}\n\n\t} else {\n\t\t/* data request */\n\t\tint ret;\n\n\t\tdata = (unsigned char *)str;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 8, PropModeReplace,\n\t\t    data, length);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"DATA: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\t}\n\n\tif (! trapped_xerror) {\n\t\tint ret = -2, skip_it = 0, ms = 0;\n\t\tdouble now = dnow();\n\t\tstatic double last_check = 0.0;\n\n\t\tif (now > last_check + 0.2) {\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (!valid_window(req_event->requestor , NULL, 1)) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"selection_request: not a valid window: 0x%x\\n\",\n\t\t\t\t\t    req_event->requestor);\n\t\t\t\t}\n\t\t\t\tms = 10;\n\t\t\t}\n\t\t\tif (trapped_xerror) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t}\n\t\t\tlast_check = dnow();\n\t\t}\n\n\t\tif (!skip_it) {\n\t\t\tret = XSendEvent(req_event->display, req_event->requestor, False, 0,\n\t\t\t    (XEvent *)&notify_event);\n\t\t}\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"XSendEvent() -> %d\\n\", ret);\n\t\t}\n\t\tif (ms > 0) {\n\t\t\tusleep(ms * 1000);\n\t\t}\n\t}\n\tif (trapped_xerror) {\n\t\trfbLog(\"selection_request: ignored XError while sending \"\n\t\t    \"%s selection to 0x%x.\\n\", type, req_event->requestor);\n\t}\n\n\tXFlush_wr(dpy);\n\tif (sync_it) {\n\t\tusleep(10 * 1000);\n\t\tXSync(dpy, False);\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *xcut_str_primary = NULL;",
            "char *xcut_str_clipboard = NULL;",
            "void selection_request(XEvent *ev, char *type);",
            "void selection_send(XEvent *ev);",
            "void resend_selection(char *type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nchar *xcut_str_primary = NULL;\nchar *xcut_str_clipboard = NULL;\nvoid selection_request(XEvent *ev, char *type);\nvoid selection_send(XEvent *ev);\nvoid resend_selection(char *type);\n\nvoid selection_request(XEvent *ev, char *type) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev || !type) {}\n\treturn;\n#else\n\tXSelectionEvent notify_event;\n\tXSelectionRequestEvent *req_event;\n\tXErrorHandler old_handler;\n\tchar *str;\n\tunsigned int length;\n\tunsigned char *data;\n\tstatic Atom xa_targets = None;\n\tstatic int sync_it = -1;\n# ifndef XA_LENGTH\n\tunsigned long XA_LENGTH;\n# endif\n\tRAWFB_RET_VOID\n\n# ifndef XA_LENGTH\n\tXA_LENGTH = XInternAtom(dpy, \"LENGTH\", True);\n# endif\n\n\tif (sync_it < 0) {\n\t\tif (getenv(\"X11VNC_SENDEVENT_SYNC\")) {\n\t\t\tsync_it = 1;\n\t\t} else {\n\t\t\tsync_it = 0;\n\t\t}\n\t}\n\n\treq_event = &(ev->xselectionrequest);\n\tnotify_event.type \t= SelectionNotify;\n\tnotify_event.display\t= req_event->display;\n\tnotify_event.requestor\t= req_event->requestor;\n\tnotify_event.selection\t= req_event->selection;\n\tnotify_event.target\t= req_event->target;\n\tnotify_event.time\t= req_event->time;\n\n\tif (req_event->property == None) {\n\t\tnotify_event.property = req_event->target;\n\t} else {\n\t\tnotify_event.property = req_event->property;\n\t}\n\n\tif (!strcmp(type, \"PRIMARY\")) {\n\t\tstr = xcut_str_primary;\n\t} else if (!strcmp(type, \"CLIPBOARD\")) {\n\t\tstr = xcut_str_clipboard;\n\t} else {\n\t\treturn;\n\t}\n\tif (str) {\n\t\tlength = strlen(str);\n\t} else {\n\t\tlength = 0;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"%s\\trequest event:   owner=0x%x requestor=0x%x sel=%03d targ=%d prop=%d\\n\",\n\t\t\ttype, req_event->owner, req_event->requestor, req_event->selection,\n\t\t\treq_event->target, req_event->property);\n\t}\n\n\tif (xa_targets == None) {\n\t\txa_targets = XInternAtom(dpy, \"TARGETS\", False);\n\t}\n\n\t/* the window may have gone away, so trap errors */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (ev->xselectionrequest.target == XA_LENGTH) {\n\t\t/* length request */\n\t\tint ret;\n\t\tlong llength = (long) length;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) &llength, 1);\t/* had sizeof(unsigned int) = 4 before... */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"LENGTH: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\n\t} else if (xa_targets != None && ev->xselectionrequest.target == xa_targets) {\n\t\t/* targets request */\n\t\tint ret;\n\t\tAtom targets[2];\n\t\ttargets[0] = (Atom) xa_targets;\n\t\ttargets[1] = (Atom) XA_STRING;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 32, PropModeReplace,\n\t\t    (unsigned char *) targets, 2);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"TARGETS: XChangeProperty() -> %d -- sz1: %d  sz2: %d\\n\",\n\t\t\t    ret, sizeof(targets[0]), sizeof(targets)/sizeof(targets[0]));\n\t\t}\n\n\t} else {\n\t\t/* data request */\n\t\tint ret;\n\n\t\tdata = (unsigned char *)str;\n\n\t\tret = XChangeProperty(ev->xselectionrequest.display,\n\t\t    ev->xselectionrequest.requestor,\n\t\t    ev->xselectionrequest.property,\n\t\t    ev->xselectionrequest.target, 8, PropModeReplace,\n\t\t    data, length);\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"DATA: XChangeProperty() -> %d\\n\", ret);\n\t\t}\n\t}\n\n\tif (! trapped_xerror) {\n\t\tint ret = -2, skip_it = 0, ms = 0;\n\t\tdouble now = dnow();\n\t\tstatic double last_check = 0.0;\n\n\t\tif (now > last_check + 0.2) {\n\t\t\tXFlush_wr(dpy);\n\t\t\tif (!valid_window(req_event->requestor , NULL, 1)) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"selection_request: not a valid window: 0x%x\\n\",\n\t\t\t\t\t    req_event->requestor);\n\t\t\t\t}\n\t\t\t\tms = 10;\n\t\t\t}\n\t\t\tif (trapped_xerror) {\n\t\t\t\tsync_it = 1;\n\t\t\t\tskip_it = 1;\n\t\t\t}\n\t\t\tlast_check = dnow();\n\t\t}\n\n\t\tif (!skip_it) {\n\t\t\tret = XSendEvent(req_event->display, req_event->requestor, False, 0,\n\t\t\t    (XEvent *)&notify_event);\n\t\t}\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"XSendEvent() -> %d\\n\", ret);\n\t\t}\n\t\tif (ms > 0) {\n\t\t\tusleep(ms * 1000);\n\t\t}\n\t}\n\tif (trapped_xerror) {\n\t\trfbLog(\"selection_request: ignored XError while sending \"\n\t\t    \"%s selection to 0x%x.\\n\", type, req_event->requestor);\n\t}\n\n\tXFlush_wr(dpy);\n\tif (sync_it) {\n\t\tusleep(10 * 1000);\n\t\tXSync(dpy, False);\n\t}\n\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "SelectionRequest",
            "&xev"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"request %s\\n\"",
            "req"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XConvertSelection",
          "args": [
            "dpy",
            "atom",
            "XA_STRING",
            "XA_STRING",
            "selwin",
            "CurrentTime"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetSelectionOwner",
          "args": [
            "dpy",
            "atom"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selection_send",
          "args": [
            "&xev"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "selection_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
          "lines": "374-508",
          "snippet": "void selection_send(XEvent *ev) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, oldlen, newlen, toobig = 0, len;\n\tstatic int err = 0, sent_one = 0;\n\tchar before[CHKSZ], after[CHKSZ];\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar *selection_str;\n\n\tRAWFB_RET_VOID\n\t/*\n\t * remember info about our last value of PRIMARY (or CUT_BUFFER0)\n\t * so we can check for any changes below.\n\t */\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tif (! watch_primary) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = primary_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event PRIMARY   prop: %d  requestor: 0x%x  atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tif (! watch_clipboard) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = clipboard_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event CLIPBOARD prop: %d  requestor: 0x%x atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n\t\n\toldlen = strlen(selection_str);\n\tstrncpy(before, selection_str, CHKSZ);\n\n\tselection_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read in the current value of PRIMARY or CLIPBOARD: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, ev->xselection.requestor,\n\t\t    ev->xselection.property, nitems/4, PROP_MAX/16, True,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\ttoobig = 1;\n\t\t\t\tXFree_wr(data);\n\t\t\t\tif (err) {\t/* cut down on messages */\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\terr = 5;\n\t\t\t\t}\n\t\t\t\trfbLog(\"warning: truncating large PRIMARY\"\n\t\t\t\t    \"/CLIPBOARD selection > %d bytes.\\n\",\n\t\t\t\t    PROP_MAX);\n\t\t\t\tbreak;\n\t\t\t}\nif (debug_sel) fprintf(stderr, \"selection_send: data: '%s' dlen: %d nitems: %lu ba: %lu\\n\", data, dlen, nitems, bytes_after);\n\t\t\tmemcpy(selection_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tselection_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tif (! toobig) {\n\t\terr = 0;\n\t} else if (err) {\n\t\terr--;\n\t}\n\n\tif (! sent_one) {\n\t\t/* try to force a send first time in */\n\t\toldlen = -1;\n\t\tsent_one = 1;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"selection_send:  %s '%s'\\n\",\n\t\t    ev->xselection.selection == XA_PRIMARY ? \"PRIMARY  \" : \"CLIPBOARD\",\n\t\t    selection_str);\n\t}\n\n\t/* look for changes in the new value */\n\tnewlen = strlen(selection_str);\n\tstrncpy(after, selection_str, CHKSZ);\n\n\tif (oldlen == newlen && strncmp(before, after, CHKSZ) == 0) {\n\t\t/* evidently no change */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send:  no change.\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tif (newlen == 0) {\n\t\t/* do not bother sending a null string out */\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"selection_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tlen = newlen;\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tprimary_len = len;\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tclipboard_len = len;\n\t}\n\tif (check_sel_direction(\"send\", \"selection_send\", selection_str, len)) {\n\t\trfbSendServerCutText(screen, selection_str, len);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CHKSZ 32"
          ],
          "globals_used": [
            "Atom clipboard_atom = None;",
            "void selection_request(XEvent *ev, char *type);",
            "int check_sel_direction(char *dir, char *label, char *sel, int len);",
            "void selection_send(XEvent *ev);",
            "void resend_selection(char *type);",
            "static char primary_str[PROP_MAX+1];",
            "static char clipboard_str[PROP_MAX+1];",
            "static int primary_len   = 0;",
            "static int clipboard_len = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CHKSZ 32\n\nAtom clipboard_atom = None;\nvoid selection_request(XEvent *ev, char *type);\nint check_sel_direction(char *dir, char *label, char *sel, int len);\nvoid selection_send(XEvent *ev);\nvoid resend_selection(char *type);\nstatic char primary_str[PROP_MAX+1];\nstatic char clipboard_str[PROP_MAX+1];\nstatic int primary_len   = 0;\nstatic int clipboard_len = 0;\n\nvoid selection_send(XEvent *ev) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!ev) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, oldlen, newlen, toobig = 0, len;\n\tstatic int err = 0, sent_one = 0;\n\tchar before[CHKSZ], after[CHKSZ];\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tchar *selection_str;\n\n\tRAWFB_RET_VOID\n\t/*\n\t * remember info about our last value of PRIMARY (or CUT_BUFFER0)\n\t * so we can check for any changes below.\n\t */\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tif (! watch_primary) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = primary_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event PRIMARY   prop: %d  requestor: 0x%x  atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tif (! watch_clipboard) {\n\t\t\treturn;\n\t\t}\n\t\tselection_str = clipboard_str;\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send: event CLIPBOARD prop: %d  requestor: 0x%x atom: %d\\n\",\n\t\t\t    ev->xselection.property, ev->xselection.requestor, ev->xselection.selection);\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n\t\n\toldlen = strlen(selection_str);\n\tstrncpy(before, selection_str, CHKSZ);\n\n\tselection_str[0] = '\\0';\n\tslen = 0;\n\n\t/* read in the current value of PRIMARY or CLIPBOARD: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, ev->xselection.requestor,\n\t\t    ev->xselection.property, nitems/4, PROP_MAX/16, True,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\ttoobig = 1;\n\t\t\t\tXFree_wr(data);\n\t\t\t\tif (err) {\t/* cut down on messages */\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\terr = 5;\n\t\t\t\t}\n\t\t\t\trfbLog(\"warning: truncating large PRIMARY\"\n\t\t\t\t    \"/CLIPBOARD selection > %d bytes.\\n\",\n\t\t\t\t    PROP_MAX);\n\t\t\t\tbreak;\n\t\t\t}\nif (debug_sel) fprintf(stderr, \"selection_send: data: '%s' dlen: %d nitems: %lu ba: %lu\\n\", data, dlen, nitems, bytes_after);\n\t\t\tmemcpy(selection_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tselection_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tif (! toobig) {\n\t\terr = 0;\n\t} else if (err) {\n\t\terr--;\n\t}\n\n\tif (! sent_one) {\n\t\t/* try to force a send first time in */\n\t\toldlen = -1;\n\t\tsent_one = 1;\n\t}\n\tif (debug_sel) {\n\t\trfbLog(\"selection_send:  %s '%s'\\n\",\n\t\t    ev->xselection.selection == XA_PRIMARY ? \"PRIMARY  \" : \"CLIPBOARD\",\n\t\t    selection_str);\n\t}\n\n\t/* look for changes in the new value */\n\tnewlen = strlen(selection_str);\n\tstrncpy(after, selection_str, CHKSZ);\n\n\tif (oldlen == newlen && strncmp(before, after, CHKSZ) == 0) {\n\t\t/* evidently no change */\n\t\tif (debug_sel) {\n\t\t\trfbLog(\"selection_send:  no change.\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tif (newlen == 0) {\n\t\t/* do not bother sending a null string out */\n\t\treturn;\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"selection_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\n\tlen = newlen;\n\tif (ev->xselection.selection == XA_PRIMARY) {\n\t\tprimary_len = len;\n\t} else if (clipboard_atom && ev->xselection.selection == clipboard_atom)  {\n\t\tclipboard_len = len;\n\t}\n\tif (check_sel_direction(\"send\", \"selection_send\", selection_str, len)) {\n\t\trfbSendServerCutText(screen, selection_str, len);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "SelectionNotify",
            "&xev"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xfixes_base_event_type +\n\t\t    XFixesCursorNotify",
            "&xev"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_xrandr_event",
          "args": [
            "\"check_xevents\""
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "check_xrandr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "184-290",
          "snippet": "int check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrandr_present = 0;",
            "int xrandr_width  = -1;",
            "int xrandr_height = -1;",
            "int xrandr_rotation = -1;",
            "Time xrandr_timestamp = 0;",
            "Time xrandr_cfg_time = 0;",
            "int check_xrandr_event(char *msg);",
            "int known_xrandr_mode(char *s);",
            "static int handle_subwin_resize(char *msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nTime xrandr_timestamp = 0;\nTime xrandr_cfg_time = 0;\nint check_xrandr_event(char *msg);\nint known_xrandr_mode(char *s);\nstatic int handle_subwin_resize(char *msg);\n\nint check_xrandr_event(char *msg) {\n\tXEvent xev;\n\n\tRAWFB_RET(0)\n\n\t/* it is assumed that X_LOCK is on at this point. */\n\n\tif (subwin) {\n\t\treturn handle_subwin_resize(msg);\n\t}\n#if HAVE_LIBXRANDR\n\tif (! xrandr_present) {\n\t\treturn 0;\n\t}\n\tif (! xrandr && ! xrandr_maybe) {\n\t\treturn 0;\n\t}\n\n\n\tif (xrandr_base_event_type && XCheckTypedEvent(dpy,\n\t    xrandr_base_event_type + RRScreenChangeNotify, &xev)) {\n\t\tint do_change, qout = 0;\n\t\tstatic int first = 1;\n\t\tXRRScreenChangeNotifyEvent *rev;\n\n\t\trev = (XRRScreenChangeNotifyEvent *) &xev;\n\n\t\tif (first && ! xrandr) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tif (getenv(\"X11VNC_DEBUG_XRANDR\") == NULL) {\n\t\t\t\tqout = 1;\n\t\t\t}\n\t\t}\n\t\tfirst = 0;\n\t\t\t\n\t\trfbLog(\"check_xrandr_event():\\n\");\n\t\trfbLog(\"Detected XRANDR event at location '%s':\\n\", msg);\n\n\t\tif (qout) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"  serial:          %d\\n\", (int) rev->serial);\n\t\t\trfbLog(\"  timestamp:       %d\\n\", (int) rev->timestamp);\n\t\t\trfbLog(\"  cfg_timestamp:   %d\\n\", (int) rev->config_timestamp);\n\t\t\trfbLog(\"  size_id:         %d\\n\", (int) rev->size_index);\n\t\t\trfbLog(\"  sub_pixel:       %d\\n\", (int) rev->subpixel_order);\n\t\t\trfbLog(\"  rotation:        %d\\n\", (int) rev->rotation);\n\t\t\trfbLog(\"  width:           %d\\n\", (int) rev->width);\n\t\t\trfbLog(\"  height:          %d\\n\", (int) rev->height);\n\t\t\trfbLog(\"  mwidth:          %d mm\\n\", (int) rev->mwidth);\n\t\t\trfbLog(\"  mheight:         %d mm\\n\", (int) rev->mheight);\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"check_xrandr_event: previous WxH: %dx%d\\n\",\n\t\t\t    wdpy_x, wdpy_y);\n\t\t}\n\n\t\tif (wdpy_x == rev->width && wdpy_y == rev->height &&\n\t\t    xrandr_rotation == (int) rev->rotation) {\n\t\t\trfbLog(\"check_xrandr_event: no change detected.\\n\");\n\t\t\tdo_change = 0;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: \"\n\t\t\t\t    \"enabling full XRANDR trapping anyway.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_change = 1;\n\t\t\tif (! xrandr) {\n\t\t    \t\trfbLog(\"check_xrandr_event: Resize; \"\n\t\t\t\t    \"enabling full XRANDR trapping.\\n\");\n\t\t\t\txrandr = 1;\n\t\t\t}\n\t\t}\n\n\t\txrandr_width  = rev->width;\n\t\txrandr_height = rev->height;\n\t\txrandr_timestamp = rev->timestamp;\n\t\txrandr_cfg_time  = rev->config_timestamp;\n\t\txrandr_rotation = (int) rev->rotation;\n\n\t\tif (! qout) rfbLog(\"check_xrandr_event: updating config...\\n\");\n\t\tXRRUpdateConfiguration(&xev);\n\n\t\tif (do_change) {\n\t\t\t/* under do_change caller normally returns before its X_UNLOCK */\n\t\t\tX_UNLOCK;\n\t\t\thandle_xrandr_change(rev->width, rev->height);\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (qout) {\n\t\t\treturn do_change;\n\t\t}\n\t\trfbLog(\"check_xrandr_event: current  WxH: %dx%d\\n\",\n\t\t    XDisplayWidth(dpy, scr), XDisplayHeight(dpy, scr));\n\t\trfbLog(\"check_xrandr_event(): returning control to\"\n\t\t    \" caller...\\n\");\n\n\n\t\treturn do_change;\n\t}\n#else\n\txev.type = 0;\n#endif\n\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_tod_with_servertime",
          "args": [],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "sync_tod_with_servertime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "875-948",
          "snippet": "void sync_tod_with_servertime(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic Atom ticker_atom = None;\n\tXEvent xev;\n\tchar diff[128];\n\tstatic int seq = 0;\n\tstatic unsigned long xserver_ticks = 1;\n\tint i, db = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (atom_NET_ACTIVE_WINDOW == None) {\n\t\tatom_NET_ACTIVE_WINDOW = XInternAtom(dpy, \"_NET_ACTIVE_WINDOW\", True);\n\t}\n\tif (atom_NET_CURRENT_DESKTOP == None) {\n\t\tatom_NET_CURRENT_DESKTOP = XInternAtom(dpy, \"_NET_CURRENT_DESKTOP\", True);\n\t}\n\tif (atom_NET_CLIENT_LIST_STACKING == None) {\n\t\tatom_NET_CLIENT_LIST_STACKING = XInternAtom(dpy, \"_NET_CLIENT_LIST_STACKING\", True);\n\t}\n\tif (atom_XROOTPMAP_ID == None) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t}\n\n\tif (! ticker_atom) {\n\t\tchar *ticker_str = \"X11VNC_TICKER\";\n\t\tif (getenv(\"X11VNC_TICKER\")) {\n\t\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t\t}\n\t\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\t}\n\tif (! ticker_atom) {\n\t\treturn;\n\t}\n\n\tXSync(dpy, False);\n\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tset_prop_atom(xev.xproperty.atom);\n\t}\n\n\tsnprintf(diff, sizeof diff, \"%d/%08d/%lu/%.6f\", (int) getpid(), seq++,\n\t    xserver_ticks, servertime_diff); \n\tXChangeProperty(dpy, rootwin, ticker_atom, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *) diff, strlen(diff));\n\tXSync(dpy, False);\n\n\tfor (i=0; i < 10; i++) {\n\t\tint k, got = 0;\n\t\t\n\t\tfor (k=0; k < 5; k++) {\n\t\t\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\t\t\tif (xev.xproperty.atom == ticker_atom) {\n\t\t\t\t\tdouble stime;\n\t\t\t\t\t\n\t\t\t\t\txserver_ticks = xev.xproperty.time;\n\t\t\t\t\tstime = (double) xev.xproperty.time;\n\t\t\t\t\tstime = stime/1000.0;\n\t\t\t\t\tservertime_diff = dnow() - stime;\n\t\t\t\t\tif (db) rfbLog(\"set servertime_diff: \"\n\t\t\t\t\t    \"%.6f\\n\", servertime_diff);\n\t\t\t\t\tgot = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (got) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(1000);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sync_tod_with_servertime(void);",
            "void set_prop_atom(Atom atom);",
            "static int process_watch(char *str, int parent, int db);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid sync_tod_with_servertime(void);\nvoid set_prop_atom(Atom atom);\nstatic int process_watch(char *str, int parent, int db);\n\nvoid sync_tod_with_servertime(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic Atom ticker_atom = None;\n\tXEvent xev;\n\tchar diff[128];\n\tstatic int seq = 0;\n\tstatic unsigned long xserver_ticks = 1;\n\tint i, db = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (atom_NET_ACTIVE_WINDOW == None) {\n\t\tatom_NET_ACTIVE_WINDOW = XInternAtom(dpy, \"_NET_ACTIVE_WINDOW\", True);\n\t}\n\tif (atom_NET_CURRENT_DESKTOP == None) {\n\t\tatom_NET_CURRENT_DESKTOP = XInternAtom(dpy, \"_NET_CURRENT_DESKTOP\", True);\n\t}\n\tif (atom_NET_CLIENT_LIST_STACKING == None) {\n\t\tatom_NET_CLIENT_LIST_STACKING = XInternAtom(dpy, \"_NET_CLIENT_LIST_STACKING\", True);\n\t}\n\tif (atom_XROOTPMAP_ID == None) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t}\n\n\tif (! ticker_atom) {\n\t\tchar *ticker_str = \"X11VNC_TICKER\";\n\t\tif (getenv(\"X11VNC_TICKER\")) {\n\t\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t\t}\n\t\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\t}\n\tif (! ticker_atom) {\n\t\treturn;\n\t}\n\n\tXSync(dpy, False);\n\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tset_prop_atom(xev.xproperty.atom);\n\t}\n\n\tsnprintf(diff, sizeof diff, \"%d/%08d/%lu/%.6f\", (int) getpid(), seq++,\n\t    xserver_ticks, servertime_diff); \n\tXChangeProperty(dpy, rootwin, ticker_atom, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *) diff, strlen(diff));\n\tXSync(dpy, False);\n\n\tfor (i=0; i < 10; i++) {\n\t\tint k, got = 0;\n\t\t\n\t\tfor (k=0; k < 5; k++) {\n\t\t\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\t\t\tif (xev.xproperty.atom == ticker_atom) {\n\t\t\t\t\tdouble stime;\n\t\t\t\t\t\n\t\t\t\t\txserver_ticks = xev.xproperty.time;\n\t\t\t\t\tstime = (double) xev.xproperty.time;\n\t\t\t\t\tstime = stime/1000.0;\n\t\t\t\t\tservertime_diff = dnow() - stime;\n\t\t\t\t\tif (db) rfbLog(\"set servertime_diff: \"\n\t\t\t\t\t    \"%.6f\\n\", servertime_diff);\n\t\t\t\t\tgot = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (got) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(1000);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfac",
          "args": [],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "rfac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "454-473",
          "snippet": "double rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double rnow(void);",
            "double rfac(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble rnow(void);\ndouble rfac(void);\n\ndouble rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_x11vnc_remote_prop",
          "args": [
            "0"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "read_x11vnc_remote_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3106-3174",
          "snippet": "void read_x11vnc_remote_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tx11vnc_remote_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || x11vnc_remote_prop == None) {\n\t\t/* not active or problem with X11VNC_REMOTE atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into x11vnc_remote_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    x11vnc_remote_prop, nitems/4, X11VNC_REMOTE_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > X11VNC_REMOTE_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large X11VNC_REMOTE\"\n\t\t\t\t   \" string > %d bytes.\\n\", X11VNC_REMOTE_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(x11vnc_remote_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tx11vnc_remote_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tx11vnc_remote_str[X11VNC_REMOTE_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ans=stop:N/A,ans=quit:N/A,ans=\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"qry=stop,quit,exit\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ack=\") == x11vnc_remote_str) {\n\t\t;\n\t} else if (quiet && strstr(x11vnc_remote_str, \"qry=ping\") ==\n\t    x11vnc_remote_str) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"cmd=\") &&\n\t    strstr(x11vnc_remote_str, \"passwd\")) {\n\t\trfbLog(\"read X11VNC_REMOTE: *\\n\");\n\t} else if (strlen(x11vnc_remote_str) > 36) {\n\t\tchar trim[100]; \n\t\ttrim[0] = '\\0';\n\t\tstrncat(trim, x11vnc_remote_str, 36);\n\t\trfbLog(\"read X11VNC_REMOTE: %s ...\\n\", trim);\n\t\t\n\t} else {\n\t\trfbLog(\"read X11VNC_REMOTE: %s\\n\", x11vnc_remote_str);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char x11vnc_remote_str[X11VNC_REMOTE_MAX+1];",
            "Atom x11vnc_remote_prop = None;",
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "int cmd_ok(char *cmd);",
            "void read_x11vnc_remote_prop(int);",
            "void adjust_grabs(int grab, int quiet);",
            "int set_xprop(char *prop, Window win, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar x11vnc_remote_str[X11VNC_REMOTE_MAX+1];\nAtom x11vnc_remote_prop = None;\nint new_fb_size_clients(rfbScreenInfoPtr s);\nint cmd_ok(char *cmd);\nvoid read_x11vnc_remote_prop(int);\nvoid adjust_grabs(int grab, int quiet);\nint set_xprop(char *prop, Window win, char *value);\n\nvoid read_x11vnc_remote_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tx11vnc_remote_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || x11vnc_remote_prop == None) {\n\t\t/* not active or problem with X11VNC_REMOTE atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into x11vnc_remote_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    x11vnc_remote_prop, nitems/4, X11VNC_REMOTE_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > X11VNC_REMOTE_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large X11VNC_REMOTE\"\n\t\t\t\t   \" string > %d bytes.\\n\", X11VNC_REMOTE_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(x11vnc_remote_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tx11vnc_remote_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tx11vnc_remote_str[X11VNC_REMOTE_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ans=stop:N/A,ans=quit:N/A,ans=\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"qry=stop,quit,exit\")) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"ack=\") == x11vnc_remote_str) {\n\t\t;\n\t} else if (quiet && strstr(x11vnc_remote_str, \"qry=ping\") ==\n\t    x11vnc_remote_str) {\n\t\t;\n\t} else if (strstr(x11vnc_remote_str, \"cmd=\") &&\n\t    strstr(x11vnc_remote_str, \"passwd\")) {\n\t\trfbLog(\"read X11VNC_REMOTE: *\\n\");\n\t} else if (strlen(x11vnc_remote_str) > 36) {\n\t\tchar trim[100]; \n\t\ttrim[0] = '\\0';\n\t\tstrncat(trim, x11vnc_remote_str, 36);\n\t\trfbLog(\"read X11VNC_REMOTE: %s ...\\n\", trim);\n\t\t\n\t} else {\n\t\trfbLog(\"read X11VNC_REMOTE: %s\\n\", x11vnc_remote_str);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_vnc_connect_prop",
          "args": [
            "0"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "read_vnc_connect_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3054-3104",
          "snippet": "void read_vnc_connect_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tvnc_connect_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || vnc_connect_prop == None) {\n\t\t/* not active or problem with VNC_CONNECT atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into vnc_connect_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    vnc_connect_prop, nitems/4, VNC_CONNECT_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large VNC_CONNECT\"\n\t\t\t\t   \" string > %d bytes.\\n\", VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vnc_connect_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tvnc_connect_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tvnc_connect_str[VNC_CONNECT_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else {\n\t\trfbLog(\"read VNC_CONNECT: %s\\n\", vnc_connect_str);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char vnc_connect_str[VNC_CONNECT_MAX+1];",
            "Atom vnc_connect_prop = None;",
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void read_vnc_connect_prop(int);",
            "int set_xprop(char *prop, Window win, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar vnc_connect_str[VNC_CONNECT_MAX+1];\nAtom vnc_connect_prop = None;\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid read_vnc_connect_prop(int);\nint set_xprop(char *prop, Window win, char *value);\n\nvoid read_vnc_connect_prop(int nomsg) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!nomsg) {}\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\tint db = 1;\n\n\tvnc_connect_str[0] = '\\0';\n\tslen = 0;\n\n\tif (! vnc_connect || vnc_connect_prop == None) {\n\t\t/* not active or problem with VNC_CONNECT atom */\n\t\treturn;\n\t}\n\tRAWFB_RET_VOID\n\n\t/* read the property value into vnc_connect_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    vnc_connect_prop, nitems/4, VNC_CONNECT_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > VNC_CONNECT_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large VNC_CONNECT\"\n\t\t\t\t   \" string > %d bytes.\\n\", VNC_CONNECT_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vnc_connect_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tvnc_connect_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tvnc_connect_str[VNC_CONNECT_MAX] = '\\0';\n\tif (! db || nomsg) {\n\t\t;\n\t} else {\n\t\trfbLog(\"read VNC_CONNECT: %s\\n\", vnc_connect_str);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cutbuffer_send",
          "args": [],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "cutbuffer_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/selection.c",
          "lines": "298-358",
          "snippet": "void cutbuffer_send(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, len;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\n\tcutbuffer_str[0] = '\\0';\n\tslen = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* read the property value into cutbuffer_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    XA_CUT_BUFFER0, nitems/4, PROP_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large CUT_BUFFER0\"\n\t\t\t\t   \" selection > %d bytes.\\n\", PROP_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(cutbuffer_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tcutbuffer_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tcutbuffer_str[PROP_MAX] = '\\0';\n\n\tif (debug_sel) {\n\t\trfbLog(\"cutbuffer_send: '%s'\\n\", cutbuffer_str);\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"cutbuffer_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\tcutbuffer_len = len = strlen(cutbuffer_str);\n\tif (check_sel_direction(\"send\", \"cutbuffer_send\", cutbuffer_str, len)) {\n\t\trfbSendServerCutText(screen, cutbuffer_str, len);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void selection_request(XEvent *ev, char *type);",
            "int check_sel_direction(char *dir, char *label, char *sel, int len);",
            "void cutbuffer_send(void);",
            "void resend_selection(char *type);",
            "static char cutbuffer_str[PROP_MAX+1];",
            "static int cutbuffer_len = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid selection_request(XEvent *ev, char *type);\nint check_sel_direction(char *dir, char *label, char *sel, int len);\nvoid cutbuffer_send(void);\nvoid resend_selection(char *type);\nstatic char cutbuffer_str[PROP_MAX+1];\nstatic int cutbuffer_len = 0;\n\nvoid cutbuffer_send(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tAtom type;\n\tint format, slen, dlen, len;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n\n\tcutbuffer_str[0] = '\\0';\n\tslen = 0;\n\n\tRAWFB_RET_VOID\n\n\t/* read the property value into cutbuffer_str: */\n\tdo {\n\t\tif (XGetWindowProperty(dpy, DefaultRootWindow(dpy),\n\t\t    XA_CUT_BUFFER0, nitems/4, PROP_MAX/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > PROP_MAX) {\n\t\t\t\t/* too big */\n\t\t\t\trfbLog(\"warning: truncating large CUT_BUFFER0\"\n\t\t\t\t   \" selection > %d bytes.\\n\", PROP_MAX);\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(cutbuffer_str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tcutbuffer_str[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n\n\tcutbuffer_str[PROP_MAX] = '\\0';\n\n\tif (debug_sel) {\n\t\trfbLog(\"cutbuffer_send: '%s'\\n\", cutbuffer_str);\n\t}\n\n\tif (! all_clients_initialized()) {\n\t\trfbLog(\"cutbuffer_send: no send: uninitialized clients\\n\");\n\t\treturn; /* some clients initializing, cannot send */ \n\t}\n\tif (unixpw_in_progress) {\n\t\treturn;\n\t}\n\n\t/* now send it to any connected VNC clients (rfbServerCutText) */\n\tif (!screen) {\n\t\treturn;\n\t}\n\tcutbuffer_len = len = strlen(cutbuffer_str);\n\tif (check_sel_direction(\"send\", \"cutbuffer_send\", cutbuffer_str, len)) {\n\t\trfbSendServerCutText(screen, cutbuffer_str, len);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\"",
            "got_x11vnc_remote"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xevents: warning: %d vnc_connect events since last check.\\n\"",
            "got_vnc_connect"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_xevents: warning: %d cutbuffer events since last check.\\n\"",
            "got_cutbuffer"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PROP_DBG\""
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "PropertyNotify",
            "&xev"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_prop_atom",
          "args": [
            "xev.xproperty.atom"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "set_prop_atom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1191-1197",
          "snippet": "void set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_prop_atom(Atom atom);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_prop_atom(Atom atom);\n\nvoid set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "PropertyNotify",
            "&xev"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"subwin_obscured: %d -> %d\\n\"",
            "prev",
            "subwin_obscured"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "VisibilityNotify",
            "&xev"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "ClientMessage",
            "&xev"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "base",
            "&xev"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "base",
            "&xev"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_modtweak",
          "args": [],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_modtweak",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "2509-2613",
          "snippet": "void initialize_modtweak(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tKeySym keysym, *keymap;\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tint use_lowest_index = 0;\n\n\tif (use_xkb_modtweak) {\n\t\tinitialize_xkb_modtweak();\n\t\treturn;\n\t}\n\tmemset(modifiers, -1, sizeof(modifiers));\n\tfor (i=0; i<0x100; i++) {\n\t\tkeycodes[i] = NoSymbol;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (getenv(\"MODTWEAK_LOWEST\")) {\n\t\tuse_lowest_index = 1;\n\t}\n\n\tX_LOCK;\n\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t    &syms_per_keycode);\n\n\t/* handle alphabetic char with only one keysym (no upper + lower) */\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tKeySym lower, upper;\n\t\t/* 2nd one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 1];\n\t\tif (keysym != NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* 1st one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 0];\n\t\tif (keysym == NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\tXConvertCase(keysym, &lower, &upper);\n\t\tif (lower != upper) {\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 0] = lower;\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 1] = upper;\n\t\t}\n\t}\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tif (debug_keyboard) {\n\t\t\tif (i == minkey) {\n\t\t\t\trfbLog(\"initialize_modtweak: keycode -> \"\n\t\t\t\t    \"keysyms mapping info:\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"  %03d  \", i);\n\t\t}\n\t\tfor (j = 0; j < syms_per_keycode; j++) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\tchar *sym;\n#if 0\n\t\t\t\tsym =XKeysymToString(XKeycodeToKeysym_wr(dpy,i,j));\n#else\n\t\t\t\tkeysym = keymap[(i-minkey)*syms_per_keycode+j];\n\t\t\t\tsym = XKeysymToString(keysym);\n#endif\n\t\t\t\tfprintf(stderr, \"%-18s \", sym ? sym : \"null\");\n\t\t\t\tif (j == syms_per_keycode - 1) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j >= 4) {\n\t\t\t\t/*\n\t\t\t\t * Something wacky in the keymapping.\n\t\t\t\t * Ignore these non Shift/AltGr chords\n\t\t\t\t * for now... n.b. we try to automatically\n\t\t\t\t * switch to -xkb for this case.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif ( keysym >= ' ' && keysym < 0x100\n\t\t\t    && i == XKeysymToKeycode(dpy, keysym) ) {\n\t\t\t\tif (use_lowest_index && keycodes[keysym] != NoSymbol) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tkeycodes[keysym] = i;\n\t\t\t\tmodifiers[keysym] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tleft_shift_code = XKeysymToKeycode(dpy, XK_Shift_L);\n\tright_shift_code = XKeysymToKeycode(dpy, XK_Shift_R);\n\taltgr_code = XKeysymToKeycode(dpy, XK_Mode_switch);\n\tiso_level3_code = NoSymbol;\n#ifdef XK_ISO_Level3_Shift\n\tiso_level3_code = XKeysymToKeycode(dpy, XK_ISO_Level3_Shift);\n#endif\n\n\tXFree_wr ((void *) keymap);\n\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int add_keysym(KeySym keysym);",
            "void initialize_modtweak(void);",
            "static void initialize_xkb_modtweak(void);",
            "static char modifiers[0x100];",
            "static KeyCode keycodes[0x100];",
            "static KeyCode left_shift_code, right_shift_code, altgr_code, iso_level3_code;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint add_keysym(KeySym keysym);\nvoid initialize_modtweak(void);\nstatic void initialize_xkb_modtweak(void);\nstatic char modifiers[0x100];\nstatic KeyCode keycodes[0x100];\nstatic KeyCode left_shift_code, right_shift_code, altgr_code, iso_level3_code;\n\nvoid initialize_modtweak(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tKeySym keysym, *keymap;\n\tint i, j, minkey, maxkey, syms_per_keycode;\n\tint use_lowest_index = 0;\n\n\tif (use_xkb_modtweak) {\n\t\tinitialize_xkb_modtweak();\n\t\treturn;\n\t}\n\tmemset(modifiers, -1, sizeof(modifiers));\n\tfor (i=0; i<0x100; i++) {\n\t\tkeycodes[i] = NoSymbol;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tif (getenv(\"MODTWEAK_LOWEST\")) {\n\t\tuse_lowest_index = 1;\n\t}\n\n\tX_LOCK;\n\tXDisplayKeycodes(dpy, &minkey, &maxkey);\n\n\tkeymap = XGetKeyboardMapping(dpy, minkey, (maxkey - minkey + 1),\n\t    &syms_per_keycode);\n\n\t/* handle alphabetic char with only one keysym (no upper + lower) */\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tKeySym lower, upper;\n\t\t/* 2nd one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 1];\n\t\tif (keysym != NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* 1st one */\n\t\tkeysym = keymap[(i - minkey) * syms_per_keycode + 0];\n\t\tif (keysym == NoSymbol) {\n\t\t\tcontinue;\n\t\t}\n\t\tXConvertCase(keysym, &lower, &upper);\n\t\tif (lower != upper) {\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 0] = lower;\n\t\t\tkeymap[(i - minkey) * syms_per_keycode + 1] = upper;\n\t\t}\n\t}\n\tfor (i = minkey; i <= maxkey; i++) {\n\t\tif (debug_keyboard) {\n\t\t\tif (i == minkey) {\n\t\t\t\trfbLog(\"initialize_modtweak: keycode -> \"\n\t\t\t\t    \"keysyms mapping info:\\n\");\n\t\t\t}\n\t\t\tfprintf(stderr, \"  %03d  \", i);\n\t\t}\n\t\tfor (j = 0; j < syms_per_keycode; j++) {\n\t\t\tif (debug_keyboard) {\n\t\t\t\tchar *sym;\n#if 0\n\t\t\t\tsym =XKeysymToString(XKeycodeToKeysym_wr(dpy,i,j));\n#else\n\t\t\t\tkeysym = keymap[(i-minkey)*syms_per_keycode+j];\n\t\t\t\tsym = XKeysymToString(keysym);\n#endif\n\t\t\t\tfprintf(stderr, \"%-18s \", sym ? sym : \"null\");\n\t\t\t\tif (j == syms_per_keycode - 1) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j >= 4) {\n\t\t\t\t/*\n\t\t\t\t * Something wacky in the keymapping.\n\t\t\t\t * Ignore these non Shift/AltGr chords\n\t\t\t\t * for now... n.b. we try to automatically\n\t\t\t\t * switch to -xkb for this case.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkeysym = keymap[ (i - minkey) * syms_per_keycode + j ];\n\t\t\tif ( keysym >= ' ' && keysym < 0x100\n\t\t\t    && i == XKeysymToKeycode(dpy, keysym) ) {\n\t\t\t\tif (use_lowest_index && keycodes[keysym] != NoSymbol) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tkeycodes[keysym] = i;\n\t\t\t\tmodifiers[keysym] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tleft_shift_code = XKeysymToKeycode(dpy, XK_Shift_L);\n\tright_shift_code = XKeysymToKeycode(dpy, XK_Shift_R);\n\taltgr_code = XKeysymToKeycode(dpy, XK_Mode_switch);\n\tiso_level3_code = NoSymbol;\n#ifdef XK_ISO_Level3_Shift\n\tiso_level3_code = XKeysymToKeycode(dpy, XK_ISO_Level3_Shift);\n#endif\n\n\tXFree_wr ((void *) keymap);\n\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XRefreshKeyboardMapping",
          "args": [
            "(XMappingEvent *) &xev"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "MappingNotify",
            "&xev"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDestroyWindow",
          "args": [
            "dpy",
            "xrf"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XMapWindow",
          "args": [
            "dpy",
            "xrf"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\"",
            "coff_x",
            "coff_y",
            "dpy_x",
            "dpy_y",
            "xrf"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateWindow",
          "args": [
            "dpy",
            "window",
            "coff_x",
            "coff_y",
            "dpy_x",
            "dpy_y",
            "0",
            "CopyFromParent",
            "InputOutput",
            "&visual",
            "mask",
            "&swa"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetSelectionOwner",
          "args": [
            "dpy",
            "XA_PRIMARY"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetSelectionOwner",
          "args": [
            "dpy",
            "XA_PRIMARY"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_xevents",
          "args": [
            "reset"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xevents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "337-434",
          "snippet": "static void initialize_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int did_xselect_input = 0;\n\tstatic int did_xcreate_simple_window = 0;\n\tstatic int did_vnc_connect_prop = 0;\n\tstatic int did_x11vnc_remote_prop = 0;\n\tstatic int did_clipboard_atom = 0;\n\tstatic int did_xfixes = 0;\n\tstatic int did_xdamage = 0;\n\tstatic int did_xrandr = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (reset) {\n\t\tdid_xselect_input = 0;\n\t\tdid_xcreate_simple_window = 0;\n\t\tdid_vnc_connect_prop = 0;\n\t\tdid_x11vnc_remote_prop = 0;\n\t\tdid_clipboard_atom = 0;\n\t\tdid_xfixes = 0;\n\t\tdid_xdamage = 0;\n\t\tdid_xrandr = 0;\n\t}\n\n\tif ((watch_selection || vnc_connect) && !did_xselect_input) {\n\t\t/*\n\t\t * register desired event(s) for notification.\n\t\t * PropertyChangeMask is for CUT_BUFFER0 changes.\n\t\t * XXX: does this cause a flood of other stuff?\n\t\t */\n\t\tX_LOCK;\n\t\txselectinput_rootwin |= PropertyChangeMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\tXSelectInput_wr(dpy, subwin, VisibilityChangeMask);\n\t\t}\n\t\tX_UNLOCK;\n\t\tdid_xselect_input = 1;\n\t}\n\tif (watch_selection && !did_xcreate_simple_window) {\n\t\t/* create fake window for our selection ownership, etc */\n\n\t\t/*\n\t\t * We try to delay creating selwin until we are past\n\t\t * any GDM, (or other KillInitClients=true) manager.\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tX_LOCK;\n\t\t\tselwin = XCreateSimpleWindow(dpy, rootwin, 3, 2, 1, 1, 0, 0, 0);\n\t\t\tX_UNLOCK;\n\t\t\tdid_xcreate_simple_window = 1;\n\t\t\tif (! quiet) rfbLog(\"created selwin: 0x%lx\\n\", selwin);\n\t\t}\n\t}\n\n\tif ((xrandr || xrandr_maybe) && !did_xrandr) {\n\t\tinitialize_xrandr();\n\t\tdid_xrandr = 1;\n\t}\n\tif (vnc_connect && !did_vnc_connect_prop) {\n\t\tinitialize_vnc_connect_prop();\n\t\tdid_vnc_connect_prop = 1;\n\t}\n\tif (vnc_connect && !did_x11vnc_remote_prop) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tdid_x11vnc_remote_prop = 1;\n\t}\n\tif (run_gui_pid > 0) {\n\t\tkill(run_gui_pid, SIGUSR1);\n\t\trun_gui_pid = 0;\n\t}\n\tif (!did_clipboard_atom) {\n\t\tinitialize_clipboard_atom();\n\t\tdid_clipboard_atom = 1;\n\t}\n\tif (xfixes_present && use_xfixes && !did_xfixes) {\n\t\t/*\n\t\t * We try to delay creating initializing xfixes until\n\t\t * we are past the display manager, due to Xorg bug:\n\t\t * http://bugs.freedesktop.org/show_bug.cgi?id=18451\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tinitialize_xfixes();\n\t\t\tdid_xfixes = 1;\n\t\t\tif (! quiet) rfbLog(\"called initialize_xfixes()\\n\");\n\t\t}\n\t}\n\tif (xdamage_present && !did_xdamage) {\n\t\tinitialize_xdamage();\n\t\tdid_xdamage = 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_vnc_connect_prop(void);",
            "void initialize_x11vnc_remote_prop(void);",
            "void initialize_clipboard_atom(void);",
            "void check_xevents(int reset);",
            "void set_server_input(rfbClientPtr cl, int s);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
            "static void initialize_xevents(int reset);",
            "static void bust_grab(int reset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_vnc_connect_prop(void);\nvoid initialize_x11vnc_remote_prop(void);\nvoid initialize_clipboard_atom(void);\nvoid check_xevents(int reset);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void bust_grab(int reset);\n\nstatic void initialize_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int did_xselect_input = 0;\n\tstatic int did_xcreate_simple_window = 0;\n\tstatic int did_vnc_connect_prop = 0;\n\tstatic int did_x11vnc_remote_prop = 0;\n\tstatic int did_clipboard_atom = 0;\n\tstatic int did_xfixes = 0;\n\tstatic int did_xdamage = 0;\n\tstatic int did_xrandr = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (reset) {\n\t\tdid_xselect_input = 0;\n\t\tdid_xcreate_simple_window = 0;\n\t\tdid_vnc_connect_prop = 0;\n\t\tdid_x11vnc_remote_prop = 0;\n\t\tdid_clipboard_atom = 0;\n\t\tdid_xfixes = 0;\n\t\tdid_xdamage = 0;\n\t\tdid_xrandr = 0;\n\t}\n\n\tif ((watch_selection || vnc_connect) && !did_xselect_input) {\n\t\t/*\n\t\t * register desired event(s) for notification.\n\t\t * PropertyChangeMask is for CUT_BUFFER0 changes.\n\t\t * XXX: does this cause a flood of other stuff?\n\t\t */\n\t\tX_LOCK;\n\t\txselectinput_rootwin |= PropertyChangeMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\tXSelectInput_wr(dpy, subwin, VisibilityChangeMask);\n\t\t}\n\t\tX_UNLOCK;\n\t\tdid_xselect_input = 1;\n\t}\n\tif (watch_selection && !did_xcreate_simple_window) {\n\t\t/* create fake window for our selection ownership, etc */\n\n\t\t/*\n\t\t * We try to delay creating selwin until we are past\n\t\t * any GDM, (or other KillInitClients=true) manager.\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tX_LOCK;\n\t\t\tselwin = XCreateSimpleWindow(dpy, rootwin, 3, 2, 1, 1, 0, 0, 0);\n\t\t\tX_UNLOCK;\n\t\t\tdid_xcreate_simple_window = 1;\n\t\t\tif (! quiet) rfbLog(\"created selwin: 0x%lx\\n\", selwin);\n\t\t}\n\t}\n\n\tif ((xrandr || xrandr_maybe) && !did_xrandr) {\n\t\tinitialize_xrandr();\n\t\tdid_xrandr = 1;\n\t}\n\tif (vnc_connect && !did_vnc_connect_prop) {\n\t\tinitialize_vnc_connect_prop();\n\t\tdid_vnc_connect_prop = 1;\n\t}\n\tif (vnc_connect && !did_x11vnc_remote_prop) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tdid_x11vnc_remote_prop = 1;\n\t}\n\tif (run_gui_pid > 0) {\n\t\tkill(run_gui_pid, SIGUSR1);\n\t\trun_gui_pid = 0;\n\t}\n\tif (!did_clipboard_atom) {\n\t\tinitialize_clipboard_atom();\n\t\tdid_clipboard_atom = 1;\n\t}\n\tif (xfixes_present && use_xfixes && !did_xfixes) {\n\t\t/*\n\t\t * We try to delay creating initializing xfixes until\n\t\t * we are past the display manager, due to Xorg bug:\n\t\t * http://bugs.freedesktop.org/show_bug.cgi?id=18451\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tinitialize_xfixes();\n\t\t\tdid_xfixes = 1;\n\t\t\tif (! quiet) rfbLog(\"called initialize_xfixes()\\n\");\n\t\t}\n\t}\n\tif (xdamage_present && !did_xdamage) {\n\t\tinitialize_xdamage();\n\t\tdid_xdamage = 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "wsock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1964-1970",
          "snippet": "static void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DEBUG_XEVENTS 1\n\nint sync_tod_delay = 20;\nvoid sync_tod_with_servertime(void);\nvoid set_prop_atom(Atom atom);\nvoid check_xevents(int reset);\nvoid set_server_input(rfbClientPtr cl, int s);\nvoid set_text_chat(rfbClientPtr cl, int l, char *t);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void print_xevent_bases(void);\nstatic void bust_grab(int reset);\n\nvoid check_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tXEvent xev;\n\tint tmp, have_clients = 0;\n\tstatic int sent_some_sel = 0;\n\tstatic time_t last_call = 0;\n\tstatic time_t last_bell = 0;\n\tstatic time_t last_init_check = 0;\n\tstatic time_t last_sync = 0;\n\tstatic time_t last_time_sync = 0;\n\ttime_t now = time(NULL);\n\tstatic double last_request = 0.0;\n\tstatic double last_xrefresh = 0.0;\n\tXErrorHandler old_handler;\n\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_init_check+1 || reset) {\n\t\tlast_init_check = now;\n\t\tinitialize_xevents(reset);\n\t\tif (reset) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (screen && screen->clientHead) {\n\t\thave_clients = 1;\n\t}\n\n\tX_LOCK;\n\t/*\n\t * There is a bug where we have to wait before sending text to\n\t * the client... so instead of sending right away we wait a\n\t * the few seconds.\n\t */\n\n\tif (have_clients && watch_selection && !sent_some_sel\n\t    && now > last_client + sel_waittime) {\n\t\tif (XGetSelectionOwner(dpy, XA_PRIMARY) == None) {\n\t\t\tcutbuffer_send();\n\t\t}\n\t\tsent_some_sel = 1;\n\t}\n\tif (! have_clients) {\n\t\t/*\n\t\t * If we don't have clients we can miss the X server\n\t\t * going away until a client connects.\n\t\t */\n\t\tstatic time_t last_X_ping = 0;\n\t\tif (now > last_X_ping + 5) {\n\t\t\tlast_X_ping = now;\n\t\t\tXGetSelectionOwner(dpy, XA_PRIMARY);\n\t\t}\n\t}\n\n\tif (have_clients && xrefresh > 0.0 && dnow() > last_xrefresh + xrefresh) {\n\t\tXSetWindowAttributes swa;\n\t\tVisual visual;\n\t\tWindow xrf;\n\t\tunsigned long mask;\n\n\t\tswa.override_redirect = True;\n\t\tswa.backing_store = NotUseful;\n\t\tswa.save_under = False;\n\t\tswa.background_pixmap = None;\n\t\tvisual.visualid = CopyFromParent;\n\t\tmask = (CWOverrideRedirect|CWBackingStore|CWSaveUnder|CWBackPixmap);\n\n\t\txrf = XCreateWindow(dpy, window, coff_x, coff_y, dpy_x, dpy_y, 0, CopyFromParent,\n\t\t    InputOutput, &visual, mask, &swa);\n\t\tif (xrf != None) {\n\t\t\tif (0) fprintf(stderr, \"XCreateWindow(%d, %d, %d, %d) 0x%lx\\n\", coff_x, coff_y, dpy_x, dpy_y, xrf);\n\t\t\tXMapWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t\tXDestroyWindow(dpy, xrf);\n\t\t\tXFlush_wr(dpy);\n\t\t}\n\t\tlast_xrefresh = dnow();\n\t}\n\n\tif (now > last_call+1) {\n\t\t/* we only check these once a second or so. */\n\t\tint n = 0;\n\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\twhile (XCheckTypedEvent(dpy, MappingNotify, &xev)) {\n\t\t\tXRefreshKeyboardMapping((XMappingEvent *) &xev);\n\t\t\tn++;\n\t\t}\n\t\tif (n && use_modifier_tweak) {\n\t\t\tX_UNLOCK;\n\t\t\tinitialize_modtweak();\n\t\t\tX_LOCK;\n\t\t}\n\t\tif (xtrap_base_event_type) {\n\t\t\tint base = xtrap_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tif (xtest_base_event_type) {\n\t\t\tint base = xtest_base_event_type;\n\t\t\twhile (XCheckTypedEvent(dpy, base, &xev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * we can get ClientMessage from our XSendEvent() call in \n\t\t * selection_request().\n\t\t */\n\t\twhile (XCheckTypedEvent(dpy, ClientMessage, &xev)) {\n\t\t\t;\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tlast_call = now;\n\t}\n\n\tif (freeze_when_obscured) {\n\t\tif (XCheckTypedEvent(dpy, VisibilityNotify, &xev)) {\n\t\t\tif (xev.type == VisibilityNotify && xev.xany.window == subwin) {\n\t\t\t\tint prev = subwin_obscured;\n\t\t\t\tif (xev.xvisibility.state == VisibilityUnobscured) {\n\t\t\t\t\tsubwin_obscured = 0;\n\t\t\t\t} else if (xev.xvisibility.state == VisibilityPartiallyObscured) {\n\t\t\t\t\tsubwin_obscured = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsubwin_obscured = 2;\n\t\t\t\t}\n\t\t\t\trfbLog(\"subwin_obscured: %d -> %d\\n\", prev, subwin_obscured);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check for CUT_BUFFER0, VNC_CONNECT, X11VNC_REMOTE changes: */\n\tif (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tint got_cutbuffer = 0;\n\t\tint got_vnc_connect = 0;\n\t\tint got_x11vnc_remote = 0;\n\t\tstatic int prop_dbg = -1;\n\n\t\t/* to avoid piling up between calls, read all PropertyNotify now */\n\t\tdo {\n\t\t\tif (xev.type == PropertyNotify) {\n\t\t\t\tif (xev.xproperty.atom == XA_CUT_BUFFER0) {\n\t\t\t\t\tgot_cutbuffer++;\n\t\t\t\t} else if (vnc_connect && vnc_connect_prop != None\n\t\t\t\t    && xev.xproperty.atom == vnc_connect_prop) {\n\t\t\t\t\tgot_vnc_connect++;\n\t\t\t\t} else if (vnc_connect && x11vnc_remote_prop != None\n\t\t\t\t    && xev.xproperty.atom == x11vnc_remote_prop) {\n\t\t\t\t\tgot_x11vnc_remote++;\n\t\t\t\t}\n\t\t\t\tset_prop_atom(xev.xproperty.atom);\n\t\t\t}\n\t\t} while (XCheckTypedEvent(dpy, PropertyNotify, &xev));\n\n\t\tif (prop_dbg < 0) {\n\t\t\tprop_dbg = 0;\n\t\t\tif (getenv(\"PROP_DBG\")) {\n\t\t\t\tprop_dbg = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (prop_dbg && (got_cutbuffer > 1 || got_vnc_connect > 1 || got_x11vnc_remote > 1)) {\n\t\t\tstatic double lastmsg = 0.0;\n\t\t\tstatic int count = 0;\n\t\t\tdouble now = dnow();\n\n\t\t\tif (1 && now > lastmsg + 300.0) {\n\t\t\t\tif (got_cutbuffer > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d cutbuffer events since last check.\\n\", got_cutbuffer);\n\t\t\t\t}\n\t\t\t\tif (got_vnc_connect > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d vnc_connect events since last check.\\n\", got_vnc_connect);\n\t\t\t\t}\n\t\t\t\tif (got_x11vnc_remote > 1) {\n\t\t\t\t\trfbLog(\"check_xevents: warning: %d x11vnc_remote events since last check.\\n\", got_x11vnc_remote);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif (count >= 3) {\n\t\t\t\t\tlastmsg = now;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_cutbuffer)  {\n\t\t\t/*\n\t\t\t * Go retrieve CUT_BUFFER0 and send it.\n\t\t\t *\n\t\t\t * set_cutbuffer is a flag to try to avoid\n\t\t\t * processing our own cutbuffer changes.\n\t\t\t */\n\t\t\tif (have_clients && watch_selection && !set_cutbuffer) {\n\t\t\t\tcutbuffer_send();\n\t\t\t\tsent_some_sel = 1;\n\t\t\t}\n\t\t\tset_cutbuffer = 0;\n\t\t} \n\t\tif (got_vnc_connect) {\n\t\t\t/*\n\t\t\t * Go retrieve VNC_CONNECT string.\n\t\t\t */\n\t\t\tread_vnc_connect_prop(0);\n\t\t} \n\t\tif (got_x11vnc_remote) {\n\t\t\t/*\n\t\t\t * Go retrieve X11VNC_REMOTE string.\n\t\t\t */\n\t\t\tread_x11vnc_remote_prop(0);\n\t\t}\n\t}\n\n\t/* do this now that we have just cleared PropertyNotify */\n\ttmp = 0;\n\tif (rfac() < 0.6) {\n\t\ttmp = 1;\n\t}\n\tif (now > last_time_sync + sync_tod_delay + tmp) {\n\t\tsync_tod_with_servertime();\n\t\tlast_time_sync = now;\n\t}\n\n#if HAVE_LIBXRANDR\n\tif (xrandr || xrandr_maybe) {\n\t\tcheck_xrandr_event(\"check_xevents\");\n\t}\n#endif\n#if HAVE_LIBXFIXES\n\tif (xfixes_present && use_xfixes && xfixes_first_initialized && xfixes_base_event_type) {\n\t\tif (XCheckTypedEvent(dpy, xfixes_base_event_type +\n\t\t    XFixesCursorNotify, &xev)) {\n\t\t\tgot_xfixes_cursor_notify++;\n\t\t}\n\t}\n#endif\n\n\t/* check for our PRIMARY request notification: */\n\tif (watch_primary || watch_clipboard) {\n\t\tint doprimary = 1, doclipboard = 2, which, own = 0;\n\t\tdouble delay = 1.0;\n\t\tAtom atom;\n\t\tchar *req;\n\n\t\tif (XCheckTypedEvent(dpy, SelectionNotify, &xev)) {\n\t\t\tif (xev.type == SelectionNotify &&\n\t\t\t    xev.xselection.requestor == selwin &&\n\t\t\t    xev.xselection.property != None &&\n\t\t\t    xev.xselection.target == XA_STRING) {\n\t\t\t\tAtom s = xev.xselection.selection;\n\t\t\t        if (s == XA_PRIMARY || s == clipboard_atom) {\n\t\t\t\t\t/* go retrieve it and check it */\n\t\t\t\t\tif (now > last_client + sel_waittime\n\t\t\t\t\t    || sent_some_sel) {\n\t\t\t\t\t\tselection_send(&xev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Every second or so, request PRIMARY or CLIPBOARD,\n\t\t * unless we already own it or there is no owner or we\n\t\t * have no clients. \n\t\t * TODO: even at this low rate we should look into\n\t\t * and performance problems in odds cases (large text,\n\t\t * modem, etc.)\n\t\t */\n\t\twhich = 0;\n\t\tif (watch_primary && watch_clipboard && ! own_clipboard &&\n\t\t    ! own_primary) {\n\t\t\tdelay = 0.6;\n\t\t}\n\t\tif (dnow() > last_request + delay) {\n\t\t\t/*\n\t\t\t * It is not a good idea to do both at the same\n\t\t\t * time so we must choose one:\n\t\t\t */\n\t\t\tif (watch_primary && watch_clipboard) {\n\t\t\t\tstatic int count = 0;\n\t\t\t\tif (own_clipboard) {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t} else if (own_primary) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else if (count++ % 3 == 0) {\n\t\t\t\t\twhich = doclipboard;\n\t\t\t\t} else {\n\t\t\t\t\twhich = doprimary;\n\t\t\t\t}\n\t\t\t} else if (watch_primary) {\n\t\t\t\twhich = doprimary;\n\t\t\t} else if (watch_clipboard) {\n\t\t\t\twhich = doclipboard;\n\t\t\t}\n\t\t\tlast_request = dnow();\n\t\t}\n\t\tatom = None;\n\t\treq = \"none\";\n\t\tif (which == doprimary) {\n\t\t\town = own_primary;\n\t\t\tatom = XA_PRIMARY;\n\t\t\treq = \"PRIMARY\";\n\t\t} else if (which == doclipboard) {\n\t\t\town = own_clipboard;\n\t\t\tatom = clipboard_atom;\n\t\t\treq = \"CLIPBOARD\";\n\t\t}\n\t\tif (which != 0 && ! own && have_clients &&\n\t\t    XGetSelectionOwner(dpy, atom) != None && selwin != None) {\n\t\t\tXConvertSelection(dpy, atom, XA_STRING, XA_STRING,\n\t\t\t    selwin, CurrentTime);\n\t\t\tif (debug_sel) {\n\t\t\t\trfbLog(\"request %s\\n\", req);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (own_primary || own_clipboard) {\n\t\t/* we own PRIMARY or CLIPBOARD, see if someone requested it: */\n\t\ttrapped_xerror = 0;\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\n\t\tif (XCheckTypedEvent(dpy, SelectionRequest, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == XA_PRIMARY) {\n\t\t\t\tselection_request(&xev, \"PRIMARY\");\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionRequest &&\n\t\t\t    xev.xselectionrequest.selection == clipboard_atom) {\n\t\t\t\tselection_request(&xev, \"CLIPBOARD\");\n\t\t\t}\n\t\t}\n\n\t\t/* we own PRIMARY or CLIPBOARD, see if we no longer own it: */\n\t\tif (XCheckTypedEvent(dpy, SelectionClear, &xev)) {\n\t\t\tif (own_primary && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == XA_PRIMARY) {\n\t\t\t\town_primary = 0;\n\t\t\t\tif (xcut_str_primary) {\n\t\t\t\t\tfree(xcut_str_primary);\n\t\t\t\t\txcut_str_primary = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released PRIMARY.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (own_clipboard && xev.type == SelectionClear &&\n\t\t\t    xev.xselectionclear.selection == clipboard_atom) {\n\t\t\t\town_clipboard = 0;\n\t\t\t\tif (xcut_str_clipboard) {\n\t\t\t\t\tfree(xcut_str_clipboard);\n\t\t\t\t\txcut_str_clipboard = NULL;\n\t\t\t\t}\n\t\t\t\tif (debug_sel) {\n\t\t\t\t\trfbLog(\"Released CLIPBOARD.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t}\n\n\tif (watch_bell || now > last_bell+1) {\n\t\tlast_bell = now;\n\t\tcheck_bell_event();\n\t}\n\tif (tray_request != None) {\n\t\tstatic time_t last_tray_request = 0;\n\t\tif (now > last_tray_request + 2) {\n\t\t\tlast_tray_request = now;\n\t\t\tif (tray_embed(tray_request, tray_unembed)) {\n\t\t\t\ttray_window = tray_request;\n\t\t\t\ttray_request = None;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef DEBUG_XEVENTS\n#define DEBUG_XEVENTS 1\n#endif\n#if DEBUG_XEVENTS\n\tif (debug_xevents) {\n\t\tstatic time_t last_check = 0;\n\t\tstatic time_t reminder = 0;\n\t\tstatic int freq = 0;\n\n\t\tif (! freq) {\n\t\t\tif (getenv(\"X11VNC_REMINDER_RATE\")) {\n\t\t\t\tfreq = atoi(getenv(\"X11VNC_REMINDER_RATE\"));\n\t\t\t} else {\n\t\t\t\tfreq = 300;\n\t\t\t}\n\t\t}\n\n\t\tif (now > last_check + 1) {\n\t\t\tint ev_type_max = 300, ev_size = 400;\n\t\t\tXEvent xevs[400];\n\t\t\tint i, tot = XEventsQueued(dpy, QueuedAlready);\n\n\t\t\tif (reminder == 0 || (tot && now > reminder + freq)) {\n\t\t\t\tprint_xevent_bases();\n\t\t\t\treminder = now;\n\t\t\t}\n\t\t\tlast_check = now;\n\n\t\t\tif (tot) {\n\t\t    \t\tfprintf(stderr, \"Total events queued: %d\\n\",\n\t\t\t\t    tot);\n\t\t\t}\n\t\t\tfor (i=1; i<ev_type_max; i++) {\n\t\t\t\tint k, n = 0;\n\t\t\t\twhile (XCheckTypedEvent(dpy, i, xevs+n)) {\n\t\t\t\t\tif (++n >= ev_size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n) {\n\t\t\t\t\tfprintf(stderr, \"  %d%s events of type\"\n\t\t\t\t\t    \" %d queued\\n\", n,\n\t\t\t\t\t    (n >= ev_size) ? \"+\" : \"\", i);\n\t\t\t\t}\n\t\t\t\tfor (k=n-1; k >= 0; k--) {\n\t\t\t\t\tXPutBackEvent(dpy, xevs+k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (now > last_sync + 1200) {\n\t\t/* kludge for any remaining event leaks */\n\t\tint bugout = use_xdamage ? 500 : 50;\n\t\tint qlen, i;\n\t\tif (last_sync != 0) {\n\t\t\tqlen = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (qlen >= bugout) {\n\t\t\t\trfbLog(\"event leak: %d queued, \"\n\t\t\t\t    \" calling XSync(dpy, True)\\n\", qlen);  \n\t\t\t\trfbLog(\"  for diagnostics run: 'x11vnc -R\"\n\t\t\t\t    \" debug_xevents:1'\\n\");\n\t\t\t\tXSync(dpy, True);\n\t\t\t}\n\t\t}\n\t\tlast_sync = now;\n\n\t\t/* clear these, we don't want any events on them */\n\t\tif (rdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(rdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(rdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t\tif (gdpy_ctrl) {\n\t\t\tqlen = XEventsQueued(gdpy_ctrl, QueuedAlready);\n\t\t\tfor (i=0; i<qlen; i++) {\n\t\t\t\tXNextEvent(gdpy_ctrl, &xev);\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "set_prop_atom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1191-1197",
    "snippet": "void set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_prop_atom(Atom atom);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_prop_atom(Atom atom);\n\nvoid set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}"
  },
  {
    "function_name": "check_autorepeat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "1067-1189",
    "snippet": "void check_autorepeat(void) {\n\tstatic time_t last_check = 0;\n\tstatic int idle_timeout = -300, idle_reset = 0;\n\ttime_t now = time(NULL);\n\tint autorepeat_is_on, autorepeat_initially_on;\n\n\tif (! no_autorepeat || ! client_count) {\n\t\treturn;\n\t}\n\tif (now <= last_check + 1) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tif (idle_timeout < 0) {\n\t\tif (getenv(\"X11VNC_IDLE_TIMEOUT\")) {\n\t\t\tidle_timeout = atoi(getenv(\"X11VNC_IDLE_TIMEOUT\"));\n\t\t}\n\t\tif (idle_timeout < 0) {\n\t\t\tidle_timeout = -idle_timeout;\n\t\t}\n\t}\n\n\tlast_check = now;\n\n\tautorepeat_is_on = get_autorepeat_state();\n\tautorepeat_initially_on = get_initial_autorepeat_state();\n\n\tif (view_only) {\n\t\tif (! autorepeat_is_on) {\n\t\t\tautorepeat(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (now > last_keyboard_input + idle_timeout) {\n\t\t/* autorepeat should be on when idle */\n\t\tif (! autorepeat_is_on && autorepeat_initially_on) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"idle keyboard:   turning X autorepeat\"\n\t\t\t\t    \" back on.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(1, 1);\n\t\t\tidle_reset = 1;\n\t\t}\n\t} else {\n\t\tif (idle_reset) {\n\t\t\tint i, state[256], didmsg = 0, pressed = 0;\n\t\t\tint mwt = 600, mmax = 20;\n\t\t\tstatic int msgcnt = 0;\n\t\t\tstatic double lastmsg = 0.0;\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t\tif (use_threads) {X_LOCK;}\n\t\t\tget_keystate(state);\n\t\t\tif (use_threads) {X_UNLOCK;}\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tif (state[i] != 0) {\n\t\t\t\t\t/* better wait until all keys are up  */\n\t\t\t\t\tpressed++;\n\t\t\t\t\tif (msgcnt < mmax || dnow() > lastmsg + mwt) {\n\t\t\t\t\t\tchar *str = \"unset\";\n#if !NO_X11\n\t\t\t\t\t\tif (use_threads) {X_LOCK;}\n\t\t\t\t\t\tstr = XKeysymToString(XKeycodeToKeysym_wr(dpy, i, 0));\n\t\t\t\t\t\tif (use_threads) {X_UNLOCK;}\n#endif\n\t\t\t\t\t\tstr = str ? str : \"nosymbol\";\n\t\t\t\t\t\tdidmsg++;\n\t\t\t\t\t\trfbLog(\"active keyboard: waiting until \"\n\t\t\t\t\t\t    \"all keys are up. key_down=%d %s.  \"\n\t\t\t\t\t\t    \"If the key is inaccessible via keyboard, \"\n\t\t\t\t\t\t    \"consider 'x11vnc -R clear_all'\\n\", i, str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (didmsg > 0) {\n\t\t\t\tmsgcnt++;\n\t\t\t\tif (msgcnt == mmax) {\n\t\t\t\t\trfbLog(\"active keyboard: last such \"\n\t\t\t\t\t    \"message for %d secs.\\n\", mwt);\n\t\t\t\t}\n\t\t\t\tlastmsg = dnow();\n\t\t\t}\n\t\t\tif (pressed > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (idle_reset) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"active keyboard: turning X autorepeat\"\n\t\t\t\t    \" off.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(0, 1);\n\t\t\tidle_reset = 0;\n\n\t\t} else if (no_repeat_countdown && autorepeat_is_on) {\n\t\t\tint n = no_repeat_countdown - 1;\n\t\t\tif (n >= 0) {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!! (%d resets left)\\n\", n);\n\t\t\t} else {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!!\\n\");\n\t\t\t}\n\t\t\tif (no_repeat_countdown > 0) {\n\t\t\t\tno_repeat_countdown--;\n\t\t\t}\n\t\t\tautorepeat(1, 0);\n\t\t\tautorepeat(0, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_autorepeat(void);",
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autorepeat",
          "args": [
            "0",
            "0"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "autorepeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "386-442",
          "snippet": "void autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);",
            "void autorepeat(int restore, int bequiet);",
            "void delete_added_keycodes(int bequiet);",
            "static void delete_keycode(KeyCode kc, int bequiet);",
            "static int save_auto_repeat = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\nvoid autorepeat(int restore, int bequiet);\nvoid delete_added_keycodes(int bequiet);\nstatic void delete_keycode(KeyCode kc, int bequiet);\nstatic int save_auto_repeat = -1;\n\nvoid autorepeat(int restore, int bequiet) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!restore || !bequiet) {}\n\treturn;\n#else\n\tint global_auto_repeat;\n\tXKeyboardControl kctrl;\n\n\tRAWFB_RET_VOID\n\n\tif (restore) {\n\t\tif (save_auto_repeat < 0) {\n\t\t\treturn;\t\t/* nothing to restore */\n\t\t}\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\t/* read state and skip restore if equal (e.g. no clients) */\n\t\tif (global_auto_repeat == save_auto_repeat) {\n\t\t\treturn;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = save_auto_repeat;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Restored X server key autorepeat to: %d\\n\",\n\t\t\t    save_auto_repeat);\n\t\t}\n\t} else {\n\t\tglobal_auto_repeat = get_autorepeat_state();\n\t\tif (save_auto_repeat < 0) {\n\t\t\t/*\n\t\t\t * we only remember the state at startup\n\t\t\t * to avoid confusing ourselves later on.\n\t\t\t */\n\t\t\tsave_auto_repeat = global_auto_repeat;\n\t\t}\n\n\t\tX_LOCK;\n\t\tkctrl.auto_repeat_mode = AutoRepeatModeOff;\n\t\tXChangeKeyboardControl(dpy, KBAutoRepeatMode, &kctrl);\n\t\tXFlush_wr(dpy);\n\t\tX_UNLOCK;\n\n\t\tif (! bequiet && ! quiet) {\n\t\t\trfbLog(\"Disabled X server key autorepeat.\\n\");\n\t\t\tif (no_repeat_countdown >= 0) {\n\t\t\t\trfbLog(\"  to force back on run: 'xset r on' (%d \"\n\t\t\t\t    \"times)\\n\", no_repeat_countdown+1);\n\t\t\t}\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Battling with something for \"\n\t\t\t\t    \"-norepeat!!\\n\""
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Battling with something for \"\n\t\t\t\t    \"-norepeat!! (%d resets left)\\n\"",
            "n"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"active keyboard: turning X autorepeat\"\n\t\t\t\t    \" off.\\n\""
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"active keyboard: last such \"\n\t\t\t\t\t    \"message for %d secs.\\n\"",
            "mwt"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"active keyboard: waiting until \"\n\t\t\t\t\t\t    \"all keys are up. key_down=%d %s.  \"\n\t\t\t\t\t\t    \"If the key is inaccessible via keyboard, \"\n\t\t\t\t\t\t    \"consider 'x11vnc -R clear_all'\\n\"",
            "i",
            "str"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XKeysymToString",
          "args": [
            "XKeycodeToKeysym_wr(dpy, i, 0)"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "XKeysymToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "1449-2807",
          "snippet": "char *XKeysymToString(KeySym k) {\n#ifndef XK_0_nosuch\n\tif (k == XK_VoidSymbol) return \"VoidSymbol\";\n#ifdef XK_MISCELLANY\n\tif (k == XK_BackSpace) return \"BackSpace\";\n\tif (k == XK_Tab) return \"Tab\";\n\tif (k == XK_Linefeed) return \"Linefeed\";\n\tif (k == XK_Clear) return \"Clear\";\n\tif (k == XK_Return) return \"Return\";\n\tif (k == XK_Pause) return \"Pause\";\n\tif (k == XK_Scroll_Lock) return \"Scroll_Lock\";\n\tif (k == XK_Sys_Req) return \"Sys_Req\";\n\tif (k == XK_Escape) return \"Escape\";\n\tif (k == XK_Delete) return \"Delete\";\n\tif (k == XK_Multi_key) return \"Multi_key\";\n\tif (k == XK_SingleCandidate) return \"SingleCandidate\";\n\tif (k == XK_MultipleCandidate) return \"MultipleCandidate\";\n\tif (k == XK_PreviousCandidate) return \"PreviousCandidate\";\n\tif (k == XK_Kanji) return \"Kanji\";\n\tif (k == XK_Muhenkan) return \"Muhenkan\";\n\tif (k == XK_Henkan_Mode) return \"Henkan_Mode\";\n\tif (k == XK_Henkan) return \"Henkan\";\n\tif (k == XK_Romaji) return \"Romaji\";\n\tif (k == XK_Hiragana) return \"Hiragana\";\n\tif (k == XK_Katakana) return \"Katakana\";\n\tif (k == XK_Hiragana_Katakana) return \"Hiragana_Katakana\";\n\tif (k == XK_Zenkaku) return \"Zenkaku\";\n\tif (k == XK_Hankaku) return \"Hankaku\";\n\tif (k == XK_Zenkaku_Hankaku) return \"Zenkaku_Hankaku\";\n\tif (k == XK_Touroku) return \"Touroku\";\n\tif (k == XK_Massyo) return \"Massyo\";\n\tif (k == XK_Kana_Lock) return \"Kana_Lock\";\n\tif (k == XK_Kana_Shift) return \"Kana_Shift\";\n\tif (k == XK_Eisu_Shift) return \"Eisu_Shift\";\n\tif (k == XK_Eisu_toggle) return \"Eisu_toggle\";\n\tif (k == XK_Zen_Koho) return \"Zen_Koho\";\n\tif (k == XK_Mae_Koho) return \"Mae_Koho\";\n\tif (k == XK_Home) return \"Home\";\n\tif (k == XK_Left) return \"Left\";\n\tif (k == XK_Up) return \"Up\";\n\tif (k == XK_Right) return \"Right\";\n\tif (k == XK_Down) return \"Down\";\n\tif (k == XK_Prior) return \"Prior\";\n\tif (k == XK_Page_Up) return \"Page_Up\";\n\tif (k == XK_Next) return \"Next\";\n\tif (k == XK_Page_Down) return \"Page_Down\";\n\tif (k == XK_End) return \"End\";\n\tif (k == XK_Begin) return \"Begin\";\n\tif (k == XK_Select) return \"Select\";\n\tif (k == XK_Print) return \"Print\";\n\tif (k == XK_Execute) return \"Execute\";\n\tif (k == XK_Insert) return \"Insert\";\n\tif (k == XK_Undo) return \"Undo\";\n\tif (k == XK_Redo) return \"Redo\";\n\tif (k == XK_Menu) return \"Menu\";\n\tif (k == XK_Find) return \"Find\";\n\tif (k == XK_Cancel) return \"Cancel\";\n\tif (k == XK_Help) return \"Help\";\n\tif (k == XK_Break) return \"Break\";\n\tif (k == XK_Mode_switch) return \"Mode_switch\";\n\tif (k == XK_script_switch) return \"script_switch\";\n\tif (k == XK_Num_Lock) return \"Num_Lock\";\n\tif (k == XK_KP_Space) return \"KP_Space\";\n\tif (k == XK_KP_Tab) return \"KP_Tab\";\n\tif (k == XK_KP_Enter) return \"KP_Enter\";\n\tif (k == XK_KP_F1) return \"KP_F1\";\n\tif (k == XK_KP_F2) return \"KP_F2\";\n\tif (k == XK_KP_F3) return \"KP_F3\";\n\tif (k == XK_KP_F4) return \"KP_F4\";\n\tif (k == XK_KP_Home) return \"KP_Home\";\n\tif (k == XK_KP_Left) return \"KP_Left\";\n\tif (k == XK_KP_Up) return \"KP_Up\";\n\tif (k == XK_KP_Right) return \"KP_Right\";\n\tif (k == XK_KP_Down) return \"KP_Down\";\n\tif (k == XK_KP_Prior) return \"KP_Prior\";\n\tif (k == XK_KP_Page_Up) return \"KP_Page_Up\";\n\tif (k == XK_KP_Next) return \"KP_Next\";\n\tif (k == XK_KP_Page_Down) return \"KP_Page_Down\";\n\tif (k == XK_KP_End) return \"KP_End\";\n\tif (k == XK_KP_Begin) return \"KP_Begin\";\n\tif (k == XK_KP_Insert) return \"KP_Insert\";\n\tif (k == XK_KP_Delete) return \"KP_Delete\";\n\tif (k == XK_KP_Equal) return \"KP_Equal\";\n\tif (k == XK_KP_Multiply) return \"KP_Multiply\";\n\tif (k == XK_KP_Add) return \"KP_Add\";\n\tif (k == XK_KP_Separator) return \"KP_Separator\";\n\tif (k == XK_KP_Subtract) return \"KP_Subtract\";\n\tif (k == XK_KP_Decimal) return \"KP_Decimal\";\n\tif (k == XK_KP_Divide) return \"KP_Divide\";\n\tif (k == XK_KP_0) return \"KP_0\";\n\tif (k == XK_KP_1) return \"KP_1\";\n\tif (k == XK_KP_2) return \"KP_2\";\n\tif (k == XK_KP_3) return \"KP_3\";\n\tif (k == XK_KP_4) return \"KP_4\";\n\tif (k == XK_KP_5) return \"KP_5\";\n\tif (k == XK_KP_6) return \"KP_6\";\n\tif (k == XK_KP_7) return \"KP_7\";\n\tif (k == XK_KP_8) return \"KP_8\";\n\tif (k == XK_KP_9) return \"KP_9\";\n\tif (k == XK_F1) return \"F1\";\n\tif (k == XK_F2) return \"F2\";\n\tif (k == XK_F3) return \"F3\";\n\tif (k == XK_F4) return \"F4\";\n\tif (k == XK_F5) return \"F5\";\n\tif (k == XK_F6) return \"F6\";\n\tif (k == XK_F7) return \"F7\";\n\tif (k == XK_F8) return \"F8\";\n\tif (k == XK_F9) return \"F9\";\n\tif (k == XK_F10) return \"F10\";\n\tif (k == XK_F11) return \"F11\";\n\tif (k == XK_L1) return \"L1\";\n\tif (k == XK_F12) return \"F12\";\n\tif (k == XK_L2) return \"L2\";\n\tif (k == XK_F13) return \"F13\";\n\tif (k == XK_L3) return \"L3\";\n\tif (k == XK_F14) return \"F14\";\n\tif (k == XK_L4) return \"L4\";\n\tif (k == XK_F15) return \"F15\";\n\tif (k == XK_L5) return \"L5\";\n\tif (k == XK_F16) return \"F16\";\n\tif (k == XK_L6) return \"L6\";\n\tif (k == XK_F17) return \"F17\";\n\tif (k == XK_L7) return \"L7\";\n\tif (k == XK_F18) return \"F18\";\n\tif (k == XK_L8) return \"L8\";\n\tif (k == XK_F19) return \"F19\";\n\tif (k == XK_L9) return \"L9\";\n\tif (k == XK_F20) return \"F20\";\n\tif (k == XK_L10) return \"L10\";\n\tif (k == XK_F21) return \"F21\";\n\tif (k == XK_R1) return \"R1\";\n\tif (k == XK_F22) return \"F22\";\n\tif (k == XK_R2) return \"R2\";\n\tif (k == XK_F23) return \"F23\";\n\tif (k == XK_R3) return \"R3\";\n\tif (k == XK_F24) return \"F24\";\n\tif (k == XK_R4) return \"R4\";\n\tif (k == XK_F25) return \"F25\";\n\tif (k == XK_R5) return \"R5\";\n\tif (k == XK_F26) return \"F26\";\n\tif (k == XK_R6) return \"R6\";\n\tif (k == XK_F27) return \"F27\";\n\tif (k == XK_R7) return \"R7\";\n\tif (k == XK_F28) return \"F28\";\n\tif (k == XK_R8) return \"R8\";\n\tif (k == XK_F29) return \"F29\";\n\tif (k == XK_R9) return \"R9\";\n\tif (k == XK_F30) return \"F30\";\n\tif (k == XK_R10) return \"R10\";\n\tif (k == XK_F31) return \"F31\";\n\tif (k == XK_R11) return \"R11\";\n\tif (k == XK_F32) return \"F32\";\n\tif (k == XK_R12) return \"R12\";\n\tif (k == XK_F33) return \"F33\";\n\tif (k == XK_R13) return \"R13\";\n\tif (k == XK_F34) return \"F34\";\n\tif (k == XK_R14) return \"R14\";\n\tif (k == XK_F35) return \"F35\";\n\tif (k == XK_R15) return \"R15\";\n\tif (k == XK_Shift_L) return \"Shift_L\";\n\tif (k == XK_Shift_R) return \"Shift_R\";\n\tif (k == XK_Control_L) return \"Control_L\";\n\tif (k == XK_Control_R) return \"Control_R\";\n\tif (k == XK_Caps_Lock) return \"Caps_Lock\";\n\tif (k == XK_Shift_Lock) return \"Shift_Lock\";\n\tif (k == XK_Meta_L) return \"Meta_L\";\n\tif (k == XK_Meta_R) return \"Meta_R\";\n\tif (k == XK_Alt_L) return \"Alt_L\";\n\tif (k == XK_Alt_R) return \"Alt_R\";\n\tif (k == XK_Super_L) return \"Super_L\";\n\tif (k == XK_Super_R) return \"Super_R\";\n\tif (k == XK_Hyper_L) return \"Hyper_L\";\n\tif (k == XK_Hyper_R) return \"Hyper_R\";\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (k == XK_ISO_Lock) return \"ISO_Lock\";\n\tif (k == XK_ISO_Level2_Latch) return \"ISO_Level2_Latch\";\n\tif (k == XK_ISO_Level3_Shift) return \"ISO_Level3_Shift\";\n\tif (k == XK_ISO_Level3_Latch) return \"ISO_Level3_Latch\";\n\tif (k == XK_ISO_Level3_Lock) return \"ISO_Level3_Lock\";\n\tif (k == XK_ISO_Group_Shift) return \"ISO_Group_Shift\";\n\tif (k == XK_ISO_Group_Latch) return \"ISO_Group_Latch\";\n\tif (k == XK_ISO_Group_Lock) return \"ISO_Group_Lock\";\n\tif (k == XK_ISO_Next_Group) return \"ISO_Next_Group\";\n\tif (k == XK_ISO_Next_Group_Lock) return \"ISO_Next_Group_Lock\";\n\tif (k == XK_ISO_Prev_Group) return \"ISO_Prev_Group\";\n\tif (k == XK_ISO_Prev_Group_Lock) return \"ISO_Prev_Group_Lock\";\n\tif (k == XK_ISO_First_Group) return \"ISO_First_Group\";\n\tif (k == XK_ISO_First_Group_Lock) return \"ISO_First_Group_Lock\";\n\tif (k == XK_ISO_Last_Group) return \"ISO_Last_Group\";\n\tif (k == XK_ISO_Last_Group_Lock) return \"ISO_Last_Group_Lock\";\n\tif (k == XK_ISO_Left_Tab) return \"ISO_Left_Tab\";\n\tif (k == XK_ISO_Move_Line_Up) return \"ISO_Move_Line_Up\";\n\tif (k == XK_ISO_Move_Line_Down) return \"ISO_Move_Line_Down\";\n\tif (k == XK_ISO_Partial_Line_Up) return \"ISO_Partial_Line_Up\";\n\tif (k == XK_ISO_Partial_Line_Down) return \"ISO_Partial_Line_Down\";\n\tif (k == XK_ISO_Partial_Space_Left) return \"ISO_Partial_Space_Left\";\n\tif (k == XK_ISO_Partial_Space_Right) return \"ISO_Partial_Space_Right\";\n\tif (k == XK_ISO_Set_Margin_Left) return \"ISO_Set_Margin_Left\";\n\tif (k == XK_ISO_Set_Margin_Right) return \"ISO_Set_Margin_Right\";\n\tif (k == XK_ISO_Release_Margin_Left) return \"ISO_Release_Margin_Left\";\n\tif (k == XK_ISO_Release_Margin_Right) return \"ISO_Release_Margin_Right\";\n\tif (k == XK_ISO_Release_Both_Margins) return \"ISO_Release_Both_Margins\";\n\tif (k == XK_ISO_Fast_Cursor_Left) return \"ISO_Fast_Cursor_Left\";\n\tif (k == XK_ISO_Fast_Cursor_Right) return \"ISO_Fast_Cursor_Right\";\n\tif (k == XK_ISO_Fast_Cursor_Up) return \"ISO_Fast_Cursor_Up\";\n\tif (k == XK_ISO_Fast_Cursor_Down) return \"ISO_Fast_Cursor_Down\";\n\tif (k == XK_ISO_Continuous_Underline) return \"ISO_Continuous_Underline\";\n\tif (k == XK_ISO_Discontinuous_Underline) return \"ISO_Discontinuous_Underline\";\n\tif (k == XK_ISO_Emphasize) return \"ISO_Emphasize\";\n\tif (k == XK_ISO_Center_Object) return \"ISO_Center_Object\";\n\tif (k == XK_ISO_Enter) return \"ISO_Enter\";\n\tif (k == XK_dead_grave) return \"dead_grave\";\n\tif (k == XK_dead_acute) return \"dead_acute\";\n\tif (k == XK_dead_circumflex) return \"dead_circumflex\";\n\tif (k == XK_dead_tilde) return \"dead_tilde\";\n\tif (k == XK_dead_macron) return \"dead_macron\";\n\tif (k == XK_dead_breve) return \"dead_breve\";\n\tif (k == XK_dead_abovedot) return \"dead_abovedot\";\n\tif (k == XK_dead_diaeresis) return \"dead_diaeresis\";\n\tif (k == XK_dead_abovering) return \"dead_abovering\";\n\tif (k == XK_dead_doubleacute) return \"dead_doubleacute\";\n\tif (k == XK_dead_caron) return \"dead_caron\";\n\tif (k == XK_dead_cedilla) return \"dead_cedilla\";\n\tif (k == XK_dead_ogonek) return \"dead_ogonek\";\n\tif (k == XK_dead_iota) return \"dead_iota\";\n\tif (k == XK_dead_voiced_sound) return \"dead_voiced_sound\";\n\tif (k == XK_dead_semivoiced_sound) return \"dead_semivoiced_sound\";\n\tif (k == XK_dead_belowdot) return \"dead_belowdot\";\n\tif (k == XK_First_Virtual_Screen) return \"First_Virtual_Screen\";\n\tif (k == XK_Prev_Virtual_Screen) return \"Prev_Virtual_Screen\";\n\tif (k == XK_Next_Virtual_Screen) return \"Next_Virtual_Screen\";\n\tif (k == XK_Last_Virtual_Screen) return \"Last_Virtual_Screen\";\n\tif (k == XK_Terminate_Server) return \"Terminate_Server\";\n\tif (k == XK_AccessX_Enable) return \"AccessX_Enable\";\n\tif (k == XK_AccessX_Feedback_Enable) return \"AccessX_Feedback_Enable\";\n\tif (k == XK_RepeatKeys_Enable) return \"RepeatKeys_Enable\";\n\tif (k == XK_SlowKeys_Enable) return \"SlowKeys_Enable\";\n\tif (k == XK_BounceKeys_Enable) return \"BounceKeys_Enable\";\n\tif (k == XK_StickyKeys_Enable) return \"StickyKeys_Enable\";\n\tif (k == XK_MouseKeys_Enable) return \"MouseKeys_Enable\";\n\tif (k == XK_MouseKeys_Accel_Enable) return \"MouseKeys_Accel_Enable\";\n\tif (k == XK_Overlay1_Enable) return \"Overlay1_Enable\";\n\tif (k == XK_Overlay2_Enable) return \"Overlay2_Enable\";\n\tif (k == XK_AudibleBell_Enable) return \"AudibleBell_Enable\";\n\tif (k == XK_Pointer_Left) return \"Pointer_Left\";\n\tif (k == XK_Pointer_Right) return \"Pointer_Right\";\n\tif (k == XK_Pointer_Up) return \"Pointer_Up\";\n\tif (k == XK_Pointer_Down) return \"Pointer_Down\";\n\tif (k == XK_Pointer_UpLeft) return \"Pointer_UpLeft\";\n\tif (k == XK_Pointer_UpRight) return \"Pointer_UpRight\";\n\tif (k == XK_Pointer_DownLeft) return \"Pointer_DownLeft\";\n\tif (k == XK_Pointer_DownRight) return \"Pointer_DownRight\";\n\tif (k == XK_Pointer_Button_Dflt) return \"Pointer_Button_Dflt\";\n\tif (k == XK_Pointer_Button1) return \"Pointer_Button1\";\n\tif (k == XK_Pointer_Button2) return \"Pointer_Button2\";\n\tif (k == XK_Pointer_Button3) return \"Pointer_Button3\";\n\tif (k == XK_Pointer_Button4) return \"Pointer_Button4\";\n\tif (k == XK_Pointer_Button5) return \"Pointer_Button5\";\n\tif (k == XK_Pointer_DblClick_Dflt) return \"Pointer_DblClick_Dflt\";\n\tif (k == XK_Pointer_DblClick1) return \"Pointer_DblClick1\";\n\tif (k == XK_Pointer_DblClick2) return \"Pointer_DblClick2\";\n\tif (k == XK_Pointer_DblClick3) return \"Pointer_DblClick3\";\n\tif (k == XK_Pointer_DblClick4) return \"Pointer_DblClick4\";\n\tif (k == XK_Pointer_DblClick5) return \"Pointer_DblClick5\";\n\tif (k == XK_Pointer_Drag_Dflt) return \"Pointer_Drag_Dflt\";\n\tif (k == XK_Pointer_Drag1) return \"Pointer_Drag1\";\n\tif (k == XK_Pointer_Drag2) return \"Pointer_Drag2\";\n\tif (k == XK_Pointer_Drag3) return \"Pointer_Drag3\";\n\tif (k == XK_Pointer_Drag4) return \"Pointer_Drag4\";\n\tif (k == XK_Pointer_Drag5) return \"Pointer_Drag5\";\n\tif (k == XK_Pointer_EnableKeys) return \"Pointer_EnableKeys\";\n\tif (k == XK_Pointer_Accelerate) return \"Pointer_Accelerate\";\n\tif (k == XK_Pointer_DfltBtnNext) return \"Pointer_DfltBtnNext\";\n\tif (k == XK_Pointer_DfltBtnPrev) return \"Pointer_DfltBtnPrev\";\n#endif\n#ifdef XK_3270\n\tif (k == XK_3270_Duplicate) return \"3270_Duplicate\";\n\tif (k == XK_3270_FieldMark) return \"3270_FieldMark\";\n\tif (k == XK_3270_Right2) return \"3270_Right2\";\n\tif (k == XK_3270_Left2) return \"3270_Left2\";\n\tif (k == XK_3270_BackTab) return \"3270_BackTab\";\n\tif (k == XK_3270_EraseEOF) return \"3270_EraseEOF\";\n\tif (k == XK_3270_EraseInput) return \"3270_EraseInput\";\n\tif (k == XK_3270_Reset) return \"3270_Reset\";\n\tif (k == XK_3270_Quit) return \"3270_Quit\";\n\tif (k == XK_3270_PA1) return \"3270_PA1\";\n\tif (k == XK_3270_PA2) return \"3270_PA2\";\n\tif (k == XK_3270_PA3) return \"3270_PA3\";\n\tif (k == XK_3270_Test) return \"3270_Test\";\n\tif (k == XK_3270_Attn) return \"3270_Attn\";\n\tif (k == XK_3270_CursorBlink) return \"3270_CursorBlink\";\n\tif (k == XK_3270_AltCursor) return \"3270_AltCursor\";\n\tif (k == XK_3270_KeyClick) return \"3270_KeyClick\";\n\tif (k == XK_3270_Jump) return \"3270_Jump\";\n\tif (k == XK_3270_Ident) return \"3270_Ident\";\n\tif (k == XK_3270_Rule) return \"3270_Rule\";\n\tif (k == XK_3270_Copy) return \"3270_Copy\";\n\tif (k == XK_3270_Play) return \"3270_Play\";\n\tif (k == XK_3270_Setup) return \"3270_Setup\";\n\tif (k == XK_3270_Record) return \"3270_Record\";\n\tif (k == XK_3270_ChangeScreen) return \"3270_ChangeScreen\";\n\tif (k == XK_3270_DeleteWord) return \"3270_DeleteWord\";\n\tif (k == XK_3270_ExSelect) return \"3270_ExSelect\";\n\tif (k == XK_3270_CursorSelect) return \"3270_CursorSelect\";\n\tif (k == XK_3270_PrintScreen) return \"3270_PrintScreen\";\n\tif (k == XK_3270_Enter) return \"3270_Enter\";\n#endif\n#ifdef XK_LATIN1\n\tif (k == XK_space) return \"space\";\n\tif (k == XK_exclam) return \"exclam\";\n\tif (k == XK_quotedbl) return \"quotedbl\";\n\tif (k == XK_numbersign) return \"numbersign\";\n\tif (k == XK_dollar) return \"dollar\";\n\tif (k == XK_percent) return \"percent\";\n\tif (k == XK_ampersand) return \"ampersand\";\n\tif (k == XK_apostrophe) return \"apostrophe\";\n\tif (k == XK_quoteright) return \"quoteright\";\n\tif (k == XK_parenleft) return \"parenleft\";\n\tif (k == XK_parenright) return \"parenright\";\n\tif (k == XK_asterisk) return \"asterisk\";\n\tif (k == XK_plus) return \"plus\";\n\tif (k == XK_comma) return \"comma\";\n\tif (k == XK_minus) return \"minus\";\n\tif (k == XK_period) return \"period\";\n\tif (k == XK_slash) return \"slash\";\n\tif (k == XK_0) return \"0\";\n\tif (k == XK_1) return \"1\";\n\tif (k == XK_2) return \"2\";\n\tif (k == XK_3) return \"3\";\n\tif (k == XK_4) return \"4\";\n\tif (k == XK_5) return \"5\";\n\tif (k == XK_6) return \"6\";\n\tif (k == XK_7) return \"7\";\n\tif (k == XK_8) return \"8\";\n\tif (k == XK_9) return \"9\";\n\tif (k == XK_colon) return \"colon\";\n\tif (k == XK_semicolon) return \"semicolon\";\n\tif (k == XK_less) return \"less\";\n\tif (k == XK_equal) return \"equal\";\n\tif (k == XK_greater) return \"greater\";\n\tif (k == XK_question) return \"question\";\n\tif (k == XK_at) return \"at\";\n\tif (k == XK_A) return \"A\";\n\tif (k == XK_B) return \"B\";\n\tif (k == XK_C) return \"C\";\n\tif (k == XK_D) return \"D\";\n\tif (k == XK_E) return \"E\";\n\tif (k == XK_F) return \"F\";\n\tif (k == XK_G) return \"G\";\n\tif (k == XK_H) return \"H\";\n\tif (k == XK_I) return \"I\";\n\tif (k == XK_J) return \"J\";\n\tif (k == XK_K) return \"K\";\n\tif (k == XK_L) return \"L\";\n\tif (k == XK_M) return \"M\";\n\tif (k == XK_N) return \"N\";\n\tif (k == XK_O) return \"O\";\n\tif (k == XK_P) return \"P\";\n\tif (k == XK_Q) return \"Q\";\n\tif (k == XK_R) return \"R\";\n\tif (k == XK_S) return \"S\";\n\tif (k == XK_T) return \"T\";\n\tif (k == XK_U) return \"U\";\n\tif (k == XK_V) return \"V\";\n\tif (k == XK_W) return \"W\";\n\tif (k == XK_X) return \"X\";\n\tif (k == XK_Y) return \"Y\";\n\tif (k == XK_Z) return \"Z\";\n\tif (k == XK_bracketleft) return \"bracketleft\";\n\tif (k == XK_backslash) return \"backslash\";\n\tif (k == XK_bracketright) return \"bracketright\";\n\tif (k == XK_asciicircum) return \"asciicircum\";\n\tif (k == XK_underscore) return \"underscore\";\n\tif (k == XK_grave) return \"grave\";\n\tif (k == XK_quoteleft) return \"quoteleft\";\n\tif (k == XK_a) return \"a\";\n\tif (k == XK_b) return \"b\";\n\tif (k == XK_c) return \"c\";\n\tif (k == XK_d) return \"d\";\n\tif (k == XK_e) return \"e\";\n\tif (k == XK_f) return \"f\";\n\tif (k == XK_g) return \"g\";\n\tif (k == XK_h) return \"h\";\n\tif (k == XK_i) return \"i\";\n\tif (k == XK_j) return \"j\";\n\tif (k == XK_k) return \"k\";\n\tif (k == XK_l) return \"l\";\n\tif (k == XK_m) return \"m\";\n\tif (k == XK_n) return \"n\";\n\tif (k == XK_o) return \"o\";\n\tif (k == XK_p) return \"p\";\n\tif (k == XK_q) return \"q\";\n\tif (k == XK_r) return \"r\";\n\tif (k == XK_s) return \"s\";\n\tif (k == XK_t) return \"t\";\n\tif (k == XK_u) return \"u\";\n\tif (k == XK_v) return \"v\";\n\tif (k == XK_w) return \"w\";\n\tif (k == XK_x) return \"x\";\n\tif (k == XK_y) return \"y\";\n\tif (k == XK_z) return \"z\";\n\tif (k == XK_braceleft) return \"braceleft\";\n\tif (k == XK_bar) return \"bar\";\n\tif (k == XK_braceright) return \"braceright\";\n\tif (k == XK_asciitilde) return \"asciitilde\";\n\tif (k == XK_nobreakspace) return \"nobreakspace\";\n\tif (k == XK_exclamdown) return \"exclamdown\";\n\tif (k == XK_cent) return \"cent\";\n\tif (k == XK_sterling) return \"sterling\";\n\tif (k == XK_currency) return \"currency\";\n\tif (k == XK_yen) return \"yen\";\n\tif (k == XK_brokenbar) return \"brokenbar\";\n\tif (k == XK_section) return \"section\";\n\tif (k == XK_diaeresis) return \"diaeresis\";\n\tif (k == XK_copyright) return \"copyright\";\n\tif (k == XK_ordfeminine) return \"ordfeminine\";\n\tif (k == XK_guillemotleft) return \"guillemotleft\";\n\tif (k == XK_notsign) return \"notsign\";\n\tif (k == XK_hyphen) return \"hyphen\";\n\tif (k == XK_registered) return \"registered\";\n\tif (k == XK_macron) return \"macron\";\n\tif (k == XK_degree) return \"degree\";\n\tif (k == XK_plusminus) return \"plusminus\";\n\tif (k == XK_twosuperior) return \"twosuperior\";\n\tif (k == XK_threesuperior) return \"threesuperior\";\n\tif (k == XK_acute) return \"acute\";\n\tif (k == XK_mu) return \"mu\";\n\tif (k == XK_paragraph) return \"paragraph\";\n\tif (k == XK_periodcentered) return \"periodcentered\";\n\tif (k == XK_cedilla) return \"cedilla\";\n\tif (k == XK_onesuperior) return \"onesuperior\";\n\tif (k == XK_masculine) return \"masculine\";\n\tif (k == XK_guillemotright) return \"guillemotright\";\n\tif (k == XK_onequarter) return \"onequarter\";\n\tif (k == XK_onehalf) return \"onehalf\";\n\tif (k == XK_threequarters) return \"threequarters\";\n\tif (k == XK_questiondown) return \"questiondown\";\n\tif (k == XK_Agrave) return \"Agrave\";\n\tif (k == XK_Aacute) return \"Aacute\";\n\tif (k == XK_Acircumflex) return \"Acircumflex\";\n\tif (k == XK_Atilde) return \"Atilde\";\n\tif (k == XK_Adiaeresis) return \"Adiaeresis\";\n\tif (k == XK_Aring) return \"Aring\";\n\tif (k == XK_AE) return \"AE\";\n\tif (k == XK_Ccedilla) return \"Ccedilla\";\n\tif (k == XK_Egrave) return \"Egrave\";\n\tif (k == XK_Eacute) return \"Eacute\";\n\tif (k == XK_Ecircumflex) return \"Ecircumflex\";\n\tif (k == XK_Ediaeresis) return \"Ediaeresis\";\n\tif (k == XK_Igrave) return \"Igrave\";\n\tif (k == XK_Iacute) return \"Iacute\";\n\tif (k == XK_Icircumflex) return \"Icircumflex\";\n\tif (k == XK_Idiaeresis) return \"Idiaeresis\";\n\tif (k == XK_ETH) return \"ETH\";\n\tif (k == XK_Eth) return \"Eth\";\n\tif (k == XK_Ntilde) return \"Ntilde\";\n\tif (k == XK_Ograve) return \"Ograve\";\n\tif (k == XK_Oacute) return \"Oacute\";\n\tif (k == XK_Ocircumflex) return \"Ocircumflex\";\n\tif (k == XK_Otilde) return \"Otilde\";\n\tif (k == XK_Odiaeresis) return \"Odiaeresis\";\n\tif (k == XK_multiply) return \"multiply\";\n\tif (k == XK_Ooblique) return \"Ooblique\";\n\tif (k == XK_Ugrave) return \"Ugrave\";\n\tif (k == XK_Uacute) return \"Uacute\";\n\tif (k == XK_Ucircumflex) return \"Ucircumflex\";\n\tif (k == XK_Udiaeresis) return \"Udiaeresis\";\n\tif (k == XK_Yacute) return \"Yacute\";\n\tif (k == XK_THORN) return \"THORN\";\n\tif (k == XK_Thorn) return \"Thorn\";\n\tif (k == XK_ssharp) return \"ssharp\";\n\tif (k == XK_agrave) return \"agrave\";\n\tif (k == XK_aacute) return \"aacute\";\n\tif (k == XK_acircumflex) return \"acircumflex\";\n\tif (k == XK_atilde) return \"atilde\";\n\tif (k == XK_adiaeresis) return \"adiaeresis\";\n\tif (k == XK_aring) return \"aring\";\n\tif (k == XK_ae) return \"ae\";\n\tif (k == XK_ccedilla) return \"ccedilla\";\n\tif (k == XK_egrave) return \"egrave\";\n\tif (k == XK_eacute) return \"eacute\";\n\tif (k == XK_ecircumflex) return \"ecircumflex\";\n\tif (k == XK_ediaeresis) return \"ediaeresis\";\n\tif (k == XK_igrave) return \"igrave\";\n\tif (k == XK_iacute) return \"iacute\";\n\tif (k == XK_icircumflex) return \"icircumflex\";\n\tif (k == XK_idiaeresis) return \"idiaeresis\";\n\tif (k == XK_eth) return \"eth\";\n\tif (k == XK_ntilde) return \"ntilde\";\n\tif (k == XK_ograve) return \"ograve\";\n\tif (k == XK_oacute) return \"oacute\";\n\tif (k == XK_ocircumflex) return \"ocircumflex\";\n\tif (k == XK_otilde) return \"otilde\";\n\tif (k == XK_odiaeresis) return \"odiaeresis\";\n\tif (k == XK_division) return \"division\";\n\tif (k == XK_oslash) return \"oslash\";\n\tif (k == XK_ugrave) return \"ugrave\";\n\tif (k == XK_uacute) return \"uacute\";\n\tif (k == XK_ucircumflex) return \"ucircumflex\";\n\tif (k == XK_udiaeresis) return \"udiaeresis\";\n\tif (k == XK_yacute) return \"yacute\";\n\tif (k == XK_thorn) return \"thorn\";\n\tif (k == XK_ydiaeresis) return \"ydiaeresis\";\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (k == XK_Aogonek) return \"Aogonek\";\n\tif (k == XK_breve) return \"breve\";\n\tif (k == XK_Lstroke) return \"Lstroke\";\n\tif (k == XK_Lcaron) return \"Lcaron\";\n\tif (k == XK_Sacute) return \"Sacute\";\n\tif (k == XK_Scaron) return \"Scaron\";\n\tif (k == XK_Scedilla) return \"Scedilla\";\n\tif (k == XK_Tcaron) return \"Tcaron\";\n\tif (k == XK_Zacute) return \"Zacute\";\n\tif (k == XK_Zcaron) return \"Zcaron\";\n\tif (k == XK_Zabovedot) return \"Zabovedot\";\n\tif (k == XK_aogonek) return \"aogonek\";\n\tif (k == XK_ogonek) return \"ogonek\";\n\tif (k == XK_lstroke) return \"lstroke\";\n\tif (k == XK_lcaron) return \"lcaron\";\n\tif (k == XK_sacute) return \"sacute\";\n\tif (k == XK_caron) return \"caron\";\n\tif (k == XK_scaron) return \"scaron\";\n\tif (k == XK_scedilla) return \"scedilla\";\n\tif (k == XK_tcaron) return \"tcaron\";\n\tif (k == XK_zacute) return \"zacute\";\n\tif (k == XK_doubleacute) return \"doubleacute\";\n\tif (k == XK_zcaron) return \"zcaron\";\n\tif (k == XK_zabovedot) return \"zabovedot\";\n\tif (k == XK_Racute) return \"Racute\";\n\tif (k == XK_Abreve) return \"Abreve\";\n\tif (k == XK_Lacute) return \"Lacute\";\n\tif (k == XK_Cacute) return \"Cacute\";\n\tif (k == XK_Ccaron) return \"Ccaron\";\n\tif (k == XK_Eogonek) return \"Eogonek\";\n\tif (k == XK_Ecaron) return \"Ecaron\";\n\tif (k == XK_Dcaron) return \"Dcaron\";\n\tif (k == XK_Dstroke) return \"Dstroke\";\n\tif (k == XK_Nacute) return \"Nacute\";\n\tif (k == XK_Ncaron) return \"Ncaron\";\n\tif (k == XK_Odoubleacute) return \"Odoubleacute\";\n\tif (k == XK_Rcaron) return \"Rcaron\";\n\tif (k == XK_Uring) return \"Uring\";\n\tif (k == XK_Udoubleacute) return \"Udoubleacute\";\n\tif (k == XK_Tcedilla) return \"Tcedilla\";\n\tif (k == XK_racute) return \"racute\";\n\tif (k == XK_abreve) return \"abreve\";\n\tif (k == XK_lacute) return \"lacute\";\n\tif (k == XK_cacute) return \"cacute\";\n\tif (k == XK_ccaron) return \"ccaron\";\n\tif (k == XK_eogonek) return \"eogonek\";\n\tif (k == XK_ecaron) return \"ecaron\";\n\tif (k == XK_dcaron) return \"dcaron\";\n\tif (k == XK_dstroke) return \"dstroke\";\n\tif (k == XK_nacute) return \"nacute\";\n\tif (k == XK_ncaron) return \"ncaron\";\n\tif (k == XK_odoubleacute) return \"odoubleacute\";\n\tif (k == XK_udoubleacute) return \"udoubleacute\";\n\tif (k == XK_rcaron) return \"rcaron\";\n\tif (k == XK_uring) return \"uring\";\n\tif (k == XK_tcedilla) return \"tcedilla\";\n\tif (k == XK_abovedot) return \"abovedot\";\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (k == XK_Hstroke) return \"Hstroke\";\n\tif (k == XK_Hcircumflex) return \"Hcircumflex\";\n\tif (k == XK_Iabovedot) return \"Iabovedot\";\n\tif (k == XK_Gbreve) return \"Gbreve\";\n\tif (k == XK_Jcircumflex) return \"Jcircumflex\";\n\tif (k == XK_hstroke) return \"hstroke\";\n\tif (k == XK_hcircumflex) return \"hcircumflex\";\n\tif (k == XK_idotless) return \"idotless\";\n\tif (k == XK_gbreve) return \"gbreve\";\n\tif (k == XK_jcircumflex) return \"jcircumflex\";\n\tif (k == XK_Cabovedot) return \"Cabovedot\";\n\tif (k == XK_Ccircumflex) return \"Ccircumflex\";\n\tif (k == XK_Gabovedot) return \"Gabovedot\";\n\tif (k == XK_Gcircumflex) return \"Gcircumflex\";\n\tif (k == XK_Ubreve) return \"Ubreve\";\n\tif (k == XK_Scircumflex) return \"Scircumflex\";\n\tif (k == XK_cabovedot) return \"cabovedot\";\n\tif (k == XK_ccircumflex) return \"ccircumflex\";\n\tif (k == XK_gabovedot) return \"gabovedot\";\n\tif (k == XK_gcircumflex) return \"gcircumflex\";\n\tif (k == XK_ubreve) return \"ubreve\";\n\tif (k == XK_scircumflex) return \"scircumflex\";\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (k == XK_kra) return \"kra\";\n\tif (k == XK_kappa) return \"kappa\";\n\tif (k == XK_Rcedilla) return \"Rcedilla\";\n\tif (k == XK_Itilde) return \"Itilde\";\n\tif (k == XK_Lcedilla) return \"Lcedilla\";\n\tif (k == XK_Emacron) return \"Emacron\";\n\tif (k == XK_Gcedilla) return \"Gcedilla\";\n\tif (k == XK_Tslash) return \"Tslash\";\n\tif (k == XK_rcedilla) return \"rcedilla\";\n\tif (k == XK_itilde) return \"itilde\";\n\tif (k == XK_lcedilla) return \"lcedilla\";\n\tif (k == XK_emacron) return \"emacron\";\n\tif (k == XK_gcedilla) return \"gcedilla\";\n\tif (k == XK_tslash) return \"tslash\";\n\tif (k == XK_ENG) return \"ENG\";\n\tif (k == XK_eng) return \"eng\";\n\tif (k == XK_Amacron) return \"Amacron\";\n\tif (k == XK_Iogonek) return \"Iogonek\";\n\tif (k == XK_Eabovedot) return \"Eabovedot\";\n\tif (k == XK_Imacron) return \"Imacron\";\n\tif (k == XK_Ncedilla) return \"Ncedilla\";\n\tif (k == XK_Omacron) return \"Omacron\";\n\tif (k == XK_Kcedilla) return \"Kcedilla\";\n\tif (k == XK_Uogonek) return \"Uogonek\";\n\tif (k == XK_Utilde) return \"Utilde\";\n\tif (k == XK_Umacron) return \"Umacron\";\n\tif (k == XK_amacron) return \"amacron\";\n\tif (k == XK_iogonek) return \"iogonek\";\n\tif (k == XK_eabovedot) return \"eabovedot\";\n\tif (k == XK_imacron) return \"imacron\";\n\tif (k == XK_ncedilla) return \"ncedilla\";\n\tif (k == XK_omacron) return \"omacron\";\n\tif (k == XK_kcedilla) return \"kcedilla\";\n\tif (k == XK_uogonek) return \"uogonek\";\n\tif (k == XK_utilde) return \"utilde\";\n\tif (k == XK_umacron) return \"umacron\";\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (k == XK_overline) return \"overline\";\n\tif (k == XK_kana_fullstop) return \"kana_fullstop\";\n\tif (k == XK_kana_openingbracket) return \"kana_openingbracket\";\n\tif (k == XK_kana_closingbracket) return \"kana_closingbracket\";\n\tif (k == XK_kana_comma) return \"kana_comma\";\n\tif (k == XK_kana_conjunctive) return \"kana_conjunctive\";\n\tif (k == XK_kana_middledot) return \"kana_middledot\";\n\tif (k == XK_kana_WO) return \"kana_WO\";\n\tif (k == XK_kana_a) return \"kana_a\";\n\tif (k == XK_kana_i) return \"kana_i\";\n\tif (k == XK_kana_u) return \"kana_u\";\n\tif (k == XK_kana_e) return \"kana_e\";\n\tif (k == XK_kana_o) return \"kana_o\";\n\tif (k == XK_kana_ya) return \"kana_ya\";\n\tif (k == XK_kana_yu) return \"kana_yu\";\n\tif (k == XK_kana_yo) return \"kana_yo\";\n\tif (k == XK_kana_tsu) return \"kana_tsu\";\n\tif (k == XK_kana_tu) return \"kana_tu\";\n\tif (k == XK_prolongedsound) return \"prolongedsound\";\n\tif (k == XK_kana_A) return \"kana_A\";\n\tif (k == XK_kana_I) return \"kana_I\";\n\tif (k == XK_kana_U) return \"kana_U\";\n\tif (k == XK_kana_E) return \"kana_E\";\n\tif (k == XK_kana_O) return \"kana_O\";\n\tif (k == XK_kana_KA) return \"kana_KA\";\n\tif (k == XK_kana_KI) return \"kana_KI\";\n\tif (k == XK_kana_KU) return \"kana_KU\";\n\tif (k == XK_kana_KE) return \"kana_KE\";\n\tif (k == XK_kana_KO) return \"kana_KO\";\n\tif (k == XK_kana_SA) return \"kana_SA\";\n\tif (k == XK_kana_SHI) return \"kana_SHI\";\n\tif (k == XK_kana_SU) return \"kana_SU\";\n\tif (k == XK_kana_SE) return \"kana_SE\";\n\tif (k == XK_kana_SO) return \"kana_SO\";\n\tif (k == XK_kana_TA) return \"kana_TA\";\n\tif (k == XK_kana_CHI) return \"kana_CHI\";\n\tif (k == XK_kana_TI) return \"kana_TI\";\n\tif (k == XK_kana_TSU) return \"kana_TSU\";\n\tif (k == XK_kana_TU) return \"kana_TU\";\n\tif (k == XK_kana_TE) return \"kana_TE\";\n\tif (k == XK_kana_TO) return \"kana_TO\";\n\tif (k == XK_kana_NA) return \"kana_NA\";\n\tif (k == XK_kana_NI) return \"kana_NI\";\n\tif (k == XK_kana_NU) return \"kana_NU\";\n\tif (k == XK_kana_NE) return \"kana_NE\";\n\tif (k == XK_kana_NO) return \"kana_NO\";\n\tif (k == XK_kana_HA) return \"kana_HA\";\n\tif (k == XK_kana_HI) return \"kana_HI\";\n\tif (k == XK_kana_FU) return \"kana_FU\";\n\tif (k == XK_kana_HU) return \"kana_HU\";\n\tif (k == XK_kana_HE) return \"kana_HE\";\n\tif (k == XK_kana_HO) return \"kana_HO\";\n\tif (k == XK_kana_MA) return \"kana_MA\";\n\tif (k == XK_kana_MI) return \"kana_MI\";\n\tif (k == XK_kana_MU) return \"kana_MU\";\n\tif (k == XK_kana_ME) return \"kana_ME\";\n\tif (k == XK_kana_MO) return \"kana_MO\";\n\tif (k == XK_kana_YA) return \"kana_YA\";\n\tif (k == XK_kana_YU) return \"kana_YU\";\n\tif (k == XK_kana_YO) return \"kana_YO\";\n\tif (k == XK_kana_RA) return \"kana_RA\";\n\tif (k == XK_kana_RI) return \"kana_RI\";\n\tif (k == XK_kana_RU) return \"kana_RU\";\n\tif (k == XK_kana_RE) return \"kana_RE\";\n\tif (k == XK_kana_RO) return \"kana_RO\";\n\tif (k == XK_kana_WA) return \"kana_WA\";\n\tif (k == XK_kana_N) return \"kana_N\";\n\tif (k == XK_voicedsound) return \"voicedsound\";\n\tif (k == XK_semivoicedsound) return \"semivoicedsound\";\n\tif (k == XK_kana_switch) return \"kana_switch\";\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (k == XK_Arabic_comma) return \"Arabic_comma\";\n\tif (k == XK_Arabic_semicolon) return \"Arabic_semicolon\";\n\tif (k == XK_Arabic_question_mark) return \"Arabic_question_mark\";\n\tif (k == XK_Arabic_hamza) return \"Arabic_hamza\";\n\tif (k == XK_Arabic_maddaonalef) return \"Arabic_maddaonalef\";\n\tif (k == XK_Arabic_hamzaonalef) return \"Arabic_hamzaonalef\";\n\tif (k == XK_Arabic_hamzaonwaw) return \"Arabic_hamzaonwaw\";\n\tif (k == XK_Arabic_hamzaunderalef) return \"Arabic_hamzaunderalef\";\n\tif (k == XK_Arabic_hamzaonyeh) return \"Arabic_hamzaonyeh\";\n\tif (k == XK_Arabic_alef) return \"Arabic_alef\";\n\tif (k == XK_Arabic_beh) return \"Arabic_beh\";\n\tif (k == XK_Arabic_tehmarbuta) return \"Arabic_tehmarbuta\";\n\tif (k == XK_Arabic_teh) return \"Arabic_teh\";\n\tif (k == XK_Arabic_theh) return \"Arabic_theh\";\n\tif (k == XK_Arabic_jeem) return \"Arabic_jeem\";\n\tif (k == XK_Arabic_hah) return \"Arabic_hah\";\n\tif (k == XK_Arabic_khah) return \"Arabic_khah\";\n\tif (k == XK_Arabic_dal) return \"Arabic_dal\";\n\tif (k == XK_Arabic_thal) return \"Arabic_thal\";\n\tif (k == XK_Arabic_ra) return \"Arabic_ra\";\n\tif (k == XK_Arabic_zain) return \"Arabic_zain\";\n\tif (k == XK_Arabic_seen) return \"Arabic_seen\";\n\tif (k == XK_Arabic_sheen) return \"Arabic_sheen\";\n\tif (k == XK_Arabic_sad) return \"Arabic_sad\";\n\tif (k == XK_Arabic_dad) return \"Arabic_dad\";\n\tif (k == XK_Arabic_tah) return \"Arabic_tah\";\n\tif (k == XK_Arabic_zah) return \"Arabic_zah\";\n\tif (k == XK_Arabic_ain) return \"Arabic_ain\";\n\tif (k == XK_Arabic_ghain) return \"Arabic_ghain\";\n\tif (k == XK_Arabic_tatweel) return \"Arabic_tatweel\";\n\tif (k == XK_Arabic_feh) return \"Arabic_feh\";\n\tif (k == XK_Arabic_qaf) return \"Arabic_qaf\";\n\tif (k == XK_Arabic_kaf) return \"Arabic_kaf\";\n\tif (k == XK_Arabic_lam) return \"Arabic_lam\";\n\tif (k == XK_Arabic_meem) return \"Arabic_meem\";\n\tif (k == XK_Arabic_noon) return \"Arabic_noon\";\n\tif (k == XK_Arabic_ha) return \"Arabic_ha\";\n\tif (k == XK_Arabic_heh) return \"Arabic_heh\";\n\tif (k == XK_Arabic_waw) return \"Arabic_waw\";\n\tif (k == XK_Arabic_alefmaksura) return \"Arabic_alefmaksura\";\n\tif (k == XK_Arabic_yeh) return \"Arabic_yeh\";\n\tif (k == XK_Arabic_fathatan) return \"Arabic_fathatan\";\n\tif (k == XK_Arabic_dammatan) return \"Arabic_dammatan\";\n\tif (k == XK_Arabic_kasratan) return \"Arabic_kasratan\";\n\tif (k == XK_Arabic_fatha) return \"Arabic_fatha\";\n\tif (k == XK_Arabic_damma) return \"Arabic_damma\";\n\tif (k == XK_Arabic_kasra) return \"Arabic_kasra\";\n\tif (k == XK_Arabic_shadda) return \"Arabic_shadda\";\n\tif (k == XK_Arabic_sukun) return \"Arabic_sukun\";\n\tif (k == XK_Arabic_switch) return \"Arabic_switch\";\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (k == XK_Serbian_dje) return \"Serbian_dje\";\n\tif (k == XK_Macedonia_gje) return \"Macedonia_gje\";\n\tif (k == XK_Cyrillic_io) return \"Cyrillic_io\";\n\tif (k == XK_Ukrainian_ie) return \"Ukrainian_ie\";\n\tif (k == XK_Ukranian_je) return \"Ukranian_je\";\n\tif (k == XK_Macedonia_dse) return \"Macedonia_dse\";\n\tif (k == XK_Ukrainian_i) return \"Ukrainian_i\";\n\tif (k == XK_Ukranian_i) return \"Ukranian_i\";\n\tif (k == XK_Ukrainian_yi) return \"Ukrainian_yi\";\n\tif (k == XK_Ukranian_yi) return \"Ukranian_yi\";\n\tif (k == XK_Cyrillic_je) return \"Cyrillic_je\";\n\tif (k == XK_Serbian_je) return \"Serbian_je\";\n\tif (k == XK_Cyrillic_lje) return \"Cyrillic_lje\";\n\tif (k == XK_Serbian_lje) return \"Serbian_lje\";\n\tif (k == XK_Cyrillic_nje) return \"Cyrillic_nje\";\n\tif (k == XK_Serbian_nje) return \"Serbian_nje\";\n\tif (k == XK_Serbian_tshe) return \"Serbian_tshe\";\n\tif (k == XK_Macedonia_kje) return \"Macedonia_kje\";\n\tif (k == XK_Byelorussian_shortu) return \"Byelorussian_shortu\";\n\tif (k == XK_Cyrillic_dzhe) return \"Cyrillic_dzhe\";\n\tif (k == XK_Serbian_dze) return \"Serbian_dze\";\n\tif (k == XK_numerosign) return \"numerosign\";\n\tif (k == XK_Serbian_DJE) return \"Serbian_DJE\";\n\tif (k == XK_Macedonia_GJE) return \"Macedonia_GJE\";\n\tif (k == XK_Cyrillic_IO) return \"Cyrillic_IO\";\n\tif (k == XK_Ukrainian_IE) return \"Ukrainian_IE\";\n\tif (k == XK_Ukranian_JE) return \"Ukranian_JE\";\n\tif (k == XK_Macedonia_DSE) return \"Macedonia_DSE\";\n\tif (k == XK_Ukrainian_I) return \"Ukrainian_I\";\n\tif (k == XK_Ukranian_I) return \"Ukranian_I\";\n\tif (k == XK_Ukrainian_YI) return \"Ukrainian_YI\";\n\tif (k == XK_Ukranian_YI) return \"Ukranian_YI\";\n\tif (k == XK_Cyrillic_JE) return \"Cyrillic_JE\";\n\tif (k == XK_Serbian_JE) return \"Serbian_JE\";\n\tif (k == XK_Cyrillic_LJE) return \"Cyrillic_LJE\";\n\tif (k == XK_Serbian_LJE) return \"Serbian_LJE\";\n\tif (k == XK_Cyrillic_NJE) return \"Cyrillic_NJE\";\n\tif (k == XK_Serbian_NJE) return \"Serbian_NJE\";\n\tif (k == XK_Serbian_TSHE) return \"Serbian_TSHE\";\n\tif (k == XK_Macedonia_KJE) return \"Macedonia_KJE\";\n\tif (k == XK_Byelorussian_SHORTU) return \"Byelorussian_SHORTU\";\n\tif (k == XK_Cyrillic_DZHE) return \"Cyrillic_DZHE\";\n\tif (k == XK_Serbian_DZE) return \"Serbian_DZE\";\n\tif (k == XK_Cyrillic_yu) return \"Cyrillic_yu\";\n\tif (k == XK_Cyrillic_a) return \"Cyrillic_a\";\n\tif (k == XK_Cyrillic_be) return \"Cyrillic_be\";\n\tif (k == XK_Cyrillic_tse) return \"Cyrillic_tse\";\n\tif (k == XK_Cyrillic_de) return \"Cyrillic_de\";\n\tif (k == XK_Cyrillic_ie) return \"Cyrillic_ie\";\n\tif (k == XK_Cyrillic_ef) return \"Cyrillic_ef\";\n\tif (k == XK_Cyrillic_ghe) return \"Cyrillic_ghe\";\n\tif (k == XK_Cyrillic_ha) return \"Cyrillic_ha\";\n\tif (k == XK_Cyrillic_i) return \"Cyrillic_i\";\n\tif (k == XK_Cyrillic_shorti) return \"Cyrillic_shorti\";\n\tif (k == XK_Cyrillic_ka) return \"Cyrillic_ka\";\n\tif (k == XK_Cyrillic_el) return \"Cyrillic_el\";\n\tif (k == XK_Cyrillic_em) return \"Cyrillic_em\";\n\tif (k == XK_Cyrillic_en) return \"Cyrillic_en\";\n\tif (k == XK_Cyrillic_o) return \"Cyrillic_o\";\n\tif (k == XK_Cyrillic_pe) return \"Cyrillic_pe\";\n\tif (k == XK_Cyrillic_ya) return \"Cyrillic_ya\";\n\tif (k == XK_Cyrillic_er) return \"Cyrillic_er\";\n\tif (k == XK_Cyrillic_es) return \"Cyrillic_es\";\n\tif (k == XK_Cyrillic_te) return \"Cyrillic_te\";\n\tif (k == XK_Cyrillic_u) return \"Cyrillic_u\";\n\tif (k == XK_Cyrillic_zhe) return \"Cyrillic_zhe\";\n\tif (k == XK_Cyrillic_ve) return \"Cyrillic_ve\";\n\tif (k == XK_Cyrillic_softsign) return \"Cyrillic_softsign\";\n\tif (k == XK_Cyrillic_yeru) return \"Cyrillic_yeru\";\n\tif (k == XK_Cyrillic_ze) return \"Cyrillic_ze\";\n\tif (k == XK_Cyrillic_sha) return \"Cyrillic_sha\";\n\tif (k == XK_Cyrillic_e) return \"Cyrillic_e\";\n\tif (k == XK_Cyrillic_shcha) return \"Cyrillic_shcha\";\n\tif (k == XK_Cyrillic_che) return \"Cyrillic_che\";\n\tif (k == XK_Cyrillic_hardsign) return \"Cyrillic_hardsign\";\n\tif (k == XK_Cyrillic_YU) return \"Cyrillic_YU\";\n\tif (k == XK_Cyrillic_A) return \"Cyrillic_A\";\n\tif (k == XK_Cyrillic_BE) return \"Cyrillic_BE\";\n\tif (k == XK_Cyrillic_TSE) return \"Cyrillic_TSE\";\n\tif (k == XK_Cyrillic_DE) return \"Cyrillic_DE\";\n\tif (k == XK_Cyrillic_IE) return \"Cyrillic_IE\";\n\tif (k == XK_Cyrillic_EF) return \"Cyrillic_EF\";\n\tif (k == XK_Cyrillic_GHE) return \"Cyrillic_GHE\";\n\tif (k == XK_Cyrillic_HA) return \"Cyrillic_HA\";\n\tif (k == XK_Cyrillic_I) return \"Cyrillic_I\";\n\tif (k == XK_Cyrillic_SHORTI) return \"Cyrillic_SHORTI\";\n\tif (k == XK_Cyrillic_KA) return \"Cyrillic_KA\";\n\tif (k == XK_Cyrillic_EL) return \"Cyrillic_EL\";\n\tif (k == XK_Cyrillic_EM) return \"Cyrillic_EM\";\n\tif (k == XK_Cyrillic_EN) return \"Cyrillic_EN\";\n\tif (k == XK_Cyrillic_O) return \"Cyrillic_O\";\n\tif (k == XK_Cyrillic_PE) return \"Cyrillic_PE\";\n\tif (k == XK_Cyrillic_YA) return \"Cyrillic_YA\";\n\tif (k == XK_Cyrillic_ER) return \"Cyrillic_ER\";\n\tif (k == XK_Cyrillic_ES) return \"Cyrillic_ES\";\n\tif (k == XK_Cyrillic_TE) return \"Cyrillic_TE\";\n\tif (k == XK_Cyrillic_U) return \"Cyrillic_U\";\n\tif (k == XK_Cyrillic_ZHE) return \"Cyrillic_ZHE\";\n\tif (k == XK_Cyrillic_VE) return \"Cyrillic_VE\";\n\tif (k == XK_Cyrillic_SOFTSIGN) return \"Cyrillic_SOFTSIGN\";\n\tif (k == XK_Cyrillic_YERU) return \"Cyrillic_YERU\";\n\tif (k == XK_Cyrillic_ZE) return \"Cyrillic_ZE\";\n\tif (k == XK_Cyrillic_SHA) return \"Cyrillic_SHA\";\n\tif (k == XK_Cyrillic_E) return \"Cyrillic_E\";\n\tif (k == XK_Cyrillic_SHCHA) return \"Cyrillic_SHCHA\";\n\tif (k == XK_Cyrillic_CHE) return \"Cyrillic_CHE\";\n\tif (k == XK_Cyrillic_HARDSIGN) return \"Cyrillic_HARDSIGN\";\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (k == XK_Greek_ALPHAaccent) return \"Greek_ALPHAaccent\";\n\tif (k == XK_Greek_EPSILONaccent) return \"Greek_EPSILONaccent\";\n\tif (k == XK_Greek_ETAaccent) return \"Greek_ETAaccent\";\n\tif (k == XK_Greek_IOTAaccent) return \"Greek_IOTAaccent\";\n\tif (k == XK_Greek_IOTAdieresis) return \"Greek_IOTAdieresis\";\n\tif (k == XK_Greek_OMICRONaccent) return \"Greek_OMICRONaccent\";\n\tif (k == XK_Greek_UPSILONaccent) return \"Greek_UPSILONaccent\";\n\tif (k == XK_Greek_UPSILONdieresis) return \"Greek_UPSILONdieresis\";\n\tif (k == XK_Greek_OMEGAaccent) return \"Greek_OMEGAaccent\";\n\tif (k == XK_Greek_accentdieresis) return \"Greek_accentdieresis\";\n\tif (k == XK_Greek_horizbar) return \"Greek_horizbar\";\n\tif (k == XK_Greek_alphaaccent) return \"Greek_alphaaccent\";\n\tif (k == XK_Greek_epsilonaccent) return \"Greek_epsilonaccent\";\n\tif (k == XK_Greek_etaaccent) return \"Greek_etaaccent\";\n\tif (k == XK_Greek_iotaaccent) return \"Greek_iotaaccent\";\n\tif (k == XK_Greek_iotadieresis) return \"Greek_iotadieresis\";\n\tif (k == XK_Greek_iotaaccentdieresis) return \"Greek_iotaaccentdieresis\";\n\tif (k == XK_Greek_omicronaccent) return \"Greek_omicronaccent\";\n\tif (k == XK_Greek_upsilonaccent) return \"Greek_upsilonaccent\";\n\tif (k == XK_Greek_upsilondieresis) return \"Greek_upsilondieresis\";\n\tif (k == XK_Greek_upsilonaccentdieresis) return \"Greek_upsilonaccentdieresis\";\n\tif (k == XK_Greek_omegaaccent) return \"Greek_omegaaccent\";\n\tif (k == XK_Greek_ALPHA) return \"Greek_ALPHA\";\n\tif (k == XK_Greek_BETA) return \"Greek_BETA\";\n\tif (k == XK_Greek_GAMMA) return \"Greek_GAMMA\";\n\tif (k == XK_Greek_DELTA) return \"Greek_DELTA\";\n\tif (k == XK_Greek_EPSILON) return \"Greek_EPSILON\";\n\tif (k == XK_Greek_ZETA) return \"Greek_ZETA\";\n\tif (k == XK_Greek_ETA) return \"Greek_ETA\";\n\tif (k == XK_Greek_THETA) return \"Greek_THETA\";\n\tif (k == XK_Greek_IOTA) return \"Greek_IOTA\";\n\tif (k == XK_Greek_KAPPA) return \"Greek_KAPPA\";\n\tif (k == XK_Greek_LAMDA) return \"Greek_LAMDA\";\n\tif (k == XK_Greek_LAMBDA) return \"Greek_LAMBDA\";\n\tif (k == XK_Greek_MU) return \"Greek_MU\";\n\tif (k == XK_Greek_NU) return \"Greek_NU\";\n\tif (k == XK_Greek_XI) return \"Greek_XI\";\n\tif (k == XK_Greek_OMICRON) return \"Greek_OMICRON\";\n\tif (k == XK_Greek_PI) return \"Greek_PI\";\n\tif (k == XK_Greek_RHO) return \"Greek_RHO\";\n\tif (k == XK_Greek_SIGMA) return \"Greek_SIGMA\";\n\tif (k == XK_Greek_TAU) return \"Greek_TAU\";\n\tif (k == XK_Greek_UPSILON) return \"Greek_UPSILON\";\n\tif (k == XK_Greek_PHI) return \"Greek_PHI\";\n\tif (k == XK_Greek_CHI) return \"Greek_CHI\";\n\tif (k == XK_Greek_PSI) return \"Greek_PSI\";\n\tif (k == XK_Greek_OMEGA) return \"Greek_OMEGA\";\n\tif (k == XK_Greek_alpha) return \"Greek_alpha\";\n\tif (k == XK_Greek_beta) return \"Greek_beta\";\n\tif (k == XK_Greek_gamma) return \"Greek_gamma\";\n\tif (k == XK_Greek_delta) return \"Greek_delta\";\n\tif (k == XK_Greek_epsilon) return \"Greek_epsilon\";\n\tif (k == XK_Greek_zeta) return \"Greek_zeta\";\n\tif (k == XK_Greek_eta) return \"Greek_eta\";\n\tif (k == XK_Greek_theta) return \"Greek_theta\";\n\tif (k == XK_Greek_iota) return \"Greek_iota\";\n\tif (k == XK_Greek_kappa) return \"Greek_kappa\";\n\tif (k == XK_Greek_lamda) return \"Greek_lamda\";\n\tif (k == XK_Greek_lambda) return \"Greek_lambda\";\n\tif (k == XK_Greek_mu) return \"Greek_mu\";\n\tif (k == XK_Greek_nu) return \"Greek_nu\";\n\tif (k == XK_Greek_xi) return \"Greek_xi\";\n\tif (k == XK_Greek_omicron) return \"Greek_omicron\";\n\tif (k == XK_Greek_pi) return \"Greek_pi\";\n\tif (k == XK_Greek_rho) return \"Greek_rho\";\n\tif (k == XK_Greek_sigma) return \"Greek_sigma\";\n\tif (k == XK_Greek_finalsmallsigma) return \"Greek_finalsmallsigma\";\n\tif (k == XK_Greek_tau) return \"Greek_tau\";\n\tif (k == XK_Greek_upsilon) return \"Greek_upsilon\";\n\tif (k == XK_Greek_phi) return \"Greek_phi\";\n\tif (k == XK_Greek_chi) return \"Greek_chi\";\n\tif (k == XK_Greek_psi) return \"Greek_psi\";\n\tif (k == XK_Greek_omega) return \"Greek_omega\";\n\tif (k == XK_Greek_switch) return \"Greek_switch\";\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (k == XK_leftradical) return \"leftradical\";\n\tif (k == XK_topleftradical) return \"topleftradical\";\n\tif (k == XK_horizconnector) return \"horizconnector\";\n\tif (k == XK_topintegral) return \"topintegral\";\n\tif (k == XK_botintegral) return \"botintegral\";\n\tif (k == XK_vertconnector) return \"vertconnector\";\n\tif (k == XK_topleftsqbracket) return \"topleftsqbracket\";\n\tif (k == XK_botleftsqbracket) return \"botleftsqbracket\";\n\tif (k == XK_toprightsqbracket) return \"toprightsqbracket\";\n\tif (k == XK_botrightsqbracket) return \"botrightsqbracket\";\n\tif (k == XK_topleftparens) return \"topleftparens\";\n\tif (k == XK_botleftparens) return \"botleftparens\";\n\tif (k == XK_toprightparens) return \"toprightparens\";\n\tif (k == XK_botrightparens) return \"botrightparens\";\n\tif (k == XK_leftmiddlecurlybrace) return \"leftmiddlecurlybrace\";\n\tif (k == XK_rightmiddlecurlybrace) return \"rightmiddlecurlybrace\";\n\tif (k == XK_topleftsummation) return \"topleftsummation\";\n\tif (k == XK_botleftsummation) return \"botleftsummation\";\n\tif (k == XK_topvertsummationconnector) return \"topvertsummationconnector\";\n\tif (k == XK_botvertsummationconnector) return \"botvertsummationconnector\";\n\tif (k == XK_toprightsummation) return \"toprightsummation\";\n\tif (k == XK_botrightsummation) return \"botrightsummation\";\n\tif (k == XK_rightmiddlesummation) return \"rightmiddlesummation\";\n\tif (k == XK_lessthanequal) return \"lessthanequal\";\n\tif (k == XK_notequal) return \"notequal\";\n\tif (k == XK_greaterthanequal) return \"greaterthanequal\";\n\tif (k == XK_integral) return \"integral\";\n\tif (k == XK_therefore) return \"therefore\";\n\tif (k == XK_variation) return \"variation\";\n\tif (k == XK_infinity) return \"infinity\";\n\tif (k == XK_nabla) return \"nabla\";\n\tif (k == XK_approximate) return \"approximate\";\n\tif (k == XK_similarequal) return \"similarequal\";\n\tif (k == XK_ifonlyif) return \"ifonlyif\";\n\tif (k == XK_implies) return \"implies\";\n\tif (k == XK_identical) return \"identical\";\n\tif (k == XK_radical) return \"radical\";\n\tif (k == XK_includedin) return \"includedin\";\n\tif (k == XK_includes) return \"includes\";\n\tif (k == XK_intersection) return \"intersection\";\n\tif (k == XK_union) return \"union\";\n\tif (k == XK_logicaland) return \"logicaland\";\n\tif (k == XK_logicalor) return \"logicalor\";\n\tif (k == XK_partialderivative) return \"partialderivative\";\n\tif (k == XK_function) return \"function\";\n\tif (k == XK_leftarrow) return \"leftarrow\";\n\tif (k == XK_uparrow) return \"uparrow\";\n\tif (k == XK_rightarrow) return \"rightarrow\";\n\tif (k == XK_downarrow) return \"downarrow\";\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (k == XK_blank) return \"blank\";\n\tif (k == XK_soliddiamond) return \"soliddiamond\";\n\tif (k == XK_checkerboard) return \"checkerboard\";\n\tif (k == XK_ht) return \"ht\";\n\tif (k == XK_ff) return \"ff\";\n\tif (k == XK_cr) return \"cr\";\n\tif (k == XK_lf) return \"lf\";\n\tif (k == XK_nl) return \"nl\";\n\tif (k == XK_vt) return \"vt\";\n\tif (k == XK_lowrightcorner) return \"lowrightcorner\";\n\tif (k == XK_uprightcorner) return \"uprightcorner\";\n\tif (k == XK_upleftcorner) return \"upleftcorner\";\n\tif (k == XK_lowleftcorner) return \"lowleftcorner\";\n\tif (k == XK_crossinglines) return \"crossinglines\";\n\tif (k == XK_horizlinescan1) return \"horizlinescan1\";\n\tif (k == XK_horizlinescan3) return \"horizlinescan3\";\n\tif (k == XK_horizlinescan5) return \"horizlinescan5\";\n\tif (k == XK_horizlinescan7) return \"horizlinescan7\";\n\tif (k == XK_horizlinescan9) return \"horizlinescan9\";\n\tif (k == XK_leftt) return \"leftt\";\n\tif (k == XK_rightt) return \"rightt\";\n\tif (k == XK_bott) return \"bott\";\n\tif (k == XK_topt) return \"topt\";\n\tif (k == XK_vertbar) return \"vertbar\";\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (k == XK_emspace) return \"emspace\";\n\tif (k == XK_enspace) return \"enspace\";\n\tif (k == XK_em3space) return \"em3space\";\n\tif (k == XK_em4space) return \"em4space\";\n\tif (k == XK_digitspace) return \"digitspace\";\n\tif (k == XK_punctspace) return \"punctspace\";\n\tif (k == XK_thinspace) return \"thinspace\";\n\tif (k == XK_hairspace) return \"hairspace\";\n\tif (k == XK_emdash) return \"emdash\";\n\tif (k == XK_endash) return \"endash\";\n\tif (k == XK_signifblank) return \"signifblank\";\n\tif (k == XK_ellipsis) return \"ellipsis\";\n\tif (k == XK_doubbaselinedot) return \"doubbaselinedot\";\n\tif (k == XK_onethird) return \"onethird\";\n\tif (k == XK_twothirds) return \"twothirds\";\n\tif (k == XK_onefifth) return \"onefifth\";\n\tif (k == XK_twofifths) return \"twofifths\";\n\tif (k == XK_threefifths) return \"threefifths\";\n\tif (k == XK_fourfifths) return \"fourfifths\";\n\tif (k == XK_onesixth) return \"onesixth\";\n\tif (k == XK_fivesixths) return \"fivesixths\";\n\tif (k == XK_careof) return \"careof\";\n\tif (k == XK_figdash) return \"figdash\";\n\tif (k == XK_leftanglebracket) return \"leftanglebracket\";\n\tif (k == XK_decimalpoint) return \"decimalpoint\";\n\tif (k == XK_rightanglebracket) return \"rightanglebracket\";\n\tif (k == XK_marker) return \"marker\";\n\tif (k == XK_oneeighth) return \"oneeighth\";\n\tif (k == XK_threeeighths) return \"threeeighths\";\n\tif (k == XK_fiveeighths) return \"fiveeighths\";\n\tif (k == XK_seveneighths) return \"seveneighths\";\n\tif (k == XK_trademark) return \"trademark\";\n\tif (k == XK_signaturemark) return \"signaturemark\";\n\tif (k == XK_trademarkincircle) return \"trademarkincircle\";\n\tif (k == XK_leftopentriangle) return \"leftopentriangle\";\n\tif (k == XK_rightopentriangle) return \"rightopentriangle\";\n\tif (k == XK_emopencircle) return \"emopencircle\";\n\tif (k == XK_emopenrectangle) return \"emopenrectangle\";\n\tif (k == XK_leftsinglequotemark) return \"leftsinglequotemark\";\n\tif (k == XK_rightsinglequotemark) return \"rightsinglequotemark\";\n\tif (k == XK_leftdoublequotemark) return \"leftdoublequotemark\";\n\tif (k == XK_rightdoublequotemark) return \"rightdoublequotemark\";\n\tif (k == XK_prescription) return \"prescription\";\n\tif (k == XK_minutes) return \"minutes\";\n\tif (k == XK_seconds) return \"seconds\";\n\tif (k == XK_latincross) return \"latincross\";\n\tif (k == XK_hexagram) return \"hexagram\";\n\tif (k == XK_filledrectbullet) return \"filledrectbullet\";\n\tif (k == XK_filledlefttribullet) return \"filledlefttribullet\";\n\tif (k == XK_filledrighttribullet) return \"filledrighttribullet\";\n\tif (k == XK_emfilledcircle) return \"emfilledcircle\";\n\tif (k == XK_emfilledrect) return \"emfilledrect\";\n\tif (k == XK_enopencircbullet) return \"enopencircbullet\";\n\tif (k == XK_enopensquarebullet) return \"enopensquarebullet\";\n\tif (k == XK_openrectbullet) return \"openrectbullet\";\n\tif (k == XK_opentribulletup) return \"opentribulletup\";\n\tif (k == XK_opentribulletdown) return \"opentribulletdown\";\n\tif (k == XK_openstar) return \"openstar\";\n\tif (k == XK_enfilledcircbullet) return \"enfilledcircbullet\";\n\tif (k == XK_enfilledsqbullet) return \"enfilledsqbullet\";\n\tif (k == XK_filledtribulletup) return \"filledtribulletup\";\n\tif (k == XK_filledtribulletdown) return \"filledtribulletdown\";\n\tif (k == XK_leftpointer) return \"leftpointer\";\n\tif (k == XK_rightpointer) return \"rightpointer\";\n\tif (k == XK_club) return \"club\";\n\tif (k == XK_diamond) return \"diamond\";\n\tif (k == XK_heart) return \"heart\";\n\tif (k == XK_maltesecross) return \"maltesecross\";\n\tif (k == XK_dagger) return \"dagger\";\n\tif (k == XK_doubledagger) return \"doubledagger\";\n\tif (k == XK_checkmark) return \"checkmark\";\n\tif (k == XK_ballotcross) return \"ballotcross\";\n\tif (k == XK_musicalsharp) return \"musicalsharp\";\n\tif (k == XK_musicalflat) return \"musicalflat\";\n\tif (k == XK_malesymbol) return \"malesymbol\";\n\tif (k == XK_femalesymbol) return \"femalesymbol\";\n\tif (k == XK_telephone) return \"telephone\";\n\tif (k == XK_telephonerecorder) return \"telephonerecorder\";\n\tif (k == XK_phonographcopyright) return \"phonographcopyright\";\n\tif (k == XK_caret) return \"caret\";\n\tif (k == XK_singlelowquotemark) return \"singlelowquotemark\";\n\tif (k == XK_doublelowquotemark) return \"doublelowquotemark\";\n\tif (k == XK_cursor) return \"cursor\";\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (k == XK_leftcaret) return \"leftcaret\";\n\tif (k == XK_rightcaret) return \"rightcaret\";\n\tif (k == XK_downcaret) return \"downcaret\";\n\tif (k == XK_upcaret) return \"upcaret\";\n\tif (k == XK_overbar) return \"overbar\";\n\tif (k == XK_downtack) return \"downtack\";\n\tif (k == XK_upshoe) return \"upshoe\";\n\tif (k == XK_downstile) return \"downstile\";\n\tif (k == XK_underbar) return \"underbar\";\n\tif (k == XK_jot) return \"jot\";\n\tif (k == XK_quad) return \"quad\";\n\tif (k == XK_uptack) return \"uptack\";\n\tif (k == XK_circle) return \"circle\";\n\tif (k == XK_upstile) return \"upstile\";\n\tif (k == XK_downshoe) return \"downshoe\";\n\tif (k == XK_rightshoe) return \"rightshoe\";\n\tif (k == XK_leftshoe) return \"leftshoe\";\n\tif (k == XK_lefttack) return \"lefttack\";\n\tif (k == XK_righttack) return \"righttack\";\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (k == XK_hebrew_doublelowline) return \"hebrew_doublelowline\";\n\tif (k == XK_hebrew_aleph) return \"hebrew_aleph\";\n\tif (k == XK_hebrew_bet) return \"hebrew_bet\";\n\tif (k == XK_hebrew_beth) return \"hebrew_beth\";\n\tif (k == XK_hebrew_gimel) return \"hebrew_gimel\";\n\tif (k == XK_hebrew_gimmel) return \"hebrew_gimmel\";\n\tif (k == XK_hebrew_dalet) return \"hebrew_dalet\";\n\tif (k == XK_hebrew_daleth) return \"hebrew_daleth\";\n\tif (k == XK_hebrew_he) return \"hebrew_he\";\n\tif (k == XK_hebrew_waw) return \"hebrew_waw\";\n\tif (k == XK_hebrew_zain) return \"hebrew_zain\";\n\tif (k == XK_hebrew_zayin) return \"hebrew_zayin\";\n\tif (k == XK_hebrew_chet) return \"hebrew_chet\";\n\tif (k == XK_hebrew_het) return \"hebrew_het\";\n\tif (k == XK_hebrew_tet) return \"hebrew_tet\";\n\tif (k == XK_hebrew_teth) return \"hebrew_teth\";\n\tif (k == XK_hebrew_yod) return \"hebrew_yod\";\n\tif (k == XK_hebrew_finalkaph) return \"hebrew_finalkaph\";\n\tif (k == XK_hebrew_kaph) return \"hebrew_kaph\";\n\tif (k == XK_hebrew_lamed) return \"hebrew_lamed\";\n\tif (k == XK_hebrew_finalmem) return \"hebrew_finalmem\";\n\tif (k == XK_hebrew_mem) return \"hebrew_mem\";\n\tif (k == XK_hebrew_finalnun) return \"hebrew_finalnun\";\n\tif (k == XK_hebrew_nun) return \"hebrew_nun\";\n\tif (k == XK_hebrew_samech) return \"hebrew_samech\";\n\tif (k == XK_hebrew_samekh) return \"hebrew_samekh\";\n\tif (k == XK_hebrew_ayin) return \"hebrew_ayin\";\n\tif (k == XK_hebrew_finalpe) return \"hebrew_finalpe\";\n\tif (k == XK_hebrew_pe) return \"hebrew_pe\";\n\tif (k == XK_hebrew_finalzade) return \"hebrew_finalzade\";\n\tif (k == XK_hebrew_finalzadi) return \"hebrew_finalzadi\";\n\tif (k == XK_hebrew_zade) return \"hebrew_zade\";\n\tif (k == XK_hebrew_zadi) return \"hebrew_zadi\";\n\tif (k == XK_hebrew_qoph) return \"hebrew_qoph\";\n\tif (k == XK_hebrew_kuf) return \"hebrew_kuf\";\n\tif (k == XK_hebrew_resh) return \"hebrew_resh\";\n\tif (k == XK_hebrew_shin) return \"hebrew_shin\";\n\tif (k == XK_hebrew_taw) return \"hebrew_taw\";\n\tif (k == XK_hebrew_taf) return \"hebrew_taf\";\n\tif (k == XK_Hebrew_switch) return \"Hebrew_switch\";\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (k == XK_Thai_kokai) return \"Thai_kokai\";\n\tif (k == XK_Thai_khokhai) return \"Thai_khokhai\";\n\tif (k == XK_Thai_khokhuat) return \"Thai_khokhuat\";\n\tif (k == XK_Thai_khokhwai) return \"Thai_khokhwai\";\n\tif (k == XK_Thai_khokhon) return \"Thai_khokhon\";\n\tif (k == XK_Thai_khorakhang) return \"Thai_khorakhang\";\n\tif (k == XK_Thai_ngongu) return \"Thai_ngongu\";\n\tif (k == XK_Thai_chochan) return \"Thai_chochan\";\n\tif (k == XK_Thai_choching) return \"Thai_choching\";\n\tif (k == XK_Thai_chochang) return \"Thai_chochang\";\n\tif (k == XK_Thai_soso) return \"Thai_soso\";\n\tif (k == XK_Thai_chochoe) return \"Thai_chochoe\";\n\tif (k == XK_Thai_yoying) return \"Thai_yoying\";\n\tif (k == XK_Thai_dochada) return \"Thai_dochada\";\n\tif (k == XK_Thai_topatak) return \"Thai_topatak\";\n\tif (k == XK_Thai_thothan) return \"Thai_thothan\";\n\tif (k == XK_Thai_thonangmontho) return \"Thai_thonangmontho\";\n\tif (k == XK_Thai_thophuthao) return \"Thai_thophuthao\";\n\tif (k == XK_Thai_nonen) return \"Thai_nonen\";\n\tif (k == XK_Thai_dodek) return \"Thai_dodek\";\n\tif (k == XK_Thai_totao) return \"Thai_totao\";\n\tif (k == XK_Thai_thothung) return \"Thai_thothung\";\n\tif (k == XK_Thai_thothahan) return \"Thai_thothahan\";\n\tif (k == XK_Thai_thothong) return \"Thai_thothong\";\n\tif (k == XK_Thai_nonu) return \"Thai_nonu\";\n\tif (k == XK_Thai_bobaimai) return \"Thai_bobaimai\";\n\tif (k == XK_Thai_popla) return \"Thai_popla\";\n\tif (k == XK_Thai_phophung) return \"Thai_phophung\";\n\tif (k == XK_Thai_fofa) return \"Thai_fofa\";\n\tif (k == XK_Thai_phophan) return \"Thai_phophan\";\n\tif (k == XK_Thai_fofan) return \"Thai_fofan\";\n\tif (k == XK_Thai_phosamphao) return \"Thai_phosamphao\";\n\tif (k == XK_Thai_moma) return \"Thai_moma\";\n\tif (k == XK_Thai_yoyak) return \"Thai_yoyak\";\n\tif (k == XK_Thai_rorua) return \"Thai_rorua\";\n\tif (k == XK_Thai_ru) return \"Thai_ru\";\n\tif (k == XK_Thai_loling) return \"Thai_loling\";\n\tif (k == XK_Thai_lu) return \"Thai_lu\";\n\tif (k == XK_Thai_wowaen) return \"Thai_wowaen\";\n\tif (k == XK_Thai_sosala) return \"Thai_sosala\";\n\tif (k == XK_Thai_sorusi) return \"Thai_sorusi\";\n\tif (k == XK_Thai_sosua) return \"Thai_sosua\";\n\tif (k == XK_Thai_hohip) return \"Thai_hohip\";\n\tif (k == XK_Thai_lochula) return \"Thai_lochula\";\n\tif (k == XK_Thai_oang) return \"Thai_oang\";\n\tif (k == XK_Thai_honokhuk) return \"Thai_honokhuk\";\n\tif (k == XK_Thai_paiyannoi) return \"Thai_paiyannoi\";\n\tif (k == XK_Thai_saraa) return \"Thai_saraa\";\n\tif (k == XK_Thai_maihanakat) return \"Thai_maihanakat\";\n\tif (k == XK_Thai_saraaa) return \"Thai_saraaa\";\n\tif (k == XK_Thai_saraam) return \"Thai_saraam\";\n\tif (k == XK_Thai_sarai) return \"Thai_sarai\";\n\tif (k == XK_Thai_saraii) return \"Thai_saraii\";\n\tif (k == XK_Thai_saraue) return \"Thai_saraue\";\n\tif (k == XK_Thai_sarauee) return \"Thai_sarauee\";\n\tif (k == XK_Thai_sarau) return \"Thai_sarau\";\n\tif (k == XK_Thai_sarauu) return \"Thai_sarauu\";\n\tif (k == XK_Thai_phinthu) return \"Thai_phinthu\";\n\tif (k == XK_Thai_maihanakat_maitho) return \"Thai_maihanakat_maitho\";\n\tif (k == XK_Thai_baht) return \"Thai_baht\";\n\tif (k == XK_Thai_sarae) return \"Thai_sarae\";\n\tif (k == XK_Thai_saraae) return \"Thai_saraae\";\n\tif (k == XK_Thai_sarao) return \"Thai_sarao\";\n\tif (k == XK_Thai_saraaimaimuan) return \"Thai_saraaimaimuan\";\n\tif (k == XK_Thai_saraaimaimalai) return \"Thai_saraaimaimalai\";\n\tif (k == XK_Thai_lakkhangyao) return \"Thai_lakkhangyao\";\n\tif (k == XK_Thai_maiyamok) return \"Thai_maiyamok\";\n\tif (k == XK_Thai_maitaikhu) return \"Thai_maitaikhu\";\n\tif (k == XK_Thai_maiek) return \"Thai_maiek\";\n\tif (k == XK_Thai_maitho) return \"Thai_maitho\";\n\tif (k == XK_Thai_maitri) return \"Thai_maitri\";\n\tif (k == XK_Thai_maichattawa) return \"Thai_maichattawa\";\n\tif (k == XK_Thai_thanthakhat) return \"Thai_thanthakhat\";\n\tif (k == XK_Thai_nikhahit) return \"Thai_nikhahit\";\n\tif (k == XK_Thai_leksun) return \"Thai_leksun\";\n\tif (k == XK_Thai_leknung) return \"Thai_leknung\";\n\tif (k == XK_Thai_leksong) return \"Thai_leksong\";\n\tif (k == XK_Thai_leksam) return \"Thai_leksam\";\n\tif (k == XK_Thai_leksi) return \"Thai_leksi\";\n\tif (k == XK_Thai_lekha) return \"Thai_lekha\";\n\tif (k == XK_Thai_lekhok) return \"Thai_lekhok\";\n\tif (k == XK_Thai_lekchet) return \"Thai_lekchet\";\n\tif (k == XK_Thai_lekpaet) return \"Thai_lekpaet\";\n\tif (k == XK_Thai_lekkao) return \"Thai_lekkao\";\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (k == XK_Hangul) return \"Hangul\";\n\tif (k == XK_Hangul_Start) return \"Hangul_Start\";\n\tif (k == XK_Hangul_End) return \"Hangul_End\";\n\tif (k == XK_Hangul_Hanja) return \"Hangul_Hanja\";\n\tif (k == XK_Hangul_Jamo) return \"Hangul_Jamo\";\n\tif (k == XK_Hangul_Romaja) return \"Hangul_Romaja\";\n\tif (k == XK_Hangul_Codeinput) return \"Hangul_Codeinput\";\n\tif (k == XK_Hangul_Jeonja) return \"Hangul_Jeonja\";\n\tif (k == XK_Hangul_Banja) return \"Hangul_Banja\";\n\tif (k == XK_Hangul_PreHanja) return \"Hangul_PreHanja\";\n\tif (k == XK_Hangul_PostHanja) return \"Hangul_PostHanja\";\n\tif (k == XK_Hangul_SingleCandidate) return \"Hangul_SingleCandidate\";\n\tif (k == XK_Hangul_MultipleCandidate) return \"Hangul_MultipleCandidate\";\n\tif (k == XK_Hangul_PreviousCandidate) return \"Hangul_PreviousCandidate\";\n\tif (k == XK_Hangul_Special) return \"Hangul_Special\";\n\tif (k == XK_Hangul_switch) return \"Hangul_switch\";\n\tif (k == XK_Hangul_Kiyeog) return \"Hangul_Kiyeog\";\n\tif (k == XK_Hangul_SsangKiyeog) return \"Hangul_SsangKiyeog\";\n\tif (k == XK_Hangul_KiyeogSios) return \"Hangul_KiyeogSios\";\n\tif (k == XK_Hangul_Nieun) return \"Hangul_Nieun\";\n\tif (k == XK_Hangul_NieunJieuj) return \"Hangul_NieunJieuj\";\n\tif (k == XK_Hangul_NieunHieuh) return \"Hangul_NieunHieuh\";\n\tif (k == XK_Hangul_Dikeud) return \"Hangul_Dikeud\";\n\tif (k == XK_Hangul_SsangDikeud) return \"Hangul_SsangDikeud\";\n\tif (k == XK_Hangul_Rieul) return \"Hangul_Rieul\";\n\tif (k == XK_Hangul_RieulKiyeog) return \"Hangul_RieulKiyeog\";\n\tif (k == XK_Hangul_RieulMieum) return \"Hangul_RieulMieum\";\n\tif (k == XK_Hangul_RieulPieub) return \"Hangul_RieulPieub\";\n\tif (k == XK_Hangul_RieulSios) return \"Hangul_RieulSios\";\n\tif (k == XK_Hangul_RieulTieut) return \"Hangul_RieulTieut\";\n\tif (k == XK_Hangul_RieulPhieuf) return \"Hangul_RieulPhieuf\";\n\tif (k == XK_Hangul_RieulHieuh) return \"Hangul_RieulHieuh\";\n\tif (k == XK_Hangul_Mieum) return \"Hangul_Mieum\";\n\tif (k == XK_Hangul_Pieub) return \"Hangul_Pieub\";\n\tif (k == XK_Hangul_SsangPieub) return \"Hangul_SsangPieub\";\n\tif (k == XK_Hangul_PieubSios) return \"Hangul_PieubSios\";\n\tif (k == XK_Hangul_Sios) return \"Hangul_Sios\";\n\tif (k == XK_Hangul_SsangSios) return \"Hangul_SsangSios\";\n\tif (k == XK_Hangul_Ieung) return \"Hangul_Ieung\";\n\tif (k == XK_Hangul_Jieuj) return \"Hangul_Jieuj\";\n\tif (k == XK_Hangul_SsangJieuj) return \"Hangul_SsangJieuj\";\n\tif (k == XK_Hangul_Cieuc) return \"Hangul_Cieuc\";\n\tif (k == XK_Hangul_Khieuq) return \"Hangul_Khieuq\";\n\tif (k == XK_Hangul_Tieut) return \"Hangul_Tieut\";\n\tif (k == XK_Hangul_Phieuf) return \"Hangul_Phieuf\";\n\tif (k == XK_Hangul_Hieuh) return \"Hangul_Hieuh\";\n\tif (k == XK_Hangul_A) return \"Hangul_A\";\n\tif (k == XK_Hangul_AE) return \"Hangul_AE\";\n\tif (k == XK_Hangul_YA) return \"Hangul_YA\";\n\tif (k == XK_Hangul_YAE) return \"Hangul_YAE\";\n\tif (k == XK_Hangul_EO) return \"Hangul_EO\";\n\tif (k == XK_Hangul_E) return \"Hangul_E\";\n\tif (k == XK_Hangul_YEO) return \"Hangul_YEO\";\n\tif (k == XK_Hangul_YE) return \"Hangul_YE\";\n\tif (k == XK_Hangul_O) return \"Hangul_O\";\n\tif (k == XK_Hangul_WA) return \"Hangul_WA\";\n\tif (k == XK_Hangul_WAE) return \"Hangul_WAE\";\n\tif (k == XK_Hangul_OE) return \"Hangul_OE\";\n\tif (k == XK_Hangul_YO) return \"Hangul_YO\";\n\tif (k == XK_Hangul_U) return \"Hangul_U\";\n\tif (k == XK_Hangul_WEO) return \"Hangul_WEO\";\n\tif (k == XK_Hangul_WE) return \"Hangul_WE\";\n\tif (k == XK_Hangul_WI) return \"Hangul_WI\";\n\tif (k == XK_Hangul_YU) return \"Hangul_YU\";\n\tif (k == XK_Hangul_EU) return \"Hangul_EU\";\n\tif (k == XK_Hangul_YI) return \"Hangul_YI\";\n\tif (k == XK_Hangul_I) return \"Hangul_I\";\n\tif (k == XK_Hangul_J_Kiyeog) return \"Hangul_J_Kiyeog\";\n\tif (k == XK_Hangul_J_SsangKiyeog) return \"Hangul_J_SsangKiyeog\";\n\tif (k == XK_Hangul_J_KiyeogSios) return \"Hangul_J_KiyeogSios\";\n\tif (k == XK_Hangul_J_Nieun) return \"Hangul_J_Nieun\";\n\tif (k == XK_Hangul_J_NieunJieuj) return \"Hangul_J_NieunJieuj\";\n\tif (k == XK_Hangul_J_NieunHieuh) return \"Hangul_J_NieunHieuh\";\n\tif (k == XK_Hangul_J_Dikeud) return \"Hangul_J_Dikeud\";\n\tif (k == XK_Hangul_J_Rieul) return \"Hangul_J_Rieul\";\n\tif (k == XK_Hangul_J_RieulKiyeog) return \"Hangul_J_RieulKiyeog\";\n\tif (k == XK_Hangul_J_RieulMieum) return \"Hangul_J_RieulMieum\";\n\tif (k == XK_Hangul_J_RieulPieub) return \"Hangul_J_RieulPieub\";\n\tif (k == XK_Hangul_J_RieulSios) return \"Hangul_J_RieulSios\";\n\tif (k == XK_Hangul_J_RieulTieut) return \"Hangul_J_RieulTieut\";\n\tif (k == XK_Hangul_J_RieulPhieuf) return \"Hangul_J_RieulPhieuf\";\n\tif (k == XK_Hangul_J_RieulHieuh) return \"Hangul_J_RieulHieuh\";\n\tif (k == XK_Hangul_J_Mieum) return \"Hangul_J_Mieum\";\n\tif (k == XK_Hangul_J_Pieub) return \"Hangul_J_Pieub\";\n\tif (k == XK_Hangul_J_PieubSios) return \"Hangul_J_PieubSios\";\n\tif (k == XK_Hangul_J_Sios) return \"Hangul_J_Sios\";\n\tif (k == XK_Hangul_J_SsangSios) return \"Hangul_J_SsangSios\";\n\tif (k == XK_Hangul_J_Ieung) return \"Hangul_J_Ieung\";\n\tif (k == XK_Hangul_J_Jieuj) return \"Hangul_J_Jieuj\";\n\tif (k == XK_Hangul_J_Cieuc) return \"Hangul_J_Cieuc\";\n\tif (k == XK_Hangul_J_Khieuq) return \"Hangul_J_Khieuq\";\n\tif (k == XK_Hangul_J_Tieut) return \"Hangul_J_Tieut\";\n\tif (k == XK_Hangul_J_Phieuf) return \"Hangul_J_Phieuf\";\n\tif (k == XK_Hangul_J_Hieuh) return \"Hangul_J_Hieuh\";\n\tif (k == XK_Hangul_RieulYeorinHieuh) return \"Hangul_RieulYeorinHieuh\";\n\tif (k == XK_Hangul_SunkyeongeumMieum) return \"Hangul_SunkyeongeumMieum\";\n\tif (k == XK_Hangul_SunkyeongeumPieub) return \"Hangul_SunkyeongeumPieub\";\n\tif (k == XK_Hangul_PanSios) return \"Hangul_PanSios\";\n\tif (k == XK_Hangul_KkogjiDalrinIeung) return \"Hangul_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_SunkyeongeumPhieuf) return \"Hangul_SunkyeongeumPhieuf\";\n\tif (k == XK_Hangul_YeorinHieuh) return \"Hangul_YeorinHieuh\";\n\tif (k == XK_Hangul_AraeA) return \"Hangul_AraeA\";\n\tif (k == XK_Hangul_AraeAE) return \"Hangul_AraeAE\";\n\tif (k == XK_Hangul_J_PanSios) return \"Hangul_J_PanSios\";\n\tif (k == XK_Hangul_J_KkogjiDalrinIeung) return \"Hangul_J_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_J_YeorinHieuh) return \"Hangul_J_YeorinHieuh\";\n\tif (k == XK_Korean_Won) return \"Korean_Won\";\n#endif /* XK_KOREAN */\n\tif (k == XK_EuroSign) return \"EuroSign\";\n#endif\n\treturn NULL;\t\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "char *XKeysymToString(KeySym k) {\n#ifndef XK_0_nosuch\n\tif (k == XK_VoidSymbol) return \"VoidSymbol\";\n#ifdef XK_MISCELLANY\n\tif (k == XK_BackSpace) return \"BackSpace\";\n\tif (k == XK_Tab) return \"Tab\";\n\tif (k == XK_Linefeed) return \"Linefeed\";\n\tif (k == XK_Clear) return \"Clear\";\n\tif (k == XK_Return) return \"Return\";\n\tif (k == XK_Pause) return \"Pause\";\n\tif (k == XK_Scroll_Lock) return \"Scroll_Lock\";\n\tif (k == XK_Sys_Req) return \"Sys_Req\";\n\tif (k == XK_Escape) return \"Escape\";\n\tif (k == XK_Delete) return \"Delete\";\n\tif (k == XK_Multi_key) return \"Multi_key\";\n\tif (k == XK_SingleCandidate) return \"SingleCandidate\";\n\tif (k == XK_MultipleCandidate) return \"MultipleCandidate\";\n\tif (k == XK_PreviousCandidate) return \"PreviousCandidate\";\n\tif (k == XK_Kanji) return \"Kanji\";\n\tif (k == XK_Muhenkan) return \"Muhenkan\";\n\tif (k == XK_Henkan_Mode) return \"Henkan_Mode\";\n\tif (k == XK_Henkan) return \"Henkan\";\n\tif (k == XK_Romaji) return \"Romaji\";\n\tif (k == XK_Hiragana) return \"Hiragana\";\n\tif (k == XK_Katakana) return \"Katakana\";\n\tif (k == XK_Hiragana_Katakana) return \"Hiragana_Katakana\";\n\tif (k == XK_Zenkaku) return \"Zenkaku\";\n\tif (k == XK_Hankaku) return \"Hankaku\";\n\tif (k == XK_Zenkaku_Hankaku) return \"Zenkaku_Hankaku\";\n\tif (k == XK_Touroku) return \"Touroku\";\n\tif (k == XK_Massyo) return \"Massyo\";\n\tif (k == XK_Kana_Lock) return \"Kana_Lock\";\n\tif (k == XK_Kana_Shift) return \"Kana_Shift\";\n\tif (k == XK_Eisu_Shift) return \"Eisu_Shift\";\n\tif (k == XK_Eisu_toggle) return \"Eisu_toggle\";\n\tif (k == XK_Zen_Koho) return \"Zen_Koho\";\n\tif (k == XK_Mae_Koho) return \"Mae_Koho\";\n\tif (k == XK_Home) return \"Home\";\n\tif (k == XK_Left) return \"Left\";\n\tif (k == XK_Up) return \"Up\";\n\tif (k == XK_Right) return \"Right\";\n\tif (k == XK_Down) return \"Down\";\n\tif (k == XK_Prior) return \"Prior\";\n\tif (k == XK_Page_Up) return \"Page_Up\";\n\tif (k == XK_Next) return \"Next\";\n\tif (k == XK_Page_Down) return \"Page_Down\";\n\tif (k == XK_End) return \"End\";\n\tif (k == XK_Begin) return \"Begin\";\n\tif (k == XK_Select) return \"Select\";\n\tif (k == XK_Print) return \"Print\";\n\tif (k == XK_Execute) return \"Execute\";\n\tif (k == XK_Insert) return \"Insert\";\n\tif (k == XK_Undo) return \"Undo\";\n\tif (k == XK_Redo) return \"Redo\";\n\tif (k == XK_Menu) return \"Menu\";\n\tif (k == XK_Find) return \"Find\";\n\tif (k == XK_Cancel) return \"Cancel\";\n\tif (k == XK_Help) return \"Help\";\n\tif (k == XK_Break) return \"Break\";\n\tif (k == XK_Mode_switch) return \"Mode_switch\";\n\tif (k == XK_script_switch) return \"script_switch\";\n\tif (k == XK_Num_Lock) return \"Num_Lock\";\n\tif (k == XK_KP_Space) return \"KP_Space\";\n\tif (k == XK_KP_Tab) return \"KP_Tab\";\n\tif (k == XK_KP_Enter) return \"KP_Enter\";\n\tif (k == XK_KP_F1) return \"KP_F1\";\n\tif (k == XK_KP_F2) return \"KP_F2\";\n\tif (k == XK_KP_F3) return \"KP_F3\";\n\tif (k == XK_KP_F4) return \"KP_F4\";\n\tif (k == XK_KP_Home) return \"KP_Home\";\n\tif (k == XK_KP_Left) return \"KP_Left\";\n\tif (k == XK_KP_Up) return \"KP_Up\";\n\tif (k == XK_KP_Right) return \"KP_Right\";\n\tif (k == XK_KP_Down) return \"KP_Down\";\n\tif (k == XK_KP_Prior) return \"KP_Prior\";\n\tif (k == XK_KP_Page_Up) return \"KP_Page_Up\";\n\tif (k == XK_KP_Next) return \"KP_Next\";\n\tif (k == XK_KP_Page_Down) return \"KP_Page_Down\";\n\tif (k == XK_KP_End) return \"KP_End\";\n\tif (k == XK_KP_Begin) return \"KP_Begin\";\n\tif (k == XK_KP_Insert) return \"KP_Insert\";\n\tif (k == XK_KP_Delete) return \"KP_Delete\";\n\tif (k == XK_KP_Equal) return \"KP_Equal\";\n\tif (k == XK_KP_Multiply) return \"KP_Multiply\";\n\tif (k == XK_KP_Add) return \"KP_Add\";\n\tif (k == XK_KP_Separator) return \"KP_Separator\";\n\tif (k == XK_KP_Subtract) return \"KP_Subtract\";\n\tif (k == XK_KP_Decimal) return \"KP_Decimal\";\n\tif (k == XK_KP_Divide) return \"KP_Divide\";\n\tif (k == XK_KP_0) return \"KP_0\";\n\tif (k == XK_KP_1) return \"KP_1\";\n\tif (k == XK_KP_2) return \"KP_2\";\n\tif (k == XK_KP_3) return \"KP_3\";\n\tif (k == XK_KP_4) return \"KP_4\";\n\tif (k == XK_KP_5) return \"KP_5\";\n\tif (k == XK_KP_6) return \"KP_6\";\n\tif (k == XK_KP_7) return \"KP_7\";\n\tif (k == XK_KP_8) return \"KP_8\";\n\tif (k == XK_KP_9) return \"KP_9\";\n\tif (k == XK_F1) return \"F1\";\n\tif (k == XK_F2) return \"F2\";\n\tif (k == XK_F3) return \"F3\";\n\tif (k == XK_F4) return \"F4\";\n\tif (k == XK_F5) return \"F5\";\n\tif (k == XK_F6) return \"F6\";\n\tif (k == XK_F7) return \"F7\";\n\tif (k == XK_F8) return \"F8\";\n\tif (k == XK_F9) return \"F9\";\n\tif (k == XK_F10) return \"F10\";\n\tif (k == XK_F11) return \"F11\";\n\tif (k == XK_L1) return \"L1\";\n\tif (k == XK_F12) return \"F12\";\n\tif (k == XK_L2) return \"L2\";\n\tif (k == XK_F13) return \"F13\";\n\tif (k == XK_L3) return \"L3\";\n\tif (k == XK_F14) return \"F14\";\n\tif (k == XK_L4) return \"L4\";\n\tif (k == XK_F15) return \"F15\";\n\tif (k == XK_L5) return \"L5\";\n\tif (k == XK_F16) return \"F16\";\n\tif (k == XK_L6) return \"L6\";\n\tif (k == XK_F17) return \"F17\";\n\tif (k == XK_L7) return \"L7\";\n\tif (k == XK_F18) return \"F18\";\n\tif (k == XK_L8) return \"L8\";\n\tif (k == XK_F19) return \"F19\";\n\tif (k == XK_L9) return \"L9\";\n\tif (k == XK_F20) return \"F20\";\n\tif (k == XK_L10) return \"L10\";\n\tif (k == XK_F21) return \"F21\";\n\tif (k == XK_R1) return \"R1\";\n\tif (k == XK_F22) return \"F22\";\n\tif (k == XK_R2) return \"R2\";\n\tif (k == XK_F23) return \"F23\";\n\tif (k == XK_R3) return \"R3\";\n\tif (k == XK_F24) return \"F24\";\n\tif (k == XK_R4) return \"R4\";\n\tif (k == XK_F25) return \"F25\";\n\tif (k == XK_R5) return \"R5\";\n\tif (k == XK_F26) return \"F26\";\n\tif (k == XK_R6) return \"R6\";\n\tif (k == XK_F27) return \"F27\";\n\tif (k == XK_R7) return \"R7\";\n\tif (k == XK_F28) return \"F28\";\n\tif (k == XK_R8) return \"R8\";\n\tif (k == XK_F29) return \"F29\";\n\tif (k == XK_R9) return \"R9\";\n\tif (k == XK_F30) return \"F30\";\n\tif (k == XK_R10) return \"R10\";\n\tif (k == XK_F31) return \"F31\";\n\tif (k == XK_R11) return \"R11\";\n\tif (k == XK_F32) return \"F32\";\n\tif (k == XK_R12) return \"R12\";\n\tif (k == XK_F33) return \"F33\";\n\tif (k == XK_R13) return \"R13\";\n\tif (k == XK_F34) return \"F34\";\n\tif (k == XK_R14) return \"R14\";\n\tif (k == XK_F35) return \"F35\";\n\tif (k == XK_R15) return \"R15\";\n\tif (k == XK_Shift_L) return \"Shift_L\";\n\tif (k == XK_Shift_R) return \"Shift_R\";\n\tif (k == XK_Control_L) return \"Control_L\";\n\tif (k == XK_Control_R) return \"Control_R\";\n\tif (k == XK_Caps_Lock) return \"Caps_Lock\";\n\tif (k == XK_Shift_Lock) return \"Shift_Lock\";\n\tif (k == XK_Meta_L) return \"Meta_L\";\n\tif (k == XK_Meta_R) return \"Meta_R\";\n\tif (k == XK_Alt_L) return \"Alt_L\";\n\tif (k == XK_Alt_R) return \"Alt_R\";\n\tif (k == XK_Super_L) return \"Super_L\";\n\tif (k == XK_Super_R) return \"Super_R\";\n\tif (k == XK_Hyper_L) return \"Hyper_L\";\n\tif (k == XK_Hyper_R) return \"Hyper_R\";\n#endif /* XK_MISCELLANY */\n#ifdef XK_XKB_KEYS\n\tif (k == XK_ISO_Lock) return \"ISO_Lock\";\n\tif (k == XK_ISO_Level2_Latch) return \"ISO_Level2_Latch\";\n\tif (k == XK_ISO_Level3_Shift) return \"ISO_Level3_Shift\";\n\tif (k == XK_ISO_Level3_Latch) return \"ISO_Level3_Latch\";\n\tif (k == XK_ISO_Level3_Lock) return \"ISO_Level3_Lock\";\n\tif (k == XK_ISO_Group_Shift) return \"ISO_Group_Shift\";\n\tif (k == XK_ISO_Group_Latch) return \"ISO_Group_Latch\";\n\tif (k == XK_ISO_Group_Lock) return \"ISO_Group_Lock\";\n\tif (k == XK_ISO_Next_Group) return \"ISO_Next_Group\";\n\tif (k == XK_ISO_Next_Group_Lock) return \"ISO_Next_Group_Lock\";\n\tif (k == XK_ISO_Prev_Group) return \"ISO_Prev_Group\";\n\tif (k == XK_ISO_Prev_Group_Lock) return \"ISO_Prev_Group_Lock\";\n\tif (k == XK_ISO_First_Group) return \"ISO_First_Group\";\n\tif (k == XK_ISO_First_Group_Lock) return \"ISO_First_Group_Lock\";\n\tif (k == XK_ISO_Last_Group) return \"ISO_Last_Group\";\n\tif (k == XK_ISO_Last_Group_Lock) return \"ISO_Last_Group_Lock\";\n\tif (k == XK_ISO_Left_Tab) return \"ISO_Left_Tab\";\n\tif (k == XK_ISO_Move_Line_Up) return \"ISO_Move_Line_Up\";\n\tif (k == XK_ISO_Move_Line_Down) return \"ISO_Move_Line_Down\";\n\tif (k == XK_ISO_Partial_Line_Up) return \"ISO_Partial_Line_Up\";\n\tif (k == XK_ISO_Partial_Line_Down) return \"ISO_Partial_Line_Down\";\n\tif (k == XK_ISO_Partial_Space_Left) return \"ISO_Partial_Space_Left\";\n\tif (k == XK_ISO_Partial_Space_Right) return \"ISO_Partial_Space_Right\";\n\tif (k == XK_ISO_Set_Margin_Left) return \"ISO_Set_Margin_Left\";\n\tif (k == XK_ISO_Set_Margin_Right) return \"ISO_Set_Margin_Right\";\n\tif (k == XK_ISO_Release_Margin_Left) return \"ISO_Release_Margin_Left\";\n\tif (k == XK_ISO_Release_Margin_Right) return \"ISO_Release_Margin_Right\";\n\tif (k == XK_ISO_Release_Both_Margins) return \"ISO_Release_Both_Margins\";\n\tif (k == XK_ISO_Fast_Cursor_Left) return \"ISO_Fast_Cursor_Left\";\n\tif (k == XK_ISO_Fast_Cursor_Right) return \"ISO_Fast_Cursor_Right\";\n\tif (k == XK_ISO_Fast_Cursor_Up) return \"ISO_Fast_Cursor_Up\";\n\tif (k == XK_ISO_Fast_Cursor_Down) return \"ISO_Fast_Cursor_Down\";\n\tif (k == XK_ISO_Continuous_Underline) return \"ISO_Continuous_Underline\";\n\tif (k == XK_ISO_Discontinuous_Underline) return \"ISO_Discontinuous_Underline\";\n\tif (k == XK_ISO_Emphasize) return \"ISO_Emphasize\";\n\tif (k == XK_ISO_Center_Object) return \"ISO_Center_Object\";\n\tif (k == XK_ISO_Enter) return \"ISO_Enter\";\n\tif (k == XK_dead_grave) return \"dead_grave\";\n\tif (k == XK_dead_acute) return \"dead_acute\";\n\tif (k == XK_dead_circumflex) return \"dead_circumflex\";\n\tif (k == XK_dead_tilde) return \"dead_tilde\";\n\tif (k == XK_dead_macron) return \"dead_macron\";\n\tif (k == XK_dead_breve) return \"dead_breve\";\n\tif (k == XK_dead_abovedot) return \"dead_abovedot\";\n\tif (k == XK_dead_diaeresis) return \"dead_diaeresis\";\n\tif (k == XK_dead_abovering) return \"dead_abovering\";\n\tif (k == XK_dead_doubleacute) return \"dead_doubleacute\";\n\tif (k == XK_dead_caron) return \"dead_caron\";\n\tif (k == XK_dead_cedilla) return \"dead_cedilla\";\n\tif (k == XK_dead_ogonek) return \"dead_ogonek\";\n\tif (k == XK_dead_iota) return \"dead_iota\";\n\tif (k == XK_dead_voiced_sound) return \"dead_voiced_sound\";\n\tif (k == XK_dead_semivoiced_sound) return \"dead_semivoiced_sound\";\n\tif (k == XK_dead_belowdot) return \"dead_belowdot\";\n\tif (k == XK_First_Virtual_Screen) return \"First_Virtual_Screen\";\n\tif (k == XK_Prev_Virtual_Screen) return \"Prev_Virtual_Screen\";\n\tif (k == XK_Next_Virtual_Screen) return \"Next_Virtual_Screen\";\n\tif (k == XK_Last_Virtual_Screen) return \"Last_Virtual_Screen\";\n\tif (k == XK_Terminate_Server) return \"Terminate_Server\";\n\tif (k == XK_AccessX_Enable) return \"AccessX_Enable\";\n\tif (k == XK_AccessX_Feedback_Enable) return \"AccessX_Feedback_Enable\";\n\tif (k == XK_RepeatKeys_Enable) return \"RepeatKeys_Enable\";\n\tif (k == XK_SlowKeys_Enable) return \"SlowKeys_Enable\";\n\tif (k == XK_BounceKeys_Enable) return \"BounceKeys_Enable\";\n\tif (k == XK_StickyKeys_Enable) return \"StickyKeys_Enable\";\n\tif (k == XK_MouseKeys_Enable) return \"MouseKeys_Enable\";\n\tif (k == XK_MouseKeys_Accel_Enable) return \"MouseKeys_Accel_Enable\";\n\tif (k == XK_Overlay1_Enable) return \"Overlay1_Enable\";\n\tif (k == XK_Overlay2_Enable) return \"Overlay2_Enable\";\n\tif (k == XK_AudibleBell_Enable) return \"AudibleBell_Enable\";\n\tif (k == XK_Pointer_Left) return \"Pointer_Left\";\n\tif (k == XK_Pointer_Right) return \"Pointer_Right\";\n\tif (k == XK_Pointer_Up) return \"Pointer_Up\";\n\tif (k == XK_Pointer_Down) return \"Pointer_Down\";\n\tif (k == XK_Pointer_UpLeft) return \"Pointer_UpLeft\";\n\tif (k == XK_Pointer_UpRight) return \"Pointer_UpRight\";\n\tif (k == XK_Pointer_DownLeft) return \"Pointer_DownLeft\";\n\tif (k == XK_Pointer_DownRight) return \"Pointer_DownRight\";\n\tif (k == XK_Pointer_Button_Dflt) return \"Pointer_Button_Dflt\";\n\tif (k == XK_Pointer_Button1) return \"Pointer_Button1\";\n\tif (k == XK_Pointer_Button2) return \"Pointer_Button2\";\n\tif (k == XK_Pointer_Button3) return \"Pointer_Button3\";\n\tif (k == XK_Pointer_Button4) return \"Pointer_Button4\";\n\tif (k == XK_Pointer_Button5) return \"Pointer_Button5\";\n\tif (k == XK_Pointer_DblClick_Dflt) return \"Pointer_DblClick_Dflt\";\n\tif (k == XK_Pointer_DblClick1) return \"Pointer_DblClick1\";\n\tif (k == XK_Pointer_DblClick2) return \"Pointer_DblClick2\";\n\tif (k == XK_Pointer_DblClick3) return \"Pointer_DblClick3\";\n\tif (k == XK_Pointer_DblClick4) return \"Pointer_DblClick4\";\n\tif (k == XK_Pointer_DblClick5) return \"Pointer_DblClick5\";\n\tif (k == XK_Pointer_Drag_Dflt) return \"Pointer_Drag_Dflt\";\n\tif (k == XK_Pointer_Drag1) return \"Pointer_Drag1\";\n\tif (k == XK_Pointer_Drag2) return \"Pointer_Drag2\";\n\tif (k == XK_Pointer_Drag3) return \"Pointer_Drag3\";\n\tif (k == XK_Pointer_Drag4) return \"Pointer_Drag4\";\n\tif (k == XK_Pointer_Drag5) return \"Pointer_Drag5\";\n\tif (k == XK_Pointer_EnableKeys) return \"Pointer_EnableKeys\";\n\tif (k == XK_Pointer_Accelerate) return \"Pointer_Accelerate\";\n\tif (k == XK_Pointer_DfltBtnNext) return \"Pointer_DfltBtnNext\";\n\tif (k == XK_Pointer_DfltBtnPrev) return \"Pointer_DfltBtnPrev\";\n#endif\n#ifdef XK_3270\n\tif (k == XK_3270_Duplicate) return \"3270_Duplicate\";\n\tif (k == XK_3270_FieldMark) return \"3270_FieldMark\";\n\tif (k == XK_3270_Right2) return \"3270_Right2\";\n\tif (k == XK_3270_Left2) return \"3270_Left2\";\n\tif (k == XK_3270_BackTab) return \"3270_BackTab\";\n\tif (k == XK_3270_EraseEOF) return \"3270_EraseEOF\";\n\tif (k == XK_3270_EraseInput) return \"3270_EraseInput\";\n\tif (k == XK_3270_Reset) return \"3270_Reset\";\n\tif (k == XK_3270_Quit) return \"3270_Quit\";\n\tif (k == XK_3270_PA1) return \"3270_PA1\";\n\tif (k == XK_3270_PA2) return \"3270_PA2\";\n\tif (k == XK_3270_PA3) return \"3270_PA3\";\n\tif (k == XK_3270_Test) return \"3270_Test\";\n\tif (k == XK_3270_Attn) return \"3270_Attn\";\n\tif (k == XK_3270_CursorBlink) return \"3270_CursorBlink\";\n\tif (k == XK_3270_AltCursor) return \"3270_AltCursor\";\n\tif (k == XK_3270_KeyClick) return \"3270_KeyClick\";\n\tif (k == XK_3270_Jump) return \"3270_Jump\";\n\tif (k == XK_3270_Ident) return \"3270_Ident\";\n\tif (k == XK_3270_Rule) return \"3270_Rule\";\n\tif (k == XK_3270_Copy) return \"3270_Copy\";\n\tif (k == XK_3270_Play) return \"3270_Play\";\n\tif (k == XK_3270_Setup) return \"3270_Setup\";\n\tif (k == XK_3270_Record) return \"3270_Record\";\n\tif (k == XK_3270_ChangeScreen) return \"3270_ChangeScreen\";\n\tif (k == XK_3270_DeleteWord) return \"3270_DeleteWord\";\n\tif (k == XK_3270_ExSelect) return \"3270_ExSelect\";\n\tif (k == XK_3270_CursorSelect) return \"3270_CursorSelect\";\n\tif (k == XK_3270_PrintScreen) return \"3270_PrintScreen\";\n\tif (k == XK_3270_Enter) return \"3270_Enter\";\n#endif\n#ifdef XK_LATIN1\n\tif (k == XK_space) return \"space\";\n\tif (k == XK_exclam) return \"exclam\";\n\tif (k == XK_quotedbl) return \"quotedbl\";\n\tif (k == XK_numbersign) return \"numbersign\";\n\tif (k == XK_dollar) return \"dollar\";\n\tif (k == XK_percent) return \"percent\";\n\tif (k == XK_ampersand) return \"ampersand\";\n\tif (k == XK_apostrophe) return \"apostrophe\";\n\tif (k == XK_quoteright) return \"quoteright\";\n\tif (k == XK_parenleft) return \"parenleft\";\n\tif (k == XK_parenright) return \"parenright\";\n\tif (k == XK_asterisk) return \"asterisk\";\n\tif (k == XK_plus) return \"plus\";\n\tif (k == XK_comma) return \"comma\";\n\tif (k == XK_minus) return \"minus\";\n\tif (k == XK_period) return \"period\";\n\tif (k == XK_slash) return \"slash\";\n\tif (k == XK_0) return \"0\";\n\tif (k == XK_1) return \"1\";\n\tif (k == XK_2) return \"2\";\n\tif (k == XK_3) return \"3\";\n\tif (k == XK_4) return \"4\";\n\tif (k == XK_5) return \"5\";\n\tif (k == XK_6) return \"6\";\n\tif (k == XK_7) return \"7\";\n\tif (k == XK_8) return \"8\";\n\tif (k == XK_9) return \"9\";\n\tif (k == XK_colon) return \"colon\";\n\tif (k == XK_semicolon) return \"semicolon\";\n\tif (k == XK_less) return \"less\";\n\tif (k == XK_equal) return \"equal\";\n\tif (k == XK_greater) return \"greater\";\n\tif (k == XK_question) return \"question\";\n\tif (k == XK_at) return \"at\";\n\tif (k == XK_A) return \"A\";\n\tif (k == XK_B) return \"B\";\n\tif (k == XK_C) return \"C\";\n\tif (k == XK_D) return \"D\";\n\tif (k == XK_E) return \"E\";\n\tif (k == XK_F) return \"F\";\n\tif (k == XK_G) return \"G\";\n\tif (k == XK_H) return \"H\";\n\tif (k == XK_I) return \"I\";\n\tif (k == XK_J) return \"J\";\n\tif (k == XK_K) return \"K\";\n\tif (k == XK_L) return \"L\";\n\tif (k == XK_M) return \"M\";\n\tif (k == XK_N) return \"N\";\n\tif (k == XK_O) return \"O\";\n\tif (k == XK_P) return \"P\";\n\tif (k == XK_Q) return \"Q\";\n\tif (k == XK_R) return \"R\";\n\tif (k == XK_S) return \"S\";\n\tif (k == XK_T) return \"T\";\n\tif (k == XK_U) return \"U\";\n\tif (k == XK_V) return \"V\";\n\tif (k == XK_W) return \"W\";\n\tif (k == XK_X) return \"X\";\n\tif (k == XK_Y) return \"Y\";\n\tif (k == XK_Z) return \"Z\";\n\tif (k == XK_bracketleft) return \"bracketleft\";\n\tif (k == XK_backslash) return \"backslash\";\n\tif (k == XK_bracketright) return \"bracketright\";\n\tif (k == XK_asciicircum) return \"asciicircum\";\n\tif (k == XK_underscore) return \"underscore\";\n\tif (k == XK_grave) return \"grave\";\n\tif (k == XK_quoteleft) return \"quoteleft\";\n\tif (k == XK_a) return \"a\";\n\tif (k == XK_b) return \"b\";\n\tif (k == XK_c) return \"c\";\n\tif (k == XK_d) return \"d\";\n\tif (k == XK_e) return \"e\";\n\tif (k == XK_f) return \"f\";\n\tif (k == XK_g) return \"g\";\n\tif (k == XK_h) return \"h\";\n\tif (k == XK_i) return \"i\";\n\tif (k == XK_j) return \"j\";\n\tif (k == XK_k) return \"k\";\n\tif (k == XK_l) return \"l\";\n\tif (k == XK_m) return \"m\";\n\tif (k == XK_n) return \"n\";\n\tif (k == XK_o) return \"o\";\n\tif (k == XK_p) return \"p\";\n\tif (k == XK_q) return \"q\";\n\tif (k == XK_r) return \"r\";\n\tif (k == XK_s) return \"s\";\n\tif (k == XK_t) return \"t\";\n\tif (k == XK_u) return \"u\";\n\tif (k == XK_v) return \"v\";\n\tif (k == XK_w) return \"w\";\n\tif (k == XK_x) return \"x\";\n\tif (k == XK_y) return \"y\";\n\tif (k == XK_z) return \"z\";\n\tif (k == XK_braceleft) return \"braceleft\";\n\tif (k == XK_bar) return \"bar\";\n\tif (k == XK_braceright) return \"braceright\";\n\tif (k == XK_asciitilde) return \"asciitilde\";\n\tif (k == XK_nobreakspace) return \"nobreakspace\";\n\tif (k == XK_exclamdown) return \"exclamdown\";\n\tif (k == XK_cent) return \"cent\";\n\tif (k == XK_sterling) return \"sterling\";\n\tif (k == XK_currency) return \"currency\";\n\tif (k == XK_yen) return \"yen\";\n\tif (k == XK_brokenbar) return \"brokenbar\";\n\tif (k == XK_section) return \"section\";\n\tif (k == XK_diaeresis) return \"diaeresis\";\n\tif (k == XK_copyright) return \"copyright\";\n\tif (k == XK_ordfeminine) return \"ordfeminine\";\n\tif (k == XK_guillemotleft) return \"guillemotleft\";\n\tif (k == XK_notsign) return \"notsign\";\n\tif (k == XK_hyphen) return \"hyphen\";\n\tif (k == XK_registered) return \"registered\";\n\tif (k == XK_macron) return \"macron\";\n\tif (k == XK_degree) return \"degree\";\n\tif (k == XK_plusminus) return \"plusminus\";\n\tif (k == XK_twosuperior) return \"twosuperior\";\n\tif (k == XK_threesuperior) return \"threesuperior\";\n\tif (k == XK_acute) return \"acute\";\n\tif (k == XK_mu) return \"mu\";\n\tif (k == XK_paragraph) return \"paragraph\";\n\tif (k == XK_periodcentered) return \"periodcentered\";\n\tif (k == XK_cedilla) return \"cedilla\";\n\tif (k == XK_onesuperior) return \"onesuperior\";\n\tif (k == XK_masculine) return \"masculine\";\n\tif (k == XK_guillemotright) return \"guillemotright\";\n\tif (k == XK_onequarter) return \"onequarter\";\n\tif (k == XK_onehalf) return \"onehalf\";\n\tif (k == XK_threequarters) return \"threequarters\";\n\tif (k == XK_questiondown) return \"questiondown\";\n\tif (k == XK_Agrave) return \"Agrave\";\n\tif (k == XK_Aacute) return \"Aacute\";\n\tif (k == XK_Acircumflex) return \"Acircumflex\";\n\tif (k == XK_Atilde) return \"Atilde\";\n\tif (k == XK_Adiaeresis) return \"Adiaeresis\";\n\tif (k == XK_Aring) return \"Aring\";\n\tif (k == XK_AE) return \"AE\";\n\tif (k == XK_Ccedilla) return \"Ccedilla\";\n\tif (k == XK_Egrave) return \"Egrave\";\n\tif (k == XK_Eacute) return \"Eacute\";\n\tif (k == XK_Ecircumflex) return \"Ecircumflex\";\n\tif (k == XK_Ediaeresis) return \"Ediaeresis\";\n\tif (k == XK_Igrave) return \"Igrave\";\n\tif (k == XK_Iacute) return \"Iacute\";\n\tif (k == XK_Icircumflex) return \"Icircumflex\";\n\tif (k == XK_Idiaeresis) return \"Idiaeresis\";\n\tif (k == XK_ETH) return \"ETH\";\n\tif (k == XK_Eth) return \"Eth\";\n\tif (k == XK_Ntilde) return \"Ntilde\";\n\tif (k == XK_Ograve) return \"Ograve\";\n\tif (k == XK_Oacute) return \"Oacute\";\n\tif (k == XK_Ocircumflex) return \"Ocircumflex\";\n\tif (k == XK_Otilde) return \"Otilde\";\n\tif (k == XK_Odiaeresis) return \"Odiaeresis\";\n\tif (k == XK_multiply) return \"multiply\";\n\tif (k == XK_Ooblique) return \"Ooblique\";\n\tif (k == XK_Ugrave) return \"Ugrave\";\n\tif (k == XK_Uacute) return \"Uacute\";\n\tif (k == XK_Ucircumflex) return \"Ucircumflex\";\n\tif (k == XK_Udiaeresis) return \"Udiaeresis\";\n\tif (k == XK_Yacute) return \"Yacute\";\n\tif (k == XK_THORN) return \"THORN\";\n\tif (k == XK_Thorn) return \"Thorn\";\n\tif (k == XK_ssharp) return \"ssharp\";\n\tif (k == XK_agrave) return \"agrave\";\n\tif (k == XK_aacute) return \"aacute\";\n\tif (k == XK_acircumflex) return \"acircumflex\";\n\tif (k == XK_atilde) return \"atilde\";\n\tif (k == XK_adiaeresis) return \"adiaeresis\";\n\tif (k == XK_aring) return \"aring\";\n\tif (k == XK_ae) return \"ae\";\n\tif (k == XK_ccedilla) return \"ccedilla\";\n\tif (k == XK_egrave) return \"egrave\";\n\tif (k == XK_eacute) return \"eacute\";\n\tif (k == XK_ecircumflex) return \"ecircumflex\";\n\tif (k == XK_ediaeresis) return \"ediaeresis\";\n\tif (k == XK_igrave) return \"igrave\";\n\tif (k == XK_iacute) return \"iacute\";\n\tif (k == XK_icircumflex) return \"icircumflex\";\n\tif (k == XK_idiaeresis) return \"idiaeresis\";\n\tif (k == XK_eth) return \"eth\";\n\tif (k == XK_ntilde) return \"ntilde\";\n\tif (k == XK_ograve) return \"ograve\";\n\tif (k == XK_oacute) return \"oacute\";\n\tif (k == XK_ocircumflex) return \"ocircumflex\";\n\tif (k == XK_otilde) return \"otilde\";\n\tif (k == XK_odiaeresis) return \"odiaeresis\";\n\tif (k == XK_division) return \"division\";\n\tif (k == XK_oslash) return \"oslash\";\n\tif (k == XK_ugrave) return \"ugrave\";\n\tif (k == XK_uacute) return \"uacute\";\n\tif (k == XK_ucircumflex) return \"ucircumflex\";\n\tif (k == XK_udiaeresis) return \"udiaeresis\";\n\tif (k == XK_yacute) return \"yacute\";\n\tif (k == XK_thorn) return \"thorn\";\n\tif (k == XK_ydiaeresis) return \"ydiaeresis\";\n#endif /* XK_LATIN1 */\n#ifdef XK_LATIN2\n\tif (k == XK_Aogonek) return \"Aogonek\";\n\tif (k == XK_breve) return \"breve\";\n\tif (k == XK_Lstroke) return \"Lstroke\";\n\tif (k == XK_Lcaron) return \"Lcaron\";\n\tif (k == XK_Sacute) return \"Sacute\";\n\tif (k == XK_Scaron) return \"Scaron\";\n\tif (k == XK_Scedilla) return \"Scedilla\";\n\tif (k == XK_Tcaron) return \"Tcaron\";\n\tif (k == XK_Zacute) return \"Zacute\";\n\tif (k == XK_Zcaron) return \"Zcaron\";\n\tif (k == XK_Zabovedot) return \"Zabovedot\";\n\tif (k == XK_aogonek) return \"aogonek\";\n\tif (k == XK_ogonek) return \"ogonek\";\n\tif (k == XK_lstroke) return \"lstroke\";\n\tif (k == XK_lcaron) return \"lcaron\";\n\tif (k == XK_sacute) return \"sacute\";\n\tif (k == XK_caron) return \"caron\";\n\tif (k == XK_scaron) return \"scaron\";\n\tif (k == XK_scedilla) return \"scedilla\";\n\tif (k == XK_tcaron) return \"tcaron\";\n\tif (k == XK_zacute) return \"zacute\";\n\tif (k == XK_doubleacute) return \"doubleacute\";\n\tif (k == XK_zcaron) return \"zcaron\";\n\tif (k == XK_zabovedot) return \"zabovedot\";\n\tif (k == XK_Racute) return \"Racute\";\n\tif (k == XK_Abreve) return \"Abreve\";\n\tif (k == XK_Lacute) return \"Lacute\";\n\tif (k == XK_Cacute) return \"Cacute\";\n\tif (k == XK_Ccaron) return \"Ccaron\";\n\tif (k == XK_Eogonek) return \"Eogonek\";\n\tif (k == XK_Ecaron) return \"Ecaron\";\n\tif (k == XK_Dcaron) return \"Dcaron\";\n\tif (k == XK_Dstroke) return \"Dstroke\";\n\tif (k == XK_Nacute) return \"Nacute\";\n\tif (k == XK_Ncaron) return \"Ncaron\";\n\tif (k == XK_Odoubleacute) return \"Odoubleacute\";\n\tif (k == XK_Rcaron) return \"Rcaron\";\n\tif (k == XK_Uring) return \"Uring\";\n\tif (k == XK_Udoubleacute) return \"Udoubleacute\";\n\tif (k == XK_Tcedilla) return \"Tcedilla\";\n\tif (k == XK_racute) return \"racute\";\n\tif (k == XK_abreve) return \"abreve\";\n\tif (k == XK_lacute) return \"lacute\";\n\tif (k == XK_cacute) return \"cacute\";\n\tif (k == XK_ccaron) return \"ccaron\";\n\tif (k == XK_eogonek) return \"eogonek\";\n\tif (k == XK_ecaron) return \"ecaron\";\n\tif (k == XK_dcaron) return \"dcaron\";\n\tif (k == XK_dstroke) return \"dstroke\";\n\tif (k == XK_nacute) return \"nacute\";\n\tif (k == XK_ncaron) return \"ncaron\";\n\tif (k == XK_odoubleacute) return \"odoubleacute\";\n\tif (k == XK_udoubleacute) return \"udoubleacute\";\n\tif (k == XK_rcaron) return \"rcaron\";\n\tif (k == XK_uring) return \"uring\";\n\tif (k == XK_tcedilla) return \"tcedilla\";\n\tif (k == XK_abovedot) return \"abovedot\";\n#endif /* XK_LATIN2 */\n#ifdef XK_LATIN3\n\tif (k == XK_Hstroke) return \"Hstroke\";\n\tif (k == XK_Hcircumflex) return \"Hcircumflex\";\n\tif (k == XK_Iabovedot) return \"Iabovedot\";\n\tif (k == XK_Gbreve) return \"Gbreve\";\n\tif (k == XK_Jcircumflex) return \"Jcircumflex\";\n\tif (k == XK_hstroke) return \"hstroke\";\n\tif (k == XK_hcircumflex) return \"hcircumflex\";\n\tif (k == XK_idotless) return \"idotless\";\n\tif (k == XK_gbreve) return \"gbreve\";\n\tif (k == XK_jcircumflex) return \"jcircumflex\";\n\tif (k == XK_Cabovedot) return \"Cabovedot\";\n\tif (k == XK_Ccircumflex) return \"Ccircumflex\";\n\tif (k == XK_Gabovedot) return \"Gabovedot\";\n\tif (k == XK_Gcircumflex) return \"Gcircumflex\";\n\tif (k == XK_Ubreve) return \"Ubreve\";\n\tif (k == XK_Scircumflex) return \"Scircumflex\";\n\tif (k == XK_cabovedot) return \"cabovedot\";\n\tif (k == XK_ccircumflex) return \"ccircumflex\";\n\tif (k == XK_gabovedot) return \"gabovedot\";\n\tif (k == XK_gcircumflex) return \"gcircumflex\";\n\tif (k == XK_ubreve) return \"ubreve\";\n\tif (k == XK_scircumflex) return \"scircumflex\";\n#endif /* XK_LATIN3 */\n#ifdef XK_LATIN4\n\tif (k == XK_kra) return \"kra\";\n\tif (k == XK_kappa) return \"kappa\";\n\tif (k == XK_Rcedilla) return \"Rcedilla\";\n\tif (k == XK_Itilde) return \"Itilde\";\n\tif (k == XK_Lcedilla) return \"Lcedilla\";\n\tif (k == XK_Emacron) return \"Emacron\";\n\tif (k == XK_Gcedilla) return \"Gcedilla\";\n\tif (k == XK_Tslash) return \"Tslash\";\n\tif (k == XK_rcedilla) return \"rcedilla\";\n\tif (k == XK_itilde) return \"itilde\";\n\tif (k == XK_lcedilla) return \"lcedilla\";\n\tif (k == XK_emacron) return \"emacron\";\n\tif (k == XK_gcedilla) return \"gcedilla\";\n\tif (k == XK_tslash) return \"tslash\";\n\tif (k == XK_ENG) return \"ENG\";\n\tif (k == XK_eng) return \"eng\";\n\tif (k == XK_Amacron) return \"Amacron\";\n\tif (k == XK_Iogonek) return \"Iogonek\";\n\tif (k == XK_Eabovedot) return \"Eabovedot\";\n\tif (k == XK_Imacron) return \"Imacron\";\n\tif (k == XK_Ncedilla) return \"Ncedilla\";\n\tif (k == XK_Omacron) return \"Omacron\";\n\tif (k == XK_Kcedilla) return \"Kcedilla\";\n\tif (k == XK_Uogonek) return \"Uogonek\";\n\tif (k == XK_Utilde) return \"Utilde\";\n\tif (k == XK_Umacron) return \"Umacron\";\n\tif (k == XK_amacron) return \"amacron\";\n\tif (k == XK_iogonek) return \"iogonek\";\n\tif (k == XK_eabovedot) return \"eabovedot\";\n\tif (k == XK_imacron) return \"imacron\";\n\tif (k == XK_ncedilla) return \"ncedilla\";\n\tif (k == XK_omacron) return \"omacron\";\n\tif (k == XK_kcedilla) return \"kcedilla\";\n\tif (k == XK_uogonek) return \"uogonek\";\n\tif (k == XK_utilde) return \"utilde\";\n\tif (k == XK_umacron) return \"umacron\";\n#endif /* XK_LATIN4 */\n#ifdef XK_KATAKANA\n\tif (k == XK_overline) return \"overline\";\n\tif (k == XK_kana_fullstop) return \"kana_fullstop\";\n\tif (k == XK_kana_openingbracket) return \"kana_openingbracket\";\n\tif (k == XK_kana_closingbracket) return \"kana_closingbracket\";\n\tif (k == XK_kana_comma) return \"kana_comma\";\n\tif (k == XK_kana_conjunctive) return \"kana_conjunctive\";\n\tif (k == XK_kana_middledot) return \"kana_middledot\";\n\tif (k == XK_kana_WO) return \"kana_WO\";\n\tif (k == XK_kana_a) return \"kana_a\";\n\tif (k == XK_kana_i) return \"kana_i\";\n\tif (k == XK_kana_u) return \"kana_u\";\n\tif (k == XK_kana_e) return \"kana_e\";\n\tif (k == XK_kana_o) return \"kana_o\";\n\tif (k == XK_kana_ya) return \"kana_ya\";\n\tif (k == XK_kana_yu) return \"kana_yu\";\n\tif (k == XK_kana_yo) return \"kana_yo\";\n\tif (k == XK_kana_tsu) return \"kana_tsu\";\n\tif (k == XK_kana_tu) return \"kana_tu\";\n\tif (k == XK_prolongedsound) return \"prolongedsound\";\n\tif (k == XK_kana_A) return \"kana_A\";\n\tif (k == XK_kana_I) return \"kana_I\";\n\tif (k == XK_kana_U) return \"kana_U\";\n\tif (k == XK_kana_E) return \"kana_E\";\n\tif (k == XK_kana_O) return \"kana_O\";\n\tif (k == XK_kana_KA) return \"kana_KA\";\n\tif (k == XK_kana_KI) return \"kana_KI\";\n\tif (k == XK_kana_KU) return \"kana_KU\";\n\tif (k == XK_kana_KE) return \"kana_KE\";\n\tif (k == XK_kana_KO) return \"kana_KO\";\n\tif (k == XK_kana_SA) return \"kana_SA\";\n\tif (k == XK_kana_SHI) return \"kana_SHI\";\n\tif (k == XK_kana_SU) return \"kana_SU\";\n\tif (k == XK_kana_SE) return \"kana_SE\";\n\tif (k == XK_kana_SO) return \"kana_SO\";\n\tif (k == XK_kana_TA) return \"kana_TA\";\n\tif (k == XK_kana_CHI) return \"kana_CHI\";\n\tif (k == XK_kana_TI) return \"kana_TI\";\n\tif (k == XK_kana_TSU) return \"kana_TSU\";\n\tif (k == XK_kana_TU) return \"kana_TU\";\n\tif (k == XK_kana_TE) return \"kana_TE\";\n\tif (k == XK_kana_TO) return \"kana_TO\";\n\tif (k == XK_kana_NA) return \"kana_NA\";\n\tif (k == XK_kana_NI) return \"kana_NI\";\n\tif (k == XK_kana_NU) return \"kana_NU\";\n\tif (k == XK_kana_NE) return \"kana_NE\";\n\tif (k == XK_kana_NO) return \"kana_NO\";\n\tif (k == XK_kana_HA) return \"kana_HA\";\n\tif (k == XK_kana_HI) return \"kana_HI\";\n\tif (k == XK_kana_FU) return \"kana_FU\";\n\tif (k == XK_kana_HU) return \"kana_HU\";\n\tif (k == XK_kana_HE) return \"kana_HE\";\n\tif (k == XK_kana_HO) return \"kana_HO\";\n\tif (k == XK_kana_MA) return \"kana_MA\";\n\tif (k == XK_kana_MI) return \"kana_MI\";\n\tif (k == XK_kana_MU) return \"kana_MU\";\n\tif (k == XK_kana_ME) return \"kana_ME\";\n\tif (k == XK_kana_MO) return \"kana_MO\";\n\tif (k == XK_kana_YA) return \"kana_YA\";\n\tif (k == XK_kana_YU) return \"kana_YU\";\n\tif (k == XK_kana_YO) return \"kana_YO\";\n\tif (k == XK_kana_RA) return \"kana_RA\";\n\tif (k == XK_kana_RI) return \"kana_RI\";\n\tif (k == XK_kana_RU) return \"kana_RU\";\n\tif (k == XK_kana_RE) return \"kana_RE\";\n\tif (k == XK_kana_RO) return \"kana_RO\";\n\tif (k == XK_kana_WA) return \"kana_WA\";\n\tif (k == XK_kana_N) return \"kana_N\";\n\tif (k == XK_voicedsound) return \"voicedsound\";\n\tif (k == XK_semivoicedsound) return \"semivoicedsound\";\n\tif (k == XK_kana_switch) return \"kana_switch\";\n#endif /* XK_KATAKANA */\n#ifdef XK_ARABIC\n\tif (k == XK_Arabic_comma) return \"Arabic_comma\";\n\tif (k == XK_Arabic_semicolon) return \"Arabic_semicolon\";\n\tif (k == XK_Arabic_question_mark) return \"Arabic_question_mark\";\n\tif (k == XK_Arabic_hamza) return \"Arabic_hamza\";\n\tif (k == XK_Arabic_maddaonalef) return \"Arabic_maddaonalef\";\n\tif (k == XK_Arabic_hamzaonalef) return \"Arabic_hamzaonalef\";\n\tif (k == XK_Arabic_hamzaonwaw) return \"Arabic_hamzaonwaw\";\n\tif (k == XK_Arabic_hamzaunderalef) return \"Arabic_hamzaunderalef\";\n\tif (k == XK_Arabic_hamzaonyeh) return \"Arabic_hamzaonyeh\";\n\tif (k == XK_Arabic_alef) return \"Arabic_alef\";\n\tif (k == XK_Arabic_beh) return \"Arabic_beh\";\n\tif (k == XK_Arabic_tehmarbuta) return \"Arabic_tehmarbuta\";\n\tif (k == XK_Arabic_teh) return \"Arabic_teh\";\n\tif (k == XK_Arabic_theh) return \"Arabic_theh\";\n\tif (k == XK_Arabic_jeem) return \"Arabic_jeem\";\n\tif (k == XK_Arabic_hah) return \"Arabic_hah\";\n\tif (k == XK_Arabic_khah) return \"Arabic_khah\";\n\tif (k == XK_Arabic_dal) return \"Arabic_dal\";\n\tif (k == XK_Arabic_thal) return \"Arabic_thal\";\n\tif (k == XK_Arabic_ra) return \"Arabic_ra\";\n\tif (k == XK_Arabic_zain) return \"Arabic_zain\";\n\tif (k == XK_Arabic_seen) return \"Arabic_seen\";\n\tif (k == XK_Arabic_sheen) return \"Arabic_sheen\";\n\tif (k == XK_Arabic_sad) return \"Arabic_sad\";\n\tif (k == XK_Arabic_dad) return \"Arabic_dad\";\n\tif (k == XK_Arabic_tah) return \"Arabic_tah\";\n\tif (k == XK_Arabic_zah) return \"Arabic_zah\";\n\tif (k == XK_Arabic_ain) return \"Arabic_ain\";\n\tif (k == XK_Arabic_ghain) return \"Arabic_ghain\";\n\tif (k == XK_Arabic_tatweel) return \"Arabic_tatweel\";\n\tif (k == XK_Arabic_feh) return \"Arabic_feh\";\n\tif (k == XK_Arabic_qaf) return \"Arabic_qaf\";\n\tif (k == XK_Arabic_kaf) return \"Arabic_kaf\";\n\tif (k == XK_Arabic_lam) return \"Arabic_lam\";\n\tif (k == XK_Arabic_meem) return \"Arabic_meem\";\n\tif (k == XK_Arabic_noon) return \"Arabic_noon\";\n\tif (k == XK_Arabic_ha) return \"Arabic_ha\";\n\tif (k == XK_Arabic_heh) return \"Arabic_heh\";\n\tif (k == XK_Arabic_waw) return \"Arabic_waw\";\n\tif (k == XK_Arabic_alefmaksura) return \"Arabic_alefmaksura\";\n\tif (k == XK_Arabic_yeh) return \"Arabic_yeh\";\n\tif (k == XK_Arabic_fathatan) return \"Arabic_fathatan\";\n\tif (k == XK_Arabic_dammatan) return \"Arabic_dammatan\";\n\tif (k == XK_Arabic_kasratan) return \"Arabic_kasratan\";\n\tif (k == XK_Arabic_fatha) return \"Arabic_fatha\";\n\tif (k == XK_Arabic_damma) return \"Arabic_damma\";\n\tif (k == XK_Arabic_kasra) return \"Arabic_kasra\";\n\tif (k == XK_Arabic_shadda) return \"Arabic_shadda\";\n\tif (k == XK_Arabic_sukun) return \"Arabic_sukun\";\n\tif (k == XK_Arabic_switch) return \"Arabic_switch\";\n#endif /* XK_ARABIC */\n#ifdef XK_CYRILLIC\n\tif (k == XK_Serbian_dje) return \"Serbian_dje\";\n\tif (k == XK_Macedonia_gje) return \"Macedonia_gje\";\n\tif (k == XK_Cyrillic_io) return \"Cyrillic_io\";\n\tif (k == XK_Ukrainian_ie) return \"Ukrainian_ie\";\n\tif (k == XK_Ukranian_je) return \"Ukranian_je\";\n\tif (k == XK_Macedonia_dse) return \"Macedonia_dse\";\n\tif (k == XK_Ukrainian_i) return \"Ukrainian_i\";\n\tif (k == XK_Ukranian_i) return \"Ukranian_i\";\n\tif (k == XK_Ukrainian_yi) return \"Ukrainian_yi\";\n\tif (k == XK_Ukranian_yi) return \"Ukranian_yi\";\n\tif (k == XK_Cyrillic_je) return \"Cyrillic_je\";\n\tif (k == XK_Serbian_je) return \"Serbian_je\";\n\tif (k == XK_Cyrillic_lje) return \"Cyrillic_lje\";\n\tif (k == XK_Serbian_lje) return \"Serbian_lje\";\n\tif (k == XK_Cyrillic_nje) return \"Cyrillic_nje\";\n\tif (k == XK_Serbian_nje) return \"Serbian_nje\";\n\tif (k == XK_Serbian_tshe) return \"Serbian_tshe\";\n\tif (k == XK_Macedonia_kje) return \"Macedonia_kje\";\n\tif (k == XK_Byelorussian_shortu) return \"Byelorussian_shortu\";\n\tif (k == XK_Cyrillic_dzhe) return \"Cyrillic_dzhe\";\n\tif (k == XK_Serbian_dze) return \"Serbian_dze\";\n\tif (k == XK_numerosign) return \"numerosign\";\n\tif (k == XK_Serbian_DJE) return \"Serbian_DJE\";\n\tif (k == XK_Macedonia_GJE) return \"Macedonia_GJE\";\n\tif (k == XK_Cyrillic_IO) return \"Cyrillic_IO\";\n\tif (k == XK_Ukrainian_IE) return \"Ukrainian_IE\";\n\tif (k == XK_Ukranian_JE) return \"Ukranian_JE\";\n\tif (k == XK_Macedonia_DSE) return \"Macedonia_DSE\";\n\tif (k == XK_Ukrainian_I) return \"Ukrainian_I\";\n\tif (k == XK_Ukranian_I) return \"Ukranian_I\";\n\tif (k == XK_Ukrainian_YI) return \"Ukrainian_YI\";\n\tif (k == XK_Ukranian_YI) return \"Ukranian_YI\";\n\tif (k == XK_Cyrillic_JE) return \"Cyrillic_JE\";\n\tif (k == XK_Serbian_JE) return \"Serbian_JE\";\n\tif (k == XK_Cyrillic_LJE) return \"Cyrillic_LJE\";\n\tif (k == XK_Serbian_LJE) return \"Serbian_LJE\";\n\tif (k == XK_Cyrillic_NJE) return \"Cyrillic_NJE\";\n\tif (k == XK_Serbian_NJE) return \"Serbian_NJE\";\n\tif (k == XK_Serbian_TSHE) return \"Serbian_TSHE\";\n\tif (k == XK_Macedonia_KJE) return \"Macedonia_KJE\";\n\tif (k == XK_Byelorussian_SHORTU) return \"Byelorussian_SHORTU\";\n\tif (k == XK_Cyrillic_DZHE) return \"Cyrillic_DZHE\";\n\tif (k == XK_Serbian_DZE) return \"Serbian_DZE\";\n\tif (k == XK_Cyrillic_yu) return \"Cyrillic_yu\";\n\tif (k == XK_Cyrillic_a) return \"Cyrillic_a\";\n\tif (k == XK_Cyrillic_be) return \"Cyrillic_be\";\n\tif (k == XK_Cyrillic_tse) return \"Cyrillic_tse\";\n\tif (k == XK_Cyrillic_de) return \"Cyrillic_de\";\n\tif (k == XK_Cyrillic_ie) return \"Cyrillic_ie\";\n\tif (k == XK_Cyrillic_ef) return \"Cyrillic_ef\";\n\tif (k == XK_Cyrillic_ghe) return \"Cyrillic_ghe\";\n\tif (k == XK_Cyrillic_ha) return \"Cyrillic_ha\";\n\tif (k == XK_Cyrillic_i) return \"Cyrillic_i\";\n\tif (k == XK_Cyrillic_shorti) return \"Cyrillic_shorti\";\n\tif (k == XK_Cyrillic_ka) return \"Cyrillic_ka\";\n\tif (k == XK_Cyrillic_el) return \"Cyrillic_el\";\n\tif (k == XK_Cyrillic_em) return \"Cyrillic_em\";\n\tif (k == XK_Cyrillic_en) return \"Cyrillic_en\";\n\tif (k == XK_Cyrillic_o) return \"Cyrillic_o\";\n\tif (k == XK_Cyrillic_pe) return \"Cyrillic_pe\";\n\tif (k == XK_Cyrillic_ya) return \"Cyrillic_ya\";\n\tif (k == XK_Cyrillic_er) return \"Cyrillic_er\";\n\tif (k == XK_Cyrillic_es) return \"Cyrillic_es\";\n\tif (k == XK_Cyrillic_te) return \"Cyrillic_te\";\n\tif (k == XK_Cyrillic_u) return \"Cyrillic_u\";\n\tif (k == XK_Cyrillic_zhe) return \"Cyrillic_zhe\";\n\tif (k == XK_Cyrillic_ve) return \"Cyrillic_ve\";\n\tif (k == XK_Cyrillic_softsign) return \"Cyrillic_softsign\";\n\tif (k == XK_Cyrillic_yeru) return \"Cyrillic_yeru\";\n\tif (k == XK_Cyrillic_ze) return \"Cyrillic_ze\";\n\tif (k == XK_Cyrillic_sha) return \"Cyrillic_sha\";\n\tif (k == XK_Cyrillic_e) return \"Cyrillic_e\";\n\tif (k == XK_Cyrillic_shcha) return \"Cyrillic_shcha\";\n\tif (k == XK_Cyrillic_che) return \"Cyrillic_che\";\n\tif (k == XK_Cyrillic_hardsign) return \"Cyrillic_hardsign\";\n\tif (k == XK_Cyrillic_YU) return \"Cyrillic_YU\";\n\tif (k == XK_Cyrillic_A) return \"Cyrillic_A\";\n\tif (k == XK_Cyrillic_BE) return \"Cyrillic_BE\";\n\tif (k == XK_Cyrillic_TSE) return \"Cyrillic_TSE\";\n\tif (k == XK_Cyrillic_DE) return \"Cyrillic_DE\";\n\tif (k == XK_Cyrillic_IE) return \"Cyrillic_IE\";\n\tif (k == XK_Cyrillic_EF) return \"Cyrillic_EF\";\n\tif (k == XK_Cyrillic_GHE) return \"Cyrillic_GHE\";\n\tif (k == XK_Cyrillic_HA) return \"Cyrillic_HA\";\n\tif (k == XK_Cyrillic_I) return \"Cyrillic_I\";\n\tif (k == XK_Cyrillic_SHORTI) return \"Cyrillic_SHORTI\";\n\tif (k == XK_Cyrillic_KA) return \"Cyrillic_KA\";\n\tif (k == XK_Cyrillic_EL) return \"Cyrillic_EL\";\n\tif (k == XK_Cyrillic_EM) return \"Cyrillic_EM\";\n\tif (k == XK_Cyrillic_EN) return \"Cyrillic_EN\";\n\tif (k == XK_Cyrillic_O) return \"Cyrillic_O\";\n\tif (k == XK_Cyrillic_PE) return \"Cyrillic_PE\";\n\tif (k == XK_Cyrillic_YA) return \"Cyrillic_YA\";\n\tif (k == XK_Cyrillic_ER) return \"Cyrillic_ER\";\n\tif (k == XK_Cyrillic_ES) return \"Cyrillic_ES\";\n\tif (k == XK_Cyrillic_TE) return \"Cyrillic_TE\";\n\tif (k == XK_Cyrillic_U) return \"Cyrillic_U\";\n\tif (k == XK_Cyrillic_ZHE) return \"Cyrillic_ZHE\";\n\tif (k == XK_Cyrillic_VE) return \"Cyrillic_VE\";\n\tif (k == XK_Cyrillic_SOFTSIGN) return \"Cyrillic_SOFTSIGN\";\n\tif (k == XK_Cyrillic_YERU) return \"Cyrillic_YERU\";\n\tif (k == XK_Cyrillic_ZE) return \"Cyrillic_ZE\";\n\tif (k == XK_Cyrillic_SHA) return \"Cyrillic_SHA\";\n\tif (k == XK_Cyrillic_E) return \"Cyrillic_E\";\n\tif (k == XK_Cyrillic_SHCHA) return \"Cyrillic_SHCHA\";\n\tif (k == XK_Cyrillic_CHE) return \"Cyrillic_CHE\";\n\tif (k == XK_Cyrillic_HARDSIGN) return \"Cyrillic_HARDSIGN\";\n#endif /* XK_CYRILLIC */\n#ifdef XK_GREEK\n\tif (k == XK_Greek_ALPHAaccent) return \"Greek_ALPHAaccent\";\n\tif (k == XK_Greek_EPSILONaccent) return \"Greek_EPSILONaccent\";\n\tif (k == XK_Greek_ETAaccent) return \"Greek_ETAaccent\";\n\tif (k == XK_Greek_IOTAaccent) return \"Greek_IOTAaccent\";\n\tif (k == XK_Greek_IOTAdieresis) return \"Greek_IOTAdieresis\";\n\tif (k == XK_Greek_OMICRONaccent) return \"Greek_OMICRONaccent\";\n\tif (k == XK_Greek_UPSILONaccent) return \"Greek_UPSILONaccent\";\n\tif (k == XK_Greek_UPSILONdieresis) return \"Greek_UPSILONdieresis\";\n\tif (k == XK_Greek_OMEGAaccent) return \"Greek_OMEGAaccent\";\n\tif (k == XK_Greek_accentdieresis) return \"Greek_accentdieresis\";\n\tif (k == XK_Greek_horizbar) return \"Greek_horizbar\";\n\tif (k == XK_Greek_alphaaccent) return \"Greek_alphaaccent\";\n\tif (k == XK_Greek_epsilonaccent) return \"Greek_epsilonaccent\";\n\tif (k == XK_Greek_etaaccent) return \"Greek_etaaccent\";\n\tif (k == XK_Greek_iotaaccent) return \"Greek_iotaaccent\";\n\tif (k == XK_Greek_iotadieresis) return \"Greek_iotadieresis\";\n\tif (k == XK_Greek_iotaaccentdieresis) return \"Greek_iotaaccentdieresis\";\n\tif (k == XK_Greek_omicronaccent) return \"Greek_omicronaccent\";\n\tif (k == XK_Greek_upsilonaccent) return \"Greek_upsilonaccent\";\n\tif (k == XK_Greek_upsilondieresis) return \"Greek_upsilondieresis\";\n\tif (k == XK_Greek_upsilonaccentdieresis) return \"Greek_upsilonaccentdieresis\";\n\tif (k == XK_Greek_omegaaccent) return \"Greek_omegaaccent\";\n\tif (k == XK_Greek_ALPHA) return \"Greek_ALPHA\";\n\tif (k == XK_Greek_BETA) return \"Greek_BETA\";\n\tif (k == XK_Greek_GAMMA) return \"Greek_GAMMA\";\n\tif (k == XK_Greek_DELTA) return \"Greek_DELTA\";\n\tif (k == XK_Greek_EPSILON) return \"Greek_EPSILON\";\n\tif (k == XK_Greek_ZETA) return \"Greek_ZETA\";\n\tif (k == XK_Greek_ETA) return \"Greek_ETA\";\n\tif (k == XK_Greek_THETA) return \"Greek_THETA\";\n\tif (k == XK_Greek_IOTA) return \"Greek_IOTA\";\n\tif (k == XK_Greek_KAPPA) return \"Greek_KAPPA\";\n\tif (k == XK_Greek_LAMDA) return \"Greek_LAMDA\";\n\tif (k == XK_Greek_LAMBDA) return \"Greek_LAMBDA\";\n\tif (k == XK_Greek_MU) return \"Greek_MU\";\n\tif (k == XK_Greek_NU) return \"Greek_NU\";\n\tif (k == XK_Greek_XI) return \"Greek_XI\";\n\tif (k == XK_Greek_OMICRON) return \"Greek_OMICRON\";\n\tif (k == XK_Greek_PI) return \"Greek_PI\";\n\tif (k == XK_Greek_RHO) return \"Greek_RHO\";\n\tif (k == XK_Greek_SIGMA) return \"Greek_SIGMA\";\n\tif (k == XK_Greek_TAU) return \"Greek_TAU\";\n\tif (k == XK_Greek_UPSILON) return \"Greek_UPSILON\";\n\tif (k == XK_Greek_PHI) return \"Greek_PHI\";\n\tif (k == XK_Greek_CHI) return \"Greek_CHI\";\n\tif (k == XK_Greek_PSI) return \"Greek_PSI\";\n\tif (k == XK_Greek_OMEGA) return \"Greek_OMEGA\";\n\tif (k == XK_Greek_alpha) return \"Greek_alpha\";\n\tif (k == XK_Greek_beta) return \"Greek_beta\";\n\tif (k == XK_Greek_gamma) return \"Greek_gamma\";\n\tif (k == XK_Greek_delta) return \"Greek_delta\";\n\tif (k == XK_Greek_epsilon) return \"Greek_epsilon\";\n\tif (k == XK_Greek_zeta) return \"Greek_zeta\";\n\tif (k == XK_Greek_eta) return \"Greek_eta\";\n\tif (k == XK_Greek_theta) return \"Greek_theta\";\n\tif (k == XK_Greek_iota) return \"Greek_iota\";\n\tif (k == XK_Greek_kappa) return \"Greek_kappa\";\n\tif (k == XK_Greek_lamda) return \"Greek_lamda\";\n\tif (k == XK_Greek_lambda) return \"Greek_lambda\";\n\tif (k == XK_Greek_mu) return \"Greek_mu\";\n\tif (k == XK_Greek_nu) return \"Greek_nu\";\n\tif (k == XK_Greek_xi) return \"Greek_xi\";\n\tif (k == XK_Greek_omicron) return \"Greek_omicron\";\n\tif (k == XK_Greek_pi) return \"Greek_pi\";\n\tif (k == XK_Greek_rho) return \"Greek_rho\";\n\tif (k == XK_Greek_sigma) return \"Greek_sigma\";\n\tif (k == XK_Greek_finalsmallsigma) return \"Greek_finalsmallsigma\";\n\tif (k == XK_Greek_tau) return \"Greek_tau\";\n\tif (k == XK_Greek_upsilon) return \"Greek_upsilon\";\n\tif (k == XK_Greek_phi) return \"Greek_phi\";\n\tif (k == XK_Greek_chi) return \"Greek_chi\";\n\tif (k == XK_Greek_psi) return \"Greek_psi\";\n\tif (k == XK_Greek_omega) return \"Greek_omega\";\n\tif (k == XK_Greek_switch) return \"Greek_switch\";\n#endif /* XK_GREEK */\n#ifdef XK_TECHNICAL\n\tif (k == XK_leftradical) return \"leftradical\";\n\tif (k == XK_topleftradical) return \"topleftradical\";\n\tif (k == XK_horizconnector) return \"horizconnector\";\n\tif (k == XK_topintegral) return \"topintegral\";\n\tif (k == XK_botintegral) return \"botintegral\";\n\tif (k == XK_vertconnector) return \"vertconnector\";\n\tif (k == XK_topleftsqbracket) return \"topleftsqbracket\";\n\tif (k == XK_botleftsqbracket) return \"botleftsqbracket\";\n\tif (k == XK_toprightsqbracket) return \"toprightsqbracket\";\n\tif (k == XK_botrightsqbracket) return \"botrightsqbracket\";\n\tif (k == XK_topleftparens) return \"topleftparens\";\n\tif (k == XK_botleftparens) return \"botleftparens\";\n\tif (k == XK_toprightparens) return \"toprightparens\";\n\tif (k == XK_botrightparens) return \"botrightparens\";\n\tif (k == XK_leftmiddlecurlybrace) return \"leftmiddlecurlybrace\";\n\tif (k == XK_rightmiddlecurlybrace) return \"rightmiddlecurlybrace\";\n\tif (k == XK_topleftsummation) return \"topleftsummation\";\n\tif (k == XK_botleftsummation) return \"botleftsummation\";\n\tif (k == XK_topvertsummationconnector) return \"topvertsummationconnector\";\n\tif (k == XK_botvertsummationconnector) return \"botvertsummationconnector\";\n\tif (k == XK_toprightsummation) return \"toprightsummation\";\n\tif (k == XK_botrightsummation) return \"botrightsummation\";\n\tif (k == XK_rightmiddlesummation) return \"rightmiddlesummation\";\n\tif (k == XK_lessthanequal) return \"lessthanequal\";\n\tif (k == XK_notequal) return \"notequal\";\n\tif (k == XK_greaterthanequal) return \"greaterthanequal\";\n\tif (k == XK_integral) return \"integral\";\n\tif (k == XK_therefore) return \"therefore\";\n\tif (k == XK_variation) return \"variation\";\n\tif (k == XK_infinity) return \"infinity\";\n\tif (k == XK_nabla) return \"nabla\";\n\tif (k == XK_approximate) return \"approximate\";\n\tif (k == XK_similarequal) return \"similarequal\";\n\tif (k == XK_ifonlyif) return \"ifonlyif\";\n\tif (k == XK_implies) return \"implies\";\n\tif (k == XK_identical) return \"identical\";\n\tif (k == XK_radical) return \"radical\";\n\tif (k == XK_includedin) return \"includedin\";\n\tif (k == XK_includes) return \"includes\";\n\tif (k == XK_intersection) return \"intersection\";\n\tif (k == XK_union) return \"union\";\n\tif (k == XK_logicaland) return \"logicaland\";\n\tif (k == XK_logicalor) return \"logicalor\";\n\tif (k == XK_partialderivative) return \"partialderivative\";\n\tif (k == XK_function) return \"function\";\n\tif (k == XK_leftarrow) return \"leftarrow\";\n\tif (k == XK_uparrow) return \"uparrow\";\n\tif (k == XK_rightarrow) return \"rightarrow\";\n\tif (k == XK_downarrow) return \"downarrow\";\n#endif /* XK_TECHNICAL */\n#ifdef XK_SPECIAL\n\tif (k == XK_blank) return \"blank\";\n\tif (k == XK_soliddiamond) return \"soliddiamond\";\n\tif (k == XK_checkerboard) return \"checkerboard\";\n\tif (k == XK_ht) return \"ht\";\n\tif (k == XK_ff) return \"ff\";\n\tif (k == XK_cr) return \"cr\";\n\tif (k == XK_lf) return \"lf\";\n\tif (k == XK_nl) return \"nl\";\n\tif (k == XK_vt) return \"vt\";\n\tif (k == XK_lowrightcorner) return \"lowrightcorner\";\n\tif (k == XK_uprightcorner) return \"uprightcorner\";\n\tif (k == XK_upleftcorner) return \"upleftcorner\";\n\tif (k == XK_lowleftcorner) return \"lowleftcorner\";\n\tif (k == XK_crossinglines) return \"crossinglines\";\n\tif (k == XK_horizlinescan1) return \"horizlinescan1\";\n\tif (k == XK_horizlinescan3) return \"horizlinescan3\";\n\tif (k == XK_horizlinescan5) return \"horizlinescan5\";\n\tif (k == XK_horizlinescan7) return \"horizlinescan7\";\n\tif (k == XK_horizlinescan9) return \"horizlinescan9\";\n\tif (k == XK_leftt) return \"leftt\";\n\tif (k == XK_rightt) return \"rightt\";\n\tif (k == XK_bott) return \"bott\";\n\tif (k == XK_topt) return \"topt\";\n\tif (k == XK_vertbar) return \"vertbar\";\n#endif /* XK_SPECIAL */\n#ifdef XK_PUBLISHING\n\tif (k == XK_emspace) return \"emspace\";\n\tif (k == XK_enspace) return \"enspace\";\n\tif (k == XK_em3space) return \"em3space\";\n\tif (k == XK_em4space) return \"em4space\";\n\tif (k == XK_digitspace) return \"digitspace\";\n\tif (k == XK_punctspace) return \"punctspace\";\n\tif (k == XK_thinspace) return \"thinspace\";\n\tif (k == XK_hairspace) return \"hairspace\";\n\tif (k == XK_emdash) return \"emdash\";\n\tif (k == XK_endash) return \"endash\";\n\tif (k == XK_signifblank) return \"signifblank\";\n\tif (k == XK_ellipsis) return \"ellipsis\";\n\tif (k == XK_doubbaselinedot) return \"doubbaselinedot\";\n\tif (k == XK_onethird) return \"onethird\";\n\tif (k == XK_twothirds) return \"twothirds\";\n\tif (k == XK_onefifth) return \"onefifth\";\n\tif (k == XK_twofifths) return \"twofifths\";\n\tif (k == XK_threefifths) return \"threefifths\";\n\tif (k == XK_fourfifths) return \"fourfifths\";\n\tif (k == XK_onesixth) return \"onesixth\";\n\tif (k == XK_fivesixths) return \"fivesixths\";\n\tif (k == XK_careof) return \"careof\";\n\tif (k == XK_figdash) return \"figdash\";\n\tif (k == XK_leftanglebracket) return \"leftanglebracket\";\n\tif (k == XK_decimalpoint) return \"decimalpoint\";\n\tif (k == XK_rightanglebracket) return \"rightanglebracket\";\n\tif (k == XK_marker) return \"marker\";\n\tif (k == XK_oneeighth) return \"oneeighth\";\n\tif (k == XK_threeeighths) return \"threeeighths\";\n\tif (k == XK_fiveeighths) return \"fiveeighths\";\n\tif (k == XK_seveneighths) return \"seveneighths\";\n\tif (k == XK_trademark) return \"trademark\";\n\tif (k == XK_signaturemark) return \"signaturemark\";\n\tif (k == XK_trademarkincircle) return \"trademarkincircle\";\n\tif (k == XK_leftopentriangle) return \"leftopentriangle\";\n\tif (k == XK_rightopentriangle) return \"rightopentriangle\";\n\tif (k == XK_emopencircle) return \"emopencircle\";\n\tif (k == XK_emopenrectangle) return \"emopenrectangle\";\n\tif (k == XK_leftsinglequotemark) return \"leftsinglequotemark\";\n\tif (k == XK_rightsinglequotemark) return \"rightsinglequotemark\";\n\tif (k == XK_leftdoublequotemark) return \"leftdoublequotemark\";\n\tif (k == XK_rightdoublequotemark) return \"rightdoublequotemark\";\n\tif (k == XK_prescription) return \"prescription\";\n\tif (k == XK_minutes) return \"minutes\";\n\tif (k == XK_seconds) return \"seconds\";\n\tif (k == XK_latincross) return \"latincross\";\n\tif (k == XK_hexagram) return \"hexagram\";\n\tif (k == XK_filledrectbullet) return \"filledrectbullet\";\n\tif (k == XK_filledlefttribullet) return \"filledlefttribullet\";\n\tif (k == XK_filledrighttribullet) return \"filledrighttribullet\";\n\tif (k == XK_emfilledcircle) return \"emfilledcircle\";\n\tif (k == XK_emfilledrect) return \"emfilledrect\";\n\tif (k == XK_enopencircbullet) return \"enopencircbullet\";\n\tif (k == XK_enopensquarebullet) return \"enopensquarebullet\";\n\tif (k == XK_openrectbullet) return \"openrectbullet\";\n\tif (k == XK_opentribulletup) return \"opentribulletup\";\n\tif (k == XK_opentribulletdown) return \"opentribulletdown\";\n\tif (k == XK_openstar) return \"openstar\";\n\tif (k == XK_enfilledcircbullet) return \"enfilledcircbullet\";\n\tif (k == XK_enfilledsqbullet) return \"enfilledsqbullet\";\n\tif (k == XK_filledtribulletup) return \"filledtribulletup\";\n\tif (k == XK_filledtribulletdown) return \"filledtribulletdown\";\n\tif (k == XK_leftpointer) return \"leftpointer\";\n\tif (k == XK_rightpointer) return \"rightpointer\";\n\tif (k == XK_club) return \"club\";\n\tif (k == XK_diamond) return \"diamond\";\n\tif (k == XK_heart) return \"heart\";\n\tif (k == XK_maltesecross) return \"maltesecross\";\n\tif (k == XK_dagger) return \"dagger\";\n\tif (k == XK_doubledagger) return \"doubledagger\";\n\tif (k == XK_checkmark) return \"checkmark\";\n\tif (k == XK_ballotcross) return \"ballotcross\";\n\tif (k == XK_musicalsharp) return \"musicalsharp\";\n\tif (k == XK_musicalflat) return \"musicalflat\";\n\tif (k == XK_malesymbol) return \"malesymbol\";\n\tif (k == XK_femalesymbol) return \"femalesymbol\";\n\tif (k == XK_telephone) return \"telephone\";\n\tif (k == XK_telephonerecorder) return \"telephonerecorder\";\n\tif (k == XK_phonographcopyright) return \"phonographcopyright\";\n\tif (k == XK_caret) return \"caret\";\n\tif (k == XK_singlelowquotemark) return \"singlelowquotemark\";\n\tif (k == XK_doublelowquotemark) return \"doublelowquotemark\";\n\tif (k == XK_cursor) return \"cursor\";\n#endif /* XK_PUBLISHING */\n#ifdef XK_APL\n\tif (k == XK_leftcaret) return \"leftcaret\";\n\tif (k == XK_rightcaret) return \"rightcaret\";\n\tif (k == XK_downcaret) return \"downcaret\";\n\tif (k == XK_upcaret) return \"upcaret\";\n\tif (k == XK_overbar) return \"overbar\";\n\tif (k == XK_downtack) return \"downtack\";\n\tif (k == XK_upshoe) return \"upshoe\";\n\tif (k == XK_downstile) return \"downstile\";\n\tif (k == XK_underbar) return \"underbar\";\n\tif (k == XK_jot) return \"jot\";\n\tif (k == XK_quad) return \"quad\";\n\tif (k == XK_uptack) return \"uptack\";\n\tif (k == XK_circle) return \"circle\";\n\tif (k == XK_upstile) return \"upstile\";\n\tif (k == XK_downshoe) return \"downshoe\";\n\tif (k == XK_rightshoe) return \"rightshoe\";\n\tif (k == XK_leftshoe) return \"leftshoe\";\n\tif (k == XK_lefttack) return \"lefttack\";\n\tif (k == XK_righttack) return \"righttack\";\n#endif /* XK_APL */\n#ifdef XK_HEBREW\n\tif (k == XK_hebrew_doublelowline) return \"hebrew_doublelowline\";\n\tif (k == XK_hebrew_aleph) return \"hebrew_aleph\";\n\tif (k == XK_hebrew_bet) return \"hebrew_bet\";\n\tif (k == XK_hebrew_beth) return \"hebrew_beth\";\n\tif (k == XK_hebrew_gimel) return \"hebrew_gimel\";\n\tif (k == XK_hebrew_gimmel) return \"hebrew_gimmel\";\n\tif (k == XK_hebrew_dalet) return \"hebrew_dalet\";\n\tif (k == XK_hebrew_daleth) return \"hebrew_daleth\";\n\tif (k == XK_hebrew_he) return \"hebrew_he\";\n\tif (k == XK_hebrew_waw) return \"hebrew_waw\";\n\tif (k == XK_hebrew_zain) return \"hebrew_zain\";\n\tif (k == XK_hebrew_zayin) return \"hebrew_zayin\";\n\tif (k == XK_hebrew_chet) return \"hebrew_chet\";\n\tif (k == XK_hebrew_het) return \"hebrew_het\";\n\tif (k == XK_hebrew_tet) return \"hebrew_tet\";\n\tif (k == XK_hebrew_teth) return \"hebrew_teth\";\n\tif (k == XK_hebrew_yod) return \"hebrew_yod\";\n\tif (k == XK_hebrew_finalkaph) return \"hebrew_finalkaph\";\n\tif (k == XK_hebrew_kaph) return \"hebrew_kaph\";\n\tif (k == XK_hebrew_lamed) return \"hebrew_lamed\";\n\tif (k == XK_hebrew_finalmem) return \"hebrew_finalmem\";\n\tif (k == XK_hebrew_mem) return \"hebrew_mem\";\n\tif (k == XK_hebrew_finalnun) return \"hebrew_finalnun\";\n\tif (k == XK_hebrew_nun) return \"hebrew_nun\";\n\tif (k == XK_hebrew_samech) return \"hebrew_samech\";\n\tif (k == XK_hebrew_samekh) return \"hebrew_samekh\";\n\tif (k == XK_hebrew_ayin) return \"hebrew_ayin\";\n\tif (k == XK_hebrew_finalpe) return \"hebrew_finalpe\";\n\tif (k == XK_hebrew_pe) return \"hebrew_pe\";\n\tif (k == XK_hebrew_finalzade) return \"hebrew_finalzade\";\n\tif (k == XK_hebrew_finalzadi) return \"hebrew_finalzadi\";\n\tif (k == XK_hebrew_zade) return \"hebrew_zade\";\n\tif (k == XK_hebrew_zadi) return \"hebrew_zadi\";\n\tif (k == XK_hebrew_qoph) return \"hebrew_qoph\";\n\tif (k == XK_hebrew_kuf) return \"hebrew_kuf\";\n\tif (k == XK_hebrew_resh) return \"hebrew_resh\";\n\tif (k == XK_hebrew_shin) return \"hebrew_shin\";\n\tif (k == XK_hebrew_taw) return \"hebrew_taw\";\n\tif (k == XK_hebrew_taf) return \"hebrew_taf\";\n\tif (k == XK_Hebrew_switch) return \"Hebrew_switch\";\n#endif /* XK_HEBREW */\n#ifdef XK_THAI\n\tif (k == XK_Thai_kokai) return \"Thai_kokai\";\n\tif (k == XK_Thai_khokhai) return \"Thai_khokhai\";\n\tif (k == XK_Thai_khokhuat) return \"Thai_khokhuat\";\n\tif (k == XK_Thai_khokhwai) return \"Thai_khokhwai\";\n\tif (k == XK_Thai_khokhon) return \"Thai_khokhon\";\n\tif (k == XK_Thai_khorakhang) return \"Thai_khorakhang\";\n\tif (k == XK_Thai_ngongu) return \"Thai_ngongu\";\n\tif (k == XK_Thai_chochan) return \"Thai_chochan\";\n\tif (k == XK_Thai_choching) return \"Thai_choching\";\n\tif (k == XK_Thai_chochang) return \"Thai_chochang\";\n\tif (k == XK_Thai_soso) return \"Thai_soso\";\n\tif (k == XK_Thai_chochoe) return \"Thai_chochoe\";\n\tif (k == XK_Thai_yoying) return \"Thai_yoying\";\n\tif (k == XK_Thai_dochada) return \"Thai_dochada\";\n\tif (k == XK_Thai_topatak) return \"Thai_topatak\";\n\tif (k == XK_Thai_thothan) return \"Thai_thothan\";\n\tif (k == XK_Thai_thonangmontho) return \"Thai_thonangmontho\";\n\tif (k == XK_Thai_thophuthao) return \"Thai_thophuthao\";\n\tif (k == XK_Thai_nonen) return \"Thai_nonen\";\n\tif (k == XK_Thai_dodek) return \"Thai_dodek\";\n\tif (k == XK_Thai_totao) return \"Thai_totao\";\n\tif (k == XK_Thai_thothung) return \"Thai_thothung\";\n\tif (k == XK_Thai_thothahan) return \"Thai_thothahan\";\n\tif (k == XK_Thai_thothong) return \"Thai_thothong\";\n\tif (k == XK_Thai_nonu) return \"Thai_nonu\";\n\tif (k == XK_Thai_bobaimai) return \"Thai_bobaimai\";\n\tif (k == XK_Thai_popla) return \"Thai_popla\";\n\tif (k == XK_Thai_phophung) return \"Thai_phophung\";\n\tif (k == XK_Thai_fofa) return \"Thai_fofa\";\n\tif (k == XK_Thai_phophan) return \"Thai_phophan\";\n\tif (k == XK_Thai_fofan) return \"Thai_fofan\";\n\tif (k == XK_Thai_phosamphao) return \"Thai_phosamphao\";\n\tif (k == XK_Thai_moma) return \"Thai_moma\";\n\tif (k == XK_Thai_yoyak) return \"Thai_yoyak\";\n\tif (k == XK_Thai_rorua) return \"Thai_rorua\";\n\tif (k == XK_Thai_ru) return \"Thai_ru\";\n\tif (k == XK_Thai_loling) return \"Thai_loling\";\n\tif (k == XK_Thai_lu) return \"Thai_lu\";\n\tif (k == XK_Thai_wowaen) return \"Thai_wowaen\";\n\tif (k == XK_Thai_sosala) return \"Thai_sosala\";\n\tif (k == XK_Thai_sorusi) return \"Thai_sorusi\";\n\tif (k == XK_Thai_sosua) return \"Thai_sosua\";\n\tif (k == XK_Thai_hohip) return \"Thai_hohip\";\n\tif (k == XK_Thai_lochula) return \"Thai_lochula\";\n\tif (k == XK_Thai_oang) return \"Thai_oang\";\n\tif (k == XK_Thai_honokhuk) return \"Thai_honokhuk\";\n\tif (k == XK_Thai_paiyannoi) return \"Thai_paiyannoi\";\n\tif (k == XK_Thai_saraa) return \"Thai_saraa\";\n\tif (k == XK_Thai_maihanakat) return \"Thai_maihanakat\";\n\tif (k == XK_Thai_saraaa) return \"Thai_saraaa\";\n\tif (k == XK_Thai_saraam) return \"Thai_saraam\";\n\tif (k == XK_Thai_sarai) return \"Thai_sarai\";\n\tif (k == XK_Thai_saraii) return \"Thai_saraii\";\n\tif (k == XK_Thai_saraue) return \"Thai_saraue\";\n\tif (k == XK_Thai_sarauee) return \"Thai_sarauee\";\n\tif (k == XK_Thai_sarau) return \"Thai_sarau\";\n\tif (k == XK_Thai_sarauu) return \"Thai_sarauu\";\n\tif (k == XK_Thai_phinthu) return \"Thai_phinthu\";\n\tif (k == XK_Thai_maihanakat_maitho) return \"Thai_maihanakat_maitho\";\n\tif (k == XK_Thai_baht) return \"Thai_baht\";\n\tif (k == XK_Thai_sarae) return \"Thai_sarae\";\n\tif (k == XK_Thai_saraae) return \"Thai_saraae\";\n\tif (k == XK_Thai_sarao) return \"Thai_sarao\";\n\tif (k == XK_Thai_saraaimaimuan) return \"Thai_saraaimaimuan\";\n\tif (k == XK_Thai_saraaimaimalai) return \"Thai_saraaimaimalai\";\n\tif (k == XK_Thai_lakkhangyao) return \"Thai_lakkhangyao\";\n\tif (k == XK_Thai_maiyamok) return \"Thai_maiyamok\";\n\tif (k == XK_Thai_maitaikhu) return \"Thai_maitaikhu\";\n\tif (k == XK_Thai_maiek) return \"Thai_maiek\";\n\tif (k == XK_Thai_maitho) return \"Thai_maitho\";\n\tif (k == XK_Thai_maitri) return \"Thai_maitri\";\n\tif (k == XK_Thai_maichattawa) return \"Thai_maichattawa\";\n\tif (k == XK_Thai_thanthakhat) return \"Thai_thanthakhat\";\n\tif (k == XK_Thai_nikhahit) return \"Thai_nikhahit\";\n\tif (k == XK_Thai_leksun) return \"Thai_leksun\";\n\tif (k == XK_Thai_leknung) return \"Thai_leknung\";\n\tif (k == XK_Thai_leksong) return \"Thai_leksong\";\n\tif (k == XK_Thai_leksam) return \"Thai_leksam\";\n\tif (k == XK_Thai_leksi) return \"Thai_leksi\";\n\tif (k == XK_Thai_lekha) return \"Thai_lekha\";\n\tif (k == XK_Thai_lekhok) return \"Thai_lekhok\";\n\tif (k == XK_Thai_lekchet) return \"Thai_lekchet\";\n\tif (k == XK_Thai_lekpaet) return \"Thai_lekpaet\";\n\tif (k == XK_Thai_lekkao) return \"Thai_lekkao\";\n#endif /* XK_THAI */\n#ifdef XK_KOREAN\n\tif (k == XK_Hangul) return \"Hangul\";\n\tif (k == XK_Hangul_Start) return \"Hangul_Start\";\n\tif (k == XK_Hangul_End) return \"Hangul_End\";\n\tif (k == XK_Hangul_Hanja) return \"Hangul_Hanja\";\n\tif (k == XK_Hangul_Jamo) return \"Hangul_Jamo\";\n\tif (k == XK_Hangul_Romaja) return \"Hangul_Romaja\";\n\tif (k == XK_Hangul_Codeinput) return \"Hangul_Codeinput\";\n\tif (k == XK_Hangul_Jeonja) return \"Hangul_Jeonja\";\n\tif (k == XK_Hangul_Banja) return \"Hangul_Banja\";\n\tif (k == XK_Hangul_PreHanja) return \"Hangul_PreHanja\";\n\tif (k == XK_Hangul_PostHanja) return \"Hangul_PostHanja\";\n\tif (k == XK_Hangul_SingleCandidate) return \"Hangul_SingleCandidate\";\n\tif (k == XK_Hangul_MultipleCandidate) return \"Hangul_MultipleCandidate\";\n\tif (k == XK_Hangul_PreviousCandidate) return \"Hangul_PreviousCandidate\";\n\tif (k == XK_Hangul_Special) return \"Hangul_Special\";\n\tif (k == XK_Hangul_switch) return \"Hangul_switch\";\n\tif (k == XK_Hangul_Kiyeog) return \"Hangul_Kiyeog\";\n\tif (k == XK_Hangul_SsangKiyeog) return \"Hangul_SsangKiyeog\";\n\tif (k == XK_Hangul_KiyeogSios) return \"Hangul_KiyeogSios\";\n\tif (k == XK_Hangul_Nieun) return \"Hangul_Nieun\";\n\tif (k == XK_Hangul_NieunJieuj) return \"Hangul_NieunJieuj\";\n\tif (k == XK_Hangul_NieunHieuh) return \"Hangul_NieunHieuh\";\n\tif (k == XK_Hangul_Dikeud) return \"Hangul_Dikeud\";\n\tif (k == XK_Hangul_SsangDikeud) return \"Hangul_SsangDikeud\";\n\tif (k == XK_Hangul_Rieul) return \"Hangul_Rieul\";\n\tif (k == XK_Hangul_RieulKiyeog) return \"Hangul_RieulKiyeog\";\n\tif (k == XK_Hangul_RieulMieum) return \"Hangul_RieulMieum\";\n\tif (k == XK_Hangul_RieulPieub) return \"Hangul_RieulPieub\";\n\tif (k == XK_Hangul_RieulSios) return \"Hangul_RieulSios\";\n\tif (k == XK_Hangul_RieulTieut) return \"Hangul_RieulTieut\";\n\tif (k == XK_Hangul_RieulPhieuf) return \"Hangul_RieulPhieuf\";\n\tif (k == XK_Hangul_RieulHieuh) return \"Hangul_RieulHieuh\";\n\tif (k == XK_Hangul_Mieum) return \"Hangul_Mieum\";\n\tif (k == XK_Hangul_Pieub) return \"Hangul_Pieub\";\n\tif (k == XK_Hangul_SsangPieub) return \"Hangul_SsangPieub\";\n\tif (k == XK_Hangul_PieubSios) return \"Hangul_PieubSios\";\n\tif (k == XK_Hangul_Sios) return \"Hangul_Sios\";\n\tif (k == XK_Hangul_SsangSios) return \"Hangul_SsangSios\";\n\tif (k == XK_Hangul_Ieung) return \"Hangul_Ieung\";\n\tif (k == XK_Hangul_Jieuj) return \"Hangul_Jieuj\";\n\tif (k == XK_Hangul_SsangJieuj) return \"Hangul_SsangJieuj\";\n\tif (k == XK_Hangul_Cieuc) return \"Hangul_Cieuc\";\n\tif (k == XK_Hangul_Khieuq) return \"Hangul_Khieuq\";\n\tif (k == XK_Hangul_Tieut) return \"Hangul_Tieut\";\n\tif (k == XK_Hangul_Phieuf) return \"Hangul_Phieuf\";\n\tif (k == XK_Hangul_Hieuh) return \"Hangul_Hieuh\";\n\tif (k == XK_Hangul_A) return \"Hangul_A\";\n\tif (k == XK_Hangul_AE) return \"Hangul_AE\";\n\tif (k == XK_Hangul_YA) return \"Hangul_YA\";\n\tif (k == XK_Hangul_YAE) return \"Hangul_YAE\";\n\tif (k == XK_Hangul_EO) return \"Hangul_EO\";\n\tif (k == XK_Hangul_E) return \"Hangul_E\";\n\tif (k == XK_Hangul_YEO) return \"Hangul_YEO\";\n\tif (k == XK_Hangul_YE) return \"Hangul_YE\";\n\tif (k == XK_Hangul_O) return \"Hangul_O\";\n\tif (k == XK_Hangul_WA) return \"Hangul_WA\";\n\tif (k == XK_Hangul_WAE) return \"Hangul_WAE\";\n\tif (k == XK_Hangul_OE) return \"Hangul_OE\";\n\tif (k == XK_Hangul_YO) return \"Hangul_YO\";\n\tif (k == XK_Hangul_U) return \"Hangul_U\";\n\tif (k == XK_Hangul_WEO) return \"Hangul_WEO\";\n\tif (k == XK_Hangul_WE) return \"Hangul_WE\";\n\tif (k == XK_Hangul_WI) return \"Hangul_WI\";\n\tif (k == XK_Hangul_YU) return \"Hangul_YU\";\n\tif (k == XK_Hangul_EU) return \"Hangul_EU\";\n\tif (k == XK_Hangul_YI) return \"Hangul_YI\";\n\tif (k == XK_Hangul_I) return \"Hangul_I\";\n\tif (k == XK_Hangul_J_Kiyeog) return \"Hangul_J_Kiyeog\";\n\tif (k == XK_Hangul_J_SsangKiyeog) return \"Hangul_J_SsangKiyeog\";\n\tif (k == XK_Hangul_J_KiyeogSios) return \"Hangul_J_KiyeogSios\";\n\tif (k == XK_Hangul_J_Nieun) return \"Hangul_J_Nieun\";\n\tif (k == XK_Hangul_J_NieunJieuj) return \"Hangul_J_NieunJieuj\";\n\tif (k == XK_Hangul_J_NieunHieuh) return \"Hangul_J_NieunHieuh\";\n\tif (k == XK_Hangul_J_Dikeud) return \"Hangul_J_Dikeud\";\n\tif (k == XK_Hangul_J_Rieul) return \"Hangul_J_Rieul\";\n\tif (k == XK_Hangul_J_RieulKiyeog) return \"Hangul_J_RieulKiyeog\";\n\tif (k == XK_Hangul_J_RieulMieum) return \"Hangul_J_RieulMieum\";\n\tif (k == XK_Hangul_J_RieulPieub) return \"Hangul_J_RieulPieub\";\n\tif (k == XK_Hangul_J_RieulSios) return \"Hangul_J_RieulSios\";\n\tif (k == XK_Hangul_J_RieulTieut) return \"Hangul_J_RieulTieut\";\n\tif (k == XK_Hangul_J_RieulPhieuf) return \"Hangul_J_RieulPhieuf\";\n\tif (k == XK_Hangul_J_RieulHieuh) return \"Hangul_J_RieulHieuh\";\n\tif (k == XK_Hangul_J_Mieum) return \"Hangul_J_Mieum\";\n\tif (k == XK_Hangul_J_Pieub) return \"Hangul_J_Pieub\";\n\tif (k == XK_Hangul_J_PieubSios) return \"Hangul_J_PieubSios\";\n\tif (k == XK_Hangul_J_Sios) return \"Hangul_J_Sios\";\n\tif (k == XK_Hangul_J_SsangSios) return \"Hangul_J_SsangSios\";\n\tif (k == XK_Hangul_J_Ieung) return \"Hangul_J_Ieung\";\n\tif (k == XK_Hangul_J_Jieuj) return \"Hangul_J_Jieuj\";\n\tif (k == XK_Hangul_J_Cieuc) return \"Hangul_J_Cieuc\";\n\tif (k == XK_Hangul_J_Khieuq) return \"Hangul_J_Khieuq\";\n\tif (k == XK_Hangul_J_Tieut) return \"Hangul_J_Tieut\";\n\tif (k == XK_Hangul_J_Phieuf) return \"Hangul_J_Phieuf\";\n\tif (k == XK_Hangul_J_Hieuh) return \"Hangul_J_Hieuh\";\n\tif (k == XK_Hangul_RieulYeorinHieuh) return \"Hangul_RieulYeorinHieuh\";\n\tif (k == XK_Hangul_SunkyeongeumMieum) return \"Hangul_SunkyeongeumMieum\";\n\tif (k == XK_Hangul_SunkyeongeumPieub) return \"Hangul_SunkyeongeumPieub\";\n\tif (k == XK_Hangul_PanSios) return \"Hangul_PanSios\";\n\tif (k == XK_Hangul_KkogjiDalrinIeung) return \"Hangul_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_SunkyeongeumPhieuf) return \"Hangul_SunkyeongeumPhieuf\";\n\tif (k == XK_Hangul_YeorinHieuh) return \"Hangul_YeorinHieuh\";\n\tif (k == XK_Hangul_AraeA) return \"Hangul_AraeA\";\n\tif (k == XK_Hangul_AraeAE) return \"Hangul_AraeAE\";\n\tif (k == XK_Hangul_J_PanSios) return \"Hangul_J_PanSios\";\n\tif (k == XK_Hangul_J_KkogjiDalrinIeung) return \"Hangul_J_KkogjiDalrinIeung\";\n\tif (k == XK_Hangul_J_YeorinHieuh) return \"Hangul_J_YeorinHieuh\";\n\tif (k == XK_Korean_Won) return \"Korean_Won\";\n#endif /* XK_KOREAN */\n\tif (k == XK_EuroSign) return \"EuroSign\";\n#endif\n\treturn NULL;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "XKeycodeToKeysym_wr",
          "args": [
            "dpy",
            "i",
            "0"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "XKeycodeToKeysym_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1699-1709",
          "snippet": "KeySym XKeycodeToKeysym_wr(Display *display, KeyCode keycode, int index) {\n#if NO_X11\n\treturn 0;\n#else\n#if !HAVE_XKEYBOARD || SKIP_XKB\n\treturn XKeycodeToKeysym(display, keycode, index);\n#else\n\treturn XkbKeycodeToKeysym(display, keycode, 0, index);\n#endif\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XCloseDisplay_wr(Display *display);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XCloseDisplay_wr(Display *display);\n\nKeySym XKeycodeToKeysym_wr(Display *display, KeyCode keycode, int index) {\n#if NO_X11\n\treturn 0;\n#else\n#if !HAVE_XKEYBOARD || SKIP_XKB\n\treturn XKeycodeToKeysym(display, keycode, index);\n#else\n\treturn XkbKeycodeToKeysym(display, keycode, 0, index);\n#endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_keystate",
          "args": [
            "state"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "get_keystate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "94-120",
          "snippet": "void get_keystate(int *keystate) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!keystate) {}\n\treturn;\n#else\n\tint i, k;\n\tchar keys[32];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tXQueryKeymap(dpy, keys);\n\tfor (i=0; i<32; i++) {\n\t\tchar c = keys[i];\n\n\t\tfor (k=0; k < 8; k++) {\n\t\t\tif (c & 0x1) {\n\t\t\t\tkeystate[8*i + k] = 1;\n\t\t\t} else {\n\t\t\t\tkeystate[8*i + k] = 0;\n\t\t\t}\n\t\t\tc = c >> 1;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_keystate(int *keystate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_keystate(int *keystate);\n\nvoid get_keystate(int *keystate) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!keystate) {}\n\treturn;\n#else\n\tint i, k;\n\tchar keys[32];\n\n\tRAWFB_RET_VOID\n\t\n\t/* n.b. caller decides to X_LOCK or not. */\n\tXQueryKeymap(dpy, keys);\n\tfor (i=0; i<32; i++) {\n\t\tchar c = keys[i];\n\n\t\tfor (k=0; k < 8; k++) {\n\t\t\tif (c & 0x1) {\n\t\t\t\tkeystate[8*i + k] = 1;\n\t\t\t} else {\n\t\t\t\tkeystate[8*i + k] = 0;\n\t\t\t}\n\t\t\tc = c >> 1;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"idle keyboard:   turning X autorepeat\"\n\t\t\t\t    \" back on.\\n\""
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_initial_autorepeat_state",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "get_initial_autorepeat_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "379-384",
          "snippet": "int get_initial_autorepeat_state(void) {\n\tif (save_auto_repeat < 0) {\n\t\tsave_auto_repeat = get_autorepeat_state();\n\t}\n\treturn save_auto_repeat;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);",
            "int get_initial_autorepeat_state(void);",
            "static int save_auto_repeat = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\nint get_initial_autorepeat_state(void);\nstatic int save_auto_repeat = -1;\n\nint get_initial_autorepeat_state(void) {\n\tif (save_auto_repeat < 0) {\n\t\tsave_auto_repeat = get_autorepeat_state();\n\t}\n\treturn save_auto_repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_autorepeat_state",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "get_autorepeat_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/keyboard.c",
          "lines": "363-377",
          "snippet": "int get_autorepeat_state(void) {\n#if NO_X11\n\tRAWFB_RET(0)\n\treturn 0;\n#else\n\tXKeyboardState kstate;\n\n\tRAWFB_RET(0)\n\n\tX_LOCK;\n\tXGetKeyboardControl(dpy, &kstate);\n\tX_UNLOCK;\n\treturn kstate.global_auto_repeat;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"uinput.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"unixpw.h\"",
            "#include \"allowed_input_t.h\"",
            "#include \"cleanup.h\"",
            "#include \"rates.h\"",
            "#include \"win_utils.h\"",
            "#include \"userinput.h\"",
            "#include \"pointer.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_autorepeat_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"uinput.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"unixpw.h\"\n#include \"allowed_input_t.h\"\n#include \"cleanup.h\"\n#include \"rates.h\"\n#include \"win_utils.h\"\n#include \"userinput.h\"\n#include \"pointer.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint get_autorepeat_state(void);\n\nint get_autorepeat_state(void) {\n#if NO_X11\n\tRAWFB_RET(0)\n\treturn 0;\n#else\n\tXKeyboardState kstate;\n\n\tRAWFB_RET(0)\n\n\tX_LOCK;\n\tXGetKeyboardControl(dpy, &kstate);\n\tX_UNLOCK;\n\treturn kstate.global_auto_repeat;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_IDLE_TIMEOUT\")"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_IDLE_TIMEOUT\""
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_IDLE_TIMEOUT\""
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "wsock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1964-1970",
          "snippet": "static void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_autorepeat(void);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\n\nvoid check_autorepeat(void) {\n\tstatic time_t last_check = 0;\n\tstatic int idle_timeout = -300, idle_reset = 0;\n\ttime_t now = time(NULL);\n\tint autorepeat_is_on, autorepeat_initially_on;\n\n\tif (! no_autorepeat || ! client_count) {\n\t\treturn;\n\t}\n\tif (now <= last_check + 1) {\n\t\treturn;\n\t}\n\n\tif (unixpw_in_progress) return;\n\n\tif (idle_timeout < 0) {\n\t\tif (getenv(\"X11VNC_IDLE_TIMEOUT\")) {\n\t\t\tidle_timeout = atoi(getenv(\"X11VNC_IDLE_TIMEOUT\"));\n\t\t}\n\t\tif (idle_timeout < 0) {\n\t\t\tidle_timeout = -idle_timeout;\n\t\t}\n\t}\n\n\tlast_check = now;\n\n\tautorepeat_is_on = get_autorepeat_state();\n\tautorepeat_initially_on = get_initial_autorepeat_state();\n\n\tif (view_only) {\n\t\tif (! autorepeat_is_on) {\n\t\t\tautorepeat(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (now > last_keyboard_input + idle_timeout) {\n\t\t/* autorepeat should be on when idle */\n\t\tif (! autorepeat_is_on && autorepeat_initially_on) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"idle keyboard:   turning X autorepeat\"\n\t\t\t\t    \" back on.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(1, 1);\n\t\t\tidle_reset = 1;\n\t\t}\n\t} else {\n\t\tif (idle_reset) {\n\t\t\tint i, state[256], didmsg = 0, pressed = 0;\n\t\t\tint mwt = 600, mmax = 20;\n\t\t\tstatic int msgcnt = 0;\n\t\t\tstatic double lastmsg = 0.0;\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tstate[i] = 0;\n\t\t\t}\n\t\t\tif (use_threads) {X_LOCK;}\n\t\t\tget_keystate(state);\n\t\t\tif (use_threads) {X_UNLOCK;}\n\n\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\tif (state[i] != 0) {\n\t\t\t\t\t/* better wait until all keys are up  */\n\t\t\t\t\tpressed++;\n\t\t\t\t\tif (msgcnt < mmax || dnow() > lastmsg + mwt) {\n\t\t\t\t\t\tchar *str = \"unset\";\n#if !NO_X11\n\t\t\t\t\t\tif (use_threads) {X_LOCK;}\n\t\t\t\t\t\tstr = XKeysymToString(XKeycodeToKeysym_wr(dpy, i, 0));\n\t\t\t\t\t\tif (use_threads) {X_UNLOCK;}\n#endif\n\t\t\t\t\t\tstr = str ? str : \"nosymbol\";\n\t\t\t\t\t\tdidmsg++;\n\t\t\t\t\t\trfbLog(\"active keyboard: waiting until \"\n\t\t\t\t\t\t    \"all keys are up. key_down=%d %s.  \"\n\t\t\t\t\t\t    \"If the key is inaccessible via keyboard, \"\n\t\t\t\t\t\t    \"consider 'x11vnc -R clear_all'\\n\", i, str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (didmsg > 0) {\n\t\t\t\tmsgcnt++;\n\t\t\t\tif (msgcnt == mmax) {\n\t\t\t\t\trfbLog(\"active keyboard: last such \"\n\t\t\t\t\t    \"message for %d secs.\\n\", mwt);\n\t\t\t\t}\n\t\t\t\tlastmsg = dnow();\n\t\t\t}\n\t\t\tif (pressed > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (idle_reset) {\n\t\t\tstatic time_t last_msg = 0;\n\t\t\tstatic int cnt = 0;\n\t\t\tif (now > last_msg + idle_timeout && cnt++ < 10) {\n\t\t\t\trfbLog(\"active keyboard: turning X autorepeat\"\n\t\t\t\t    \" off.\\n\");\n\t\t\t\tlast_msg = now;\n\t\t\t}\n\t\t\tautorepeat(0, 1);\n\t\t\tidle_reset = 0;\n\n\t\t} else if (no_repeat_countdown && autorepeat_is_on) {\n\t\t\tint n = no_repeat_countdown - 1;\n\t\t\tif (n >= 0) {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!! (%d resets left)\\n\", n);\n\t\t\t} else {\n\t\t\t\trfbLog(\"Battling with something for \"\n\t\t\t\t    \"-norepeat!!\\n\");\n\t\t\t}\n\t\t\tif (no_repeat_countdown > 0) {\n\t\t\t\tno_repeat_countdown--;\n\t\t\t}\n\t\t\tautorepeat(1, 0);\n\t\t\tautorepeat(0, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_local_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "984-1064",
    "snippet": "void check_local_grab(void) {\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (grab_local <= 0) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (last_rfb_key_injected <= 0.0 && last_rfb_ptr_injected <= 0.0) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tnow = dnow();\n\n\tif (now > last_check + 0.1)   {\n#if !NO_X11\n\t\tint ret;\n\t\tdouble idle;\n\t\tXScreenSaverInfo info;\n\t\tstatic int save_viewonly = -1, local_is_idle = -1, db = -1;\n\n\t\tif (debug_keyboard) db = debug_keyboard;\n\t\tif (debug_pointer ) db = debug_pointer;\n\n\t\tif (db < 0) {\n\t\t\tif (getenv(\"LOCAL_GRAB_DEBUG\")) {\n\t\t\t\tdb = atoi(getenv(\"LOCAL_GRAB_DEBUG\"));\n\t\t\t} else {\n\t\t\t\tdb = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = XScreenSaverQueryInfo(dpy, RootWindowOfScreen(\n\t\t    ScreenOfDisplay(dpy, 0)), &info);\n\n\t\tif (ret) {\n\t\t\tdouble tlatest_rfb = 0.0;\n\n\t\t\tidle = ((double) info.idle)/1000.0;\n\t\t\tnow = dnow();\n\n\t\t\tif (last_rfb_key_injected > 0.0) {\n\t\t\t\ttlatest_rfb = last_rfb_key_injected;\n\t\t\t}\n\t\t\tif (last_rfb_ptr_injected > tlatest_rfb) {\n\t\t\t\ttlatest_rfb = last_rfb_ptr_injected;\n\t\t\t}\n\t\t\tif (db > 1) fprintf(stderr, \"idle: %.4f latest: %.4f dt: %.4f\\n\", idle, now - tlatest_rfb, idle - (now - tlatest_rfb));\n\n\t\t\tif (now - tlatest_rfb <= idle + 0.005) {\n\t\t\t\t/* 0.005 is 5ms tolerance */\n\t\t\t} else if (idle < grab_local) {\n\t\t\t\tif (local_is_idle < 0 || local_is_idle) {\n\t\t\t\t\tsave_viewonly = view_only;\n\t\t\t\t\tview_only = 1;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: set viewonly\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlocal_is_idle = 0;\n\t\t\t} else {\n\t\t\t\tif (!local_is_idle && save_viewonly >= 0) {\n\t\t\t\t\tview_only = save_viewonly;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: restored viewonly; %d\\n\", view_only);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocal_is_idle = 1;\n\t\t\t}\n\t\t}\n#endif\n\t\tlast_check = dnow();\n\t}\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int grab_local = 0;",
      "static int process_watch(char *str, int parent, int db);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_local_grab: restored viewonly; %d\\n\"",
            "view_only"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_local_grab: set viewonly\\n\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"idle: %.4f latest: %.4f dt: %.4f\\n\"",
            "idle",
            "now - tlatest_rfb",
            "idle - (now - tlatest_rfb)"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XScreenSaverQueryInfo",
          "args": [
            "dpy",
            "RootWindowOfScreen(\n\t\t    ScreenOfDisplay(dpy, 0))",
            "&info"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RootWindowOfScreen",
          "args": [
            "ScreenOfDisplay(dpy, 0)"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScreenOfDisplay",
          "args": [
            "dpy",
            "0"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"LOCAL_GRAB_DEBUG\")"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LOCAL_GRAB_DEBUG\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LOCAL_GRAB_DEBUG\""
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint grab_local = 0;\nstatic int process_watch(char *str, int parent, int db);\n\nvoid check_local_grab(void) {\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (grab_local <= 0) {\n\t\treturn;\n\t}\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tif (last_rfb_key_injected <= 0.0 && last_rfb_ptr_injected <= 0.0) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n\tnow = dnow();\n\n\tif (now > last_check + 0.1)   {\n#if !NO_X11\n\t\tint ret;\n\t\tdouble idle;\n\t\tXScreenSaverInfo info;\n\t\tstatic int save_viewonly = -1, local_is_idle = -1, db = -1;\n\n\t\tif (debug_keyboard) db = debug_keyboard;\n\t\tif (debug_pointer ) db = debug_pointer;\n\n\t\tif (db < 0) {\n\t\t\tif (getenv(\"LOCAL_GRAB_DEBUG\")) {\n\t\t\t\tdb = atoi(getenv(\"LOCAL_GRAB_DEBUG\"));\n\t\t\t} else {\n\t\t\t\tdb = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = XScreenSaverQueryInfo(dpy, RootWindowOfScreen(\n\t\t    ScreenOfDisplay(dpy, 0)), &info);\n\n\t\tif (ret) {\n\t\t\tdouble tlatest_rfb = 0.0;\n\n\t\t\tidle = ((double) info.idle)/1000.0;\n\t\t\tnow = dnow();\n\n\t\t\tif (last_rfb_key_injected > 0.0) {\n\t\t\t\ttlatest_rfb = last_rfb_key_injected;\n\t\t\t}\n\t\t\tif (last_rfb_ptr_injected > tlatest_rfb) {\n\t\t\t\ttlatest_rfb = last_rfb_ptr_injected;\n\t\t\t}\n\t\t\tif (db > 1) fprintf(stderr, \"idle: %.4f latest: %.4f dt: %.4f\\n\", idle, now - tlatest_rfb, idle - (now - tlatest_rfb));\n\n\t\t\tif (now - tlatest_rfb <= idle + 0.005) {\n\t\t\t\t/* 0.005 is 5ms tolerance */\n\t\t\t} else if (idle < grab_local) {\n\t\t\t\tif (local_is_idle < 0 || local_is_idle) {\n\t\t\t\t\tsave_viewonly = view_only;\n\t\t\t\t\tview_only = 1;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: set viewonly\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlocal_is_idle = 0;\n\t\t\t} else {\n\t\t\t\tif (!local_is_idle && save_viewonly >= 0) {\n\t\t\t\t\tview_only = save_viewonly;\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\trfbLog(\"check_local_grab: restored viewonly; %d\\n\", view_only);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlocal_is_idle = 1;\n\t\t\t}\n\t\t}\n#endif\n\t\tlast_check = dnow();\n\t}\n}"
  },
  {
    "function_name": "check_keycode_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "950-975",
    "snippet": "void check_keycode_state(void) {\n\tstatic time_t last_check = 0;\n\tint delay = 10, noinput = 3;\n\ttime_t now = time(NULL);\n\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\t/*\n\t * periodically update our model of the keycode_state[]\n\t * by correlating with the Xserver.  wait for a pause in\n\t * keyboard input to be on the safe side.  the idea here\n\t * is to remove stale keycode state, not to be perfectly\n\t * in sync with the Xserver at every instant of time.\n\t */\n\tif (now > last_check + delay && now > last_keyboard_input + noinput) {\n\t\tX_LOCK;\n\t\tinit_track_keycode_state();\n\t\tX_UNLOCK;\n\t\tlast_check = now;\n\t}\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_keycode_state(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_track_keycode_state",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "init_track_keycode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "875-881",
          "snippet": "void init_track_keycode_state(void) {\n\tint i;\n\tfor (i=0; i<256; i++) {\n\t\tkeycode_state[i] = 0;\n\t}\n\tget_keystate(keycode_state);\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int keycode_state[256];",
            "void init_track_keycode_state(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint keycode_state[256];\nvoid init_track_keycode_state(void);\n\nvoid init_track_keycode_state(void) {\n\tint i;\n\tfor (i=0; i<256; i++) {\n\t\tkeycode_state[i] = 0;\n\t}\n\tget_keystate(keycode_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "wsock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1964-1970",
          "snippet": "static void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_keycode_state(void);\n\nvoid check_keycode_state(void) {\n\tstatic time_t last_check = 0;\n\tint delay = 10, noinput = 3;\n\ttime_t now = time(NULL);\n\n\tif (! client_count) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tRAWFB_RET_VOID\n\n\t/*\n\t * periodically update our model of the keycode_state[]\n\t * by correlating with the Xserver.  wait for a pause in\n\t * keyboard input to be on the safe side.  the idea here\n\t * is to remove stale keycode state, not to be perfectly\n\t * in sync with the Xserver at every instant of time.\n\t */\n\tif (now > last_check + delay && now > last_keyboard_input + noinput) {\n\t\tX_LOCK;\n\t\tinit_track_keycode_state();\n\t\tX_UNLOCK;\n\t\tlast_check = now;\n\t}\n}"
  },
  {
    "function_name": "sync_tod_with_servertime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "875-948",
    "snippet": "void sync_tod_with_servertime(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic Atom ticker_atom = None;\n\tXEvent xev;\n\tchar diff[128];\n\tstatic int seq = 0;\n\tstatic unsigned long xserver_ticks = 1;\n\tint i, db = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (atom_NET_ACTIVE_WINDOW == None) {\n\t\tatom_NET_ACTIVE_WINDOW = XInternAtom(dpy, \"_NET_ACTIVE_WINDOW\", True);\n\t}\n\tif (atom_NET_CURRENT_DESKTOP == None) {\n\t\tatom_NET_CURRENT_DESKTOP = XInternAtom(dpy, \"_NET_CURRENT_DESKTOP\", True);\n\t}\n\tif (atom_NET_CLIENT_LIST_STACKING == None) {\n\t\tatom_NET_CLIENT_LIST_STACKING = XInternAtom(dpy, \"_NET_CLIENT_LIST_STACKING\", True);\n\t}\n\tif (atom_XROOTPMAP_ID == None) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t}\n\n\tif (! ticker_atom) {\n\t\tchar *ticker_str = \"X11VNC_TICKER\";\n\t\tif (getenv(\"X11VNC_TICKER\")) {\n\t\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t\t}\n\t\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\t}\n\tif (! ticker_atom) {\n\t\treturn;\n\t}\n\n\tXSync(dpy, False);\n\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tset_prop_atom(xev.xproperty.atom);\n\t}\n\n\tsnprintf(diff, sizeof diff, \"%d/%08d/%lu/%.6f\", (int) getpid(), seq++,\n\t    xserver_ticks, servertime_diff); \n\tXChangeProperty(dpy, rootwin, ticker_atom, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *) diff, strlen(diff));\n\tXSync(dpy, False);\n\n\tfor (i=0; i < 10; i++) {\n\t\tint k, got = 0;\n\t\t\n\t\tfor (k=0; k < 5; k++) {\n\t\t\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\t\t\tif (xev.xproperty.atom == ticker_atom) {\n\t\t\t\t\tdouble stime;\n\t\t\t\t\t\n\t\t\t\t\txserver_ticks = xev.xproperty.time;\n\t\t\t\t\tstime = (double) xev.xproperty.time;\n\t\t\t\t\tstime = stime/1000.0;\n\t\t\t\t\tservertime_diff = dnow() - stime;\n\t\t\t\t\tif (db) rfbLog(\"set servertime_diff: \"\n\t\t\t\t\t    \"%.6f\\n\", servertime_diff);\n\t\t\t\t\tgot = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (got) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(1000);\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sync_tod_with_servertime(void);",
      "void set_prop_atom(Atom atom);",
      "static int process_watch(char *str, int parent, int db);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1000"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"set servertime_diff: \"\n\t\t\t\t\t    \"%.6f\\n\"",
            "servertime_diff"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "PropertyNotify",
            "&xev"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XChangeProperty",
          "args": [
            "dpy",
            "rootwin",
            "ticker_atom",
            "XA_STRING",
            "8",
            "PropModeReplace",
            "(unsigned char *) diff",
            "strlen(diff)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "diff"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "diff",
            "sizeof diff",
            "\"%d/%08d/%lu/%.6f\"",
            "(int) getpid()",
            "seq++",
            "xserver_ticks",
            "servertime_diff"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_prop_atom",
          "args": [
            "xev.xproperty.atom"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "set_prop_atom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1191-1197",
          "snippet": "void set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_prop_atom(Atom atom);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_prop_atom(Atom atom);\n\nvoid set_prop_atom(Atom atom) {\n\tif (atom == None) return;\n\tif (atom == atom_NET_ACTIVE_WINDOW) got_NET_ACTIVE_WINDOW = dnow();\n\tif (atom == atom_NET_CURRENT_DESKTOP) got_NET_CURRENT_DESKTOP = dnow();\n\tif (atom == atom_NET_CLIENT_LIST_STACKING) got_NET_CLIENT_LIST_STACKING = dnow();\n\tif (atom == atom_XROOTPMAP_ID) got_XROOTPMAP_ID = dnow();\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "PropertyNotify",
            "&xev"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "ticker_str",
            "False"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_TICKER\""
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_TICKER\""
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_XROOTPMAP_ID\"",
            "True"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_NET_CLIENT_LIST_STACKING\"",
            "True"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_NET_CURRENT_DESKTOP\"",
            "True"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_NET_ACTIVE_WINDOW\"",
            "True"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid sync_tod_with_servertime(void);\nvoid set_prop_atom(Atom atom);\nstatic int process_watch(char *str, int parent, int db);\n\nvoid sync_tod_with_servertime(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic Atom ticker_atom = None;\n\tXEvent xev;\n\tchar diff[128];\n\tstatic int seq = 0;\n\tstatic unsigned long xserver_ticks = 1;\n\tint i, db = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (atom_NET_ACTIVE_WINDOW == None) {\n\t\tatom_NET_ACTIVE_WINDOW = XInternAtom(dpy, \"_NET_ACTIVE_WINDOW\", True);\n\t}\n\tif (atom_NET_CURRENT_DESKTOP == None) {\n\t\tatom_NET_CURRENT_DESKTOP = XInternAtom(dpy, \"_NET_CURRENT_DESKTOP\", True);\n\t}\n\tif (atom_NET_CLIENT_LIST_STACKING == None) {\n\t\tatom_NET_CLIENT_LIST_STACKING = XInternAtom(dpy, \"_NET_CLIENT_LIST_STACKING\", True);\n\t}\n\tif (atom_XROOTPMAP_ID == None) {\n\t\tatom_XROOTPMAP_ID = XInternAtom(dpy, \"_XROOTPMAP_ID\", True);\n\t}\n\n\tif (! ticker_atom) {\n\t\tchar *ticker_str = \"X11VNC_TICKER\";\n\t\tif (getenv(\"X11VNC_TICKER\")) {\n\t\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t\t}\n\t\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\t}\n\tif (! ticker_atom) {\n\t\treturn;\n\t}\n\n\tXSync(dpy, False);\n\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\tset_prop_atom(xev.xproperty.atom);\n\t}\n\n\tsnprintf(diff, sizeof diff, \"%d/%08d/%lu/%.6f\", (int) getpid(), seq++,\n\t    xserver_ticks, servertime_diff); \n\tXChangeProperty(dpy, rootwin, ticker_atom, XA_STRING, 8,\n\t    PropModeReplace, (unsigned char *) diff, strlen(diff));\n\tXSync(dpy, False);\n\n\tfor (i=0; i < 10; i++) {\n\t\tint k, got = 0;\n\t\t\n\t\tfor (k=0; k < 5; k++) {\n\t\t\twhile (XCheckTypedEvent(dpy, PropertyNotify, &xev)) {\n\t\t\t\tif (xev.xproperty.atom == ticker_atom) {\n\t\t\t\t\tdouble stime;\n\t\t\t\t\t\n\t\t\t\t\txserver_ticks = xev.xproperty.time;\n\t\t\t\t\tstime = (double) xev.xproperty.time;\n\t\t\t\t\tstime = stime/1000.0;\n\t\t\t\t\tservertime_diff = dnow() - stime;\n\t\t\t\t\tif (db) rfbLog(\"set servertime_diff: \"\n\t\t\t\t\t    \"%.6f\\n\", servertime_diff);\n\t\t\t\t\tgot = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (got) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep(1000);\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "spawn_grab_buster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "837-873",
    "snippet": "void spawn_grab_buster(void) {\n#if LIBVNCSERVER_HAVE_FORK\n\tpid_t pid;\n\tint parent = (int) getpid();\n\tchar *dstr = strdup(DisplayString(dpy));\n\n\tRAWFB_RET_VOID\n\n\tXCloseDisplay_wr(dpy); \n\tdpy = NULL;\n\n\tif ((pid = fork()) > 0) {\n\t\tgrab_buster_pid = pid;\n\t\tif (! quiet) {\n\t\t\trfbLog(\"grab_buster pid is: %d\\n\", (int) pid);\n\t\t}\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"spawn_grab_buster: could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t} else {\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\tgrab_buster_watch(parent, dstr);\n\t\texit(0);\n\t}\n\n\tdpy = XOpenDisplay_wr(dstr);\n\tif (!dpy) {\n\t\trfbLog(\"failed to reopen display %s in spawn_grab_buster\\n\",\n\t\t    dstr);\n\t\texit(1);\n\t}\n#endif\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int grab_buster = 0;",
      "void spawn_grab_buster(void);",
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
      "static void grab_buster_watch(int parent, char *dstr);",
      "static pid_t grab_buster_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"failed to reopen display %s in spawn_grab_buster\\n\"",
            "dstr"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "dstr"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_buster_watch",
          "args": [
            "parent",
            "dstr"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "grab_buster_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "757-835",
          "snippet": "static void grab_buster_watch(int parent, char *dstr) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!parent || !dstr) {}\n\treturn;\n#else\n\tAtom ticker_atom = None;\n\tint sleep = sync_tod_delay * 921 * 1000;\n\tchar propval[200];\n\tint ev, er, maj, min;\n\tint db = 0;\n\tchar *ticker_str = \"X11VNC_TICKER\";\n\n\tRAWFB_RET_VOID\n\n\tif (grab_buster > 1) {\n\t\tdb = 1;\n\t}\n\n\t/* overwrite original dpy, we let orig connection sit unused. */\n\tdpy = XOpenDisplay_wr(dstr);\n\tif (!dpy) {\n\t\tfprintf(stderr, \"grab_buster_watch: could not reopen: %s\\n\",\n\t\t    dstr);\n\t\treturn;\n\t}\n\trfbLogEnable(0);\n\n\t/* check for XTEST, etc, and then disable grabs for us */\n\tif (! XTestQueryExtension_wr(dpy, &ev, &er, &maj, &min)) {\n\t\txtest_present = 0;\n\t} else {\n\t\txtest_present = 1;\n\t}\n\tif (! XETrapQueryExtension_wr(dpy, &ev, &er, &maj)) {\n\t\txtrap_present = 0;\n\t} else {\n\t\txtrap_present = 1;\n\t}\n\n\tif (! xtest_present && ! xtrap_present) {\n\t\tfprintf(stderr, \"grab_buster_watch: no grabserver \"\n\t\t    \"protection on display: %s\\n\", dstr);\n\t\treturn;\n\t}\n\tdisable_grabserver(dpy, 0);\n\n\tusleep(3 * sleep);\n\n\tif (getenv(\"X11VNC_TICKER\")) {\n\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t}\n\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\tif (! ticker_atom) {\n\t\tfprintf(stderr, \"grab_buster_watch: no ticker atom\\n\");\n\t\treturn;\n\t}\n\n\twhile(1) {\n\t\tint slp = sleep;\n\t\tif (grab_npids > 1) {\n\t\t\tslp = slp / 8;\t\n\t\t}\n\t\tusleep(slp);\n\t\tusleep((int) (0.60 * rfac() * slp));\n\n\t\tif (kill((pid_t) parent, 0) != 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tget_prop(propval, 128, ticker_atom, None);\n\t\tif (db) fprintf(stderr, \"got_prop:   %s\\n\", propval);\n\n\t\tif (!process_watch(propval, parent, db)) {\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int grab_buster = 0;",
            "int sync_tod_delay = 20;",
            "void set_prop_atom(Atom atom);",
            "void set_server_input(rfbClientPtr cl, int s);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
            "static int process_watch(char *str, int parent, int db);",
            "static void grab_buster_watch(int parent, char *dstr);",
            "static int grab_npids = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint grab_buster = 0;\nint sync_tod_delay = 20;\nvoid set_prop_atom(Atom atom);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic int process_watch(char *str, int parent, int db);\nstatic void grab_buster_watch(int parent, char *dstr);\nstatic int grab_npids = 1;\n\nstatic void grab_buster_watch(int parent, char *dstr) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!parent || !dstr) {}\n\treturn;\n#else\n\tAtom ticker_atom = None;\n\tint sleep = sync_tod_delay * 921 * 1000;\n\tchar propval[200];\n\tint ev, er, maj, min;\n\tint db = 0;\n\tchar *ticker_str = \"X11VNC_TICKER\";\n\n\tRAWFB_RET_VOID\n\n\tif (grab_buster > 1) {\n\t\tdb = 1;\n\t}\n\n\t/* overwrite original dpy, we let orig connection sit unused. */\n\tdpy = XOpenDisplay_wr(dstr);\n\tif (!dpy) {\n\t\tfprintf(stderr, \"grab_buster_watch: could not reopen: %s\\n\",\n\t\t    dstr);\n\t\treturn;\n\t}\n\trfbLogEnable(0);\n\n\t/* check for XTEST, etc, and then disable grabs for us */\n\tif (! XTestQueryExtension_wr(dpy, &ev, &er, &maj, &min)) {\n\t\txtest_present = 0;\n\t} else {\n\t\txtest_present = 1;\n\t}\n\tif (! XETrapQueryExtension_wr(dpy, &ev, &er, &maj)) {\n\t\txtrap_present = 0;\n\t} else {\n\t\txtrap_present = 1;\n\t}\n\n\tif (! xtest_present && ! xtrap_present) {\n\t\tfprintf(stderr, \"grab_buster_watch: no grabserver \"\n\t\t    \"protection on display: %s\\n\", dstr);\n\t\treturn;\n\t}\n\tdisable_grabserver(dpy, 0);\n\n\tusleep(3 * sleep);\n\n\tif (getenv(\"X11VNC_TICKER\")) {\n\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t}\n\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\tif (! ticker_atom) {\n\t\tfprintf(stderr, \"grab_buster_watch: no ticker atom\\n\");\n\t\treturn;\n\t}\n\n\twhile(1) {\n\t\tint slp = sleep;\n\t\tif (grab_npids > 1) {\n\t\t\tslp = slp / 8;\t\n\t\t}\n\t\tusleep(slp);\n\t\tusleep((int) (0.60 * rfac() * slp));\n\n\t\tif (kill((pid_t) parent, 0) != 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tget_prop(propval, 128, ticker_atom, None);\n\t\tif (db) fprintf(stderr, \"got_prop:   %s\\n\", propval);\n\n\t\tif (!process_watch(propval, parent, db)) {\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "SIG_DFL"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "SIG_DFL"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "SIG_DFL"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "SIG_DFL"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fork\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"spawn_grab_buster: could not fork\\n\""
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"grab_buster pid is: %d\\n\"",
            "(int) pid"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "DisplayString(dpy)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DisplayString",
          "args": [
            "dpy"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint grab_buster = 0;\nvoid spawn_grab_buster(void);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void grab_buster_watch(int parent, char *dstr);\nstatic pid_t grab_buster_pid = 0;\n\nvoid spawn_grab_buster(void) {\n#if LIBVNCSERVER_HAVE_FORK\n\tpid_t pid;\n\tint parent = (int) getpid();\n\tchar *dstr = strdup(DisplayString(dpy));\n\n\tRAWFB_RET_VOID\n\n\tXCloseDisplay_wr(dpy); \n\tdpy = NULL;\n\n\tif ((pid = fork()) > 0) {\n\t\tgrab_buster_pid = pid;\n\t\tif (! quiet) {\n\t\t\trfbLog(\"grab_buster pid is: %d\\n\", (int) pid);\n\t\t}\n\t} else if (pid == -1) {\n\t\tfprintf(stderr, \"spawn_grab_buster: could not fork\\n\");\n\t\trfbLogPerror(\"fork\");\n\t} else {\n\t\tsignal(SIGHUP,  SIG_DFL);\n\t\tsignal(SIGINT,  SIG_DFL);\n\t\tsignal(SIGQUIT, SIG_DFL);\n\t\tsignal(SIGTERM, SIG_DFL);\n\n\t\tgrab_buster_watch(parent, dstr);\n\t\texit(0);\n\t}\n\n\tdpy = XOpenDisplay_wr(dstr);\n\tif (!dpy) {\n\t\trfbLog(\"failed to reopen display %s in spawn_grab_buster\\n\",\n\t\t    dstr);\n\t\texit(1);\n\t}\n#endif\n}"
  },
  {
    "function_name": "grab_buster_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "757-835",
    "snippet": "static void grab_buster_watch(int parent, char *dstr) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!parent || !dstr) {}\n\treturn;\n#else\n\tAtom ticker_atom = None;\n\tint sleep = sync_tod_delay * 921 * 1000;\n\tchar propval[200];\n\tint ev, er, maj, min;\n\tint db = 0;\n\tchar *ticker_str = \"X11VNC_TICKER\";\n\n\tRAWFB_RET_VOID\n\n\tif (grab_buster > 1) {\n\t\tdb = 1;\n\t}\n\n\t/* overwrite original dpy, we let orig connection sit unused. */\n\tdpy = XOpenDisplay_wr(dstr);\n\tif (!dpy) {\n\t\tfprintf(stderr, \"grab_buster_watch: could not reopen: %s\\n\",\n\t\t    dstr);\n\t\treturn;\n\t}\n\trfbLogEnable(0);\n\n\t/* check for XTEST, etc, and then disable grabs for us */\n\tif (! XTestQueryExtension_wr(dpy, &ev, &er, &maj, &min)) {\n\t\txtest_present = 0;\n\t} else {\n\t\txtest_present = 1;\n\t}\n\tif (! XETrapQueryExtension_wr(dpy, &ev, &er, &maj)) {\n\t\txtrap_present = 0;\n\t} else {\n\t\txtrap_present = 1;\n\t}\n\n\tif (! xtest_present && ! xtrap_present) {\n\t\tfprintf(stderr, \"grab_buster_watch: no grabserver \"\n\t\t    \"protection on display: %s\\n\", dstr);\n\t\treturn;\n\t}\n\tdisable_grabserver(dpy, 0);\n\n\tusleep(3 * sleep);\n\n\tif (getenv(\"X11VNC_TICKER\")) {\n\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t}\n\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\tif (! ticker_atom) {\n\t\tfprintf(stderr, \"grab_buster_watch: no ticker atom\\n\");\n\t\treturn;\n\t}\n\n\twhile(1) {\n\t\tint slp = sleep;\n\t\tif (grab_npids > 1) {\n\t\t\tslp = slp / 8;\t\n\t\t}\n\t\tusleep(slp);\n\t\tusleep((int) (0.60 * rfac() * slp));\n\n\t\tif (kill((pid_t) parent, 0) != 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tget_prop(propval, 128, ticker_atom, None);\n\t\tif (db) fprintf(stderr, \"got_prop:   %s\\n\", propval);\n\n\t\tif (!process_watch(propval, parent, db)) {\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int grab_buster = 0;",
      "int sync_tod_delay = 20;",
      "void set_prop_atom(Atom atom);",
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
      "static int process_watch(char *str, int parent, int db);",
      "static void grab_buster_watch(int parent, char *dstr);",
      "static int grab_npids = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_watch",
          "args": [
            "propval",
            "parent",
            "db"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "process_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "605-755",
          "snippet": "static int process_watch(char *str, int parent, int db) {\n\tint i, pid, ticker, npids;\n\tchar diff[128];\n\tunsigned long xtime;\n\tstatic grabwatch_t watches[GRABWATCH];\n\tstatic int first = 1;\n\ttime_t now = time(NULL);\n\tstatic time_t last_bust = 0;\n\tint too_long, problems = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\twatches[i].pid = 0;\n\t\t\twatches[i].tick = 0;\n\t\t\twatches[i].time = 0;\n\t\t\twatches[i].change = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* record latest value of prop */\n\tif (str && *str != '\\0') {\n\t\tif (sscanf(str, \"%d/%d/%lu/%s\", &pid, &ticker, &xtime, diff)\n\t\t    == 4) {\n\t\t\tint got = -1, free = -1;\n\n\t\t\tif (db) fprintf(stderr, \"grab_buster %d - %d - %lu - %s\"\n\t\t\t    \"\\n\", pid, ticker, xtime, diff);\n\n\t\t\tif (pid == parent && !strcmp(diff, \"QUIT\")) {\n\t\t\t\t/* that's it. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (pid == 0 || ticker == 0 || xtime == 0) {\n\t\t\t\t/* bad prop read. */\n\t\t\t\tgoto badtickerstr;\n\t\t\t}\n\t\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\t\tif (watches[i].pid == pid) {\n\t\t\t\t\tgot = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (free == -1 && watches[i].pid == 0) {\n\t\t\t\t\tfree = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (got == -1) {\n\t\t\t\tif (free == -1) {\n\t\t\t\t\t/* bad news */;\n\t\t\t\t\tfree = GRABWATCH - 1;\n\t\t\t\t}\n\t\t\t\twatches[free].pid  = pid;\n\t\t\t\twatches[free].tick = ticker;\n\t\t\t\twatches[free].time = xtime;\n\t\t\t\twatches[free].change = now;\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster free slot: %d\\n\", free);\n\t\t\t} else {\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster got  slot: %d\\n\", got);\n\t\t\t\tif (watches[got].tick != ticker) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\tif (watches[got].time != xtime) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\twatches[got].tick = ticker;\n\t\t\t\twatches[got].time = xtime;\n\t\t\t}\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"grab_buster bad prop str: %s\\n\", str);\n\t\t}\n\t}\n\n\tbadtickerstr:\n\n\ttoo_long = grab_buster_delay;\n\tif (too_long < 3 * sync_tod_delay) {\n\t\ttoo_long = 3 * sync_tod_delay;\n\t}\n\n\tnpids = 0;\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tif (watches[i].pid) {\n\t\t\tnpids++;\n\t\t}\n\t}\n\tgrab_npids = npids;\n\tif (npids > 4) {\n\t\tnpids = 4;\n\t}\n\n\t/* now check everyone we are tracking */\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tint fac = 1;\n\t\tif (!watches[i].pid) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (watches[i].change == 0) {\n\t\t\twatches[i].change = now;\t/* just to be sure */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpid = watches[i].pid;\n\n\t\tif (pid != parent) {\n\t\t\tfac = 2;\n\t\t}\n\t\tif (npids > 0) {\n\t\t\tfac *= npids;\n\t\t}\n\n\t\tif (now > watches[i].change + fac*too_long) {\n\t\t\tint process_alive = 1;\n\n\t\t\tfprintf(stderr, \"grab_buster: problem with pid: \"\n\t\t\t    \"%d - %d/%d/%d\\n\", pid, (int) now,\n\t\t\t    (int) watches[i].change, too_long);\n\n\t\t\tif (kill((pid_t) pid, 0) != 0) {\n\t\t\t\tif (1 || errno == ESRCH) {\n\t\t\t\t\tprocess_alive = 0;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!process_alive) {\n\t\t\t\twatches[i].pid = 0;\n\t\t\t\twatches[i].tick = 0;\n\t\t\t\twatches[i].time = 0;\n\t\t\t\twatches[i].change = 0;\n\t\t\t\tfprintf(stderr, \"grab_buster: pid gone: %d\\n\",\n\t\t\t\t    pid);\n\t\t\t\tif (pid == parent) {\n\t\t\t\t\t/* that's it */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint sleep = sync_tod_delay * 1000 * 1000;\n\n\t\t\t\tbust_grab(0);\n\t\t\t\tproblems++;\n\t\t\t\tlast_bust = now;\n\t\t\t\tusleep(1 * sleep);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!problems) {\n\t\tbust_grab(1);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define GRABWATCH 16"
          ],
          "globals_used": [
            "int grab_buster = 0;",
            "int sync_tod_delay = 20;",
            "void set_server_input(rfbClientPtr cl, int s);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
            "static int process_watch(char *str, int parent, int db);",
            "static int grab_buster_delay = 20;",
            "static int grab_npids = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define GRABWATCH 16\n\nint grab_buster = 0;\nint sync_tod_delay = 20;\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic int process_watch(char *str, int parent, int db);\nstatic int grab_buster_delay = 20;\nstatic int grab_npids = 1;\n\nstatic int process_watch(char *str, int parent, int db) {\n\tint i, pid, ticker, npids;\n\tchar diff[128];\n\tunsigned long xtime;\n\tstatic grabwatch_t watches[GRABWATCH];\n\tstatic int first = 1;\n\ttime_t now = time(NULL);\n\tstatic time_t last_bust = 0;\n\tint too_long, problems = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\twatches[i].pid = 0;\n\t\t\twatches[i].tick = 0;\n\t\t\twatches[i].time = 0;\n\t\t\twatches[i].change = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* record latest value of prop */\n\tif (str && *str != '\\0') {\n\t\tif (sscanf(str, \"%d/%d/%lu/%s\", &pid, &ticker, &xtime, diff)\n\t\t    == 4) {\n\t\t\tint got = -1, free = -1;\n\n\t\t\tif (db) fprintf(stderr, \"grab_buster %d - %d - %lu - %s\"\n\t\t\t    \"\\n\", pid, ticker, xtime, diff);\n\n\t\t\tif (pid == parent && !strcmp(diff, \"QUIT\")) {\n\t\t\t\t/* that's it. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (pid == 0 || ticker == 0 || xtime == 0) {\n\t\t\t\t/* bad prop read. */\n\t\t\t\tgoto badtickerstr;\n\t\t\t}\n\t\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\t\tif (watches[i].pid == pid) {\n\t\t\t\t\tgot = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (free == -1 && watches[i].pid == 0) {\n\t\t\t\t\tfree = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (got == -1) {\n\t\t\t\tif (free == -1) {\n\t\t\t\t\t/* bad news */;\n\t\t\t\t\tfree = GRABWATCH - 1;\n\t\t\t\t}\n\t\t\t\twatches[free].pid  = pid;\n\t\t\t\twatches[free].tick = ticker;\n\t\t\t\twatches[free].time = xtime;\n\t\t\t\twatches[free].change = now;\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster free slot: %d\\n\", free);\n\t\t\t} else {\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster got  slot: %d\\n\", got);\n\t\t\t\tif (watches[got].tick != ticker) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\tif (watches[got].time != xtime) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\twatches[got].tick = ticker;\n\t\t\t\twatches[got].time = xtime;\n\t\t\t}\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"grab_buster bad prop str: %s\\n\", str);\n\t\t}\n\t}\n\n\tbadtickerstr:\n\n\ttoo_long = grab_buster_delay;\n\tif (too_long < 3 * sync_tod_delay) {\n\t\ttoo_long = 3 * sync_tod_delay;\n\t}\n\n\tnpids = 0;\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tif (watches[i].pid) {\n\t\t\tnpids++;\n\t\t}\n\t}\n\tgrab_npids = npids;\n\tif (npids > 4) {\n\t\tnpids = 4;\n\t}\n\n\t/* now check everyone we are tracking */\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tint fac = 1;\n\t\tif (!watches[i].pid) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (watches[i].change == 0) {\n\t\t\twatches[i].change = now;\t/* just to be sure */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpid = watches[i].pid;\n\n\t\tif (pid != parent) {\n\t\t\tfac = 2;\n\t\t}\n\t\tif (npids > 0) {\n\t\t\tfac *= npids;\n\t\t}\n\n\t\tif (now > watches[i].change + fac*too_long) {\n\t\t\tint process_alive = 1;\n\n\t\t\tfprintf(stderr, \"grab_buster: problem with pid: \"\n\t\t\t    \"%d - %d/%d/%d\\n\", pid, (int) now,\n\t\t\t    (int) watches[i].change, too_long);\n\n\t\t\tif (kill((pid_t) pid, 0) != 0) {\n\t\t\t\tif (1 || errno == ESRCH) {\n\t\t\t\t\tprocess_alive = 0;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!process_alive) {\n\t\t\t\twatches[i].pid = 0;\n\t\t\t\twatches[i].tick = 0;\n\t\t\t\twatches[i].time = 0;\n\t\t\t\twatches[i].change = 0;\n\t\t\t\tfprintf(stderr, \"grab_buster: pid gone: %d\\n\",\n\t\t\t\t    pid);\n\t\t\t\tif (pid == parent) {\n\t\t\t\t\t/* that's it */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint sleep = sync_tod_delay * 1000 * 1000;\n\n\t\t\t\tbust_grab(0);\n\t\t\t\tproblems++;\n\t\t\t\tlast_bust = now;\n\t\t\t\tusleep(1 * sleep);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!problems) {\n\t\tbust_grab(1);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"got_prop:   %s\\n\"",
            "propval"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_prop",
          "args": [
            "propval",
            "128",
            "ticker_atom",
            "None"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "get_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "448-494",
          "snippet": "void get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_prop(char *str, int len, Atom prop, Window w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nvoid get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "(pid_t) parent",
            "0"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "(int) (0.60 * rfac() * slp)"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfac",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "rfac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "454-473",
          "snippet": "double rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double rnow(void);",
            "double rfac(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble rnow(void);\ndouble rfac(void);\n\ndouble rfac(void) {\n\tdouble f;\n\tstatic int first = 1;\n\n\tif (first) {\n\t\tunsigned int s;\n\t\tif (getenv(\"RAND_SEED\")) {\n\t\t\ts = (unsigned int) atoi(getenv(\"RAND_SEED\"));\n\t\t} else {\n\t\t\ts = (unsigned int) ((int) getpid() + 100000 * rnow());\n\t\t}\n\t\tsrand(s);\n\t\tfirst = 0;\n\t}\n\n\tf = (double) rand();\n\tf = f / ((double) RAND_MAX);\n\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "slp"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster_watch: no ticker atom\\n\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "ticker_str",
            "False"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_TICKER\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_TICKER\""
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "3 * sleep"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_grabserver",
          "args": [
            "dpy",
            "0"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "disable_grabserver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1313-1372",
          "snippet": "void disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void disable_grabserver(Display *in_dpy, int change);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid disable_grabserver(Display *in_dpy, int change);\n\nvoid disable_grabserver(Display *in_dpy, int change) {\n\tint ok = 0;\n\tstatic int didmsg = 0;\n\n\tif (debug_grabs) {\n\t\tfprintf(stderr, \"disable_grabserver/%d %.5f\\n\",\n\t\t\txserver_grabbed, dnowx());\n\t\tdidmsg = 0;\n\t}\n\n\tif (! xtrap_input) {\n\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTRAP_GrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via XTEST.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"Using DEC-XTRAP for protection\"\n\t\t\t\t\t    \" from XGrabServer.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (XTRAP_GrabControl_wr(in_dpy, True)) {\n\t\t\tif (change) {\n\t\t\t\tXTestGrabControl_wr(in_dpy, False);\n\t\t\t}\n\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\trfbLog(\"GrabServer control via DEC-XTRAP.\\n\"); \n\t\t\t\tdidmsg = 1;\n\t\t\t}\n\t\t\tok = 1;\n\t\t} else {\n\t\t\tif (XTestGrabControl_wr(in_dpy, True)) {\n\t\t\t\tok = 1;\n\t\t\t\tif (! didmsg && ! raw_fb_str) {\n\t\t\t\t\trfbLog(\"DEC-XTRAP XGrabServer \"\n\t\t\t\t\t    \"protection not available, \"\n\t\t\t\t\t    \"using XTEST.\\n\");\n\t\t\t\t\tdidmsg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (! ok && ! didmsg) {\n\t\trfbLog(\"*********************************************************\\n\");\n\t\trfbLog(\"* No XTEST or DEC-XTRAP protection from XGrabServer !!! *\\n\");\n\t\trfbLog(\"* DEADLOCK if your window manager calls XGrabServer !!! *\\n\");\n\t\trfbLog(\"*********************************************************\\n\");\n\t}\n\tXFlush_wr(in_dpy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster_watch: no grabserver \"\n\t\t    \"protection on display: %s\\n\"",
            "dstr"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XETrapQueryExtension_wr",
          "args": [
            "dpy",
            "&ev",
            "&er",
            "&maj"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "XETrapQueryExtension_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1248-1258",
          "snippet": "Bool XETrapQueryExtension_wr(Display *dpy, int *ev, int *er, int *op) {\n\tRAWFB_RET(False)\n#if HAVE_LIBXTRAP\n\treturn XETrapQueryExtension(dpy, (INT32 *)ev, (INT32 *)er,\n\t    (INT32 *)op);\n#else\n\t/* unused vars warning: */\n\tif (ev || er || op) {}\n\treturn False;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "Bool XETrapQueryExtension_wr(Display *dpy, int *ev, int *er, int *op);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nBool XETrapQueryExtension_wr(Display *dpy, int *ev, int *er, int *op);\n\nBool XETrapQueryExtension_wr(Display *dpy, int *ev, int *er, int *op) {\n\tRAWFB_RET(False)\n#if HAVE_LIBXTRAP\n\treturn XETrapQueryExtension(dpy, (INT32 *)ev, (INT32 *)er,\n\t    (INT32 *)op);\n#else\n\t/* unused vars warning: */\n\tif (ev || er || op) {}\n\treturn False;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTestQueryExtension_wr",
          "args": [
            "dpy",
            "&ev",
            "&er",
            "&maj",
            "&min"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "XTestQueryExtension_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1225-1234",
          "snippet": "Bool XTestQueryExtension_wr(Display *dpy, int *ev, int *er, int *maj,\n    int *min) {\n\tRAWFB_RET(False)\n#if HAVE_XTEST\n\treturn XTestQueryExtension(dpy, ev, er, maj, min);\n#else\n\tif (!dpy || !ev || !er || !maj || !min) {}\n\treturn False;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestQueryExtension_wr(Display *dpy, int *ev, int *er, int *maj,\n    int *min);",
            "void XTestDiscard_wr(Display *dpy);",
            "Bool XRecordQueryVersion_wr(Display *dpy, int *maj, int *min);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestQueryExtension_wr(Display *dpy, int *ev, int *er, int *maj,\n    int *min);\nvoid XTestDiscard_wr(Display *dpy);\nBool XRecordQueryVersion_wr(Display *dpy, int *maj, int *min);\n\nBool XTestQueryExtension_wr(Display *dpy, int *ev, int *er, int *maj,\n    int *min) {\n\tRAWFB_RET(False)\n#if HAVE_XTEST\n\treturn XTestQueryExtension(dpy, ev, er, maj, min);\n#else\n\tif (!dpy || !ev || !er || !maj || !min) {}\n\treturn False;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogEnable",
          "args": [
            "0"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster_watch: could not reopen: %s\\n\"",
            "dstr"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XOpenDisplay_wr",
          "args": [
            "dstr"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "XOpenDisplay_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1461-1502",
          "snippet": "Display *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Display *XOpenDisplay_wr(char *display_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nDisplay *XOpenDisplay_wr(char *display_name);\n\nDisplay *XOpenDisplay_wr(char *display_name) {\n\tDisplay *d = NULL;\n\tint db = 0;\n\n\tif (! xauth_raw(1)) {\n\t\treturn NULL;\n\t}\n#if NO_X11\n\trfbLog(\"This x11vnc was built without X11 support (-rawfb only).\\n\");\n\tif (!display_name || !d || !db) {}\n\treturn NULL;\n#else\n\n\td = XOpenDisplay(display_name);\n\tif (db) fprintf(stderr, \"XOpenDisplay_wr: %s  %p\\n\", display_name, (void *)d);\n\n\tif (d == NULL && !getenv(\"NO_XAUTHLOCALHOSTNAME\")) {\n\t\tchar *xalhn = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\tif (1 || !xalhn) {\n\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t    display_name ? display_name : \"\");\n\t\t\trfbLog(\"Trying again with XAUTHLOCALHOSTNAME=localhost ...\\n\");\n\t\t\tset_env(\"XAUTHLOCALHOSTNAME\", \"localhost\");\n\t\t\td = XOpenDisplay(display_name);\n\t\t\tif (d == NULL && xalhn) {\n\t\t\t\tchar *ptr = getenv(\"XAUTHLOCALHOSTNAME\");\n\t\t\t\tif (ptr) {\n\t\t\t\t\t*(ptr-2) = '_';\t/* yow */\n\t\t\t\t\trfbLog(\"XOpenDisplay(\\\"%s\\\") failed.\\n\",\n\t\t\t\t\t    display_name ? display_name : \"\");\n\t\t\t\t\trfbLog(\"Trying again with unset XAUTHLOCALHOSTNAME ...\\n\");\n\t\t\t\t\td = XOpenDisplay(display_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\txauth_raw(0);\n\n\treturn d;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint grab_buster = 0;\nint sync_tod_delay = 20;\nvoid set_prop_atom(Atom atom);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic int process_watch(char *str, int parent, int db);\nstatic void grab_buster_watch(int parent, char *dstr);\nstatic int grab_npids = 1;\n\nstatic void grab_buster_watch(int parent, char *dstr) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!parent || !dstr) {}\n\treturn;\n#else\n\tAtom ticker_atom = None;\n\tint sleep = sync_tod_delay * 921 * 1000;\n\tchar propval[200];\n\tint ev, er, maj, min;\n\tint db = 0;\n\tchar *ticker_str = \"X11VNC_TICKER\";\n\n\tRAWFB_RET_VOID\n\n\tif (grab_buster > 1) {\n\t\tdb = 1;\n\t}\n\n\t/* overwrite original dpy, we let orig connection sit unused. */\n\tdpy = XOpenDisplay_wr(dstr);\n\tif (!dpy) {\n\t\tfprintf(stderr, \"grab_buster_watch: could not reopen: %s\\n\",\n\t\t    dstr);\n\t\treturn;\n\t}\n\trfbLogEnable(0);\n\n\t/* check for XTEST, etc, and then disable grabs for us */\n\tif (! XTestQueryExtension_wr(dpy, &ev, &er, &maj, &min)) {\n\t\txtest_present = 0;\n\t} else {\n\t\txtest_present = 1;\n\t}\n\tif (! XETrapQueryExtension_wr(dpy, &ev, &er, &maj)) {\n\t\txtrap_present = 0;\n\t} else {\n\t\txtrap_present = 1;\n\t}\n\n\tif (! xtest_present && ! xtrap_present) {\n\t\tfprintf(stderr, \"grab_buster_watch: no grabserver \"\n\t\t    \"protection on display: %s\\n\", dstr);\n\t\treturn;\n\t}\n\tdisable_grabserver(dpy, 0);\n\n\tusleep(3 * sleep);\n\n\tif (getenv(\"X11VNC_TICKER\")) {\n\t\tticker_str = getenv(\"X11VNC_TICKER\");\n\t}\n\tticker_atom = XInternAtom(dpy, ticker_str, False);\n\tif (! ticker_atom) {\n\t\tfprintf(stderr, \"grab_buster_watch: no ticker atom\\n\");\n\t\treturn;\n\t}\n\n\twhile(1) {\n\t\tint slp = sleep;\n\t\tif (grab_npids > 1) {\n\t\t\tslp = slp / 8;\t\n\t\t}\n\t\tusleep(slp);\n\t\tusleep((int) (0.60 * rfac() * slp));\n\n\t\tif (kill((pid_t) parent, 0) != 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tget_prop(propval, 128, ticker_atom, None);\n\t\tif (db) fprintf(stderr, \"got_prop:   %s\\n\", propval);\n\n\t\tif (!process_watch(propval, parent, db)) {\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "process_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "605-755",
    "snippet": "static int process_watch(char *str, int parent, int db) {\n\tint i, pid, ticker, npids;\n\tchar diff[128];\n\tunsigned long xtime;\n\tstatic grabwatch_t watches[GRABWATCH];\n\tstatic int first = 1;\n\ttime_t now = time(NULL);\n\tstatic time_t last_bust = 0;\n\tint too_long, problems = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\twatches[i].pid = 0;\n\t\t\twatches[i].tick = 0;\n\t\t\twatches[i].time = 0;\n\t\t\twatches[i].change = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* record latest value of prop */\n\tif (str && *str != '\\0') {\n\t\tif (sscanf(str, \"%d/%d/%lu/%s\", &pid, &ticker, &xtime, diff)\n\t\t    == 4) {\n\t\t\tint got = -1, free = -1;\n\n\t\t\tif (db) fprintf(stderr, \"grab_buster %d - %d - %lu - %s\"\n\t\t\t    \"\\n\", pid, ticker, xtime, diff);\n\n\t\t\tif (pid == parent && !strcmp(diff, \"QUIT\")) {\n\t\t\t\t/* that's it. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (pid == 0 || ticker == 0 || xtime == 0) {\n\t\t\t\t/* bad prop read. */\n\t\t\t\tgoto badtickerstr;\n\t\t\t}\n\t\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\t\tif (watches[i].pid == pid) {\n\t\t\t\t\tgot = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (free == -1 && watches[i].pid == 0) {\n\t\t\t\t\tfree = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (got == -1) {\n\t\t\t\tif (free == -1) {\n\t\t\t\t\t/* bad news */;\n\t\t\t\t\tfree = GRABWATCH - 1;\n\t\t\t\t}\n\t\t\t\twatches[free].pid  = pid;\n\t\t\t\twatches[free].tick = ticker;\n\t\t\t\twatches[free].time = xtime;\n\t\t\t\twatches[free].change = now;\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster free slot: %d\\n\", free);\n\t\t\t} else {\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster got  slot: %d\\n\", got);\n\t\t\t\tif (watches[got].tick != ticker) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\tif (watches[got].time != xtime) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\twatches[got].tick = ticker;\n\t\t\t\twatches[got].time = xtime;\n\t\t\t}\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"grab_buster bad prop str: %s\\n\", str);\n\t\t}\n\t}\n\n\tbadtickerstr:\n\n\ttoo_long = grab_buster_delay;\n\tif (too_long < 3 * sync_tod_delay) {\n\t\ttoo_long = 3 * sync_tod_delay;\n\t}\n\n\tnpids = 0;\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tif (watches[i].pid) {\n\t\t\tnpids++;\n\t\t}\n\t}\n\tgrab_npids = npids;\n\tif (npids > 4) {\n\t\tnpids = 4;\n\t}\n\n\t/* now check everyone we are tracking */\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tint fac = 1;\n\t\tif (!watches[i].pid) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (watches[i].change == 0) {\n\t\t\twatches[i].change = now;\t/* just to be sure */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpid = watches[i].pid;\n\n\t\tif (pid != parent) {\n\t\t\tfac = 2;\n\t\t}\n\t\tif (npids > 0) {\n\t\t\tfac *= npids;\n\t\t}\n\n\t\tif (now > watches[i].change + fac*too_long) {\n\t\t\tint process_alive = 1;\n\n\t\t\tfprintf(stderr, \"grab_buster: problem with pid: \"\n\t\t\t    \"%d - %d/%d/%d\\n\", pid, (int) now,\n\t\t\t    (int) watches[i].change, too_long);\n\n\t\t\tif (kill((pid_t) pid, 0) != 0) {\n\t\t\t\tif (1 || errno == ESRCH) {\n\t\t\t\t\tprocess_alive = 0;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!process_alive) {\n\t\t\t\twatches[i].pid = 0;\n\t\t\t\twatches[i].tick = 0;\n\t\t\t\twatches[i].time = 0;\n\t\t\t\twatches[i].change = 0;\n\t\t\t\tfprintf(stderr, \"grab_buster: pid gone: %d\\n\",\n\t\t\t\t    pid);\n\t\t\t\tif (pid == parent) {\n\t\t\t\t\t/* that's it */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint sleep = sync_tod_delay * 1000 * 1000;\n\n\t\t\t\tbust_grab(0);\n\t\t\t\tproblems++;\n\t\t\t\tlast_bust = now;\n\t\t\t\tusleep(1 * sleep);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!problems) {\n\t\tbust_grab(1);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define GRABWATCH 16"
    ],
    "globals_used": [
      "int grab_buster = 0;",
      "int sync_tod_delay = 20;",
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
      "static int process_watch(char *str, int parent, int db);",
      "static int grab_buster_delay = 20;",
      "static int grab_npids = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bust_grab",
          "args": [
            "1"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "bust_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "496-590",
          "snippet": "static void bust_grab(int reset) {\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int bust_count = 0;\n\tstatic time_t last_bust = 0;\n\ttime_t now = time(NULL);\n\tKeyCode key;\n\tint button, x, y, nb;\n\n\tif (now > last_bust + 180) {\n\t\tbust_count = 0;\n\t}\n\tif (reset) {\n\t\tbust_count = 0;\n\t\treturn;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tbutton = 0;\n\tkey = NoSymbol;\n\n\tnb = 8;\n\tif (bust_count >= 3 * nb)  {\n\t\tfprintf(stderr, \"too many bust_grab's %d for me\\n\", bust_count);\n\t\texit(0);\n\t}\n\tif (bust_count % nb == 0) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 1) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 2) {\n\t\tkey = XKeysymToKeycode(dpy, XK_Escape);\n\t} else if (bust_count % nb == 3) {\n\t\tbutton = 3;\n\t} else if (bust_count % nb == 4) {\n\t\tkey = XKeysymToKeycode(dpy, XK_space);\n\t} else if (bust_count % nb == 5) {\n\t\tx = bust_count * 23;\n\t\ty = bust_count * 17;\n\t} else if (bust_count % nb == 5) {\n\t\tbutton = 2;\n\t} else if (bust_count % nb == 6) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t}\n\n\tif (key == NoSymbol) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t\tif (key == NoSymbol) {\n\t\t\tbutton = 1;\n\t\t}\n\t}\n\n\tbust_count++;\n\n\tif (button) {\n\t\t/* try button press+release */\n\t\tfprintf(stderr, \"**bust_grab: button%d  %.4f\\n\",\n\t\t    button, dnowx());\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else if (x > 0) {\n\t\t/* try button motion*/\n\t\tint scr = DefaultScreen(dpy);\n\n\t\tfprintf(stderr, \"**bust_grab: x=%d y=%d  %.4f\\n\", x, y,\n\t\t    dnowx());\n\t\tXTestFakeMotionEvent_wr(dpy, -1, scr, x, y, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\n\t\t/* followed by button press */\n\t\tbutton = 1;\n\t\tfprintf(stderr, \"**bust_grab: button%d\\n\", button);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else {\n\t\t/* try Escape or Space press+release */\n\t\tfprintf(stderr, \"**bust_grab: keycode: %d  %.4f\\n\",\n\t\t    (int) key, dnowx());\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t}\n\tXFlush_wr(dpy);\n\tlast_bust = time(NULL);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void check_xevents(int reset);",
            "void set_single_window(rfbClientPtr cl, int x, int y);",
            "void set_server_input(rfbClientPtr cl, int s);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
            "static void initialize_xevents(int reset);",
            "static void bust_grab(int reset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_xevents(int reset);\nvoid set_single_window(rfbClientPtr cl, int x, int y);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void bust_grab(int reset);\n\nstatic void bust_grab(int reset) {\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int bust_count = 0;\n\tstatic time_t last_bust = 0;\n\ttime_t now = time(NULL);\n\tKeyCode key;\n\tint button, x, y, nb;\n\n\tif (now > last_bust + 180) {\n\t\tbust_count = 0;\n\t}\n\tif (reset) {\n\t\tbust_count = 0;\n\t\treturn;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tbutton = 0;\n\tkey = NoSymbol;\n\n\tnb = 8;\n\tif (bust_count >= 3 * nb)  {\n\t\tfprintf(stderr, \"too many bust_grab's %d for me\\n\", bust_count);\n\t\texit(0);\n\t}\n\tif (bust_count % nb == 0) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 1) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 2) {\n\t\tkey = XKeysymToKeycode(dpy, XK_Escape);\n\t} else if (bust_count % nb == 3) {\n\t\tbutton = 3;\n\t} else if (bust_count % nb == 4) {\n\t\tkey = XKeysymToKeycode(dpy, XK_space);\n\t} else if (bust_count % nb == 5) {\n\t\tx = bust_count * 23;\n\t\ty = bust_count * 17;\n\t} else if (bust_count % nb == 5) {\n\t\tbutton = 2;\n\t} else if (bust_count % nb == 6) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t}\n\n\tif (key == NoSymbol) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t\tif (key == NoSymbol) {\n\t\t\tbutton = 1;\n\t\t}\n\t}\n\n\tbust_count++;\n\n\tif (button) {\n\t\t/* try button press+release */\n\t\tfprintf(stderr, \"**bust_grab: button%d  %.4f\\n\",\n\t\t    button, dnowx());\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else if (x > 0) {\n\t\t/* try button motion*/\n\t\tint scr = DefaultScreen(dpy);\n\n\t\tfprintf(stderr, \"**bust_grab: x=%d y=%d  %.4f\\n\", x, y,\n\t\t    dnowx());\n\t\tXTestFakeMotionEvent_wr(dpy, -1, scr, x, y, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\n\t\t/* followed by button press */\n\t\tbutton = 1;\n\t\tfprintf(stderr, \"**bust_grab: button%d\\n\", button);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else {\n\t\t/* try Escape or Space press+release */\n\t\tfprintf(stderr, \"**bust_grab: keycode: %d  %.4f\\n\",\n\t\t    (int) key, dnowx());\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t}\n\tXFlush_wr(dpy);\n\tlast_bust = time(NULL);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "1 * sleep"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster: pid gone: %d\\n\"",
            "pid"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "(pid_t) pid",
            "0"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster: problem with pid: \"\n\t\t\t    \"%d - %d/%d/%d\\n\"",
            "pid",
            "(int) now",
            "(int) watches[i].change",
            "too_long"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster bad prop str: %s\\n\"",
            "str"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster got  slot: %d\\n\"",
            "got"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster free slot: %d\\n\"",
            "free"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "diff",
            "\"QUIT\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"grab_buster %d - %d - %lu - %s\"\n\t\t\t    \"\\n\"",
            "pid",
            "ticker",
            "xtime",
            "diff"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str",
            "\"%d/%d/%lu/%s\"",
            "&pid",
            "&ticker",
            "&xtime",
            "diff"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "wsock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1964-1970",
          "snippet": "static void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define GRABWATCH 16\n\nint grab_buster = 0;\nint sync_tod_delay = 20;\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic int process_watch(char *str, int parent, int db);\nstatic int grab_buster_delay = 20;\nstatic int grab_npids = 1;\n\nstatic int process_watch(char *str, int parent, int db) {\n\tint i, pid, ticker, npids;\n\tchar diff[128];\n\tunsigned long xtime;\n\tstatic grabwatch_t watches[GRABWATCH];\n\tstatic int first = 1;\n\ttime_t now = time(NULL);\n\tstatic time_t last_bust = 0;\n\tint too_long, problems = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\twatches[i].pid = 0;\n\t\t\twatches[i].tick = 0;\n\t\t\twatches[i].time = 0;\n\t\t\twatches[i].change = 0;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\t/* record latest value of prop */\n\tif (str && *str != '\\0') {\n\t\tif (sscanf(str, \"%d/%d/%lu/%s\", &pid, &ticker, &xtime, diff)\n\t\t    == 4) {\n\t\t\tint got = -1, free = -1;\n\n\t\t\tif (db) fprintf(stderr, \"grab_buster %d - %d - %lu - %s\"\n\t\t\t    \"\\n\", pid, ticker, xtime, diff);\n\n\t\t\tif (pid == parent && !strcmp(diff, \"QUIT\")) {\n\t\t\t\t/* that's it. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (pid == 0 || ticker == 0 || xtime == 0) {\n\t\t\t\t/* bad prop read. */\n\t\t\t\tgoto badtickerstr;\n\t\t\t}\n\t\t\tfor (i=0; i < GRABWATCH; i++) {\n\t\t\t\tif (watches[i].pid == pid) {\n\t\t\t\t\tgot = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (free == -1 && watches[i].pid == 0) {\n\t\t\t\t\tfree = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (got == -1) {\n\t\t\t\tif (free == -1) {\n\t\t\t\t\t/* bad news */;\n\t\t\t\t\tfree = GRABWATCH - 1;\n\t\t\t\t}\n\t\t\t\twatches[free].pid  = pid;\n\t\t\t\twatches[free].tick = ticker;\n\t\t\t\twatches[free].time = xtime;\n\t\t\t\twatches[free].change = now;\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster free slot: %d\\n\", free);\n\t\t\t} else {\n\t\t\t\tif (db) fprintf(stderr, \"grab_buster got  slot: %d\\n\", got);\n\t\t\t\tif (watches[got].tick != ticker) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\tif (watches[got].time != xtime) {\n\t\t\t\t\twatches[got].change = now;\n\t\t\t\t}\n\t\t\t\twatches[got].tick = ticker;\n\t\t\t\twatches[got].time = xtime;\n\t\t\t}\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"grab_buster bad prop str: %s\\n\", str);\n\t\t}\n\t}\n\n\tbadtickerstr:\n\n\ttoo_long = grab_buster_delay;\n\tif (too_long < 3 * sync_tod_delay) {\n\t\ttoo_long = 3 * sync_tod_delay;\n\t}\n\n\tnpids = 0;\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tif (watches[i].pid) {\n\t\t\tnpids++;\n\t\t}\n\t}\n\tgrab_npids = npids;\n\tif (npids > 4) {\n\t\tnpids = 4;\n\t}\n\n\t/* now check everyone we are tracking */\n\tfor (i=0; i < GRABWATCH; i++) {\n\t\tint fac = 1;\n\t\tif (!watches[i].pid) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (watches[i].change == 0) {\n\t\t\twatches[i].change = now;\t/* just to be sure */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpid = watches[i].pid;\n\n\t\tif (pid != parent) {\n\t\t\tfac = 2;\n\t\t}\n\t\tif (npids > 0) {\n\t\t\tfac *= npids;\n\t\t}\n\n\t\tif (now > watches[i].change + fac*too_long) {\n\t\t\tint process_alive = 1;\n\n\t\t\tfprintf(stderr, \"grab_buster: problem with pid: \"\n\t\t\t    \"%d - %d/%d/%d\\n\", pid, (int) now,\n\t\t\t    (int) watches[i].change, too_long);\n\n\t\t\tif (kill((pid_t) pid, 0) != 0) {\n\t\t\t\tif (1 || errno == ESRCH) {\n\t\t\t\t\tprocess_alive = 0;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!process_alive) {\n\t\t\t\twatches[i].pid = 0;\n\t\t\t\twatches[i].tick = 0;\n\t\t\t\twatches[i].time = 0;\n\t\t\t\twatches[i].change = 0;\n\t\t\t\tfprintf(stderr, \"grab_buster: pid gone: %d\\n\",\n\t\t\t\t    pid);\n\t\t\t\tif (pid == parent) {\n\t\t\t\t\t/* that's it */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint sleep = sync_tod_delay * 1000 * 1000;\n\n\t\t\t\tbust_grab(0);\n\t\t\t\tproblems++;\n\t\t\t\tlast_bust = now;\n\t\t\t\tusleep(1 * sleep);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!problems) {\n\t\tbust_grab(1);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "bust_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "496-590",
    "snippet": "static void bust_grab(int reset) {\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int bust_count = 0;\n\tstatic time_t last_bust = 0;\n\ttime_t now = time(NULL);\n\tKeyCode key;\n\tint button, x, y, nb;\n\n\tif (now > last_bust + 180) {\n\t\tbust_count = 0;\n\t}\n\tif (reset) {\n\t\tbust_count = 0;\n\t\treturn;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tbutton = 0;\n\tkey = NoSymbol;\n\n\tnb = 8;\n\tif (bust_count >= 3 * nb)  {\n\t\tfprintf(stderr, \"too many bust_grab's %d for me\\n\", bust_count);\n\t\texit(0);\n\t}\n\tif (bust_count % nb == 0) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 1) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 2) {\n\t\tkey = XKeysymToKeycode(dpy, XK_Escape);\n\t} else if (bust_count % nb == 3) {\n\t\tbutton = 3;\n\t} else if (bust_count % nb == 4) {\n\t\tkey = XKeysymToKeycode(dpy, XK_space);\n\t} else if (bust_count % nb == 5) {\n\t\tx = bust_count * 23;\n\t\ty = bust_count * 17;\n\t} else if (bust_count % nb == 5) {\n\t\tbutton = 2;\n\t} else if (bust_count % nb == 6) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t}\n\n\tif (key == NoSymbol) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t\tif (key == NoSymbol) {\n\t\t\tbutton = 1;\n\t\t}\n\t}\n\n\tbust_count++;\n\n\tif (button) {\n\t\t/* try button press+release */\n\t\tfprintf(stderr, \"**bust_grab: button%d  %.4f\\n\",\n\t\t    button, dnowx());\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else if (x > 0) {\n\t\t/* try button motion*/\n\t\tint scr = DefaultScreen(dpy);\n\n\t\tfprintf(stderr, \"**bust_grab: x=%d y=%d  %.4f\\n\", x, y,\n\t\t    dnowx());\n\t\tXTestFakeMotionEvent_wr(dpy, -1, scr, x, y, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\n\t\t/* followed by button press */\n\t\tbutton = 1;\n\t\tfprintf(stderr, \"**bust_grab: button%d\\n\", button);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else {\n\t\t/* try Escape or Space press+release */\n\t\tfprintf(stderr, \"**bust_grab: keycode: %d  %.4f\\n\",\n\t\t    (int) key, dnowx());\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t}\n\tXFlush_wr(dpy);\n\tlast_bust = time(NULL);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_xevents(int reset);",
      "void set_single_window(rfbClientPtr cl, int x, int y);",
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
      "static void initialize_xevents(int reset);",
      "static void bust_grab(int reset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "wsock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1964-1970",
          "snippet": "static void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTestFakeKeyEvent_wr",
          "args": [
            "dpy",
            "-1",
            "key",
            "False",
            "CurrentTime"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "XTestFakeKeyEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "933-1017",
          "snippet": "void XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay) {\n\tstatic int first = 1;\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !key || !down || !delay || !first) {}\n\treturn;\n#else\n\tif (debug_keyboard) {\n\t\tchar *str = XKeysymToString(XKeycodeToKeysym_wr(dpy, key, 0));\n\t\trfbLog(\"XTestFakeKeyEvent(dpy, keycode=0x%x \\\"%s\\\", %s)\\n\",\n\t\t    key, str ? str : \"null\", down ? \"down\":\"up\");\n\t}\n\tif (first) { \n\t\tinit_track_keycode_state();\n\t\tfirst = 0;\n\t}\n\tif (down) {\n\t\tlast_keyboard_keycode = -key;\n\t} else {\n\t\tlast_keyboard_keycode = key;\n\t}\n\n\tif (grab_kbd) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_ptr && ungrab_both) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeKeyEvent_wr(dpy, key, down, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"keyboard: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_keyboard) {\n\t\trfbLog(\"calling XTestFakeKeyEvent(%d, %d)  %.4f\\n\",\n\t\t    key, down, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n\tXDevice xdev;\n        xdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n\tXTestFakeDeviceKeyEvent(dpy, &xdev, key, down, NULL, 0, delay);        \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeKeyEvent(dpy, key, down, delay);\n\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n\tif (debug_keyboard) {\n\t\tupup_downdown_warning(key, down);\n\t}\n\tkeycode_state[(int) key] = down ? 1 : 0;\n#endif\n\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xtest_present = 0;",
            "int keycode_state[256];",
            "void init_track_keycode_state(void);",
            "void XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestDiscard_wr(Display *dpy);",
            "static void upup_downdown_warning(KeyCode key, Bool down);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint xtest_present = 0;\nint keycode_state[256];\nvoid init_track_keycode_state(void);\nvoid XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestDiscard_wr(Display *dpy);\nstatic void upup_downdown_warning(KeyCode key, Bool down);\n\nvoid XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay) {\n\tstatic int first = 1;\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !key || !down || !delay || !first) {}\n\treturn;\n#else\n\tif (debug_keyboard) {\n\t\tchar *str = XKeysymToString(XKeycodeToKeysym_wr(dpy, key, 0));\n\t\trfbLog(\"XTestFakeKeyEvent(dpy, keycode=0x%x \\\"%s\\\", %s)\\n\",\n\t\t    key, str ? str : \"null\", down ? \"down\":\"up\");\n\t}\n\tif (first) { \n\t\tinit_track_keycode_state();\n\t\tfirst = 0;\n\t}\n\tif (down) {\n\t\tlast_keyboard_keycode = -key;\n\t} else {\n\t\tlast_keyboard_keycode = key;\n\t}\n\n\tif (grab_kbd) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_ptr && ungrab_both) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeKeyEvent_wr(dpy, key, down, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"keyboard: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_keyboard) {\n\t\trfbLog(\"calling XTestFakeKeyEvent(%d, %d)  %.4f\\n\",\n\t\t    key, down, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n\tXDevice xdev;\n        xdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n\tXTestFakeDeviceKeyEvent(dpy, &xdev, key, down, NULL, 0, delay);        \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeKeyEvent(dpy, key, down, delay);\n\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n\tif (debug_keyboard) {\n\t\tupup_downdown_warning(key, down);\n\t}\n\tkeycode_state[(int) key] = down ? 1 : 0;\n#endif\n\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"**bust_grab: keycode: %d  %.4f\\n\"",
            "(int) key",
            "dnowx()"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnowx",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTestFakeButtonEvent_wr",
          "args": [
            "dpy",
            "-1",
            "button",
            "False",
            "CurrentTime"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "XTestFakeButtonEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1046-1108",
          "snippet": "void XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay) {\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !button || !is_press || !delay) {}\n\treturn;\n#else\n\n\tif (grab_ptr) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_kbd && ungrab_both) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeButtonEvent_wr(dpy, button, is_press, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"button: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_pointer) {\n\t\trfbLog(\"calling XTestFakeButtonEvent(%d, %d)  %.4f\\n\",\n\t\t    button, is_press, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n        XDevice xdev;\n\txdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n        XTestFakeDeviceButtonEvent(dpy, &xdev, button, is_press, NULL, 0, delay);\t  \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeButtonEvent(dpy, button, is_press, delay);\n#endif\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xtest_present = 0;",
            "void XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint xtest_present = 0;\nvoid XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestDiscard_wr(Display *dpy);\n\nvoid XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay) {\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !button || !is_press || !delay) {}\n\treturn;\n#else\n\n\tif (grab_ptr) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_kbd && ungrab_both) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeButtonEvent_wr(dpy, button, is_press, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (! xtest_present) {\n\t\tDEBUG_SKIPPED_INPUT(debug_keyboard, \"button: no-XTEST\");\n\t\treturn;\n\t}\n\tif (debug_pointer) {\n\t\trfbLog(\"calling XTestFakeButtonEvent(%d, %d)  %.4f\\n\",\n\t\t    button, is_press, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n        XDevice xdev;\n\txdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n        XTestFakeDeviceButtonEvent(dpy, &xdev, button, is_press, NULL, 0, delay);\t  \n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n        XTestFakeButtonEvent(dpy, button, is_press, delay);\n#endif\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"**bust_grab: button%d\\n\"",
            "button"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTestFakeMotionEvent_wr",
          "args": [
            "dpy",
            "-1",
            "scr",
            "x",
            "y",
            "CurrentTime"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "XTestFakeMotionEvent_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1137-1196",
          "snippet": "void XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay) {\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !screen || !x || !y || !delay) {}\n\treturn;\n#else\n\n\tif (grab_ptr) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_kbd && ungrab_both) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeMotionEvent_wr(dpy, screen, x, y, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (debug_pointer) {\n\t\trfbLog(\"calling XTestFakeMotionEvent(%d, %d)  %.4f\\n\",\n\t\t    x, y, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n        int axes[] = {x, y};\n\tXDevice xdev;\n\txdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n        XTestFakeDeviceMotionEvent(dpy, &xdev, 0, 0, axes, 2, delay);\n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n          XTestFakeMotionEvent(dpy, screen, x, y, delay);\n#endif\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);",
            "void XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);",
            "void XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);",
            "void XTestDiscard_wr(Display *dpy);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTRAP_FakeKeyEvent_wr(Display* dpy, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTestFakeKeyEvent_wr(Display* dpy, int dev_id, KeyCode key, Bool down,\n    unsigned long delay);\nvoid XTRAP_FakeButtonEvent_wr(Display* dpy, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTestFakeButtonEvent_wr(Display* dpy, int dev_id, unsigned int button, Bool is_press,\n    unsigned long delay);\nvoid XTRAP_FakeMotionEvent_wr(Display* dpy, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay);\nvoid XTestDiscard_wr(Display *dpy);\n\nvoid XTestFakeMotionEvent_wr(Display* dpy, int dev_id, int screen, int x, int y,\n    unsigned long delay) {\n\tint regrab = 0;\n\n\tRAWFB_RET_VOID\n#if NO_X11\n\tnox11_exit(1);\n\tif (!dpy || !screen || !x || !y || !delay) {}\n\treturn;\n#else\n\n\tif (grab_ptr) {\n\t\tXUngrabPointer(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\tif (grab_kbd && ungrab_both) {\n\t\tXUngrabKeyboard(dpy, CurrentTime);\n\t\tregrab = 1;\n\t}\n\n\tif (xtrap_input) {\n\t\tXTRAP_FakeMotionEvent_wr(dpy, screen, x, y, delay);\n\t\tif (regrab) {\n\t\t\tadjust_grabs(1, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (debug_pointer) {\n\t\trfbLog(\"calling XTestFakeMotionEvent(%d, %d)  %.4f\\n\",\n\t\t    x, y, dnowx());\t\n\t}\n#if HAVE_XTEST\n#ifdef HAVE_XI2\n    if(use_multipointer && dev_id >= 0)\n      {\n        XErrorHandler old_handler;\n        int axes[] = {x, y};\n\tXDevice xdev;\n\txdev.device_id = dev_id;\n\n        /* there can be a race condition where this is called when the XI2 device has not yet been created */\n        old_handler = XSetErrorHandler(trap_xerror);\n        trapped_xerror = 0;\n\n        XTestFakeDeviceMotionEvent(dpy, &xdev, 0, 0, axes, 2, delay);\n\n        XSetErrorHandler(old_handler);\n        if (trapped_xerror) \n          trapped_xerror = 0;\n      }\n    else\n#endif\n          XTestFakeMotionEvent(dpy, screen, x, y, delay);\n#endif\n\tif (regrab) {\n\t\tadjust_grabs(1, 1);\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"**bust_grab: x=%d y=%d  %.4f\\n\"",
            "x",
            "y",
            "dnowx()"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultScreen",
          "args": [
            "dpy"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"**bust_grab: button%d  %.4f\\n\"",
            "button",
            "dnowx()"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XKeysymToKeycode",
          "args": [
            "dpy",
            "XK_a"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "XKeysymToKeycode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2814-2817",
          "snippet": "KeyCode XKeysymToKeycode(Display *display, KeySym keysym) {\n\tif (!display || !keysym) {}\n\treturn NoSymbol;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "KeyCode XKeysymToKeycode(Display *display, KeySym keysym) {\n\tif (!display || !keysym) {}\n\treturn NoSymbol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"too many bust_grab's %d for me\\n\"",
            "bust_count"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid check_xevents(int reset);\nvoid set_single_window(rfbClientPtr cl, int x, int y);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void bust_grab(int reset);\n\nstatic void bust_grab(int reset) {\n#if NO_X11\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int bust_count = 0;\n\tstatic time_t last_bust = 0;\n\ttime_t now = time(NULL);\n\tKeyCode key;\n\tint button, x, y, nb;\n\n\tif (now > last_bust + 180) {\n\t\tbust_count = 0;\n\t}\n\tif (reset) {\n\t\tbust_count = 0;\n\t\treturn;\n\t}\n\n\tx = 0;\n\ty = 0;\n\tbutton = 0;\n\tkey = NoSymbol;\n\n\tnb = 8;\n\tif (bust_count >= 3 * nb)  {\n\t\tfprintf(stderr, \"too many bust_grab's %d for me\\n\", bust_count);\n\t\texit(0);\n\t}\n\tif (bust_count % nb == 0) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 1) {\n\t\tbutton = 1;\n\t} else if (bust_count % nb == 2) {\n\t\tkey = XKeysymToKeycode(dpy, XK_Escape);\n\t} else if (bust_count % nb == 3) {\n\t\tbutton = 3;\n\t} else if (bust_count % nb == 4) {\n\t\tkey = XKeysymToKeycode(dpy, XK_space);\n\t} else if (bust_count % nb == 5) {\n\t\tx = bust_count * 23;\n\t\ty = bust_count * 17;\n\t} else if (bust_count % nb == 5) {\n\t\tbutton = 2;\n\t} else if (bust_count % nb == 6) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t}\n\n\tif (key == NoSymbol) {\n\t\tkey = XKeysymToKeycode(dpy, XK_a);\n\t\tif (key == NoSymbol) {\n\t\t\tbutton = 1;\n\t\t}\n\t}\n\n\tbust_count++;\n\n\tif (button) {\n\t\t/* try button press+release */\n\t\tfprintf(stderr, \"**bust_grab: button%d  %.4f\\n\",\n\t\t    button, dnowx());\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else if (x > 0) {\n\t\t/* try button motion*/\n\t\tint scr = DefaultScreen(dpy);\n\n\t\tfprintf(stderr, \"**bust_grab: x=%d y=%d  %.4f\\n\", x, y,\n\t\t    dnowx());\n\t\tXTestFakeMotionEvent_wr(dpy, -1, scr, x, y, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\n\t\t/* followed by button press */\n\t\tbutton = 1;\n\t\tfprintf(stderr, \"**bust_grab: button%d\\n\", button);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeButtonEvent_wr(dpy, -1, button, False, CurrentTime);\n\t} else {\n\t\t/* try Escape or Space press+release */\n\t\tfprintf(stderr, \"**bust_grab: keycode: %d  %.4f\\n\",\n\t\t    (int) key, dnowx());\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, True, CurrentTime);\n\t\tXFlush_wr(dpy);\n\t\tusleep(50 * 1000);\n\t\tXTestFakeKeyEvent_wr(dpy, -1, key, False, CurrentTime);\n\t}\n\tXFlush_wr(dpy);\n\tlast_bust = time(NULL);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "get_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "448-494",
    "snippet": "void get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void get_prop(char *str, int len, Atom prop, Window w);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "data"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "str+slen",
            "data",
            "dlen"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XGetWindowProperty",
          "args": [
            "dpy",
            "w",
            "prop",
            "nitems/4",
            "len/16",
            "False",
            "AnyPropertyType",
            "&type",
            "&format",
            "&nitems",
            "&bytes_after",
            "&data"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nvoid get_prop(char *str, int len, Atom prop, Window w) {\n\tint i;\n#if !NO_X11\n\tAtom type;\n\tint format, slen, dlen;\n\tunsigned long nitems = 0, bytes_after = 0;\n\tunsigned char* data = NULL;\n#endif\n\n\tfor (i=0; i<len; i++) {\n\t\tstr[i] = '\\0';\n\t}\n\tif (prop == None) {\n\t\treturn;\n\t}\n\n\tRAWFB_RET_VOID\n\n#if NO_X11\n\treturn;\n#else\n\n\tslen = 0;\n\tif (w == None) {\n\t\tw = DefaultRootWindow(dpy);\n\t}\n\n\tdo {\n\t\tif (XGetWindowProperty(dpy, w,\n\t\t    prop, nitems/4, len/16, False,\n\t\t    AnyPropertyType, &type, &format, &nitems, &bytes_after,\n\t\t    &data) == Success) {\n\n\t\t\tdlen = nitems * (format/8);\n\t\t\tif (slen + dlen > len) {\n\t\t\t\t/* too big */\n\t\t\t\tXFree_wr(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(str+slen, data, dlen);\n\t\t\tslen += dlen;\n\t\t\tstr[slen] = '\\0';\n\t\t\tXFree_wr(data);\n\t\t}\n\t} while (bytes_after > 0);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "print_xevent_bases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "436-446",
    "snippet": "static void print_xevent_bases(void) {\n\tfprintf(stderr, \"X event bases: xkb=%d, xtest=%d, xrandr=%d, \"\n\t    \"xfixes=%d, xdamage=%d, xtrap=%d\\n\", xkb_base_event_type,\n\t    xtest_base_event_type, xrandr_base_event_type,\n\t    xfixes_base_event_type, xdamage_base_event_type,\n\t    xtrap_base_event_type);\n\tfprintf(stderr, \"  MapNotify=%d, ClientMsg=%d PropNotify=%d \"\n\t    \"SelNotify=%d, SelRequest=%d\\n\", MappingNotify, ClientMessage,\n\t    PropertyNotify, SelectionNotify, SelectionRequest);\n\tfprintf(stderr, \"  SelClear=%d, Expose=%d\\n\", SelectionClear, Expose);\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void print_xevent_bases(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  SelClear=%d, Expose=%d\\n\"",
            "SelectionClear",
            "Expose"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  MapNotify=%d, ClientMsg=%d PropNotify=%d \"\n\t    \"SelNotify=%d, SelRequest=%d\\n\"",
            "MappingNotify",
            "ClientMessage",
            "PropertyNotify",
            "SelectionNotify",
            "SelectionRequest"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"X event bases: xkb=%d, xtest=%d, xrandr=%d, \"\n\t    \"xfixes=%d, xdamage=%d, xtrap=%d\\n\"",
            "xkb_base_event_type",
            "xtest_base_event_type",
            "xrandr_base_event_type",
            "xfixes_base_event_type",
            "xdamage_base_event_type",
            "xtrap_base_event_type"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic void print_xevent_bases(void);\n\nstatic void print_xevent_bases(void) {\n\tfprintf(stderr, \"X event bases: xkb=%d, xtest=%d, xrandr=%d, \"\n\t    \"xfixes=%d, xdamage=%d, xtrap=%d\\n\", xkb_base_event_type,\n\t    xtest_base_event_type, xrandr_base_event_type,\n\t    xfixes_base_event_type, xdamage_base_event_type,\n\t    xtrap_base_event_type);\n\tfprintf(stderr, \"  MapNotify=%d, ClientMsg=%d PropNotify=%d \"\n\t    \"SelNotify=%d, SelRequest=%d\\n\", MappingNotify, ClientMessage,\n\t    PropertyNotify, SelectionNotify, SelectionRequest);\n\tfprintf(stderr, \"  SelClear=%d, Expose=%d\\n\", SelectionClear, Expose);\n}"
  },
  {
    "function_name": "initialize_xevents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "337-434",
    "snippet": "static void initialize_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int did_xselect_input = 0;\n\tstatic int did_xcreate_simple_window = 0;\n\tstatic int did_vnc_connect_prop = 0;\n\tstatic int did_x11vnc_remote_prop = 0;\n\tstatic int did_clipboard_atom = 0;\n\tstatic int did_xfixes = 0;\n\tstatic int did_xdamage = 0;\n\tstatic int did_xrandr = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (reset) {\n\t\tdid_xselect_input = 0;\n\t\tdid_xcreate_simple_window = 0;\n\t\tdid_vnc_connect_prop = 0;\n\t\tdid_x11vnc_remote_prop = 0;\n\t\tdid_clipboard_atom = 0;\n\t\tdid_xfixes = 0;\n\t\tdid_xdamage = 0;\n\t\tdid_xrandr = 0;\n\t}\n\n\tif ((watch_selection || vnc_connect) && !did_xselect_input) {\n\t\t/*\n\t\t * register desired event(s) for notification.\n\t\t * PropertyChangeMask is for CUT_BUFFER0 changes.\n\t\t * XXX: does this cause a flood of other stuff?\n\t\t */\n\t\tX_LOCK;\n\t\txselectinput_rootwin |= PropertyChangeMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\tXSelectInput_wr(dpy, subwin, VisibilityChangeMask);\n\t\t}\n\t\tX_UNLOCK;\n\t\tdid_xselect_input = 1;\n\t}\n\tif (watch_selection && !did_xcreate_simple_window) {\n\t\t/* create fake window for our selection ownership, etc */\n\n\t\t/*\n\t\t * We try to delay creating selwin until we are past\n\t\t * any GDM, (or other KillInitClients=true) manager.\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tX_LOCK;\n\t\t\tselwin = XCreateSimpleWindow(dpy, rootwin, 3, 2, 1, 1, 0, 0, 0);\n\t\t\tX_UNLOCK;\n\t\t\tdid_xcreate_simple_window = 1;\n\t\t\tif (! quiet) rfbLog(\"created selwin: 0x%lx\\n\", selwin);\n\t\t}\n\t}\n\n\tif ((xrandr || xrandr_maybe) && !did_xrandr) {\n\t\tinitialize_xrandr();\n\t\tdid_xrandr = 1;\n\t}\n\tif (vnc_connect && !did_vnc_connect_prop) {\n\t\tinitialize_vnc_connect_prop();\n\t\tdid_vnc_connect_prop = 1;\n\t}\n\tif (vnc_connect && !did_x11vnc_remote_prop) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tdid_x11vnc_remote_prop = 1;\n\t}\n\tif (run_gui_pid > 0) {\n\t\tkill(run_gui_pid, SIGUSR1);\n\t\trun_gui_pid = 0;\n\t}\n\tif (!did_clipboard_atom) {\n\t\tinitialize_clipboard_atom();\n\t\tdid_clipboard_atom = 1;\n\t}\n\tif (xfixes_present && use_xfixes && !did_xfixes) {\n\t\t/*\n\t\t * We try to delay creating initializing xfixes until\n\t\t * we are past the display manager, due to Xorg bug:\n\t\t * http://bugs.freedesktop.org/show_bug.cgi?id=18451\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tinitialize_xfixes();\n\t\t\tdid_xfixes = 1;\n\t\t\tif (! quiet) rfbLog(\"called initialize_xfixes()\\n\");\n\t\t}\n\t}\n\tif (xdamage_present && !did_xdamage) {\n\t\tinitialize_xdamage();\n\t\tdid_xdamage = 1;\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_vnc_connect_prop(void);",
      "void initialize_x11vnc_remote_prop(void);",
      "void initialize_clipboard_atom(void);",
      "void check_xevents(int reset);",
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);",
      "static void initialize_xevents(int reset);",
      "static void bust_grab(int reset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "initialize_xdamage",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "736-768",
          "snippet": "void initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int use_xdamage = XDAMAGE;",
            "int xdamage_present = 0;",
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
            "int collect_xdamage(int scancnt, int call);",
            "void initialize_xdamage(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nvoid initialize_xdamage(void);\n\nvoid initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"called initialize_xfixes()\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initialize_xfixes",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xfixes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cursor.c",
          "lines": "992-1006",
          "snippet": "void initialize_xfixes(void) {\n#if HAVE_LIBXFIXES\n\tif (xfixes_present) {\n\t\tX_LOCK;\n\t\tif (use_xfixes) {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin,\n\t\t\t\tXFixesDisplayCursorNotifyMask);\n\t\t} else {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n\t\txfixes_first_initialized = 1;\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xfixes_present = 0;",
            "int xfixes_first_initialized = 0;",
            "int use_xfixes = 1;",
            "void initialize_xfixes(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xfixes_present = 0;\nint xfixes_first_initialized = 0;\nint use_xfixes = 1;\nvoid initialize_xfixes(void);\n\nvoid initialize_xfixes(void) {\n#if HAVE_LIBXFIXES\n\tif (xfixes_present) {\n\t\tX_LOCK;\n\t\tif (use_xfixes) {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin,\n\t\t\t\tXFixesDisplayCursorNotifyMask);\n\t\t} else {\n\t\t\tXFixesSelectCursorInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n\t\txfixes_first_initialized = 1;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "guess_dm_gone",
          "args": [
            "8",
            "45"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "guess_dm_gone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "286-335",
          "snippet": "int guess_dm_gone(int t1, int t2) {\n\tint wait = t2;\n\tchar *avoid = getenv(\"X11VNC_AVOID_WINDOWS\");\n\ttime_t tcheck = last_client;\n\n\tif (last_open_xdisplay > last_client) {\n\t\t/* better time for -display WAIT:... */\n\t\ttcheck = last_open_xdisplay;\n\t}\n\n\tif (avoid && !strcmp(avoid, \"never\")) {\n\t\treturn 1;\n\t}\n\tif (!screen || !screen->clientHead) {\n\t\treturn 0;\n\t}\n\tif (avoid) {\n\t\tint n = atoi(avoid);\n\t\tif (n > 1) {\n\t\t\twait = n;\n\t\t} else {\n\t\t\twait = 90;\n\t\t}\n\t} else {\n\t\tstatic time_t saw_wm = 0;\n\n\t\twait = t2;\n\n\t\tX_LOCK;\n\t\tif (wm_running()) {\n\t\t\tif (saw_wm == 0) {\n\t\t\t\tsaw_wm = time(NULL);\n\t\t\t} else if (time(NULL) <= saw_wm + 2) {\n\t\t\t\t/* try to wait a few seconds after transition */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\twait = t1;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\tif (getenv(\"DEBUG_WM_RUNNING\")) {\n\t\trfbLog(\"guess_dm_gone: wait=%d\\n\", wait);\n\t}\n\t/* we assume they've logged in OK after wait seconds... */\n\tif (time(NULL) <= tcheck + wait)  {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int guess_dm_gone(int t1, int t2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint guess_dm_gone(int t1, int t2);\n\nint guess_dm_gone(int t1, int t2) {\n\tint wait = t2;\n\tchar *avoid = getenv(\"X11VNC_AVOID_WINDOWS\");\n\ttime_t tcheck = last_client;\n\n\tif (last_open_xdisplay > last_client) {\n\t\t/* better time for -display WAIT:... */\n\t\ttcheck = last_open_xdisplay;\n\t}\n\n\tif (avoid && !strcmp(avoid, \"never\")) {\n\t\treturn 1;\n\t}\n\tif (!screen || !screen->clientHead) {\n\t\treturn 0;\n\t}\n\tif (avoid) {\n\t\tint n = atoi(avoid);\n\t\tif (n > 1) {\n\t\t\twait = n;\n\t\t} else {\n\t\t\twait = 90;\n\t\t}\n\t} else {\n\t\tstatic time_t saw_wm = 0;\n\n\t\twait = t2;\n\n\t\tX_LOCK;\n\t\tif (wm_running()) {\n\t\t\tif (saw_wm == 0) {\n\t\t\t\tsaw_wm = time(NULL);\n\t\t\t} else if (time(NULL) <= saw_wm + 2) {\n\t\t\t\t/* try to wait a few seconds after transition */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\twait = t1;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\tif (getenv(\"DEBUG_WM_RUNNING\")) {\n\t\trfbLog(\"guess_dm_gone: wait=%d\\n\", wait);\n\t}\n\t/* we assume they've logged in OK after wait seconds... */\n\tif (time(NULL) <= tcheck + wait)  {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_clipboard_atom",
          "args": [],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_clipboard_atom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "117-133",
          "snippet": "void initialize_clipboard_atom(void) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\treturn;\n#else\n\tclipboard_atom = XInternAtom(dpy, \"CLIPBOARD\", False);\n\tif (clipboard_atom == None) {\n\t\tif (! quiet) rfbLog(\"could not find atom CLIPBOARD\\n\");\n\t\tif (watch_clipboard) {\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (set_clipboard) {\n\t\t\tset_clipboard = 0;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_clipboard_atom(void);",
            "void set_prop_atom(Atom atom);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_clipboard_atom(void);\nvoid set_prop_atom(Atom atom);\n\nvoid initialize_clipboard_atom(void) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\treturn;\n#else\n\tclipboard_atom = XInternAtom(dpy, \"CLIPBOARD\", False);\n\tif (clipboard_atom == None) {\n\t\tif (! quiet) rfbLog(\"could not find atom CLIPBOARD\\n\");\n\t\tif (watch_clipboard) {\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (set_clipboard) {\n\t\t\tset_clipboard = 0;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "run_gui_pid",
            "SIGUSR1"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_x11vnc_remote_prop",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_x11vnc_remote_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "104-115",
          "snippet": "void initialize_x11vnc_remote_prop(void) {\n\tchar *prop_str;\n\tx11vnc_remote_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"X11VNC_REMOTE\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"X11VNC_REMOTE\";\n\t}\n\tx11vnc_remote_prop = XInternAtom(dpy, prop_str, False);\n#endif\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_x11vnc_remote_prop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_x11vnc_remote_prop(void);\n\nvoid initialize_x11vnc_remote_prop(void) {\n\tchar *prop_str;\n\tx11vnc_remote_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"X11VNC_REMOTE\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"X11VNC_REMOTE\";\n\t}\n\tx11vnc_remote_prop = XInternAtom(dpy, prop_str, False);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_vnc_connect_prop",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_vnc_connect_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "91-102",
          "snippet": "void initialize_vnc_connect_prop(void) {\n\tchar *prop_str;\n\tvnc_connect_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"VNC_CONNECT\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"VNC_CONNECT\";\n\t}\n\tvnc_connect_prop = XInternAtom(dpy, \"VNC_CONNECT\", False);\n#endif\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void initialize_vnc_connect_prop(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_vnc_connect_prop(void);\n\nvoid initialize_vnc_connect_prop(void) {\n\tchar *prop_str;\n\tvnc_connect_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"VNC_CONNECT\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"VNC_CONNECT\";\n\t}\n\tvnc_connect_prop = XInternAtom(dpy, \"VNC_CONNECT\", False);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_xrandr",
          "args": [],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "initialize_xrandr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xrandr.c",
          "lines": "61-84",
          "snippet": "void initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"screen.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xrandr_present = 0;",
            "int xrandr_width  = -1;",
            "int xrandr_height = -1;",
            "int xrandr_rotation = -1;",
            "void initialize_xrandr(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"screen.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nint xrandr_present = 0;\nint xrandr_width  = -1;\nint xrandr_height = -1;\nint xrandr_rotation = -1;\nvoid initialize_xrandr(void);\n\nvoid initialize_xrandr(void) {\n\tif (xrandr_present && dpy) {\n#if HAVE_LIBXRANDR\n\t\tRotation rot;\n\n\t\tX_LOCK;\n\t\txrandr_width  = XDisplayWidth(dpy, scr);\n\t\txrandr_height = XDisplayHeight(dpy, scr);\n\t\tXRRRotations(dpy, scr, &rot);\n\t\txrandr_rotation = (int) rot;\n\t\tif (xrandr || xrandr_maybe) {\n\t\t\tXRRSelectInput(dpy, rootwin, RRScreenChangeNotifyMask);\n\t\t} else {\n\t\t\tXRRSelectInput(dpy, rootwin, 0);\n\t\t}\n\t\tX_UNLOCK;\n#endif\n\t} else if (xrandr) {\n\t\trfbLog(\"-xrandr mode specified, but no RANDR support on\\n\");\n\t\trfbLog(\" display or in client library. Disabling -xrandr \"\n\t\t    \"mode.\\n\");\n\t\txrandr = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"created selwin: 0x%lx\\n\"",
            "selwin"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCreateSimpleWindow",
          "args": [
            "dpy",
            "rootwin",
            "3",
            "2",
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSelectInput_wr",
          "args": [
            "dpy",
            "subwin",
            "VisibilityChangeMask"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "XSelectInput_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1678-1697",
          "snippet": "int XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "int XSelectInput_wr(Display *display, Window w, long event_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nint XSelectInput_wr(Display *display, Window w, long event_mask);\n\nint XSelectInput_wr(Display *display, Window w, long event_mask) {\n#if NO_X11\n\tif (!display || !w || !event_mask) {}\n\treturn 0;\n#else\n\tint rc;\n\tXErrorHandler old_handler;\n\tif (display == NULL || w == None) {\n\t\treturn 0;\n\t}\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\trc = XSelectInput(display, w, event_mask);\n\tXSetErrorHandler(old_handler);\n\tif (trapped_xerror) {\n\t\trc = 0;\n\t}\n\treturn rc;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_vnc_connect_prop(void);\nvoid initialize_x11vnc_remote_prop(void);\nvoid initialize_clipboard_atom(void);\nvoid check_xevents(int reset);\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\nstatic void initialize_xevents(int reset);\nstatic void bust_grab(int reset);\n\nstatic void initialize_xevents(int reset) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\tif (!reset) {}\n\treturn;\n#else\n\tstatic int did_xselect_input = 0;\n\tstatic int did_xcreate_simple_window = 0;\n\tstatic int did_vnc_connect_prop = 0;\n\tstatic int did_x11vnc_remote_prop = 0;\n\tstatic int did_clipboard_atom = 0;\n\tstatic int did_xfixes = 0;\n\tstatic int did_xdamage = 0;\n\tstatic int did_xrandr = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (reset) {\n\t\tdid_xselect_input = 0;\n\t\tdid_xcreate_simple_window = 0;\n\t\tdid_vnc_connect_prop = 0;\n\t\tdid_x11vnc_remote_prop = 0;\n\t\tdid_clipboard_atom = 0;\n\t\tdid_xfixes = 0;\n\t\tdid_xdamage = 0;\n\t\tdid_xrandr = 0;\n\t}\n\n\tif ((watch_selection || vnc_connect) && !did_xselect_input) {\n\t\t/*\n\t\t * register desired event(s) for notification.\n\t\t * PropertyChangeMask is for CUT_BUFFER0 changes.\n\t\t * XXX: does this cause a flood of other stuff?\n\t\t */\n\t\tX_LOCK;\n\t\txselectinput_rootwin |= PropertyChangeMask;\n\t\tXSelectInput_wr(dpy, rootwin, xselectinput_rootwin);\n\n\t\tif (subwin && freeze_when_obscured) {\n\t\t\tXSelectInput_wr(dpy, subwin, VisibilityChangeMask);\n\t\t}\n\t\tX_UNLOCK;\n\t\tdid_xselect_input = 1;\n\t}\n\tif (watch_selection && !did_xcreate_simple_window) {\n\t\t/* create fake window for our selection ownership, etc */\n\n\t\t/*\n\t\t * We try to delay creating selwin until we are past\n\t\t * any GDM, (or other KillInitClients=true) manager.\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tX_LOCK;\n\t\t\tselwin = XCreateSimpleWindow(dpy, rootwin, 3, 2, 1, 1, 0, 0, 0);\n\t\t\tX_UNLOCK;\n\t\t\tdid_xcreate_simple_window = 1;\n\t\t\tif (! quiet) rfbLog(\"created selwin: 0x%lx\\n\", selwin);\n\t\t}\n\t}\n\n\tif ((xrandr || xrandr_maybe) && !did_xrandr) {\n\t\tinitialize_xrandr();\n\t\tdid_xrandr = 1;\n\t}\n\tif (vnc_connect && !did_vnc_connect_prop) {\n\t\tinitialize_vnc_connect_prop();\n\t\tdid_vnc_connect_prop = 1;\n\t}\n\tif (vnc_connect && !did_x11vnc_remote_prop) {\n\t\tinitialize_x11vnc_remote_prop();\n\t\tdid_x11vnc_remote_prop = 1;\n\t}\n\tif (run_gui_pid > 0) {\n\t\tkill(run_gui_pid, SIGUSR1);\n\t\trun_gui_pid = 0;\n\t}\n\tif (!did_clipboard_atom) {\n\t\tinitialize_clipboard_atom();\n\t\tdid_clipboard_atom = 1;\n\t}\n\tif (xfixes_present && use_xfixes && !did_xfixes) {\n\t\t/*\n\t\t * We try to delay creating initializing xfixes until\n\t\t * we are past the display manager, due to Xorg bug:\n\t\t * http://bugs.freedesktop.org/show_bug.cgi?id=18451\n\t\t */\n\t\tif (guess_dm_gone(8, 45)) {\n\t\t\tinitialize_xfixes();\n\t\t\tdid_xfixes = 1;\n\t\t\tif (! quiet) rfbLog(\"called initialize_xfixes()\\n\");\n\t\t}\n\t}\n\tif (xdamage_present && !did_xdamage) {\n\t\tinitialize_xdamage();\n\t\tdid_xdamage = 1;\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "guess_dm_gone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "286-335",
    "snippet": "int guess_dm_gone(int t1, int t2) {\n\tint wait = t2;\n\tchar *avoid = getenv(\"X11VNC_AVOID_WINDOWS\");\n\ttime_t tcheck = last_client;\n\n\tif (last_open_xdisplay > last_client) {\n\t\t/* better time for -display WAIT:... */\n\t\ttcheck = last_open_xdisplay;\n\t}\n\n\tif (avoid && !strcmp(avoid, \"never\")) {\n\t\treturn 1;\n\t}\n\tif (!screen || !screen->clientHead) {\n\t\treturn 0;\n\t}\n\tif (avoid) {\n\t\tint n = atoi(avoid);\n\t\tif (n > 1) {\n\t\t\twait = n;\n\t\t} else {\n\t\t\twait = 90;\n\t\t}\n\t} else {\n\t\tstatic time_t saw_wm = 0;\n\n\t\twait = t2;\n\n\t\tX_LOCK;\n\t\tif (wm_running()) {\n\t\t\tif (saw_wm == 0) {\n\t\t\t\tsaw_wm = time(NULL);\n\t\t\t} else if (time(NULL) <= saw_wm + 2) {\n\t\t\t\t/* try to wait a few seconds after transition */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\twait = t1;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\tif (getenv(\"DEBUG_WM_RUNNING\")) {\n\t\trfbLog(\"guess_dm_gone: wait=%d\\n\", wait);\n\t}\n\t/* we assume they've logged in OK after wait seconds... */\n\tif (time(NULL) <= tcheck + wait)  {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int guess_dm_gone(int t1, int t2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "wsock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "1964-1970",
          "snippet": "static void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nstatic int wsock_timeout_sock = -1;\n\nstatic void wsock_timeout (int sig) {\n\trfbLog(\"sig: %d, wsock_timeout.\\n\", sig);\n\tif (wsock_timeout_sock >= 0) {\n\t\tclose(wsock_timeout_sock);\n\t\twsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"guess_dm_gone: wait=%d\\n\"",
            "wait"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_WM_RUNNING\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wm_running",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "wm_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "241-284",
          "snippet": "static int wm_running(void) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tint ret = 0;\n\tRAWFB_RET(0)\n#if NO_X11\n\treturn 0;\n#else\n\t/*\n\t * Unfortunately with recent GDM (v2.28), they run gnome-session,\n\t * dbus-launch, and metacity for the Login greeter!  So the simple\n\t * XInternAtom checks below no longer work.\n         * We also see a similar thing with KDE.\n\t */\n\tif (dm_still_running()) {\n\t\treturn 0;\n\t}\n\n\t/* we are xlocked. */\n\tif (XInternAtom(dpy, \"_NET_SUPPORTED\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_NET_SUPPORTED).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_WIN_PROTOCOLS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_WIN_PROTOCOLS).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_XROOTPMAP_ID\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_XROOTPMAP_ID).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_MIT_PRIORITY_COLORS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_MIT_PRIORITY_COLORS).\\n\");\n\t\tret++;\n\t}\n\tif (!ret) {\n\t\tif (s) rfbLog(\"wm is not running.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tif (s) rfbLog(\"wm is running ret=%d.\\n\", ret);\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n\t\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_server_input(rfbClientPtr cl, int s);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\n\nstatic int wm_running(void) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tint ret = 0;\n\tRAWFB_RET(0)\n#if NO_X11\n\treturn 0;\n#else\n\t/*\n\t * Unfortunately with recent GDM (v2.28), they run gnome-session,\n\t * dbus-launch, and metacity for the Login greeter!  So the simple\n\t * XInternAtom checks below no longer work.\n         * We also see a similar thing with KDE.\n\t */\n\tif (dm_still_running()) {\n\t\treturn 0;\n\t}\n\n\t/* we are xlocked. */\n\tif (XInternAtom(dpy, \"_NET_SUPPORTED\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_NET_SUPPORTED).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_WIN_PROTOCOLS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_WIN_PROTOCOLS).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_XROOTPMAP_ID\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_XROOTPMAP_ID).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_MIT_PRIORITY_COLORS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_MIT_PRIORITY_COLORS).\\n\");\n\t\tret++;\n\t}\n\tif (!ret) {\n\t\tif (s) rfbLog(\"wm is not running.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tif (s) rfbLog(\"wm is running ret=%d.\\n\", ret);\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "avoid"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "avoid",
            "\"never\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_AVOID_WINDOWS\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint guess_dm_gone(int t1, int t2);\n\nint guess_dm_gone(int t1, int t2) {\n\tint wait = t2;\n\tchar *avoid = getenv(\"X11VNC_AVOID_WINDOWS\");\n\ttime_t tcheck = last_client;\n\n\tif (last_open_xdisplay > last_client) {\n\t\t/* better time for -display WAIT:... */\n\t\ttcheck = last_open_xdisplay;\n\t}\n\n\tif (avoid && !strcmp(avoid, \"never\")) {\n\t\treturn 1;\n\t}\n\tif (!screen || !screen->clientHead) {\n\t\treturn 0;\n\t}\n\tif (avoid) {\n\t\tint n = atoi(avoid);\n\t\tif (n > 1) {\n\t\t\twait = n;\n\t\t} else {\n\t\t\twait = 90;\n\t\t}\n\t} else {\n\t\tstatic time_t saw_wm = 0;\n\n\t\twait = t2;\n\n\t\tX_LOCK;\n\t\tif (wm_running()) {\n\t\t\tif (saw_wm == 0) {\n\t\t\t\tsaw_wm = time(NULL);\n\t\t\t} else if (time(NULL) <= saw_wm + 2) {\n\t\t\t\t/* try to wait a few seconds after transition */\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\twait = t1;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\tif (getenv(\"DEBUG_WM_RUNNING\")) {\n\t\trfbLog(\"guess_dm_gone: wait=%d\\n\", wait);\n\t}\n\t/* we assume they've logged in OK after wait seconds... */\n\tif (time(NULL) <= tcheck + wait)  {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "wm_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "241-284",
    "snippet": "static int wm_running(void) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tint ret = 0;\n\tRAWFB_RET(0)\n#if NO_X11\n\treturn 0;\n#else\n\t/*\n\t * Unfortunately with recent GDM (v2.28), they run gnome-session,\n\t * dbus-launch, and metacity for the Login greeter!  So the simple\n\t * XInternAtom checks below no longer work.\n         * We also see a similar thing with KDE.\n\t */\n\tif (dm_still_running()) {\n\t\treturn 0;\n\t}\n\n\t/* we are xlocked. */\n\tif (XInternAtom(dpy, \"_NET_SUPPORTED\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_NET_SUPPORTED).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_WIN_PROTOCOLS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_WIN_PROTOCOLS).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_XROOTPMAP_ID\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_XROOTPMAP_ID).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_MIT_PRIORITY_COLORS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_MIT_PRIORITY_COLORS).\\n\");\n\t\tret++;\n\t}\n\tif (!ret) {\n\t\tif (s) rfbLog(\"wm is not running.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tif (s) rfbLog(\"wm is running ret=%d.\\n\", ret);\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n\t\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wm is running ret=%d.\\n\"",
            "ret"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wm is not running.\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wm is running (_MIT_PRIORITY_COLORS).\\n\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_MIT_PRIORITY_COLORS\"",
            "True"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wm is running (_XROOTPMAP_ID).\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_XROOTPMAP_ID\"",
            "True"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wm is running (_WIN_PROTOCOLS).\\n\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_WIN_PROTOCOLS\"",
            "True"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"wm is running (_NET_SUPPORTED).\\n\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"_NET_SUPPORTED\"",
            "True"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dm_still_running",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "dm_still_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "179-239",
          "snippet": "static int dm_still_running(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tWindow r, parent;\n\tWindow *winlist;\n\tunsigned int nc;\n\tint rc, i;\n\tstatic XClassHint *classhint = NULL;\n\tXErrorHandler old_handler;\n\tint saw_gdm_name = 0;\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\t/* we are xlocked. */\n\trc = XQueryTree_wr(dpy, DefaultRootWindow(dpy), &r, &parent, &winlist, &nc);\n\tif (!rc || winlist == NULL || nc == 0) {\n\t\tnc = 0;\n\t}\n\tfor (i=0; i < (int) nc; i++) {\n\t\tchar *name = NULL;\n\t\tWindow w = winlist[i];\n\t\tif (XFetchName(dpy, w, &name) && name != NULL) {\n\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\tXFree_wr(name);\n\t\t}\n\t\tclasshint->res_name = NULL;\n\t\tclasshint->res_class = NULL;\n\t\tif (XGetClassHint(dpy, w, classhint)) {\n\t\t\tname = classhint->res_name;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t\tname = classhint->res_class;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (saw_gdm_name > 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (winlist != NULL) {\n\t\tXFree_wr(winlist);\n\t}\n\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\treturn saw_gdm_name;\n#endif\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void get_prop(char *str, int len, Atom prop, Window w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nstatic int dm_still_running(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tWindow r, parent;\n\tWindow *winlist;\n\tunsigned int nc;\n\tint rc, i;\n\tstatic XClassHint *classhint = NULL;\n\tXErrorHandler old_handler;\n\tint saw_gdm_name = 0;\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\t/* we are xlocked. */\n\trc = XQueryTree_wr(dpy, DefaultRootWindow(dpy), &r, &parent, &winlist, &nc);\n\tif (!rc || winlist == NULL || nc == 0) {\n\t\tnc = 0;\n\t}\n\tfor (i=0; i < (int) nc; i++) {\n\t\tchar *name = NULL;\n\t\tWindow w = winlist[i];\n\t\tif (XFetchName(dpy, w, &name) && name != NULL) {\n\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\tXFree_wr(name);\n\t\t}\n\t\tclasshint->res_name = NULL;\n\t\tclasshint->res_class = NULL;\n\t\tif (XGetClassHint(dpy, w, classhint)) {\n\t\t\tname = classhint->res_name;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t\tname = classhint->res_class;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (saw_gdm_name > 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (winlist != NULL) {\n\t\tXFree_wr(winlist);\n\t}\n\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\treturn saw_gdm_name;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_WM_RUNNING\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\n\nstatic int wm_running(void) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tint ret = 0;\n\tRAWFB_RET(0)\n#if NO_X11\n\treturn 0;\n#else\n\t/*\n\t * Unfortunately with recent GDM (v2.28), they run gnome-session,\n\t * dbus-launch, and metacity for the Login greeter!  So the simple\n\t * XInternAtom checks below no longer work.\n         * We also see a similar thing with KDE.\n\t */\n\tif (dm_still_running()) {\n\t\treturn 0;\n\t}\n\n\t/* we are xlocked. */\n\tif (XInternAtom(dpy, \"_NET_SUPPORTED\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_NET_SUPPORTED).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_WIN_PROTOCOLS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_WIN_PROTOCOLS).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_XROOTPMAP_ID\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_XROOTPMAP_ID).\\n\");\n\t\tret++;\n\t}\n\tif (XInternAtom(dpy, \"_MIT_PRIORITY_COLORS\", True) != None) {\n\t\tif (s) rfbLog(\"wm is running (_MIT_PRIORITY_COLORS).\\n\");\n\t\tret++;\n\t}\n\tif (!ret) {\n\t\tif (s) rfbLog(\"wm is not running.\\n\");\n\t\treturn 0;\n\t} else {\n\t\tif (s) rfbLog(\"wm is running ret=%d.\\n\", ret);\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n\t\n}"
  },
  {
    "function_name": "dm_still_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "179-239",
    "snippet": "static int dm_still_running(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tWindow r, parent;\n\tWindow *winlist;\n\tunsigned int nc;\n\tint rc, i;\n\tstatic XClassHint *classhint = NULL;\n\tXErrorHandler old_handler;\n\tint saw_gdm_name = 0;\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\t/* we are xlocked. */\n\trc = XQueryTree_wr(dpy, DefaultRootWindow(dpy), &r, &parent, &winlist, &nc);\n\tif (!rc || winlist == NULL || nc == 0) {\n\t\tnc = 0;\n\t}\n\tfor (i=0; i < (int) nc; i++) {\n\t\tchar *name = NULL;\n\t\tWindow w = winlist[i];\n\t\tif (XFetchName(dpy, w, &name) && name != NULL) {\n\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\tXFree_wr(name);\n\t\t}\n\t\tclasshint->res_name = NULL;\n\t\tclasshint->res_class = NULL;\n\t\tif (XGetClassHint(dpy, w, classhint)) {\n\t\t\tname = classhint->res_name;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t\tname = classhint->res_class;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (saw_gdm_name > 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (winlist != NULL) {\n\t\tXFree_wr(winlist);\n\t}\n\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\treturn saw_gdm_name;\n#endif\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void get_prop(char *str, int len, Atom prop, Window w);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "winlist"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dm_string",
          "args": [
            "name"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "dm_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
          "lines": "157-177",
          "snippet": "static int dm_string(char *str) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tif (str == NULL) {\n\t\treturn 0;\n\t}\n\tif (str[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"dm_string: %s\\n\", str);\n\tif (strstr(str, \"gdm-\") == str || strstr(str, \"Gdm-\") == str) {\n\t\tif (strstr(str, \"-greeter\") != NULL) {\n\t\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (!strcmp(str, \"kdmgreet\") || !strcmp(str, \"Kdmgreet\")) {\n\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <X11/extensions/scrnsaver.h>",
            "#include \"inet.h\"",
            "#include \"remote.h\"",
            "#include \"pointer.h\"",
            "#include \"pm.h\"",
            "#include \"screen.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"unixpw.h\"",
            "#include \"connections.h\"",
            "#include \"gui.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"selection.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xrandr.h\"",
            "#include \"xkb_bell.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void set_server_input(rfbClientPtr cl, int s);",
            "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\n\nstatic int dm_string(char *str) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tif (str == NULL) {\n\t\treturn 0;\n\t}\n\tif (str[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"dm_string: %s\\n\", str);\n\tif (strstr(str, \"gdm-\") == str || strstr(str, \"Gdm-\") == str) {\n\t\tif (strstr(str, \"-greeter\") != NULL) {\n\t\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (!strcmp(str, \"kdmgreet\") || !strcmp(str, \"Kdmgreet\")) {\n\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetClassHint",
          "args": [
            "dpy",
            "w",
            "classhint"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFetchName",
          "args": [
            "dpy",
            "w",
            "&name"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "DefaultRootWindow(dpy)",
            "&r",
            "&parent",
            "&winlist",
            "&nc"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "DefaultRootWindow",
          "args": [
            "dpy"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XAllocClassHint",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid get_prop(char *str, int len, Atom prop, Window w);\n\nstatic int dm_still_running(void) {\n#if NO_X11\n\treturn 0;\n#else\n\tWindow r, parent;\n\tWindow *winlist;\n\tunsigned int nc;\n\tint rc, i;\n\tstatic XClassHint *classhint = NULL;\n\tXErrorHandler old_handler;\n\tint saw_gdm_name = 0;\n\n\t/* some times a window can go away before we get to it */\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\n\tif (! classhint) {\n\t\tclasshint = XAllocClassHint();\n\t}\n\n\t/* we are xlocked. */\n\trc = XQueryTree_wr(dpy, DefaultRootWindow(dpy), &r, &parent, &winlist, &nc);\n\tif (!rc || winlist == NULL || nc == 0) {\n\t\tnc = 0;\n\t}\n\tfor (i=0; i < (int) nc; i++) {\n\t\tchar *name = NULL;\n\t\tWindow w = winlist[i];\n\t\tif (XFetchName(dpy, w, &name) && name != NULL) {\n\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\tXFree_wr(name);\n\t\t}\n\t\tclasshint->res_name = NULL;\n\t\tclasshint->res_class = NULL;\n\t\tif (XGetClassHint(dpy, w, classhint)) {\n\t\t\tname = classhint->res_name;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t\tname = classhint->res_class;\n\t\t\tif (name != NULL) {\n\t\t\t\tsaw_gdm_name += dm_string(name);\n\t\t\t\tXFree_wr(name);\n\t\t\t}\n\t\t}\n\t\tif (saw_gdm_name > 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (winlist != NULL) {\n\t\tXFree_wr(winlist);\n\t}\n\n\tXSync(dpy, False);\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\n\treturn saw_gdm_name;\n#endif\n}"
  },
  {
    "function_name": "dm_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "157-177",
    "snippet": "static int dm_string(char *str) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tif (str == NULL) {\n\t\treturn 0;\n\t}\n\tif (str[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"dm_string: %s\\n\", str);\n\tif (strstr(str, \"gdm-\") == str || strstr(str, \"Gdm-\") == str) {\n\t\tif (strstr(str, \"-greeter\") != NULL) {\n\t\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (!strcmp(str, \"kdmgreet\") || !strcmp(str, \"Kdmgreet\")) {\n\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void set_server_input(rfbClientPtr cl, int s);",
      "int get_keyboard_led_state_hook(rfbScreenInfoPtr s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"dm_string: %s\\n\"",
            "str"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"Kdmgreet\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"kdmgreet\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"dm_string: %s\\n\"",
            "str"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"-greeter\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"Gdm-\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"gdm-\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dm_string: %s\\n\"",
            "str"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_WM_RUNNING\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid set_server_input(rfbClientPtr cl, int s);\nint get_keyboard_led_state_hook(rfbScreenInfoPtr s);\n\nstatic int dm_string(char *str) {\n\tchar *s = getenv(\"DEBUG_WM_RUNNING\");\n\tif (str == NULL) {\n\t\treturn 0;\n\t}\n\tif (str[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"dm_string: %s\\n\", str);\n\tif (strstr(str, \"gdm-\") == str || strstr(str, \"Gdm-\") == str) {\n\t\tif (strstr(str, \"-greeter\") != NULL) {\n\t\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (!strcmp(str, \"kdmgreet\") || !strcmp(str, \"Kdmgreet\")) {\n\t\tif (s) rfbLog(\"dm_string: %s\\n\", str);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "initialize_clipboard_atom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "117-133",
    "snippet": "void initialize_clipboard_atom(void) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\treturn;\n#else\n\tclipboard_atom = XInternAtom(dpy, \"CLIPBOARD\", False);\n\tif (clipboard_atom == None) {\n\t\tif (! quiet) rfbLog(\"could not find atom CLIPBOARD\\n\");\n\t\tif (watch_clipboard) {\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (set_clipboard) {\n\t\t\tset_clipboard = 0;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_clipboard_atom(void);",
      "void set_prop_atom(Atom atom);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not find atom CLIPBOARD\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"CLIPBOARD\"",
            "False"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_clipboard_atom(void);\nvoid set_prop_atom(Atom atom);\n\nvoid initialize_clipboard_atom(void) {\n\tRAWFB_RET_VOID\n#if NO_X11\n\treturn;\n#else\n\tclipboard_atom = XInternAtom(dpy, \"CLIPBOARD\", False);\n\tif (clipboard_atom == None) {\n\t\tif (! quiet) rfbLog(\"could not find atom CLIPBOARD\\n\");\n\t\tif (watch_clipboard) {\n\t\t\twatch_clipboard = 0;\n\t\t}\n\t\tif (set_clipboard) {\n\t\t\tset_clipboard = 0;\n\t\t}\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "initialize_x11vnc_remote_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "104-115",
    "snippet": "void initialize_x11vnc_remote_prop(void) {\n\tchar *prop_str;\n\tx11vnc_remote_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"X11VNC_REMOTE\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"X11VNC_REMOTE\";\n\t}\n\tx11vnc_remote_prop = XInternAtom(dpy, prop_str, False);\n#endif\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_x11vnc_remote_prop(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "prop_str",
            "False"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_REMOTE\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_x11vnc_remote_prop(void);\n\nvoid initialize_x11vnc_remote_prop(void) {\n\tchar *prop_str;\n\tx11vnc_remote_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"X11VNC_REMOTE\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"X11VNC_REMOTE\";\n\t}\n\tx11vnc_remote_prop = XInternAtom(dpy, prop_str, False);\n#endif\n}"
  },
  {
    "function_name": "initialize_vnc_connect_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xevents.c",
    "lines": "91-102",
    "snippet": "void initialize_vnc_connect_prop(void) {\n\tchar *prop_str;\n\tvnc_connect_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"VNC_CONNECT\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"VNC_CONNECT\";\n\t}\n\tvnc_connect_prop = XInternAtom(dpy, \"VNC_CONNECT\", False);\n#endif\n}",
    "includes": [
      "#include <X11/extensions/scrnsaver.h>",
      "#include \"inet.h\"",
      "#include \"remote.h\"",
      "#include \"pointer.h\"",
      "#include \"pm.h\"",
      "#include \"screen.h\"",
      "#include \"macosx.h\"",
      "#include \"cleanup.h\"",
      "#include \"unixpw.h\"",
      "#include \"connections.h\"",
      "#include \"gui.h\"",
      "#include \"cursor.h\"",
      "#include \"keyboard.h\"",
      "#include \"selection.h\"",
      "#include \"xrecord.h\"",
      "#include \"xdamage.h\"",
      "#include \"xrandr.h\"",
      "#include \"xkb_bell.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void initialize_vnc_connect_prop(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XInternAtom",
          "args": [
            "dpy",
            "\"VNC_CONNECT\"",
            "False"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"VNC_CONNECT\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <X11/extensions/scrnsaver.h>\n#include \"inet.h\"\n#include \"remote.h\"\n#include \"pointer.h\"\n#include \"pm.h\"\n#include \"screen.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"unixpw.h\"\n#include \"connections.h\"\n#include \"gui.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"selection.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xrandr.h\"\n#include \"xkb_bell.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid initialize_vnc_connect_prop(void);\n\nvoid initialize_vnc_connect_prop(void) {\n\tchar *prop_str;\n\tvnc_connect_str[0] = '\\0';\n\tRAWFB_RET_VOID\n#if !NO_X11\n\tprop_str = getenv(\"VNC_CONNECT\");\n\tif (prop_str == NULL) {\n\t\tprop_str = \"VNC_CONNECT\";\n\t}\n\tvnc_connect_prop = XInternAtom(dpy, \"VNC_CONNECT\", False);\n#endif\n}"
  }
]