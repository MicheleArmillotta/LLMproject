[
  {
    "function_name": "mark_8bpp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "2056-2152",
    "snippet": "void mark_8bpp(int mode) {\n\tint i, cnt = 0;\n\tWindow top = None;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || !cmap8to24_fb) {\n\t\treturn;\n\t}\n\t\n\tif (mode == MARK_8BPP_TOP) {\n\t\tint k;\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t\ttop = swin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (top != None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* for each mapped 8bpp window, mark it changed: */\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tint x1, y1, x2, y2, w, h, f = 32;\n\n\t\tf = 0;\t/* skip fuzz, may bring in other windows... */\n\n\t\tif (windows_8bpp[i].win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mode == MARK_8BPP_TOP) {\n\t\t\tif (windows_8bpp[i].top != top) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint vw = 0;\n\n\t\t\tX_LOCK;\n\t\t\tvw = valid_window(windows_8bpp[i].win, &attr, 1);\n\t\t\tX_UNLOCK;\n\t\t\tif (vw) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tx1 = windows_8bpp[i].x;\n\t\ty1 = windows_8bpp[i].y;\n\t\tw  = windows_8bpp[i].w;\n\t\th  = windows_8bpp[i].h;\n\n\t\tx2 = x1 + w;\n\t\ty2 = y1 + h;\n\n\t\tif (mode == MARK_8BPP_POINTER) {\n\t\t\tint b = 32;\t/* apply some fuzz for wm border */\n\t\t\tif (cursor_x < x1 - b || cursor_y < y1 - b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cursor_x > x2 + b || cursor_y > y2 + b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* apply fuzz f around each one; constrain to screen */\n\t\tx1 = nfix(x1 - f, dpy_x);\n\t\ty1 = nfix(y1 - f, dpy_y);\n\t\tx2 = nfix(x2 + f, dpy_x+1);\n\t\ty2 = nfix(y2 + f, dpy_y+1);\n\nif (db24 > 1) fprintf(stderr, \"mark_8bpp: 0x%lx %d %d %d %d\\n\", windows_8bpp[i].win, x1, y1, x2, y2);\n\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\tcnt++;\n\t}\n\tif (cnt) {\n\t\t/* push it to viewers if possible. */\n\t\trfbPE(-1);\n\t}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MAX_8BPP_WINDOWS 64"
    ],
    "globals_used": [
      "void mark_8bpp(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "-1"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2",
            "0"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"mark_8bpp: 0x%lx %d %d %d %d\\n\"",
            "windows_8bpp[i].win",
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2 + f",
            "dpy_y+1"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "windows_8bpp[i].win",
            "&attr",
            "1"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nvoid mark_8bpp(int);\n\nvoid mark_8bpp(int mode) {\n\tint i, cnt = 0;\n\tWindow top = None;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || !cmap8to24_fb) {\n\t\treturn;\n\t}\n\t\n\tif (mode == MARK_8BPP_TOP) {\n\t\tint k;\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t\ttop = swin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (top != None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* for each mapped 8bpp window, mark it changed: */\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tint x1, y1, x2, y2, w, h, f = 32;\n\n\t\tf = 0;\t/* skip fuzz, may bring in other windows... */\n\n\t\tif (windows_8bpp[i].win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mode == MARK_8BPP_TOP) {\n\t\t\tif (windows_8bpp[i].top != top) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint vw = 0;\n\n\t\t\tX_LOCK;\n\t\t\tvw = valid_window(windows_8bpp[i].win, &attr, 1);\n\t\t\tX_UNLOCK;\n\t\t\tif (vw) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tx1 = windows_8bpp[i].x;\n\t\ty1 = windows_8bpp[i].y;\n\t\tw  = windows_8bpp[i].w;\n\t\th  = windows_8bpp[i].h;\n\n\t\tx2 = x1 + w;\n\t\ty2 = y1 + h;\n\n\t\tif (mode == MARK_8BPP_POINTER) {\n\t\t\tint b = 32;\t/* apply some fuzz for wm border */\n\t\t\tif (cursor_x < x1 - b || cursor_y < y1 - b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cursor_x > x2 + b || cursor_y > y2 + b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* apply fuzz f around each one; constrain to screen */\n\t\tx1 = nfix(x1 - f, dpy_x);\n\t\ty1 = nfix(y1 - f, dpy_y);\n\t\tx2 = nfix(x2 + f, dpy_x+1);\n\t\ty2 = nfix(y2 + f, dpy_y+1);\n\nif (db24 > 1) fprintf(stderr, \"mark_8bpp: 0x%lx %d %d %d %d\\n\", windows_8bpp[i].win, x1, y1, x2, y2);\n\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\tcnt++;\n\t}\n\tif (cnt) {\n\t\t/* push it to viewers if possible. */\n\t\trfbPE(-1);\n\t}\n}"
  },
  {
    "function_name": "bpp8to24",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1809-2054",
    "snippet": "void bpp8to24(int x1, int y1, int x2, int y2) {\n\tchar *src, *dst;\n\tunsigned char *uc;\n\tunsigned short *us;\n\tunsigned int *ui;\n\tint idx, pixelsize = bpp/8;\n\tint line, k, i, j, h, w;\n\tint n_off;\n\tsraRegionPtr rect;\n\tint validate = 1;\n\tstatic int last_map_count = 0, call_count = 0;\n\tstatic double last_get_8bpp_validate = 0.0;\n\tstatic double last_snapshot = 0.0;\n\tdouble now;\n\tdouble dt, d0 = 0.0, t2;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || ! cmap8to24_fb) {\n\t\t/* hmmm, why were we called? */\n\t\treturn;\n\t}\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 %d %d %d %d %.4f\\n\", x1, y1, x2, y2, dnow() - last_get_8bpp_validate);\n\n\tcall_count++;\n\n\t/* clip to display just in case: */\n\tif (!ncache) {\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t}\n\n\tif (wireframe_in_progress) {\n\t\t/*\n\t\t * draw_box() manages cmap8to24_fb for us so we get out as\n\t\t * soon as we can.  No need to cp main_fb -> cmap8to24_fb.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* copy from main_fb to cmap8to24_fb regardless of 8bpp windows: */\n\n\th = y2 - y1;\n\tw = x2 - x1;\n\n\tif (depth == 24) {\n\t\t/* pixelsize = 4 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb      + n_off;\n\t\tdst = cmap8to24_fb + n_off;\n\n\t\t/* otherwise, the pixel data as is */\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += main_bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t} else if (depth <= 16) {\n\t\t/* need to cook up to depth 24 TrueColor  */\n\t\tint ps1 = 1, ps2 = 4;\n\t\tif (depth > 8) {\n\t\t\tps1 = 2;\n\t\t}\n\n\t\t/* pixelsize = 1, 2 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb + n_off;\n\t\tdst = cmap8to24_fb + (4/ps1) * n_off;\n\n\t\tset_root_cmap();\n\t\tif (root_cmap) {\n#if 0\n\t\t\tunsigned int hi;\n#endif\n\n\t\t\t/* line by line ... */\n\t\t\tfor (line = 0; line < h; line++) {\n\t\t\t\t/* pixel by pixel... */\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (ps1 == 2) {\n\t\t\t\t\t\tus = (unsigned short *) (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*us);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuc = (unsigned char *)  (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*uc);\n\t\t\t\t\t}\n\t\t\t\t\tui = (unsigned int *)  (dst + ps2 * j);\n\nif (0 && line % 100 == 0 && j % 32 == 0) fprintf(stderr, \"%d %d %u  x1=%d y1=%d\\n\", line, j, root_rgb[idx], x1, y1);\n#if 0\n\t\t\t\t\tif (do_hibits) {\n\t\t\t\t\t\thi = idx << 24;\n\t\t\t\t\t\t*ui = hi | rgb[0][idx];\n\t\t\t\t\t} else {\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t*ui = root_rgb[idx];\nif (db24 > 2) histo[idx]++;\n\t\t\t\t}\n\t\t\t\tsrc += main_bytes_per_line;\n\t\t\t\tdst += main_bytes_per_line * (4/ps1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tif (last_map_count > MAX_8BPP_WINDOWS/4) {\n\t\t/* table is filling up... skip validating sometimes: */\n\t\tint skip = 3;\n\t\tif (last_map_count > MAX_8BPP_WINDOWS/2) {\n\t\t\tskip = 6;\n\t\t} else if (last_map_count > 3*MAX_8BPP_WINDOWS/4) {\n\t\t\tskip = 12;\n\t\t}\n\t\tif (call_count % skip != 0) {\n\t\t\tvalidate = 0;\n\t\t}\n\t}\n\nif (db24 > 2) {for(i=0;i<256;i++){histo[i]=0;}}\n\n\tnow = dnow();\n\tdt = now - last_get_8bpp_validate;\n\t/* TUNABLES  */\n\tif (dt < 0.003) {\n\t\t;\t/* XXX does this still give painting errors? */\n\t} else {\n\t\tint snapit = 0;\n\t\tdouble delay1, delay2, delay3;\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay1 = 1.0 * poll_8to24_delay;\n\t\t\tdelay2 = 2.0 * poll_8to24_delay;\n\t\t\tdelay3 = 10. * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay1 = 1.0 * POLL_8TO24_DELAY;\t/* 0.05 */\n\t\t\tdelay2 = 2.0 * POLL_8TO24_DELAY;\t/* 0.1  */\n\t\t\tdelay3 = 10. * POLL_8TO24_DELAY;\t/* 0.5  */\n\t\t}\n\t\tif (cache_win > 1.0) {\n\t\t\tdelay2 *= 2;\n\t\t\tdelay3 *= 2;\n\t\t}\n\t\tif (dt < delay1) {\n\t\t\tvalidate = 0;\n\t\t}\n\t\tif (last_map_count) {\n\t\t\tif (now > last_snapshot + delay2) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (now > last_snapshot + delay3) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (snapit) {\n\t\t\t/* less problems if we update the stack frequently */\n\t\t\tsnapshot_stack_list(0, 0.0);\nif (0) fprintf(stderr, \"SNAP time: %.4f\\n\", dnow() - now);\n\t\t\tupdate_stack_list();\n\t\t\tlast_snapshot = dnow();\nif (0) fprintf(stderr, \"UPDA time: %.4f\\n\", last_snapshot - now);\n\t\t}\n\nif (0) t2 = dnow();\n\t\tlast_map_count = get_8bpp_regions(validate);\n\t\tif (validate) {\n\t\t\tlast_get_8bpp_validate = dnow();\n\t\t}\nif (0) fprintf(stderr, \"get8bpp-%d: %.4f\\n\", validate, dnow() - t2);\n\t}\nif (db24) d0 = dnow();\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 w=%d h=%d m=%p c=%p r=%p ncmaps=%d\\n\", w, h, main_fb, cmap8to24_fb, rfb_fb, ncmaps);\n\n\t/*\n\t * now go back and transform and 8bpp regions to TrueColor in\n\t * cmap8to24_fb.\n\t */\n\tif (last_map_count && (ncmaps || depth <= 16)) {\n\t\tint i, j;\n\t\tint win[MAX_8BPP_WINDOWS];\n\t\tint did[MAX_8BPP_WINDOWS];\n\t\tint count = 0;\n\n\t\t/*\n\t\t * first, grab all of the associated colormaps from the\n\t\t * X server.  Hopefully just 1 or 2...\n\t\t */\n\t\tfor (j=0; j<ncmaps; j++) {\n\t\t\tif (! get_cmap(j, cmaps[j])) {\n\t\t\t\tcmap_failed[j] = 1;\n\t\t\t} else {\n\t\t\t\tcmap_failed[j] = 0;\n\t\t\t}\nif (db24 > 2) fprintf(stderr, \"cmap %d  %.4f\\n\", (int) cmaps[j], dnow() - d0);\n\t\t}\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\t\t\tif (reg) {\n\t\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t\tif (sraRgnAnd(rect, reg)) {\n\t\t\t\t\twin[count] = i;\n\t\t\t\t\tdid[count++] = 0;\n\t\t\t\t}\n\t\t\t\tsraRgnDestroy(rect);\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\n\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t/* try to apply lower windows first */\n\t\t\tfor (k=0; k < stack_list_num; k++) {\n\t\t\t\tWindow swin = stack_list[k].win;\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tif (did[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (windows_8bpp[i].top == swin) {\n\t\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\t\tdid[j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tif (! did[j]) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\tdid[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnDestroy(rect);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done time: %.4f\\n\", dnow() - d0);\n\nif (db24 > 2) {for(i=0; i<256;i++) {fprintf(stderr, \" cmap histo[%03d] %d\\n\", i, histo[i]);}}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MAX_8BPP_WINDOWS 64"
    ],
    "globals_used": [
      "void bpp8to24(int, int, int, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" cmap histo[%03d] %d\\n\"",
            "i",
            "histo[i]"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"done time: %.4f\\n\"",
            "dnow() - d0"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_8bpp_region",
          "args": [
            "i",
            "rect"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "do_8bpp_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1464-1520",
          "snippet": "static void do_8bpp_region(int n, sraRegionPtr mark) {\n\tint k, cm = -1, failed = 0;\n\tsraRectangleIterator *iter;\n\tsraRegionPtr clip;\n\tsraRect rect;\n\n\tif (! windows_8bpp[n].clip_region) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].win == None) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db24 > 1) fprintf(stderr, \"ncmaps: %d\\n\", ncmaps);\n\n\t/* see if XQueryColors failed: */\n\tfor (k=0; k<ncmaps; k++) {\n\t\tif (windows_8bpp[n].cmap == cmaps[k]) {\n\t\t\tcm = k;\n\t\t\tif (cmap_failed[k]) {\n\t\t\t\tfailed = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (windows_8bpp[n].depth != 24) {\t/* 24 won't have a cmap */\n\t\tif (failed || cm == -1) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclip = sraRgnCreateRgn(mark);\n\tsraRgnAnd(clip, windows_8bpp[n].clip_region);\n\n\t/* loop over the rectangles making up region */\n\titer = sraRgnGetIterator(clip);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\n\t\ttransform_rect(rect, windows_8bpp[n].win,\n\t\t    windows_8bpp[n].depth, cm);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnDestroy(clip);\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void do_8bpp_region(int n, sraRegionPtr mark) {\n\tint k, cm = -1, failed = 0;\n\tsraRectangleIterator *iter;\n\tsraRegionPtr clip;\n\tsraRect rect;\n\n\tif (! windows_8bpp[n].clip_region) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].win == None) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db24 > 1) fprintf(stderr, \"ncmaps: %d\\n\", ncmaps);\n\n\t/* see if XQueryColors failed: */\n\tfor (k=0; k<ncmaps; k++) {\n\t\tif (windows_8bpp[n].cmap == cmaps[k]) {\n\t\t\tcm = k;\n\t\t\tif (cmap_failed[k]) {\n\t\t\t\tfailed = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (windows_8bpp[n].depth != 24) {\t/* 24 won't have a cmap */\n\t\tif (failed || cm == -1) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclip = sraRgnCreateRgn(mark);\n\tsraRgnAnd(clip, windows_8bpp[n].clip_region);\n\n\t/* loop over the rectangles making up region */\n\titer = sraRgnGetIterator(clip);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\n\t\ttransform_rect(rect, windows_8bpp[n].win,\n\t\t    windows_8bpp[n].depth, cm);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnDestroy(clip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "rect",
            "reg"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cmap %d  %.4f\\n\"",
            "(int) cmaps[j]",
            "dnow() - d0"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cmap",
          "args": [
            "j",
            "cmaps[j]"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "get_cmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1367-1462",
          "snippet": "static int get_cmap(int j, Colormap cmap) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!j || !cmap) {}\n\treturn 0;\n#else\n\tint i, ncells, ncolor;\n\tXErrorHandler old_handler = NULL;\n\n\tRAWFB_RET(0)\n\n\tif (depth > 16) {\n\t\t/* 24 */\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\tif (!color_init) {\n\t\tint cm;\n\t\tfor (cm = 0; cm < CMAPMAX; cm++) {\n\t\t\tcolor[cm] = (XColor *) malloc(ncolor * sizeof(XColor));\n\t\t\trgb[cm] = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t\t}\n\t\tcolor_init = 1;\n\t}\n\n\tif (depth <= 16) {\n\t\t/* not working properly for depth 24... */\n\t\tX_LOCK;\n\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\tX_UNLOCK;\n\t} else {\n\t\tncells = NCOLOR;\n\t}\n\n\tif (depth > 16) {\n\t\t;\n\t} else if (ncells > ncolor) {\n\t\tncells = ncolor;\n\t} else if (ncells == 8 && depth != 3) {\n\t\t/* XXX. see set_colormap() */\n\t\tncells = 1 << depth;\n\t}\n\n\t/* initialize XColor array: */\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[j][i].pixel = i;\n\t\tcolor[j][i].pad = 0;\n\t}\nif (db24 > 1) fprintf(stderr, \"get_cmap: %d 0x%x ncolor=%d ncells=%d\\n\", j, (unsigned int) cmap, ncolor, ncells);\n\n\t/* try to query the colormap, trap errors */\n\tX_LOCK;\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tXQueryColors(dpy, cmap, color[j], ncells);\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tif (trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\t/* now map each index to depth 24 RGB */\n\tfor (i=0; i < ncells; i++) {\n\t\tunsigned int red, green, blue;\n\t\t/* strip out highest 8 bits of values: */\n\t\tred   = (color[j][i].red   & 0xff00) >> 8;\n\t\tgreen = (color[j][i].green & 0xff00) >> 8;\n\t\tblue  = (color[j][i].blue  & 0xff00) >> 8;\n\n\t\t/*\n\t\t * the maxes should be at 255 already,\n\t\t * but just in case...\n\t\t */\n\t\tred   = (main_red_max   * red  )/255;\n\t\tgreen = (main_green_max * green)/255;\n\t\tblue  = (main_blue_max  * blue )/255;\n\nif (db24 > 2) fprintf(stderr, \" cmap[%02d][%03d]: %03d %03d %03d  0x%08x \\n\", j, i, red, green, blue, ( red << main_red_shift | green << main_green_shift | blue << main_blue_shift));\n\n\t\t/* shift them over and or together for value */\n\t\tred   = red    << main_red_shift;\n\t\tgreen = green  << main_green_shift;\n\t\tblue  = blue   << main_blue_shift;\n\n\t\t/* store it in the array to be used later */\n\t\trgb[j][i] = red | green | blue;\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAPMAX 64",
            "#define NCOLOR 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CMAPMAX 64\n#define NCOLOR 256\n\nstatic int get_cmap(int j, Colormap cmap) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!j || !cmap) {}\n\treturn 0;\n#else\n\tint i, ncells, ncolor;\n\tXErrorHandler old_handler = NULL;\n\n\tRAWFB_RET(0)\n\n\tif (depth > 16) {\n\t\t/* 24 */\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\tif (!color_init) {\n\t\tint cm;\n\t\tfor (cm = 0; cm < CMAPMAX; cm++) {\n\t\t\tcolor[cm] = (XColor *) malloc(ncolor * sizeof(XColor));\n\t\t\trgb[cm] = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t\t}\n\t\tcolor_init = 1;\n\t}\n\n\tif (depth <= 16) {\n\t\t/* not working properly for depth 24... */\n\t\tX_LOCK;\n\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\tX_UNLOCK;\n\t} else {\n\t\tncells = NCOLOR;\n\t}\n\n\tif (depth > 16) {\n\t\t;\n\t} else if (ncells > ncolor) {\n\t\tncells = ncolor;\n\t} else if (ncells == 8 && depth != 3) {\n\t\t/* XXX. see set_colormap() */\n\t\tncells = 1 << depth;\n\t}\n\n\t/* initialize XColor array: */\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[j][i].pixel = i;\n\t\tcolor[j][i].pad = 0;\n\t}\nif (db24 > 1) fprintf(stderr, \"get_cmap: %d 0x%x ncolor=%d ncells=%d\\n\", j, (unsigned int) cmap, ncolor, ncells);\n\n\t/* try to query the colormap, trap errors */\n\tX_LOCK;\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tXQueryColors(dpy, cmap, color[j], ncells);\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tif (trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\t/* now map each index to depth 24 RGB */\n\tfor (i=0; i < ncells; i++) {\n\t\tunsigned int red, green, blue;\n\t\t/* strip out highest 8 bits of values: */\n\t\tred   = (color[j][i].red   & 0xff00) >> 8;\n\t\tgreen = (color[j][i].green & 0xff00) >> 8;\n\t\tblue  = (color[j][i].blue  & 0xff00) >> 8;\n\n\t\t/*\n\t\t * the maxes should be at 255 already,\n\t\t * but just in case...\n\t\t */\n\t\tred   = (main_red_max   * red  )/255;\n\t\tgreen = (main_green_max * green)/255;\n\t\tblue  = (main_blue_max  * blue )/255;\n\nif (db24 > 2) fprintf(stderr, \" cmap[%02d][%03d]: %03d %03d %03d  0x%08x \\n\", j, i, red, green, blue, ( red << main_red_shift | green << main_green_shift | blue << main_blue_shift));\n\n\t\t/* shift them over and or together for value */\n\t\tred   = red    << main_red_shift;\n\t\tgreen = green  << main_green_shift;\n\t\tblue  = blue   << main_blue_shift;\n\n\t\t/* store it in the array to be used later */\n\t\trgb[j][i] = red | green | blue;\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bpp8to24 w=%d h=%d m=%p c=%p r=%p ncmaps=%d\\n\"",
            "w",
            "h",
            "main_fb",
            "cmap8to24_fb",
            "rfb_fb",
            "ncmaps"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get8bpp-%d: %.4f\\n\"",
            "validate",
            "dnow() - t2"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_8bpp_regions",
          "args": [
            "validate"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "get_8bpp_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1208-1359",
          "snippet": "static int get_8bpp_regions(int validate) {\n\n\tXWindowAttributes attr;\n\tint i, k, mapcount = 0;\n\n\t/* initialize color map list */\n\tncmaps = 0;\n\tfor (i=0; i < CMAPMAX; i++) {\n\t\tcmaps[i] = (Colormap) 0;\n\t}\n\n\t/* loop over the table of 8bpp windows: */\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr tmp_reg, tmp_reg2;\n\t\tWindow c, w = windows_8bpp[i].win;\n\t\tint x, y;\n\n\t\tif (windows_8bpp[i].clip_region) {\n\t\t\tsraRgnDestroy(windows_8bpp[i].clip_region);\t\n\t\t}\n\t\twindows_8bpp[i].clip_region = NULL;\n\n\t\tif (w == None) {\n\t\t\tcontinue;\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"get_8bpp_regions: 0x%lx ms=%d dep=%d i=%d\\n\", w, windows_8bpp[i].map_state, windows_8bpp[i].depth, i);\n\t\tif (validate) {\n\t\t\t/*\n\t\t\t * this could be slow: validating 8bpp windows each\n\t\t\t * time...\n\t\t\t */\n\n\t\t\tX_LOCK;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\tX_UNLOCK;\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\twindows_8bpp[i].depth = attr.depth;\n\t\t\twindows_8bpp[i].map_state = attr.map_state;\n\t\t\twindows_8bpp[i].cmap = attr.colormap;\n\t\t\twindows_8bpp[i].map_installed = attr.map_installed;\n\t\t\twindows_8bpp[i].w = attr.width;\n\t\t\twindows_8bpp[i].h = attr.height;\n\t\t\twindows_8bpp[i].fetched = 1;\n\t\t\twindows_8bpp[i].last_fetched = dnow();\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tX_LOCK;\n\t\t\txtranslate(w, window, 0, 0, &x, &y, &c, 1);\n\t\t\tX_UNLOCK;\n\t\t\twindows_8bpp[i].x = x;\n\t\t\twindows_8bpp[i].y = y;\n\n\t\t} else {\n\t\t\t/* this will be faster: no call to X server: */\n\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattr.depth = windows_8bpp[i].depth;\n\t\t\tattr.map_state = windows_8bpp[i].map_state;\n\t\t\tattr.colormap = windows_8bpp[i].cmap;\n\t\t\tattr.map_installed = windows_8bpp[i].map_installed;\n\t\t\tattr.width = windows_8bpp[i].w;\n\t\t\tattr.height = windows_8bpp[i].h;\n\n\t\t\tx =  windows_8bpp[i].x; \n\t\t\ty =  windows_8bpp[i].y; \n\t\t}\n\n\t\tmapcount++;\n\n\t\t/* tmp region for this 8bpp rectangle: */\n\t\ttmp_reg = sraRgnCreateRect(nfix(x, dpy_x), nfix(y, dpy_y),\n\t\t    nfix(x + attr.width, dpy_x+1), nfix(y + attr.height, dpy_y+1));\n\n\t\t/* loop over all toplevels, top to bottom clipping: */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tint sx, sy, sw, sh;\n\nif (db24 > 1 && stack_list[k].map_state == IsViewable) fprintf(stderr, \"Stack win: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\n\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t/* found our top level: we skip the rest. */\nif (db24 > 1) fprintf(stderr, \"found top: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\t\t/* skip unmapped ones: */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* make a temp rect for this toplevel: */\n\t\t\tsx = stack_list[k].x;\n\t\t\tsy = stack_list[k].y;\n\t\t\tsw = stack_list[k].width;\n\t\t\tsh = stack_list[k].height;\n\nif (db24 > 1) fprintf(stderr, \"subtract:  0x%lx %d -- %d %d %d %d\\n\", swin, k, sx, sy, sw, sh);\n\n\t\t\ttmp_reg2 = sraRgnCreateRect(nfix(sx, dpy_x),\n\t\t\t    nfix(sy, dpy_y), nfix(sx + sw, dpy_x+1),\n\t\t\t    nfix(sy + sh, dpy_y+1));\n\n\t\t\t/* subtract it from the 8bpp window region */\n\t\t\tsraRgnSubtract(tmp_reg, tmp_reg2);\n\n\t\t\tsraRgnDestroy(tmp_reg2);\n\n\t\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t/* skip this 8bpp if completely clipped away: */\n\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, store any new colormaps: */\n\t\tif (ncmaps < CMAPMAX && attr.colormap != (Colormap) 0) {\n\t\t\tint m, seen = 0;\n\t\t\tfor (m=0; m < ncmaps; m++) {\n\t\t\t\tif (cmaps[m] == attr.colormap) {\n\t\t\t\t\tseen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seen && attr.depth <= 16) {\n\t\t\t\t/* store only new ones: */\n\t\t\t\tcmaps[ncmaps++] = attr.colormap;\n\t\t\t}\n\t\t}\n\n\t\twindows_8bpp[i].clip_region = tmp_reg;\n\t}\n\n\treturn mapcount;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAPMAX 64",
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CMAPMAX 64\n#define MAX_8BPP_WINDOWS 64\n\nstatic int get_8bpp_regions(int validate) {\n\n\tXWindowAttributes attr;\n\tint i, k, mapcount = 0;\n\n\t/* initialize color map list */\n\tncmaps = 0;\n\tfor (i=0; i < CMAPMAX; i++) {\n\t\tcmaps[i] = (Colormap) 0;\n\t}\n\n\t/* loop over the table of 8bpp windows: */\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr tmp_reg, tmp_reg2;\n\t\tWindow c, w = windows_8bpp[i].win;\n\t\tint x, y;\n\n\t\tif (windows_8bpp[i].clip_region) {\n\t\t\tsraRgnDestroy(windows_8bpp[i].clip_region);\t\n\t\t}\n\t\twindows_8bpp[i].clip_region = NULL;\n\n\t\tif (w == None) {\n\t\t\tcontinue;\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"get_8bpp_regions: 0x%lx ms=%d dep=%d i=%d\\n\", w, windows_8bpp[i].map_state, windows_8bpp[i].depth, i);\n\t\tif (validate) {\n\t\t\t/*\n\t\t\t * this could be slow: validating 8bpp windows each\n\t\t\t * time...\n\t\t\t */\n\n\t\t\tX_LOCK;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\tX_UNLOCK;\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\twindows_8bpp[i].depth = attr.depth;\n\t\t\twindows_8bpp[i].map_state = attr.map_state;\n\t\t\twindows_8bpp[i].cmap = attr.colormap;\n\t\t\twindows_8bpp[i].map_installed = attr.map_installed;\n\t\t\twindows_8bpp[i].w = attr.width;\n\t\t\twindows_8bpp[i].h = attr.height;\n\t\t\twindows_8bpp[i].fetched = 1;\n\t\t\twindows_8bpp[i].last_fetched = dnow();\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tX_LOCK;\n\t\t\txtranslate(w, window, 0, 0, &x, &y, &c, 1);\n\t\t\tX_UNLOCK;\n\t\t\twindows_8bpp[i].x = x;\n\t\t\twindows_8bpp[i].y = y;\n\n\t\t} else {\n\t\t\t/* this will be faster: no call to X server: */\n\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattr.depth = windows_8bpp[i].depth;\n\t\t\tattr.map_state = windows_8bpp[i].map_state;\n\t\t\tattr.colormap = windows_8bpp[i].cmap;\n\t\t\tattr.map_installed = windows_8bpp[i].map_installed;\n\t\t\tattr.width = windows_8bpp[i].w;\n\t\t\tattr.height = windows_8bpp[i].h;\n\n\t\t\tx =  windows_8bpp[i].x; \n\t\t\ty =  windows_8bpp[i].y; \n\t\t}\n\n\t\tmapcount++;\n\n\t\t/* tmp region for this 8bpp rectangle: */\n\t\ttmp_reg = sraRgnCreateRect(nfix(x, dpy_x), nfix(y, dpy_y),\n\t\t    nfix(x + attr.width, dpy_x+1), nfix(y + attr.height, dpy_y+1));\n\n\t\t/* loop over all toplevels, top to bottom clipping: */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tint sx, sy, sw, sh;\n\nif (db24 > 1 && stack_list[k].map_state == IsViewable) fprintf(stderr, \"Stack win: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\n\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t/* found our top level: we skip the rest. */\nif (db24 > 1) fprintf(stderr, \"found top: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\t\t/* skip unmapped ones: */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* make a temp rect for this toplevel: */\n\t\t\tsx = stack_list[k].x;\n\t\t\tsy = stack_list[k].y;\n\t\t\tsw = stack_list[k].width;\n\t\t\tsh = stack_list[k].height;\n\nif (db24 > 1) fprintf(stderr, \"subtract:  0x%lx %d -- %d %d %d %d\\n\", swin, k, sx, sy, sw, sh);\n\n\t\t\ttmp_reg2 = sraRgnCreateRect(nfix(sx, dpy_x),\n\t\t\t    nfix(sy, dpy_y), nfix(sx + sw, dpy_x+1),\n\t\t\t    nfix(sy + sh, dpy_y+1));\n\n\t\t\t/* subtract it from the 8bpp window region */\n\t\t\tsraRgnSubtract(tmp_reg, tmp_reg2);\n\n\t\t\tsraRgnDestroy(tmp_reg2);\n\n\t\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t/* skip this 8bpp if completely clipped away: */\n\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, store any new colormaps: */\n\t\tif (ncmaps < CMAPMAX && attr.colormap != (Colormap) 0) {\n\t\t\tint m, seen = 0;\n\t\t\tfor (m=0; m < ncmaps; m++) {\n\t\t\t\tif (cmaps[m] == attr.colormap) {\n\t\t\t\t\tseen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seen && attr.depth <= 16) {\n\t\t\t\t/* store only new ones: */\n\t\t\t\tcmaps[ncmaps++] = attr.colormap;\n\t\t\t}\n\t\t}\n\n\t\twindows_8bpp[i].clip_region = tmp_reg;\n\t}\n\n\treturn mapcount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"UPDA time: %.4f\\n\"",
            "last_snapshot - now"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_stack_list",
          "args": [],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "update_stack_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "307-353",
          "snippet": "void update_stack_list(void) {\n\tint k;\n\tdouble now;\n\tXWindowAttributes attr;\n\tint boff, bwin;\n\n\tif (! stack_list) {\n\t\treturn;\n\t}\n\tif (! stack_list_num) {\n\t\treturn;\n\t}\n\n\tdtime0(&now);\n\n\tboff = get_boff();\n\tbwin = get_bwin();\n\t\n\tX_LOCK;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow win = stack_list[k].win;\n\t\tif (win != None && boff <= (int) win && (int) win < boff + bwin) {\n\t\t\t;\t/* special, blackout */\n\t\t} else if (!valid_window(win, &attr, 1)) {\n\t\t\tstack_list[k].valid = 0;\n\t\t} else {\n\t\t\tstack_list[k].valid = 1;\n\t\t\tstack_list[k].x = attr.x;\n\t\t\tstack_list[k].y = attr.y;\n\t\t\tstack_list[k].width = attr.width;\n\t\t\tstack_list[k].height = attr.height;\n\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\tstack_list[k].depth = attr.depth;\n\t\t\tstack_list[k].class = attr.class;\n\t\t\tstack_list[k].backing_store = attr.backing_store;\n\t\t\tstack_list[k].map_state = attr.map_state;\n\n\t\t\t/* root_x, root_y not used for stack_list usage: */\n\t\t\tstack_list[k].rx = -1;\n\t\t\tstack_list[k].ry = -1;\n\t\t}\n\t\tstack_list[k].fetched = 1;\n\t\tstack_list[k].time = now;\n\t}\n\tX_UNLOCK;\nif (0) fprintf(stderr, \"update_stack_list[%d]: %.4f  %.4f\\n\", stack_list_num, now - x11vnc_start, dtime(&now));\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *stack_list = NULL;",
            "int stack_list_num = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_num = 0;\n\nvoid update_stack_list(void) {\n\tint k;\n\tdouble now;\n\tXWindowAttributes attr;\n\tint boff, bwin;\n\n\tif (! stack_list) {\n\t\treturn;\n\t}\n\tif (! stack_list_num) {\n\t\treturn;\n\t}\n\n\tdtime0(&now);\n\n\tboff = get_boff();\n\tbwin = get_bwin();\n\t\n\tX_LOCK;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow win = stack_list[k].win;\n\t\tif (win != None && boff <= (int) win && (int) win < boff + bwin) {\n\t\t\t;\t/* special, blackout */\n\t\t} else if (!valid_window(win, &attr, 1)) {\n\t\t\tstack_list[k].valid = 0;\n\t\t} else {\n\t\t\tstack_list[k].valid = 1;\n\t\t\tstack_list[k].x = attr.x;\n\t\t\tstack_list[k].y = attr.y;\n\t\t\tstack_list[k].width = attr.width;\n\t\t\tstack_list[k].height = attr.height;\n\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\tstack_list[k].depth = attr.depth;\n\t\t\tstack_list[k].class = attr.class;\n\t\t\tstack_list[k].backing_store = attr.backing_store;\n\t\t\tstack_list[k].map_state = attr.map_state;\n\n\t\t\t/* root_x, root_y not used for stack_list usage: */\n\t\t\tstack_list[k].rx = -1;\n\t\t\tstack_list[k].ry = -1;\n\t\t}\n\t\tstack_list[k].fetched = 1;\n\t\tstack_list[k].time = now;\n\t}\n\tX_UNLOCK;\nif (0) fprintf(stderr, \"update_stack_list[%d]: %.4f  %.4f\\n\", stack_list_num, now - x11vnc_start, dtime(&now));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SNAP time: %.4f\\n\"",
            "dnow() - now"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snapshot_stack_list",
          "args": [
            "0",
            "0.0"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_stack_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "192-293",
          "snippet": "void snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *stack_list = NULL;",
            "int stack_list_len = 0;",
            "int stack_list_num = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_len = 0;\nint stack_list_num = 0;\n\nvoid snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d %d %u  x1=%d y1=%d\\n\"",
            "line",
            "j",
            "root_rgb[idx]",
            "x1",
            "y1"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_root_cmap",
          "args": [],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "set_root_cmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "100-178",
          "snippet": "static void set_root_cmap(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic time_t last_set = 0;\n\ttime_t now = time(NULL);\n\tXWindowAttributes attr;\n\tstatic XColor *color = NULL;\n\tint redo = 0;\n\tint ncolor = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (depth > 16) {\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\n\tif (!root_rgb) {\n\t\troot_rgb = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t}\n\tif (!color) {\n\t\tcolor = (XColor *) malloc(ncolor * sizeof(XColor));\n\t}\n\n\tif (now > last_set + 10) {\n\t\tredo = 1;\n\t}\n\tif (! root_cmap || redo) {\n\t\tX_LOCK;\n\t\tif (! valid_window(window, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t\tif (attr.colormap) {\n\t\t\tint i, ncells = ncolor;\n\n\t\t\tif (depth < 8) {\n\t\t\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\t\t}\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tcolor[i].pixel = i;\n\t\t\t\tcolor[i].pad = 0;\n\t\t\t}\n\t\t\tlast_set = now;\n\t\t\troot_cmap = attr.colormap;\n\t\t\tXQueryColors(dpy, root_cmap, color, ncells);\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tunsigned int red, green, blue;\n\t\t\t\t/* strip out highest 8 bits of values: */\n\t\t\t\tred   = (color[i].red   & 0xff00) >> 8;\n\t\t\t\tgreen = (color[i].green & 0xff00) >> 8;\n\t\t\t\tblue  = (color[i].blue  & 0xff00) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * the maxes should be at 255 already,\n\t\t\t\t * but just in case...\n\t\t\t\t */\n\t\t\t\tred   = (main_red_max   * red  )/255;\n\t\t\t\tgreen = (main_green_max * green)/255;\n\t\t\t\tblue  = (main_blue_max  * blue )/255;\n\n\t\t\t\t/* shift them over and or together for value */\n\t\t\t\tred   = red    << main_red_shift;\n\t\t\t\tgreen = green  << main_green_shift;\n\t\t\t\tblue  = blue   << main_blue_shift;\n\n\t\t\t\t/* store it in the array to be used later */\n\t\t\t\troot_rgb[i] = red | green | blue;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NCOLOR 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define NCOLOR 256\n\nstatic void set_root_cmap(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic time_t last_set = 0;\n\ttime_t now = time(NULL);\n\tXWindowAttributes attr;\n\tstatic XColor *color = NULL;\n\tint redo = 0;\n\tint ncolor = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (depth > 16) {\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\n\tif (!root_rgb) {\n\t\troot_rgb = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t}\n\tif (!color) {\n\t\tcolor = (XColor *) malloc(ncolor * sizeof(XColor));\n\t}\n\n\tif (now > last_set + 10) {\n\t\tredo = 1;\n\t}\n\tif (! root_cmap || redo) {\n\t\tX_LOCK;\n\t\tif (! valid_window(window, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t\tif (attr.colormap) {\n\t\t\tint i, ncells = ncolor;\n\n\t\t\tif (depth < 8) {\n\t\t\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\t\t}\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tcolor[i].pixel = i;\n\t\t\t\tcolor[i].pad = 0;\n\t\t\t}\n\t\t\tlast_set = now;\n\t\t\troot_cmap = attr.colormap;\n\t\t\tXQueryColors(dpy, root_cmap, color, ncells);\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tunsigned int red, green, blue;\n\t\t\t\t/* strip out highest 8 bits of values: */\n\t\t\t\tred   = (color[i].red   & 0xff00) >> 8;\n\t\t\t\tgreen = (color[i].green & 0xff00) >> 8;\n\t\t\t\tblue  = (color[i].blue  & 0xff00) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * the maxes should be at 255 already,\n\t\t\t\t * but just in case...\n\t\t\t\t */\n\t\t\t\tred   = (main_red_max   * red  )/255;\n\t\t\t\tgreen = (main_green_max * green)/255;\n\t\t\t\tblue  = (main_blue_max  * blue )/255;\n\n\t\t\t\t/* shift them over and or together for value */\n\t\t\t\tred   = red    << main_red_shift;\n\t\t\t\tgreen = green  << main_green_shift;\n\t\t\t\tblue  = blue   << main_blue_shift;\n\n\t\t\t\t/* store it in the array to be used later */\n\t\t\t\troot_rgb[i] = red | green | blue;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "w * pixelsize"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2",
            "dpy_y+1"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bpp8to24 %d %d %d %d %.4f\\n\"",
            "x1",
            "y1",
            "x2",
            "y2",
            "dnow() - last_get_8bpp_validate"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nvoid bpp8to24(int, int, int, int);\n\nvoid bpp8to24(int x1, int y1, int x2, int y2) {\n\tchar *src, *dst;\n\tunsigned char *uc;\n\tunsigned short *us;\n\tunsigned int *ui;\n\tint idx, pixelsize = bpp/8;\n\tint line, k, i, j, h, w;\n\tint n_off;\n\tsraRegionPtr rect;\n\tint validate = 1;\n\tstatic int last_map_count = 0, call_count = 0;\n\tstatic double last_get_8bpp_validate = 0.0;\n\tstatic double last_snapshot = 0.0;\n\tdouble now;\n\tdouble dt, d0 = 0.0, t2;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || ! cmap8to24_fb) {\n\t\t/* hmmm, why were we called? */\n\t\treturn;\n\t}\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 %d %d %d %d %.4f\\n\", x1, y1, x2, y2, dnow() - last_get_8bpp_validate);\n\n\tcall_count++;\n\n\t/* clip to display just in case: */\n\tif (!ncache) {\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t}\n\n\tif (wireframe_in_progress) {\n\t\t/*\n\t\t * draw_box() manages cmap8to24_fb for us so we get out as\n\t\t * soon as we can.  No need to cp main_fb -> cmap8to24_fb.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* copy from main_fb to cmap8to24_fb regardless of 8bpp windows: */\n\n\th = y2 - y1;\n\tw = x2 - x1;\n\n\tif (depth == 24) {\n\t\t/* pixelsize = 4 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb      + n_off;\n\t\tdst = cmap8to24_fb + n_off;\n\n\t\t/* otherwise, the pixel data as is */\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tmemcpy(dst, src, w * pixelsize);\n\t\t\tsrc += main_bytes_per_line;\n\t\t\tdst += main_bytes_per_line;\n\t\t}\n\t} else if (depth <= 16) {\n\t\t/* need to cook up to depth 24 TrueColor  */\n\t\tint ps1 = 1, ps2 = 4;\n\t\tif (depth > 8) {\n\t\t\tps1 = 2;\n\t\t}\n\n\t\t/* pixelsize = 1, 2 */\n\t\tn_off = main_bytes_per_line * y1 + pixelsize * x1;\n\n\t\tsrc = main_fb + n_off;\n\t\tdst = cmap8to24_fb + (4/ps1) * n_off;\n\n\t\tset_root_cmap();\n\t\tif (root_cmap) {\n#if 0\n\t\t\tunsigned int hi;\n#endif\n\n\t\t\t/* line by line ... */\n\t\t\tfor (line = 0; line < h; line++) {\n\t\t\t\t/* pixel by pixel... */\n\t\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\t\tif (ps1 == 2) {\n\t\t\t\t\t\tus = (unsigned short *) (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*us);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuc = (unsigned char *)  (src + ps1 * j);\n\t\t\t\t\t\tidx = (int) (*uc);\n\t\t\t\t\t}\n\t\t\t\t\tui = (unsigned int *)  (dst + ps2 * j);\n\nif (0 && line % 100 == 0 && j % 32 == 0) fprintf(stderr, \"%d %d %u  x1=%d y1=%d\\n\", line, j, root_rgb[idx], x1, y1);\n#if 0\n\t\t\t\t\tif (do_hibits) {\n\t\t\t\t\t\thi = idx << 24;\n\t\t\t\t\t\t*ui = hi | rgb[0][idx];\n\t\t\t\t\t} else {\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t*ui = root_rgb[idx];\nif (db24 > 2) histo[idx]++;\n\t\t\t\t}\n\t\t\t\tsrc += main_bytes_per_line;\n\t\t\t\tdst += main_bytes_per_line * (4/ps1);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tif (last_map_count > MAX_8BPP_WINDOWS/4) {\n\t\t/* table is filling up... skip validating sometimes: */\n\t\tint skip = 3;\n\t\tif (last_map_count > MAX_8BPP_WINDOWS/2) {\n\t\t\tskip = 6;\n\t\t} else if (last_map_count > 3*MAX_8BPP_WINDOWS/4) {\n\t\t\tskip = 12;\n\t\t}\n\t\tif (call_count % skip != 0) {\n\t\t\tvalidate = 0;\n\t\t}\n\t}\n\nif (db24 > 2) {for(i=0;i<256;i++){histo[i]=0;}}\n\n\tnow = dnow();\n\tdt = now - last_get_8bpp_validate;\n\t/* TUNABLES  */\n\tif (dt < 0.003) {\n\t\t;\t/* XXX does this still give painting errors? */\n\t} else {\n\t\tint snapit = 0;\n\t\tdouble delay1, delay2, delay3;\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay1 = 1.0 * poll_8to24_delay;\n\t\t\tdelay2 = 2.0 * poll_8to24_delay;\n\t\t\tdelay3 = 10. * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay1 = 1.0 * POLL_8TO24_DELAY;\t/* 0.05 */\n\t\t\tdelay2 = 2.0 * POLL_8TO24_DELAY;\t/* 0.1  */\n\t\t\tdelay3 = 10. * POLL_8TO24_DELAY;\t/* 0.5  */\n\t\t}\n\t\tif (cache_win > 1.0) {\n\t\t\tdelay2 *= 2;\n\t\t\tdelay3 *= 2;\n\t\t}\n\t\tif (dt < delay1) {\n\t\t\tvalidate = 0;\n\t\t}\n\t\tif (last_map_count) {\n\t\t\tif (now > last_snapshot + delay2) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (now > last_snapshot + delay3) {\n\t\t\t\tsnapit = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (snapit) {\n\t\t\t/* less problems if we update the stack frequently */\n\t\t\tsnapshot_stack_list(0, 0.0);\nif (0) fprintf(stderr, \"SNAP time: %.4f\\n\", dnow() - now);\n\t\t\tupdate_stack_list();\n\t\t\tlast_snapshot = dnow();\nif (0) fprintf(stderr, \"UPDA time: %.4f\\n\", last_snapshot - now);\n\t\t}\n\nif (0) t2 = dnow();\n\t\tlast_map_count = get_8bpp_regions(validate);\n\t\tif (validate) {\n\t\t\tlast_get_8bpp_validate = dnow();\n\t\t}\nif (0) fprintf(stderr, \"get8bpp-%d: %.4f\\n\", validate, dnow() - t2);\n\t}\nif (db24) d0 = dnow();\n\nif (db24 > 1) fprintf(stderr, \"bpp8to24 w=%d h=%d m=%p c=%p r=%p ncmaps=%d\\n\", w, h, main_fb, cmap8to24_fb, rfb_fb, ncmaps);\n\n\t/*\n\t * now go back and transform and 8bpp regions to TrueColor in\n\t * cmap8to24_fb.\n\t */\n\tif (last_map_count && (ncmaps || depth <= 16)) {\n\t\tint i, j;\n\t\tint win[MAX_8BPP_WINDOWS];\n\t\tint did[MAX_8BPP_WINDOWS];\n\t\tint count = 0;\n\n\t\t/*\n\t\t * first, grab all of the associated colormaps from the\n\t\t * X server.  Hopefully just 1 or 2...\n\t\t */\n\t\tfor (j=0; j<ncmaps; j++) {\n\t\t\tif (! get_cmap(j, cmaps[j])) {\n\t\t\t\tcmap_failed[j] = 1;\n\t\t\t} else {\n\t\t\t\tcmap_failed[j] = 0;\n\t\t\t}\nif (db24 > 2) fprintf(stderr, \"cmap %d  %.4f\\n\", (int) cmaps[j], dnow() - d0);\n\t\t}\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\t\t\tif (reg) {\n\t\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t\tif (sraRgnAnd(rect, reg)) {\n\t\t\t\t\twin[count] = i;\n\t\t\t\t\tdid[count++] = 0;\n\t\t\t\t}\n\t\t\t\tsraRgnDestroy(rect);\n\t\t\t}\n\t\t}\n\n\t\tif (count) {\n\n\t\t\trect = sraRgnCreateRect(x1, y1, x2, y2);\n\t\t\t/* try to apply lower windows first */\n\t\t\tfor (k=0; k < stack_list_num; k++) {\n\t\t\t\tWindow swin = stack_list[k].win;\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tif (did[j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (windows_8bpp[i].top == swin) {\n\t\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\t\tdid[j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tif (! did[j]) {\n\t\t\t\t\ti = win[j];\n\t\t\t\t\tdo_8bpp_region(i, rect);\n\t\t\t\t\tdid[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsraRgnDestroy(rect);\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done time: %.4f\\n\", dnow() - d0);\n\nif (db24 > 2) {for(i=0; i<256;i++) {fprintf(stderr, \" cmap histo[%03d] %d\\n\", i, histo[i]);}}\n}"
  },
  {
    "function_name": "cmap_xi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1522-1549",
    "snippet": "static XImage *cmap_xi(XImage *xi, Window win, int win_depth) {\n#if NO_X11\n\tif (!xi || !win || !win_depth) {}\n\treturn NULL;\n#else\n\tXWindowAttributes attr;\n\tchar *d;\n\n\tif (xi) {\n\t\tXDestroyImage(xi);\n\t}\n\tif (! dpy || ! valid_window(win, &attr, 1)) {\n\t\treturn (XImage *) NULL;\n\t}\n\tif (win_depth == 24) {\n\t\td = (char *) malloc(dpy_x * dpy_y * 4);\n\t} else if (win_depth <= 16) {\n\t\tif (win_depth > 8) {\n\t\t\td = (char *) malloc(dpy_x * dpy_y * 2);\n\t\t} else {\n\t\t\td = (char *) malloc(dpy_x * dpy_y * 1);\n\t\t}\n\t} else {\n\t\treturn (XImage *) NULL;\n\t}\n\treturn XCreateImage(dpy, attr.visual, win_depth, ZPixmap, 0, d, dpy_x, dpy_y, 8, 0);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XCreateImage",
          "args": [
            "dpy",
            "attr.visual",
            "win_depth",
            "ZPixmap",
            "0",
            "d",
            "dpy_x",
            "dpy_y",
            "8",
            "0"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "XCreateImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "370-429",
          "snippet": "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int guess_bits_per_color(int bits_per_pixel);",
            "int XFlush_wr(Display *disp);",
            "Status XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint guess_bits_per_color(int bits_per_pixel);\nint XFlush_wr(Display *disp);\nStatus XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nint XFree_wr(void *data);\n\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_x * dpy_y * 1"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_x * dpy_y * 2"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_x * dpy_y * 4"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xi"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic XImage *cmap_xi(XImage *xi, Window win, int win_depth) {\n#if NO_X11\n\tif (!xi || !win || !win_depth) {}\n\treturn NULL;\n#else\n\tXWindowAttributes attr;\n\tchar *d;\n\n\tif (xi) {\n\t\tXDestroyImage(xi);\n\t}\n\tif (! dpy || ! valid_window(win, &attr, 1)) {\n\t\treturn (XImage *) NULL;\n\t}\n\tif (win_depth == 24) {\n\t\td = (char *) malloc(dpy_x * dpy_y * 4);\n\t} else if (win_depth <= 16) {\n\t\tif (win_depth > 8) {\n\t\t\td = (char *) malloc(dpy_x * dpy_y * 2);\n\t\t} else {\n\t\t\td = (char *) malloc(dpy_x * dpy_y * 1);\n\t\t}\n\t} else {\n\t\treturn (XImage *) NULL;\n\t}\n\treturn XCreateImage(dpy, attr.visual, win_depth, ZPixmap, 0, d, dpy_x, dpy_y, 8, 0);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "do_8bpp_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1464-1520",
    "snippet": "static void do_8bpp_region(int n, sraRegionPtr mark) {\n\tint k, cm = -1, failed = 0;\n\tsraRectangleIterator *iter;\n\tsraRegionPtr clip;\n\tsraRect rect;\n\n\tif (! windows_8bpp[n].clip_region) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].win == None) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db24 > 1) fprintf(stderr, \"ncmaps: %d\\n\", ncmaps);\n\n\t/* see if XQueryColors failed: */\n\tfor (k=0; k<ncmaps; k++) {\n\t\tif (windows_8bpp[n].cmap == cmaps[k]) {\n\t\t\tcm = k;\n\t\t\tif (cmap_failed[k]) {\n\t\t\t\tfailed = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (windows_8bpp[n].depth != 24) {\t/* 24 won't have a cmap */\n\t\tif (failed || cm == -1) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclip = sraRgnCreateRgn(mark);\n\tsraRgnAnd(clip, windows_8bpp[n].clip_region);\n\n\t/* loop over the rectangles making up region */\n\titer = sraRgnGetIterator(clip);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\n\t\ttransform_rect(rect, windows_8bpp[n].win,\n\t\t    windows_8bpp[n].depth, cm);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnDestroy(clip);\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "clip"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transform_rect",
          "args": [
            "rect",
            "windows_8bpp[n].win",
            "windows_8bpp[n].depth",
            "cm"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "clip"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "clip",
            "windows_8bpp[n].clip_region"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRgn",
          "args": [
            "mark"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ncmaps: %d\\n\"",
            "ncmaps"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void do_8bpp_region(int n, sraRegionPtr mark) {\n\tint k, cm = -1, failed = 0;\n\tsraRectangleIterator *iter;\n\tsraRegionPtr clip;\n\tsraRect rect;\n\n\tif (! windows_8bpp[n].clip_region) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].win == None) {\n\t\treturn;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn;\n\t}\nif (db24 > 1) fprintf(stderr, \"ncmaps: %d\\n\", ncmaps);\n\n\t/* see if XQueryColors failed: */\n\tfor (k=0; k<ncmaps; k++) {\n\t\tif (windows_8bpp[n].cmap == cmaps[k]) {\n\t\t\tcm = k;\n\t\t\tif (cmap_failed[k]) {\n\t\t\t\tfailed = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (windows_8bpp[n].depth != 24) {\t/* 24 won't have a cmap */\n\t\tif (failed || cm == -1) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclip = sraRgnCreateRgn(mark);\n\tsraRgnAnd(clip, windows_8bpp[n].clip_region);\n\n\t/* loop over the rectangles making up region */\n\titer = sraRgnGetIterator(clip);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tif (rect.x1 > rect.x2) {\n\t\t\tint tmp = rect.x2;\n\t\t\trect.x2 = rect.x1;\n\t\t\trect.x1 = tmp;\n\t\t}\n\t\tif (rect.y1 > rect.y2) {\n\t\t\tint tmp = rect.y2;\n\t\t\trect.y2 = rect.y1;\n\t\t\trect.y1 = tmp;\n\t\t}\n\n\t\ttransform_rect(rect, windows_8bpp[n].win,\n\t\t    windows_8bpp[n].depth, cm);\n\t}\n\tsraRgnReleaseIterator(iter);\n\tsraRgnDestroy(clip);\n}"
  },
  {
    "function_name": "get_cmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1367-1462",
    "snippet": "static int get_cmap(int j, Colormap cmap) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!j || !cmap) {}\n\treturn 0;\n#else\n\tint i, ncells, ncolor;\n\tXErrorHandler old_handler = NULL;\n\n\tRAWFB_RET(0)\n\n\tif (depth > 16) {\n\t\t/* 24 */\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\tif (!color_init) {\n\t\tint cm;\n\t\tfor (cm = 0; cm < CMAPMAX; cm++) {\n\t\t\tcolor[cm] = (XColor *) malloc(ncolor * sizeof(XColor));\n\t\t\trgb[cm] = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t\t}\n\t\tcolor_init = 1;\n\t}\n\n\tif (depth <= 16) {\n\t\t/* not working properly for depth 24... */\n\t\tX_LOCK;\n\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\tX_UNLOCK;\n\t} else {\n\t\tncells = NCOLOR;\n\t}\n\n\tif (depth > 16) {\n\t\t;\n\t} else if (ncells > ncolor) {\n\t\tncells = ncolor;\n\t} else if (ncells == 8 && depth != 3) {\n\t\t/* XXX. see set_colormap() */\n\t\tncells = 1 << depth;\n\t}\n\n\t/* initialize XColor array: */\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[j][i].pixel = i;\n\t\tcolor[j][i].pad = 0;\n\t}\nif (db24 > 1) fprintf(stderr, \"get_cmap: %d 0x%x ncolor=%d ncells=%d\\n\", j, (unsigned int) cmap, ncolor, ncells);\n\n\t/* try to query the colormap, trap errors */\n\tX_LOCK;\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tXQueryColors(dpy, cmap, color[j], ncells);\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tif (trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\t/* now map each index to depth 24 RGB */\n\tfor (i=0; i < ncells; i++) {\n\t\tunsigned int red, green, blue;\n\t\t/* strip out highest 8 bits of values: */\n\t\tred   = (color[j][i].red   & 0xff00) >> 8;\n\t\tgreen = (color[j][i].green & 0xff00) >> 8;\n\t\tblue  = (color[j][i].blue  & 0xff00) >> 8;\n\n\t\t/*\n\t\t * the maxes should be at 255 already,\n\t\t * but just in case...\n\t\t */\n\t\tred   = (main_red_max   * red  )/255;\n\t\tgreen = (main_green_max * green)/255;\n\t\tblue  = (main_blue_max  * blue )/255;\n\nif (db24 > 2) fprintf(stderr, \" cmap[%02d][%03d]: %03d %03d %03d  0x%08x \\n\", j, i, red, green, blue, ( red << main_red_shift | green << main_green_shift | blue << main_blue_shift));\n\n\t\t/* shift them over and or together for value */\n\t\tred   = red    << main_red_shift;\n\t\tgreen = green  << main_green_shift;\n\t\tblue  = blue   << main_blue_shift;\n\n\t\t/* store it in the array to be used later */\n\t\trgb[j][i] = red | green | blue;\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CMAPMAX 64",
      "#define NCOLOR 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" cmap[%02d][%03d]: %03d %03d %03d  0x%08x \\n\"",
            "j",
            "i",
            "red",
            "green",
            "blue",
            "( red << main_red_shift | green << main_green_shift | blue << main_blue_shift)"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryColors",
          "args": [
            "dpy",
            "cmap",
            "color[j]",
            "ncells"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_cmap: %d 0x%x ncolor=%d ncells=%d\\n\"",
            "j",
            "(unsigned int) cmap",
            "ncolor",
            "ncells"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CellsOfScreen",
          "args": [
            "ScreenOfDisplay(dpy, scr)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScreenOfDisplay",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ncolor * sizeof(unsigned int)"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ncolor * sizeof(XColor)"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CMAPMAX 64\n#define NCOLOR 256\n\nstatic int get_cmap(int j, Colormap cmap) {\n#if NO_X11\n\tRAWFB_RET(0)\n\tif (!j || !cmap) {}\n\treturn 0;\n#else\n\tint i, ncells, ncolor;\n\tXErrorHandler old_handler = NULL;\n\n\tRAWFB_RET(0)\n\n\tif (depth > 16) {\n\t\t/* 24 */\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\tif (!color_init) {\n\t\tint cm;\n\t\tfor (cm = 0; cm < CMAPMAX; cm++) {\n\t\t\tcolor[cm] = (XColor *) malloc(ncolor * sizeof(XColor));\n\t\t\trgb[cm] = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t\t}\n\t\tcolor_init = 1;\n\t}\n\n\tif (depth <= 16) {\n\t\t/* not working properly for depth 24... */\n\t\tX_LOCK;\n\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\tX_UNLOCK;\n\t} else {\n\t\tncells = NCOLOR;\n\t}\n\n\tif (depth > 16) {\n\t\t;\n\t} else if (ncells > ncolor) {\n\t\tncells = ncolor;\n\t} else if (ncells == 8 && depth != 3) {\n\t\t/* XXX. see set_colormap() */\n\t\tncells = 1 << depth;\n\t}\n\n\t/* initialize XColor array: */\n\tfor (i=0; i < ncells; i++) {\n\t\tcolor[j][i].pixel = i;\n\t\tcolor[j][i].pad = 0;\n\t}\nif (db24 > 1) fprintf(stderr, \"get_cmap: %d 0x%x ncolor=%d ncells=%d\\n\", j, (unsigned int) cmap, ncolor, ncells);\n\n\t/* try to query the colormap, trap errors */\n\tX_LOCK;\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tXQueryColors(dpy, cmap, color[j], ncells);\n\tXSetErrorHandler(old_handler);\n\tX_UNLOCK;\n\n\tif (trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\t/* now map each index to depth 24 RGB */\n\tfor (i=0; i < ncells; i++) {\n\t\tunsigned int red, green, blue;\n\t\t/* strip out highest 8 bits of values: */\n\t\tred   = (color[j][i].red   & 0xff00) >> 8;\n\t\tgreen = (color[j][i].green & 0xff00) >> 8;\n\t\tblue  = (color[j][i].blue  & 0xff00) >> 8;\n\n\t\t/*\n\t\t * the maxes should be at 255 already,\n\t\t * but just in case...\n\t\t */\n\t\tred   = (main_red_max   * red  )/255;\n\t\tgreen = (main_green_max * green)/255;\n\t\tblue  = (main_blue_max  * blue )/255;\n\nif (db24 > 2) fprintf(stderr, \" cmap[%02d][%03d]: %03d %03d %03d  0x%08x \\n\", j, i, red, green, blue, ( red << main_red_shift | green << main_green_shift | blue << main_blue_shift));\n\n\t\t/* shift them over and or together for value */\n\t\tred   = red    << main_red_shift;\n\t\tgreen = green  << main_green_shift;\n\t\tblue  = blue   << main_blue_shift;\n\n\t\t/* store it in the array to be used later */\n\t\trgb[j][i] = red | green | blue;\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "get_8bpp_regions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1208-1359",
    "snippet": "static int get_8bpp_regions(int validate) {\n\n\tXWindowAttributes attr;\n\tint i, k, mapcount = 0;\n\n\t/* initialize color map list */\n\tncmaps = 0;\n\tfor (i=0; i < CMAPMAX; i++) {\n\t\tcmaps[i] = (Colormap) 0;\n\t}\n\n\t/* loop over the table of 8bpp windows: */\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr tmp_reg, tmp_reg2;\n\t\tWindow c, w = windows_8bpp[i].win;\n\t\tint x, y;\n\n\t\tif (windows_8bpp[i].clip_region) {\n\t\t\tsraRgnDestroy(windows_8bpp[i].clip_region);\t\n\t\t}\n\t\twindows_8bpp[i].clip_region = NULL;\n\n\t\tif (w == None) {\n\t\t\tcontinue;\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"get_8bpp_regions: 0x%lx ms=%d dep=%d i=%d\\n\", w, windows_8bpp[i].map_state, windows_8bpp[i].depth, i);\n\t\tif (validate) {\n\t\t\t/*\n\t\t\t * this could be slow: validating 8bpp windows each\n\t\t\t * time...\n\t\t\t */\n\n\t\t\tX_LOCK;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\tX_UNLOCK;\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\twindows_8bpp[i].depth = attr.depth;\n\t\t\twindows_8bpp[i].map_state = attr.map_state;\n\t\t\twindows_8bpp[i].cmap = attr.colormap;\n\t\t\twindows_8bpp[i].map_installed = attr.map_installed;\n\t\t\twindows_8bpp[i].w = attr.width;\n\t\t\twindows_8bpp[i].h = attr.height;\n\t\t\twindows_8bpp[i].fetched = 1;\n\t\t\twindows_8bpp[i].last_fetched = dnow();\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tX_LOCK;\n\t\t\txtranslate(w, window, 0, 0, &x, &y, &c, 1);\n\t\t\tX_UNLOCK;\n\t\t\twindows_8bpp[i].x = x;\n\t\t\twindows_8bpp[i].y = y;\n\n\t\t} else {\n\t\t\t/* this will be faster: no call to X server: */\n\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattr.depth = windows_8bpp[i].depth;\n\t\t\tattr.map_state = windows_8bpp[i].map_state;\n\t\t\tattr.colormap = windows_8bpp[i].cmap;\n\t\t\tattr.map_installed = windows_8bpp[i].map_installed;\n\t\t\tattr.width = windows_8bpp[i].w;\n\t\t\tattr.height = windows_8bpp[i].h;\n\n\t\t\tx =  windows_8bpp[i].x; \n\t\t\ty =  windows_8bpp[i].y; \n\t\t}\n\n\t\tmapcount++;\n\n\t\t/* tmp region for this 8bpp rectangle: */\n\t\ttmp_reg = sraRgnCreateRect(nfix(x, dpy_x), nfix(y, dpy_y),\n\t\t    nfix(x + attr.width, dpy_x+1), nfix(y + attr.height, dpy_y+1));\n\n\t\t/* loop over all toplevels, top to bottom clipping: */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tint sx, sy, sw, sh;\n\nif (db24 > 1 && stack_list[k].map_state == IsViewable) fprintf(stderr, \"Stack win: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\n\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t/* found our top level: we skip the rest. */\nif (db24 > 1) fprintf(stderr, \"found top: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\t\t/* skip unmapped ones: */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* make a temp rect for this toplevel: */\n\t\t\tsx = stack_list[k].x;\n\t\t\tsy = stack_list[k].y;\n\t\t\tsw = stack_list[k].width;\n\t\t\tsh = stack_list[k].height;\n\nif (db24 > 1) fprintf(stderr, \"subtract:  0x%lx %d -- %d %d %d %d\\n\", swin, k, sx, sy, sw, sh);\n\n\t\t\ttmp_reg2 = sraRgnCreateRect(nfix(sx, dpy_x),\n\t\t\t    nfix(sy, dpy_y), nfix(sx + sw, dpy_x+1),\n\t\t\t    nfix(sy + sh, dpy_y+1));\n\n\t\t\t/* subtract it from the 8bpp window region */\n\t\t\tsraRgnSubtract(tmp_reg, tmp_reg2);\n\n\t\t\tsraRgnDestroy(tmp_reg2);\n\n\t\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t/* skip this 8bpp if completely clipped away: */\n\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, store any new colormaps: */\n\t\tif (ncmaps < CMAPMAX && attr.colormap != (Colormap) 0) {\n\t\t\tint m, seen = 0;\n\t\t\tfor (m=0; m < ncmaps; m++) {\n\t\t\t\tif (cmaps[m] == attr.colormap) {\n\t\t\t\t\tseen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seen && attr.depth <= 16) {\n\t\t\t\t/* store only new ones: */\n\t\t\t\tcmaps[ncmaps++] = attr.colormap;\n\t\t\t}\n\t\t}\n\n\t\twindows_8bpp[i].clip_region = tmp_reg;\n\t}\n\n\treturn mapcount;\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define CMAPMAX 64",
      "#define MAX_8BPP_WINDOWS 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_reg"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "tmp_reg"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "tmp_reg"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmp_reg2"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "tmp_reg",
            "tmp_reg2"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "nfix(sx, dpy_x)",
            "nfix(sy, dpy_y)",
            "nfix(sx + sw, dpy_x+1)",
            "nfix(sy + sh, dpy_y+1)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "sy + sh",
            "dpy_y+1"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"subtract:  0x%lx %d -- %d %d %d %d\\n\"",
            "swin",
            "k",
            "sx",
            "sy",
            "sw",
            "sh"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"found top: 0x%lx %d iv=%d\\n\"",
            "swin",
            "k",
            "stack_list[k].map_state"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Stack win: 0x%lx %d iv=%d\\n\"",
            "swin",
            "k",
            "stack_list[k].map_state"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "nfix(x, dpy_x)",
            "nfix(y, dpy_y)",
            "nfix(x + attr.width, dpy_x+1)",
            "nfix(y + attr.height, dpy_y+1)"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtranslate",
          "args": [
            "w",
            "window",
            "0",
            "0",
            "&x",
            "&y",
            "&c",
            "1"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "xtranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "142-173",
          "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "w",
            "&attr",
            "1"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"get_8bpp_regions: 0x%lx ms=%d dep=%d i=%d\\n\"",
            "w",
            "windows_8bpp[i].map_state",
            "windows_8bpp[i].depth",
            "i"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "windows_8bpp[i].clip_region"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CMAPMAX 64\n#define MAX_8BPP_WINDOWS 64\n\nstatic int get_8bpp_regions(int validate) {\n\n\tXWindowAttributes attr;\n\tint i, k, mapcount = 0;\n\n\t/* initialize color map list */\n\tncmaps = 0;\n\tfor (i=0; i < CMAPMAX; i++) {\n\t\tcmaps[i] = (Colormap) 0;\n\t}\n\n\t/* loop over the table of 8bpp windows: */\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr tmp_reg, tmp_reg2;\n\t\tWindow c, w = windows_8bpp[i].win;\n\t\tint x, y;\n\n\t\tif (windows_8bpp[i].clip_region) {\n\t\t\tsraRgnDestroy(windows_8bpp[i].clip_region);\t\n\t\t}\n\t\twindows_8bpp[i].clip_region = NULL;\n\n\t\tif (w == None) {\n\t\t\tcontinue;\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"get_8bpp_regions: 0x%lx ms=%d dep=%d i=%d\\n\", w, windows_8bpp[i].map_state, windows_8bpp[i].depth, i);\n\t\tif (validate) {\n\t\t\t/*\n\t\t\t * this could be slow: validating 8bpp windows each\n\t\t\t * time...\n\t\t\t */\n\n\t\t\tX_LOCK;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\tX_UNLOCK;\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\twindows_8bpp[i].depth = attr.depth;\n\t\t\twindows_8bpp[i].map_state = attr.map_state;\n\t\t\twindows_8bpp[i].cmap = attr.colormap;\n\t\t\twindows_8bpp[i].map_installed = attr.map_installed;\n\t\t\twindows_8bpp[i].w = attr.width;\n\t\t\twindows_8bpp[i].h = attr.height;\n\t\t\twindows_8bpp[i].fetched = 1;\n\t\t\twindows_8bpp[i].last_fetched = dnow();\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tX_LOCK;\n\t\t\txtranslate(w, window, 0, 0, &x, &y, &c, 1);\n\t\t\tX_UNLOCK;\n\t\t\twindows_8bpp[i].x = x;\n\t\t\twindows_8bpp[i].y = y;\n\n\t\t} else {\n\t\t\t/* this will be faster: no call to X server: */\n\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattr.depth = windows_8bpp[i].depth;\n\t\t\tattr.map_state = windows_8bpp[i].map_state;\n\t\t\tattr.colormap = windows_8bpp[i].cmap;\n\t\t\tattr.map_installed = windows_8bpp[i].map_installed;\n\t\t\tattr.width = windows_8bpp[i].w;\n\t\t\tattr.height = windows_8bpp[i].h;\n\n\t\t\tx =  windows_8bpp[i].x; \n\t\t\ty =  windows_8bpp[i].y; \n\t\t}\n\n\t\tmapcount++;\n\n\t\t/* tmp region for this 8bpp rectangle: */\n\t\ttmp_reg = sraRgnCreateRect(nfix(x, dpy_x), nfix(y, dpy_y),\n\t\t    nfix(x + attr.width, dpy_x+1), nfix(y + attr.height, dpy_y+1));\n\n\t\t/* loop over all toplevels, top to bottom clipping: */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tint sx, sy, sw, sh;\n\nif (db24 > 1 && stack_list[k].map_state == IsViewable) fprintf(stderr, \"Stack win: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\n\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t/* found our top level: we skip the rest. */\nif (db24 > 1) fprintf(stderr, \"found top: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\t\t/* skip unmapped ones: */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* make a temp rect for this toplevel: */\n\t\t\tsx = stack_list[k].x;\n\t\t\tsy = stack_list[k].y;\n\t\t\tsw = stack_list[k].width;\n\t\t\tsh = stack_list[k].height;\n\nif (db24 > 1) fprintf(stderr, \"subtract:  0x%lx %d -- %d %d %d %d\\n\", swin, k, sx, sy, sw, sh);\n\n\t\t\ttmp_reg2 = sraRgnCreateRect(nfix(sx, dpy_x),\n\t\t\t    nfix(sy, dpy_y), nfix(sx + sw, dpy_x+1),\n\t\t\t    nfix(sy + sh, dpy_y+1));\n\n\t\t\t/* subtract it from the 8bpp window region */\n\t\t\tsraRgnSubtract(tmp_reg, tmp_reg2);\n\n\t\t\tsraRgnDestroy(tmp_reg2);\n\n\t\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t/* skip this 8bpp if completely clipped away: */\n\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, store any new colormaps: */\n\t\tif (ncmaps < CMAPMAX && attr.colormap != (Colormap) 0) {\n\t\t\tint m, seen = 0;\n\t\t\tfor (m=0; m < ncmaps; m++) {\n\t\t\t\tif (cmaps[m] == attr.colormap) {\n\t\t\t\t\tseen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seen && attr.depth <= 16) {\n\t\t\t\t/* store only new ones: */\n\t\t\t\tcmaps[ncmaps++] = attr.colormap;\n\t\t\t}\n\t\t}\n\n\t\twindows_8bpp[i].clip_region = tmp_reg;\n\t}\n\n\treturn mapcount;\n}"
  },
  {
    "function_name": "mark_rgn_rects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1189-1206",
    "snippet": "static void mark_rgn_rects(sraRegionPtr mod) {\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint area = 0;\n\n\tif (sraRgnEmpty(mod)) {\n\t\treturn;\n\t}\n\t\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tmark_rect_as_modified(rect.x1, rect.y1, rect.x2, rect.y2, 0);\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\nif (db24 > 1) fprintf(stderr, \" mark_rgn_rects area: %d\\n\", area);\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" mark_rgn_rects area: %d\\n\"",
            "area"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "(rect.x2 - rect.x1)*(rect.y2 - rect.y1)"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "rect.x1",
            "rect.y1",
            "rect.x2",
            "rect.y2",
            "0"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "mod"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "mod"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void mark_rgn_rects(sraRegionPtr mod) {\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint area = 0;\n\n\tif (sraRgnEmpty(mod)) {\n\t\treturn;\n\t}\n\t\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tmark_rect_as_modified(rect.x1, rect.y1, rect.x2, rect.y2, 0);\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\nif (db24 > 1) fprintf(stderr, \" mark_rgn_rects area: %d\\n\", area);\n}"
  },
  {
    "function_name": "poll_8bpp_complement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1145-1187",
    "snippet": "static void poll_8bpp_complement(sraRegionPtr mod) {\n\tint i, y, ysh;\n\tstatic int ycnt = 0;\n\tsraRegionPtr disp, line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\n\tdisp = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tysh = scanlines[(ycnt++) % NSCAN];\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tcontinue;\t\n\t\t}\n\t\tsraRgnSubtract(disp, reg);\n\t}\n\n\ty = ysh;\n\twhile (y < dpy_y) {\n\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\tif (sraRgnAnd(line, disp)) {\n\t\t\titer = sraRgnGetIterator(line);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\tpoll_line_complement(rect.x1, rect.x2,\n\t\t\t\t    rect.y1, mod);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\t\t}\n\n\t\tsraRgnDestroy(line);\n\n\t\ty += NSCAN;\n\t}\n\n\tsraRgnDestroy(disp);\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MAX_8BPP_WINDOWS 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "disp"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "line"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_line_complement",
          "args": [
            "rect.x1",
            "rect.x2",
            "rect.y1",
            "mod"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "poll_line_complement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1006-1078",
          "snippet": "static void poll_line_complement(int x1, int x2, int y1, sraRegionPtr mod) {\n\tint n_off, w, xl, xh, stride = 32;\n\tchar *dst, *src;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tif (depth != 24) {\n\t\treturn;\n\t}\n\tif (! cmap8to24_fb) {\n\t\treturn;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn;\n\t}\n\n\tn_off = main_bytes_per_line * y1 + 4 * x1;\n\n\tsrc = main_fb + n_off;\n\tdst = cmap8to24_fb + n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw = xh - xl;\n\t\tif (memcmp(dst, src, 4 * w)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += 4 * stride;\n\t\tsrc += 4 * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\n\t\tinrun = 0;\n\t}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void poll_line_complement(int x1, int x2, int y1, sraRegionPtr mod) {\n\tint n_off, w, xl, xh, stride = 32;\n\tchar *dst, *src;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tif (depth != 24) {\n\t\treturn;\n\t}\n\tif (! cmap8to24_fb) {\n\t\treturn;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn;\n\t}\n\n\tn_off = main_bytes_per_line * y1 + 4 * x1;\n\n\tsrc = main_fb + n_off;\n\tdst = cmap8to24_fb + n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw = xh - xl;\n\t\tif (memcmp(dst, src, 4 * w)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += 4 * stride;\n\t\tsrc += 4 * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\n\t\tinrun = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "line"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "line",
            "disp"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "y",
            "dpy_x",
            "y+1"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnSubtract",
          "args": [
            "disp",
            "reg"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nstatic void poll_8bpp_complement(sraRegionPtr mod) {\n\tint i, y, ysh;\n\tstatic int ycnt = 0;\n\tsraRegionPtr disp, line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\n\tdisp = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tysh = scanlines[(ycnt++) % NSCAN];\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tcontinue;\t\n\t\t}\n\t\tsraRgnSubtract(disp, reg);\n\t}\n\n\ty = ysh;\n\twhile (y < dpy_y) {\n\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\tif (sraRgnAnd(line, disp)) {\n\t\t\titer = sraRgnGetIterator(line);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\tpoll_line_complement(rect.x1, rect.x2,\n\t\t\t\t    rect.y1, mod);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\t\t}\n\n\t\tsraRgnDestroy(line);\n\n\t\ty += NSCAN;\n\t}\n\n\tsraRgnDestroy(disp);\n}"
  },
  {
    "function_name": "poll_8bpp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1084-1143",
    "snippet": "static int poll_8bpp(sraRegionPtr mod, int validate) {\n\tint i, y, ysh, map_count;\n\tstatic int ycnt = 0;\n\tsraRegionPtr line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint br = 0, area = 0;\n\tstatic double last_call = 0.0;\n\t\n\tmap_count = get_8bpp_regions(validate);\n\nif (db24 > 1) fprintf(stderr, \"poll_8bpp mc: %d\\n\", map_count);\n\n\tif (! map_count) {\n\t\treturn 0;\n\t}\n\n\tset_poll_fb();\n\n\tysh = scanlines[(ycnt++) % NSCAN];\nif (db24 > 2) fprintf(stderr, \"poll_8bpp: ysh: %2d  %.4f\\n\", ysh, dnow() - last_call);\n\tlast_call = dnow();\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg || sraRgnEmpty(reg)) {\n\t\t\tcontinue;\n\t\t}\n\t\ty = ysh;\n\t\twhile (y < dpy_y) {\n\t\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\t\tif (sraRgnAnd(line, reg)) {\n\t\t\t\titer = sraRgnGetIterator(line);\n\t\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t\tif (! poll_line(rect.x1, rect.x2,\n\t\t\t\t\t    rect.y1, i, mod)) {\n\t\t\t\t\t\tbr = 1;\n\t\t\t\t\t\tbreak;\t/* exception */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsraRgnReleaseIterator(iter);\n\t\t\t}\n\n\t\t\tsraRgnDestroy(line);\n\t\t\ty += NSCAN;\n\t\t\tif (br) break;\n\t\t}\n\t\tif (br) break;\n\t}\n\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\n\treturn area;\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MAX_8BPP_WINDOWS 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nabs",
          "args": [
            "(rect.x2 - rect.x1)*(rect.y2 - rect.y1)"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "nabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "120-126",
          "snippet": "int nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nabs(int n) {\n\tif (n < 0) {\n\t\treturn -n;\n\t} else {\n\t\treturn n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "mod"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "line"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnReleaseIterator",
          "args": [
            "iter"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_line",
          "args": [
            "rect.x1",
            "rect.x2",
            "rect.y1",
            "i",
            "mod"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "poll_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "848-1004",
          "snippet": "static int poll_line(int x1, int x2, int y1, int n, sraRegionPtr mod) {\n#if NO_X11\n\tRAWFB_RET(1)\n\tif (!x1 || !x2 || !y1 || !n || !mod) {}\n\treturn 1;\n#else\n\tint fac, n_off, w, xo, yo;\n\tchar *poll_fb, *dst, *src;\n\tint w2, xl, xh, stride = 32;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\n\tstatic XImage *xi8 = NULL, *xi24 = NULL, *xi_r;\n\tstatic int xi8_w = 0, xi24_w = 0;\n\n\tXErrorHandler old_handler = NULL;\n\tXImage *xi;\n\tWindow c, win = windows_8bpp[n].win;\n\n\tstatic XWindowAttributes attr;\n\tstatic Window last_win = None; \n\tstatic double last_time = 0.0;\n\tdouble now;\n\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tRAWFB_RET(1)\n\n\tif (win == None) {\n\t\treturn 1;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn 1;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tnow = dnow();\n\tif (last_win != None && win == last_win && now < last_time + 0.5) {\n\t\t;\t/* use previous attr */\n\t} else {\n\t\tif (! valid_window(win, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\tlast_win = None;\n\t\t\treturn 0;\n\t\t}\n\t\tlast_time = now;\n\t\tlast_win = win;\n\t}\n\n\tif (attr.depth > 16 && attr.depth != 24) {\n\t\tX_UNLOCK;\n\t\treturn 1;\n\t} else if (attr.depth <= 16) {\n\t\txi = xi8 = p_xi(xi8, attr.visual, attr.depth, &xi8_w);\n\n\t\tpoll_fb = poll8_fb;\n\t\tif (attr.depth > 8) {\n\t\t\tfac = 2;\n\t\t} else {\n\t\t\tfac = 1;\n\t\t}\n\t\tn_off = poll8_fb_w * y1 + x1;\n\t} else {\n\t\txi = xi24 = p_xi(xi24, attr.visual, 24, &xi24_w);\n\n\t\tpoll_fb = poll24_fb;\n\t\tfac = 4;\n\t\tn_off = poll24_fb_w * y1 + x1;\n\t}\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\t/* xtranslate() not used to save two XSetErrorHandler calls */\n\tXTranslateCoordinates(dpy, win, window, 0, 0, &xo, &yo, &c);\n\n\txo = x1 - xo;\n\tyo = y1 - yo;\n\tw = x2 - x1;\n\n\tif (trapped_xerror || xo < 0 || yo < 0 || xo + w > attr.width) {\nif (db24 > 2) fprintf(stderr, \"avoid bad match...\\n\");\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\ttrapped_xerror = 0;\n\txi_r = XGetSubImage(dpy, win, xo, yo, w, 1, AllPlanes, ZPixmap, xi,\n\t    0, 0);\n\tXSetErrorHandler(old_handler);\n\n\tX_UNLOCK;\n\n\tif (! xi_r || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\tsrc = xi->data;\n\tdst = poll_fb + fac * n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw2 = xh - xl;\n\t\tif (memcmp(dst, src, fac * w2)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += fac * stride;\n\t\tsrc += fac * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int poll_line(int x1, int x2, int y1, int n, sraRegionPtr mod) {\n#if NO_X11\n\tRAWFB_RET(1)\n\tif (!x1 || !x2 || !y1 || !n || !mod) {}\n\treturn 1;\n#else\n\tint fac, n_off, w, xo, yo;\n\tchar *poll_fb, *dst, *src;\n\tint w2, xl, xh, stride = 32;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\n\tstatic XImage *xi8 = NULL, *xi24 = NULL, *xi_r;\n\tstatic int xi8_w = 0, xi24_w = 0;\n\n\tXErrorHandler old_handler = NULL;\n\tXImage *xi;\n\tWindow c, win = windows_8bpp[n].win;\n\n\tstatic XWindowAttributes attr;\n\tstatic Window last_win = None; \n\tstatic double last_time = 0.0;\n\tdouble now;\n\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tRAWFB_RET(1)\n\n\tif (win == None) {\n\t\treturn 1;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn 1;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tnow = dnow();\n\tif (last_win != None && win == last_win && now < last_time + 0.5) {\n\t\t;\t/* use previous attr */\n\t} else {\n\t\tif (! valid_window(win, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\tlast_win = None;\n\t\t\treturn 0;\n\t\t}\n\t\tlast_time = now;\n\t\tlast_win = win;\n\t}\n\n\tif (attr.depth > 16 && attr.depth != 24) {\n\t\tX_UNLOCK;\n\t\treturn 1;\n\t} else if (attr.depth <= 16) {\n\t\txi = xi8 = p_xi(xi8, attr.visual, attr.depth, &xi8_w);\n\n\t\tpoll_fb = poll8_fb;\n\t\tif (attr.depth > 8) {\n\t\t\tfac = 2;\n\t\t} else {\n\t\t\tfac = 1;\n\t\t}\n\t\tn_off = poll8_fb_w * y1 + x1;\n\t} else {\n\t\txi = xi24 = p_xi(xi24, attr.visual, 24, &xi24_w);\n\n\t\tpoll_fb = poll24_fb;\n\t\tfac = 4;\n\t\tn_off = poll24_fb_w * y1 + x1;\n\t}\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\t/* xtranslate() not used to save two XSetErrorHandler calls */\n\tXTranslateCoordinates(dpy, win, window, 0, 0, &xo, &yo, &c);\n\n\txo = x1 - xo;\n\tyo = y1 - yo;\n\tw = x2 - x1;\n\n\tif (trapped_xerror || xo < 0 || yo < 0 || xo + w > attr.width) {\nif (db24 > 2) fprintf(stderr, \"avoid bad match...\\n\");\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\ttrapped_xerror = 0;\n\txi_r = XGetSubImage(dpy, win, xo, yo, w, 1, AllPlanes, ZPixmap, xi,\n\t    0, 0);\n\tXSetErrorHandler(old_handler);\n\n\tX_UNLOCK;\n\n\tif (! xi_r || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\tsrc = xi->data;\n\tdst = poll_fb + fac * n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw2 = xh - xl;\n\t\tif (memcmp(dst, src, fac * w2)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += fac * stride;\n\t\tsrc += fac * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnIteratorNext",
          "args": [
            "iter",
            "&rect"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnGetIterator",
          "args": [
            "line"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "line",
            "reg"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "y",
            "dpy_x",
            "y+1"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "reg"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"poll_8bpp: ysh: %2d  %.4f\\n\"",
            "ysh",
            "dnow() - last_call"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_poll_fb",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "set_poll_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "285-297",
          "snippet": "static void set_poll_fb(void) {\n\t/* create polling framebuffers or recreate if too small. */\n\n\tif (! xgetimage_8to24) {\n\t\treturn;\t\t/* this saves a bit of RAM */\n\t}\n\tpfb(4, &poll24_fb, &poll24_fb_w, &poll24_fb_h);\n\tif (depth > 8 && depth <= 16) {\n\t\tpfb(2, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\t/* 2X for rare 16bpp colormap case */\n\t} else {\n\t\tpfb(1, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\n\t}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_poll_fb(void) {\n\t/* create polling framebuffers or recreate if too small. */\n\n\tif (! xgetimage_8to24) {\n\t\treturn;\t\t/* this saves a bit of RAM */\n\t}\n\tpfb(4, &poll24_fb, &poll24_fb_w, &poll24_fb_h);\n\tif (depth > 8 && depth <= 16) {\n\t\tpfb(2, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\t/* 2X for rare 16bpp colormap case */\n\t} else {\n\t\tpfb(1, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"poll_8bpp mc: %d\\n\"",
            "map_count"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_8bpp_regions",
          "args": [
            "validate"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "get_8bpp_regions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1208-1359",
          "snippet": "static int get_8bpp_regions(int validate) {\n\n\tXWindowAttributes attr;\n\tint i, k, mapcount = 0;\n\n\t/* initialize color map list */\n\tncmaps = 0;\n\tfor (i=0; i < CMAPMAX; i++) {\n\t\tcmaps[i] = (Colormap) 0;\n\t}\n\n\t/* loop over the table of 8bpp windows: */\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr tmp_reg, tmp_reg2;\n\t\tWindow c, w = windows_8bpp[i].win;\n\t\tint x, y;\n\n\t\tif (windows_8bpp[i].clip_region) {\n\t\t\tsraRgnDestroy(windows_8bpp[i].clip_region);\t\n\t\t}\n\t\twindows_8bpp[i].clip_region = NULL;\n\n\t\tif (w == None) {\n\t\t\tcontinue;\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"get_8bpp_regions: 0x%lx ms=%d dep=%d i=%d\\n\", w, windows_8bpp[i].map_state, windows_8bpp[i].depth, i);\n\t\tif (validate) {\n\t\t\t/*\n\t\t\t * this could be slow: validating 8bpp windows each\n\t\t\t * time...\n\t\t\t */\n\n\t\t\tX_LOCK;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\tX_UNLOCK;\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\twindows_8bpp[i].depth = attr.depth;\n\t\t\twindows_8bpp[i].map_state = attr.map_state;\n\t\t\twindows_8bpp[i].cmap = attr.colormap;\n\t\t\twindows_8bpp[i].map_installed = attr.map_installed;\n\t\t\twindows_8bpp[i].w = attr.width;\n\t\t\twindows_8bpp[i].h = attr.height;\n\t\t\twindows_8bpp[i].fetched = 1;\n\t\t\twindows_8bpp[i].last_fetched = dnow();\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tX_LOCK;\n\t\t\txtranslate(w, window, 0, 0, &x, &y, &c, 1);\n\t\t\tX_UNLOCK;\n\t\t\twindows_8bpp[i].x = x;\n\t\t\twindows_8bpp[i].y = y;\n\n\t\t} else {\n\t\t\t/* this will be faster: no call to X server: */\n\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattr.depth = windows_8bpp[i].depth;\n\t\t\tattr.map_state = windows_8bpp[i].map_state;\n\t\t\tattr.colormap = windows_8bpp[i].cmap;\n\t\t\tattr.map_installed = windows_8bpp[i].map_installed;\n\t\t\tattr.width = windows_8bpp[i].w;\n\t\t\tattr.height = windows_8bpp[i].h;\n\n\t\t\tx =  windows_8bpp[i].x; \n\t\t\ty =  windows_8bpp[i].y; \n\t\t}\n\n\t\tmapcount++;\n\n\t\t/* tmp region for this 8bpp rectangle: */\n\t\ttmp_reg = sraRgnCreateRect(nfix(x, dpy_x), nfix(y, dpy_y),\n\t\t    nfix(x + attr.width, dpy_x+1), nfix(y + attr.height, dpy_y+1));\n\n\t\t/* loop over all toplevels, top to bottom clipping: */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tint sx, sy, sw, sh;\n\nif (db24 > 1 && stack_list[k].map_state == IsViewable) fprintf(stderr, \"Stack win: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\n\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t/* found our top level: we skip the rest. */\nif (db24 > 1) fprintf(stderr, \"found top: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\t\t/* skip unmapped ones: */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* make a temp rect for this toplevel: */\n\t\t\tsx = stack_list[k].x;\n\t\t\tsy = stack_list[k].y;\n\t\t\tsw = stack_list[k].width;\n\t\t\tsh = stack_list[k].height;\n\nif (db24 > 1) fprintf(stderr, \"subtract:  0x%lx %d -- %d %d %d %d\\n\", swin, k, sx, sy, sw, sh);\n\n\t\t\ttmp_reg2 = sraRgnCreateRect(nfix(sx, dpy_x),\n\t\t\t    nfix(sy, dpy_y), nfix(sx + sw, dpy_x+1),\n\t\t\t    nfix(sy + sh, dpy_y+1));\n\n\t\t\t/* subtract it from the 8bpp window region */\n\t\t\tsraRgnSubtract(tmp_reg, tmp_reg2);\n\n\t\t\tsraRgnDestroy(tmp_reg2);\n\n\t\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t/* skip this 8bpp if completely clipped away: */\n\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, store any new colormaps: */\n\t\tif (ncmaps < CMAPMAX && attr.colormap != (Colormap) 0) {\n\t\t\tint m, seen = 0;\n\t\t\tfor (m=0; m < ncmaps; m++) {\n\t\t\t\tif (cmaps[m] == attr.colormap) {\n\t\t\t\t\tseen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seen && attr.depth <= 16) {\n\t\t\t\t/* store only new ones: */\n\t\t\t\tcmaps[ncmaps++] = attr.colormap;\n\t\t\t}\n\t\t}\n\n\t\twindows_8bpp[i].clip_region = tmp_reg;\n\t}\n\n\treturn mapcount;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define CMAPMAX 64",
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define CMAPMAX 64\n#define MAX_8BPP_WINDOWS 64\n\nstatic int get_8bpp_regions(int validate) {\n\n\tXWindowAttributes attr;\n\tint i, k, mapcount = 0;\n\n\t/* initialize color map list */\n\tncmaps = 0;\n\tfor (i=0; i < CMAPMAX; i++) {\n\t\tcmaps[i] = (Colormap) 0;\n\t}\n\n\t/* loop over the table of 8bpp windows: */\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr tmp_reg, tmp_reg2;\n\t\tWindow c, w = windows_8bpp[i].win;\n\t\tint x, y;\n\n\t\tif (windows_8bpp[i].clip_region) {\n\t\t\tsraRgnDestroy(windows_8bpp[i].clip_region);\t\n\t\t}\n\t\twindows_8bpp[i].clip_region = NULL;\n\n\t\tif (w == None) {\n\t\t\tcontinue;\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"get_8bpp_regions: 0x%lx ms=%d dep=%d i=%d\\n\", w, windows_8bpp[i].map_state, windows_8bpp[i].depth, i);\n\t\tif (validate) {\n\t\t\t/*\n\t\t\t * this could be slow: validating 8bpp windows each\n\t\t\t * time...\n\t\t\t */\n\n\t\t\tX_LOCK;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\tX_UNLOCK;\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tX_UNLOCK;\n\n\t\t\twindows_8bpp[i].depth = attr.depth;\n\t\t\twindows_8bpp[i].map_state = attr.map_state;\n\t\t\twindows_8bpp[i].cmap = attr.colormap;\n\t\t\twindows_8bpp[i].map_installed = attr.map_installed;\n\t\t\twindows_8bpp[i].w = attr.width;\n\t\t\twindows_8bpp[i].h = attr.height;\n\t\t\twindows_8bpp[i].fetched = 1;\n\t\t\twindows_8bpp[i].last_fetched = dnow();\n\n\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tX_LOCK;\n\t\t\txtranslate(w, window, 0, 0, &x, &y, &c, 1);\n\t\t\tX_UNLOCK;\n\t\t\twindows_8bpp[i].x = x;\n\t\t\twindows_8bpp[i].y = y;\n\n\t\t} else {\n\t\t\t/* this will be faster: no call to X server: */\n\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tattr.depth = windows_8bpp[i].depth;\n\t\t\tattr.map_state = windows_8bpp[i].map_state;\n\t\t\tattr.colormap = windows_8bpp[i].cmap;\n\t\t\tattr.map_installed = windows_8bpp[i].map_installed;\n\t\t\tattr.width = windows_8bpp[i].w;\n\t\t\tattr.height = windows_8bpp[i].h;\n\n\t\t\tx =  windows_8bpp[i].x; \n\t\t\ty =  windows_8bpp[i].y; \n\t\t}\n\n\t\tmapcount++;\n\n\t\t/* tmp region for this 8bpp rectangle: */\n\t\ttmp_reg = sraRgnCreateRect(nfix(x, dpy_x), nfix(y, dpy_y),\n\t\t    nfix(x + attr.width, dpy_x+1), nfix(y + attr.height, dpy_y+1));\n\n\t\t/* loop over all toplevels, top to bottom clipping: */\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tint sx, sy, sw, sh;\n\nif (db24 > 1 && stack_list[k].map_state == IsViewable) fprintf(stderr, \"Stack win: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\n\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t/* found our top level: we skip the rest. */\nif (db24 > 1) fprintf(stderr, \"found top: 0x%lx %d iv=%d\\n\", swin, k, stack_list[k].map_state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\t\t/* skip unmapped ones: */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* make a temp rect for this toplevel: */\n\t\t\tsx = stack_list[k].x;\n\t\t\tsy = stack_list[k].y;\n\t\t\tsw = stack_list[k].width;\n\t\t\tsh = stack_list[k].height;\n\nif (db24 > 1) fprintf(stderr, \"subtract:  0x%lx %d -- %d %d %d %d\\n\", swin, k, sx, sy, sw, sh);\n\n\t\t\ttmp_reg2 = sraRgnCreateRect(nfix(sx, dpy_x),\n\t\t\t    nfix(sy, dpy_y), nfix(sx + sw, dpy_x+1),\n\t\t\t    nfix(sy + sh, dpy_y+1));\n\n\t\t\t/* subtract it from the 8bpp window region */\n\t\t\tsraRgnSubtract(tmp_reg, tmp_reg2);\n\n\t\t\tsraRgnDestroy(tmp_reg2);\n\n\t\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sraRgnEmpty(tmp_reg)) {\n\t\t\t/* skip this 8bpp if completely clipped away: */\n\t\t\tsraRgnDestroy(tmp_reg);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* otherwise, store any new colormaps: */\n\t\tif (ncmaps < CMAPMAX && attr.colormap != (Colormap) 0) {\n\t\t\tint m, seen = 0;\n\t\t\tfor (m=0; m < ncmaps; m++) {\n\t\t\t\tif (cmaps[m] == attr.colormap) {\n\t\t\t\t\tseen = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seen && attr.depth <= 16) {\n\t\t\t\t/* store only new ones: */\n\t\t\t\tcmaps[ncmaps++] = attr.colormap;\n\t\t\t}\n\t\t}\n\n\t\twindows_8bpp[i].clip_region = tmp_reg;\n\t}\n\n\treturn mapcount;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nstatic int poll_8bpp(sraRegionPtr mod, int validate) {\n\tint i, y, ysh, map_count;\n\tstatic int ycnt = 0;\n\tsraRegionPtr line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint br = 0, area = 0;\n\tstatic double last_call = 0.0;\n\t\n\tmap_count = get_8bpp_regions(validate);\n\nif (db24 > 1) fprintf(stderr, \"poll_8bpp mc: %d\\n\", map_count);\n\n\tif (! map_count) {\n\t\treturn 0;\n\t}\n\n\tset_poll_fb();\n\n\tysh = scanlines[(ycnt++) % NSCAN];\nif (db24 > 2) fprintf(stderr, \"poll_8bpp: ysh: %2d  %.4f\\n\", ysh, dnow() - last_call);\n\tlast_call = dnow();\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg || sraRgnEmpty(reg)) {\n\t\t\tcontinue;\n\t\t}\n\t\ty = ysh;\n\t\twhile (y < dpy_y) {\n\t\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\t\tif (sraRgnAnd(line, reg)) {\n\t\t\t\titer = sraRgnGetIterator(line);\n\t\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t\tif (! poll_line(rect.x1, rect.x2,\n\t\t\t\t\t    rect.y1, i, mod)) {\n\t\t\t\t\t\tbr = 1;\n\t\t\t\t\t\tbreak;\t/* exception */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsraRgnReleaseIterator(iter);\n\t\t\t}\n\n\t\t\tsraRgnDestroy(line);\n\t\t\ty += NSCAN;\n\t\t\tif (br) break;\n\t\t}\n\t\tif (br) break;\n\t}\n\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\n\treturn area;\n}"
  },
  {
    "function_name": "poll_line_complement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "1006-1078",
    "snippet": "static void poll_line_complement(int x1, int x2, int y1, sraRegionPtr mod) {\n\tint n_off, w, xl, xh, stride = 32;\n\tchar *dst, *src;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tif (depth != 24) {\n\t\treturn;\n\t}\n\tif (! cmap8to24_fb) {\n\t\treturn;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn;\n\t}\n\n\tn_off = main_bytes_per_line * y1 + 4 * x1;\n\n\tsrc = main_fb + n_off;\n\tdst = cmap8to24_fb + n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw = xh - xl;\n\t\tif (memcmp(dst, src, 4 * w)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += 4 * stride;\n\t\tsrc += 4 * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\n\t\tinrun = 0;\n\t}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "mod",
            "rect"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "mx1",
            "my1",
            "mx2",
            "my2"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y1 + ns",
            "dpy_y+1"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "mod",
            "rect"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "mx1",
            "my1",
            "mx2",
            "my2"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dst",
            "src",
            "4 * w"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void poll_line_complement(int x1, int x2, int y1, sraRegionPtr mod) {\n\tint n_off, w, xl, xh, stride = 32;\n\tchar *dst, *src;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tif (depth != 24) {\n\t\treturn;\n\t}\n\tif (! cmap8to24_fb) {\n\t\treturn;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn;\n\t}\n\n\tn_off = main_bytes_per_line * y1 + 4 * x1;\n\n\tsrc = main_fb + n_off;\n\tdst = cmap8to24_fb + n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw = xh - xl;\n\t\tif (memcmp(dst, src, 4 * w)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += 4 * stride;\n\t\tsrc += 4 * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\n\t\tinrun = 0;\n\t}\n}"
  },
  {
    "function_name": "poll_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "848-1004",
    "snippet": "static int poll_line(int x1, int x2, int y1, int n, sraRegionPtr mod) {\n#if NO_X11\n\tRAWFB_RET(1)\n\tif (!x1 || !x2 || !y1 || !n || !mod) {}\n\treturn 1;\n#else\n\tint fac, n_off, w, xo, yo;\n\tchar *poll_fb, *dst, *src;\n\tint w2, xl, xh, stride = 32;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\n\tstatic XImage *xi8 = NULL, *xi24 = NULL, *xi_r;\n\tstatic int xi8_w = 0, xi24_w = 0;\n\n\tXErrorHandler old_handler = NULL;\n\tXImage *xi;\n\tWindow c, win = windows_8bpp[n].win;\n\n\tstatic XWindowAttributes attr;\n\tstatic Window last_win = None; \n\tstatic double last_time = 0.0;\n\tdouble now;\n\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tRAWFB_RET(1)\n\n\tif (win == None) {\n\t\treturn 1;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn 1;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tnow = dnow();\n\tif (last_win != None && win == last_win && now < last_time + 0.5) {\n\t\t;\t/* use previous attr */\n\t} else {\n\t\tif (! valid_window(win, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\tlast_win = None;\n\t\t\treturn 0;\n\t\t}\n\t\tlast_time = now;\n\t\tlast_win = win;\n\t}\n\n\tif (attr.depth > 16 && attr.depth != 24) {\n\t\tX_UNLOCK;\n\t\treturn 1;\n\t} else if (attr.depth <= 16) {\n\t\txi = xi8 = p_xi(xi8, attr.visual, attr.depth, &xi8_w);\n\n\t\tpoll_fb = poll8_fb;\n\t\tif (attr.depth > 8) {\n\t\t\tfac = 2;\n\t\t} else {\n\t\t\tfac = 1;\n\t\t}\n\t\tn_off = poll8_fb_w * y1 + x1;\n\t} else {\n\t\txi = xi24 = p_xi(xi24, attr.visual, 24, &xi24_w);\n\n\t\tpoll_fb = poll24_fb;\n\t\tfac = 4;\n\t\tn_off = poll24_fb_w * y1 + x1;\n\t}\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\t/* xtranslate() not used to save two XSetErrorHandler calls */\n\tXTranslateCoordinates(dpy, win, window, 0, 0, &xo, &yo, &c);\n\n\txo = x1 - xo;\n\tyo = y1 - yo;\n\tw = x2 - x1;\n\n\tif (trapped_xerror || xo < 0 || yo < 0 || xo + w > attr.width) {\nif (db24 > 2) fprintf(stderr, \"avoid bad match...\\n\");\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\ttrapped_xerror = 0;\n\txi_r = XGetSubImage(dpy, win, xo, yo, w, 1, AllPlanes, ZPixmap, xi,\n\t    0, 0);\n\tXSetErrorHandler(old_handler);\n\n\tX_UNLOCK;\n\n\tif (! xi_r || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\tsrc = xi->data;\n\tdst = poll_fb + fac * n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw2 = xh - xl;\n\t\tif (memcmp(dst, src, fac * w2)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += fac * stride;\n\t\tsrc += fac * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "mod",
            "rect"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "mx1",
            "my1",
            "mx2",
            "my2"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y1 + ns",
            "dpy_y+1"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "rect"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "mod",
            "rect"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "mx1",
            "my1",
            "mx2",
            "my2"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dst",
            "src",
            "fac * w2"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XGetSubImage",
          "args": [
            "dpy",
            "win",
            "xo",
            "yo",
            "w",
            "1",
            "AllPlanes",
            "ZPixmap",
            "xi",
            "0",
            "0"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "XGetSubImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "293-338",
          "snippet": "XImage *XGetSubImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format, XImage *dest_image, int dest_x, int dest_y) {\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format || !dest_image || !dest_x || !dest_y) {}\n\treturn NULL;\n#else\n\tADJUST_ROOTSHIFT\n\n\tif (overlay && dest_x == 0 && dest_y == 0) {\n\t\tsize_t size = dest_image->height * dest_image->bytes_per_line;\n\t\tXImage *xi;\n\n\t\txi = xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\n\t\tif (! xi) return NULL;\n\n\t\t/*\n\t\t * There is extra overhead from memcpy and free...\n\t\t * this is not like the real XGetSubImage().  We hope\n\t\t * this significant overhead is still small compared to\n\t\t * the time to retrieve the fb data.\n\t\t */\n\t\tmemcpy(dest_image->data, xi->data, size);\n\n\t\tXDestroyImage(xi);\n\t\treturn (dest_image);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi =  XGetSubImage(disp, pixmap, x, y, width, height, plane_mask,\n\t\t\t     format, dest_image, dest_x, dest_y);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetSubImage(disp, d, x, y, width, height, plane_mask,\n\t    format, dest_image, dest_x, dest_y);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}"
          ],
          "globals_used": [
            "int rootshift = 0;",
            "int XFlush_wr(Display *disp);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetSubImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format, XImage *dest_image, int dest_x, int dest_y);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\n#define ADJUST_ROOTSHIFT \\\n\tif (rootshift && subwin) { \\\n\t\td = rootwin; \\\n\t\tx += off_x; \\\n\t\ty += off_y; \\\n\t} \\\n\tif (clipshift) { \\\n\t\tx += coff_x; \\\n\t\ty += coff_y; \\\n\t}\n\nint rootshift = 0;\nint XFlush_wr(Display *disp);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetSubImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format, XImage *dest_image, int dest_x, int dest_y);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nXImage *XGetSubImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format, XImage *dest_image, int dest_x, int dest_y) {\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !d || !x || !y || !width || !height || !plane_mask || !format || !dest_image || !dest_x || !dest_y) {}\n\treturn NULL;\n#else\n\tADJUST_ROOTSHIFT\n\n\tif (overlay && dest_x == 0 && dest_y == 0) {\n\t\tsize_t size = dest_image->height * dest_image->bytes_per_line;\n\t\tXImage *xi;\n\n\t\txi = xreadscreen(disp, d, x, y, width, height,\n\t\t    (Bool) overlay_cursor);\n\n\t\tif (! xi) return NULL;\n\n\t\t/*\n\t\t * There is extra overhead from memcpy and free...\n\t\t * this is not like the real XGetSubImage().  We hope\n\t\t * this significant overhead is still small compared to\n\t\t * the time to retrieve the fb data.\n\t\t */\n\t\tmemcpy(dest_image->data, xi->data, size);\n\n\t\tXDestroyImage(xi);\n\t\treturn (dest_image);\n\t}\n#if HAVE_LIBXCOMPOSITE\n\tif(use_xcomposite && subwin && !rootshift) {\n\t  XErrorHandler old_handler = XSetErrorHandler(trap_xerror);\n\t  Pixmap pixmap = XCompositeNameWindowPixmap(disp, d);\n\t  XImage* xi =  XGetSubImage(disp, pixmap, x, y, width, height, plane_mask,\n\t\t\t     format, dest_image, dest_x, dest_y);\n\t  XFreePixmap(dpy, pixmap);\n\t  XSetErrorHandler(old_handler);\n\t  if(!trapped_xerror)\n\t    return xi;\n\t}\n#endif\n\treturn XGetSubImage(disp, d, x, y, width, height, plane_mask,\n\t    format, dest_image, dest_x, dest_y);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"avoid bad match...\\n\""
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTranslateCoordinates",
          "args": [
            "dpy",
            "win",
            "window",
            "0",
            "0",
            "&xo",
            "&yo",
            "&c"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_xi",
          "args": [
            "xi24",
            "attr.visual",
            "24",
            "&xi24_w"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "p_xi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "819-846",
          "snippet": "static XImage *p_xi(XImage *xi, Visual *visual, int win_depth, int *w) {\n\tRAWFB_RET(NULL)\n\n#if NO_X11\n\tif (!xi || !visual || !win_depth || !w) {}\n\treturn NULL;\n#else\n\tif (xi == NULL || *w < dpy_x) {\n\t\tchar *d;\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t\tif (win_depth != 24) {\n\t\t\tif (win_depth > 8) {\n\t\t\t\td = (char *) malloc(dpy_x * 2);\n\t\t\t} else {\n\t\t\t\td = (char *) malloc(dpy_x * 1);\n\t\t\t}\n\t\t} else {\n\t\t\td = (char *) malloc(dpy_x * 4);\n\t\t}\n\t\t*w = dpy_x;\n\t\txi = XCreateImage(dpy, visual, win_depth, ZPixmap, 0, d,\n\t\t    dpy_x, 1, 8, 0);\n\t}\n\treturn xi;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic XImage *p_xi(XImage *xi, Visual *visual, int win_depth, int *w) {\n\tRAWFB_RET(NULL)\n\n#if NO_X11\n\tif (!xi || !visual || !win_depth || !w) {}\n\treturn NULL;\n#else\n\tif (xi == NULL || *w < dpy_x) {\n\t\tchar *d;\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t\tif (win_depth != 24) {\n\t\t\tif (win_depth > 8) {\n\t\t\t\td = (char *) malloc(dpy_x * 2);\n\t\t\t} else {\n\t\t\t\td = (char *) malloc(dpy_x * 1);\n\t\t\t}\n\t\t} else {\n\t\t\td = (char *) malloc(dpy_x * 4);\n\t\t}\n\t\t*w = dpy_x;\n\t\txi = XCreateImage(dpy, visual, win_depth, ZPixmap, 0, d,\n\t\t    dpy_x, 1, 8, 0);\n\t}\n\treturn xi;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "1"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "1"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int poll_line(int x1, int x2, int y1, int n, sraRegionPtr mod) {\n#if NO_X11\n\tRAWFB_RET(1)\n\tif (!x1 || !x2 || !y1 || !n || !mod) {}\n\treturn 1;\n#else\n\tint fac, n_off, w, xo, yo;\n\tchar *poll_fb, *dst, *src;\n\tint w2, xl, xh, stride = 32;\n\tint inrun = 0, rx1 = -1, rx2 = -1;\n\n\tstatic XImage *xi8 = NULL, *xi24 = NULL, *xi_r;\n\tstatic int xi8_w = 0, xi24_w = 0;\n\n\tXErrorHandler old_handler = NULL;\n\tXImage *xi;\n\tWindow c, win = windows_8bpp[n].win;\n\n\tstatic XWindowAttributes attr;\n\tstatic Window last_win = None; \n\tstatic double last_time = 0.0;\n\tdouble now;\n\n\tsraRegionPtr rect;\n\tint mx1, mx2, my1, my2;\n\tint ns = NSCAN/2;\n\n\tRAWFB_RET(1)\n\n\tif (win == None) {\n\t\treturn 1;\n\t}\n\tif (windows_8bpp[n].map_state != IsViewable) {\n\t\treturn 1;\n\t}\n\tif (! xgetimage_8to24) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tnow = dnow();\n\tif (last_win != None && win == last_win && now < last_time + 0.5) {\n\t\t;\t/* use previous attr */\n\t} else {\n\t\tif (! valid_window(win, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\tlast_win = None;\n\t\t\treturn 0;\n\t\t}\n\t\tlast_time = now;\n\t\tlast_win = win;\n\t}\n\n\tif (attr.depth > 16 && attr.depth != 24) {\n\t\tX_UNLOCK;\n\t\treturn 1;\n\t} else if (attr.depth <= 16) {\n\t\txi = xi8 = p_xi(xi8, attr.visual, attr.depth, &xi8_w);\n\n\t\tpoll_fb = poll8_fb;\n\t\tif (attr.depth > 8) {\n\t\t\tfac = 2;\n\t\t} else {\n\t\t\tfac = 1;\n\t\t}\n\t\tn_off = poll8_fb_w * y1 + x1;\n\t} else {\n\t\txi = xi24 = p_xi(xi24, attr.visual, 24, &xi24_w);\n\n\t\tpoll_fb = poll24_fb;\n\t\tfac = 4;\n\t\tn_off = poll24_fb_w * y1 + x1;\n\t}\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\n\t/* xtranslate() not used to save two XSetErrorHandler calls */\n\tXTranslateCoordinates(dpy, win, window, 0, 0, &xo, &yo, &c);\n\n\txo = x1 - xo;\n\tyo = y1 - yo;\n\tw = x2 - x1;\n\n\tif (trapped_xerror || xo < 0 || yo < 0 || xo + w > attr.width) {\nif (db24 > 2) fprintf(stderr, \"avoid bad match...\\n\");\n\t\tXSetErrorHandler(old_handler);\n\t\ttrapped_xerror = 0;\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\ttrapped_xerror = 0;\n\txi_r = XGetSubImage(dpy, win, xo, yo, w, 1, AllPlanes, ZPixmap, xi,\n\t    0, 0);\n\tXSetErrorHandler(old_handler);\n\n\tX_UNLOCK;\n\n\tif (! xi_r || trapped_xerror) {\n\t\ttrapped_xerror = 0;\n\t\treturn 0;\n\t}\n\ttrapped_xerror = 0;\n\n\tsrc = xi->data;\n\tdst = poll_fb + fac * n_off;\n\n\tinrun = 0;\n\n\txl = x1;\n\twhile (xl < x2) {\n\t\txh = xl + stride;\n\t\tif (xh > x2) {\n\t\t\txh = x2;\n\t\t}\n\t\tw2 = xh - xl;\n\t\tif (memcmp(dst, src, fac * w2)) {\n\t\t\tif (inrun) {\n\t\t\t\trx2 = xh;\n\t\t\t} else {\n\t\t\t\trx1 = xl;\n\t\t\t\trx2 = xh;\n\t\t\t\tinrun = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (inrun) {\n\t\t\t\tmx1 = rx1;\n\t\t\t\tmx2 = rx2;\n\t\t\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\t\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\t\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\t\t\tsraRgnOr(mod, rect);\n\t\t\t\tsraRgnDestroy(rect);\t\n\t\t\t\tinrun = 0;\n\t\t\t}\n\t\t}\n\n\t\txl += stride;\n\t\tdst += fac * stride;\n\t\tsrc += fac * stride;\n\t}\n\n\tif (inrun) {\n\t\tmx1 = rx1;\n\t\tmx2 = rx2;\n\t\tmy1 = nfix(y1 - ns, dpy_y);\n\t\tmy2 = nfix(y1 + ns, dpy_y+1);\n\n\t\trect = sraRgnCreateRect(mx1, my1, mx2, my2);\n\t\tsraRgnOr(mod, rect);\n\t\tsraRgnDestroy(rect);\t\n\t}\n\treturn 1;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "p_xi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "819-846",
    "snippet": "static XImage *p_xi(XImage *xi, Visual *visual, int win_depth, int *w) {\n\tRAWFB_RET(NULL)\n\n#if NO_X11\n\tif (!xi || !visual || !win_depth || !w) {}\n\treturn NULL;\n#else\n\tif (xi == NULL || *w < dpy_x) {\n\t\tchar *d;\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t\tif (win_depth != 24) {\n\t\t\tif (win_depth > 8) {\n\t\t\t\td = (char *) malloc(dpy_x * 2);\n\t\t\t} else {\n\t\t\t\td = (char *) malloc(dpy_x * 1);\n\t\t\t}\n\t\t} else {\n\t\t\td = (char *) malloc(dpy_x * 4);\n\t\t}\n\t\t*w = dpy_x;\n\t\txi = XCreateImage(dpy, visual, win_depth, ZPixmap, 0, d,\n\t\t    dpy_x, 1, 8, 0);\n\t}\n\treturn xi;\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XCreateImage",
          "args": [
            "dpy",
            "visual",
            "win_depth",
            "ZPixmap",
            "0",
            "d",
            "dpy_x",
            "1",
            "8",
            "0"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "XCreateImage_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "370-429",
          "snippet": "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int guess_bits_per_color(int bits_per_pixel);",
            "int XFlush_wr(Display *disp);",
            "Status XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);",
            "XImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);",
            "XImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);",
            "XImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint guess_bits_per_color(int bits_per_pixel);\nint XFlush_wr(Display *disp);\nStatus XShmGetImage_wr(Display *disp, Drawable d, XImage *image, int x, int y,\n    unsigned long mask);\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\nXImage *XGetImage_wr(Display *disp, Drawable d, int x, int y,\n    unsigned int width, unsigned int height, unsigned long plane_mask,\n    int format);\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line);\nint XFree_wr(void *data);\n\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_x * 4"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_x * 1"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dpy_x * 2"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDestroyImage",
          "args": [
            "xi"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic XImage *p_xi(XImage *xi, Visual *visual, int win_depth, int *w) {\n\tRAWFB_RET(NULL)\n\n#if NO_X11\n\tif (!xi || !visual || !win_depth || !w) {}\n\treturn NULL;\n#else\n\tif (xi == NULL || *w < dpy_x) {\n\t\tchar *d;\n\t\tif (xi) {\n\t\t\tXDestroyImage(xi);\n\t\t}\n\t\tif (win_depth != 24) {\n\t\t\tif (win_depth > 8) {\n\t\t\t\td = (char *) malloc(dpy_x * 2);\n\t\t\t} else {\n\t\t\t\td = (char *) malloc(dpy_x * 1);\n\t\t\t}\n\t\t} else {\n\t\t\td = (char *) malloc(dpy_x * 4);\n\t\t}\n\t\t*w = dpy_x;\n\t\txi = XCreateImage(dpy, visual, win_depth, ZPixmap, 0, d,\n\t\t    dpy_x, 1, 8, 0);\n\t}\n\treturn xi;\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "check_depth_win",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "707-816",
    "snippet": "static int check_depth_win(Window win, Window top, XWindowAttributes *attr) {\n\tint store_it = 0;\n\t/*\n\t * only store windows with depth not equal to the default visual's\n\t * depth note some windows can have depth == 0 ... (skip them).\n\t */\n\tif (attr->depth > 0) {\n\t\tif (depth == 24 && attr->depth != 24) {\n\t\t\tstore_it = 1;\n\t\t} else if (depth <= 16 && root_cmap && attr->colormap != root_cmap) {\n\t\t\tstore_it = 1;\n\t\t}\n\t}\n\n\tif (store_it) {\n\t\tint i, j = -1, none = -1, nomap = -1;\n\t\tint newc = 0;\n\t\tif (attr->map_state == IsViewable) {\n\t\t\t/* count the visible ones: */\n\t\t\tmultivis_count++;\n\t\t\tif (attr->depth == 24) {\n\t\t\t\tmultivis_24count++;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx %d\\n\", win, attr->depth);\n\t\t}\n\n\t\t/* try to find a table slot for this window: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tif (none < 0 && windows_8bpp[i].win == None) {\n\t\t\t\t/* found first None */\n\t\t\t\tnone = i;\n\t\t\t}\n\t\t\tif (windows_8bpp[i].win == win) {\n\t\t\t\t/* found myself */\n\t\t\t\tj = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nomap < 0 && windows_8bpp[i].win != None &&\n\t\t\t    windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t/* found first unmapped */\n\t\t\t\tnomap = i;\n\t\t\t}\n\t\t}\n\t\tif (j < 0) {\n\t\t\tif (attr->map_state != IsViewable) {\n\t\t\t\t/* no slot and not visible: not worth keeping */\n\t\t\t\treturn 1;\n\t\t\t} else if (none >= 0) {\n\t\t\t\t/* put it in the first None slot */\n\t\t\t\tj = none;\n\t\t\t\tnewc = 1;\n\t\t\t} else if (nomap >=0) {\n\t\t\t\t/* put it in the first unmapped slot */\n\t\t\t\tj = nomap;\n\t\t\t}\n\t\t\t/* otherwise we cannot store it... */\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx ms: %d j: %d no: %d nm: %d dep=%d\\n\", win, attr->map_state, j, none, nomap, attr->depth);\n\n\t\t/* store if if we found a slot j: */\n\t\tif (j >= 0) {\n\t\t\tWindow w;\n\t\t\tint x, y;\n\t\t\tint now_vis = 0;\n\n\t\t\tif (attr->map_state == IsViewable &&\n\t\t\t    windows_8bpp[j].map_state != IsViewable) {\n\t\t\t\tnow_vis = 1;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: STORE 0x%lx j: %3d ms: %d dep=%d\\n\", win, j, attr->map_state, attr->depth);\n\t\t\twindows_8bpp[j].win = win;\n\t\t\twindows_8bpp[j].top = top;\n\t\t\twindows_8bpp[j].depth = attr->depth;\n\t\t\twindows_8bpp[j].map_state = attr->map_state;\n\t\t\twindows_8bpp[j].cmap = attr->colormap;\n\t\t\twindows_8bpp[j].map_installed = attr->map_installed;\n\t\t\twindows_8bpp[j].w = attr->width;\n\t\t\twindows_8bpp[j].h = attr->height;\n\t\t\twindows_8bpp[j].fetched = 1;\n\t\t\twindows_8bpp[j].last_fetched = dnow();\n\n\t\t\t/* translate x y to be WRT the root window (not parent) */\n\t\t\txtranslate(win, window, 0, 0, &x, &y, &w, 1);\n\t\t\twindows_8bpp[j].x = x;\n\t\t\twindows_8bpp[j].y = y;\n\n\t\t\tif (newc || now_vis) {\nif (db24) fprintf(stderr, \"new/now_vis: 0x%lx %d/%d\\n\", win, newc, now_vis);\n\t\t\t\t/* mark it immediately if a new one: */\n\t\t\t\tX_UNLOCK;\t/* dont forget the giant lock */\n\t\t\t\tmark_rect_as_modified(x, y, x + attr->width,\n\t\t\t\t    y + attr->height, 0);\n\t\t\t\tX_LOCK;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Error: could not find a slot.\n\t\t\t * perhaps keep age and expire old ones??\n\t\t\t */\nif (db24) fprintf(stderr, \"multivis: CANNOT STORE 0x%lx j=%d\\n\", win, j);\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\nif (db24 > 1) fprintf(stderr, \"          ------------ 0x%lx i=%d\\n\", windows_8bpp[i].win, i);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MAX_8BPP_WINDOWS 64"
    ],
    "globals_used": [
      "int multivis_count = 0;",
      "int multivis_24count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"          ------------ 0x%lx i=%d\\n\"",
            "windows_8bpp[i].win",
            "i"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"multivis: CANNOT STORE 0x%lx j=%d\\n\"",
            "win",
            "j"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x",
            "y",
            "x + attr->width",
            "y + attr->height",
            "0"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"new/now_vis: 0x%lx %d/%d\\n\"",
            "win",
            "newc",
            "now_vis"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtranslate",
          "args": [
            "win",
            "window",
            "0",
            "0",
            "&x",
            "&y",
            "&w",
            "1"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "xtranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "142-173",
          "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"multivis: STORE 0x%lx j: %3d ms: %d dep=%d\\n\"",
            "win",
            "j",
            "attr->map_state",
            "attr->depth"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"multivis: 0x%lx ms: %d j: %d no: %d nm: %d dep=%d\\n\"",
            "win",
            "attr->map_state",
            "j",
            "none",
            "nomap",
            "attr->depth"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"multivis: 0x%lx %d\\n\"",
            "win",
            "attr->depth"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nint multivis_count = 0;\nint multivis_24count = 0;\n\nstatic int check_depth_win(Window win, Window top, XWindowAttributes *attr) {\n\tint store_it = 0;\n\t/*\n\t * only store windows with depth not equal to the default visual's\n\t * depth note some windows can have depth == 0 ... (skip them).\n\t */\n\tif (attr->depth > 0) {\n\t\tif (depth == 24 && attr->depth != 24) {\n\t\t\tstore_it = 1;\n\t\t} else if (depth <= 16 && root_cmap && attr->colormap != root_cmap) {\n\t\t\tstore_it = 1;\n\t\t}\n\t}\n\n\tif (store_it) {\n\t\tint i, j = -1, none = -1, nomap = -1;\n\t\tint newc = 0;\n\t\tif (attr->map_state == IsViewable) {\n\t\t\t/* count the visible ones: */\n\t\t\tmultivis_count++;\n\t\t\tif (attr->depth == 24) {\n\t\t\t\tmultivis_24count++;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx %d\\n\", win, attr->depth);\n\t\t}\n\n\t\t/* try to find a table slot for this window: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tif (none < 0 && windows_8bpp[i].win == None) {\n\t\t\t\t/* found first None */\n\t\t\t\tnone = i;\n\t\t\t}\n\t\t\tif (windows_8bpp[i].win == win) {\n\t\t\t\t/* found myself */\n\t\t\t\tj = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nomap < 0 && windows_8bpp[i].win != None &&\n\t\t\t    windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t/* found first unmapped */\n\t\t\t\tnomap = i;\n\t\t\t}\n\t\t}\n\t\tif (j < 0) {\n\t\t\tif (attr->map_state != IsViewable) {\n\t\t\t\t/* no slot and not visible: not worth keeping */\n\t\t\t\treturn 1;\n\t\t\t} else if (none >= 0) {\n\t\t\t\t/* put it in the first None slot */\n\t\t\t\tj = none;\n\t\t\t\tnewc = 1;\n\t\t\t} else if (nomap >=0) {\n\t\t\t\t/* put it in the first unmapped slot */\n\t\t\t\tj = nomap;\n\t\t\t}\n\t\t\t/* otherwise we cannot store it... */\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx ms: %d j: %d no: %d nm: %d dep=%d\\n\", win, attr->map_state, j, none, nomap, attr->depth);\n\n\t\t/* store if if we found a slot j: */\n\t\tif (j >= 0) {\n\t\t\tWindow w;\n\t\t\tint x, y;\n\t\t\tint now_vis = 0;\n\n\t\t\tif (attr->map_state == IsViewable &&\n\t\t\t    windows_8bpp[j].map_state != IsViewable) {\n\t\t\t\tnow_vis = 1;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: STORE 0x%lx j: %3d ms: %d dep=%d\\n\", win, j, attr->map_state, attr->depth);\n\t\t\twindows_8bpp[j].win = win;\n\t\t\twindows_8bpp[j].top = top;\n\t\t\twindows_8bpp[j].depth = attr->depth;\n\t\t\twindows_8bpp[j].map_state = attr->map_state;\n\t\t\twindows_8bpp[j].cmap = attr->colormap;\n\t\t\twindows_8bpp[j].map_installed = attr->map_installed;\n\t\t\twindows_8bpp[j].w = attr->width;\n\t\t\twindows_8bpp[j].h = attr->height;\n\t\t\twindows_8bpp[j].fetched = 1;\n\t\t\twindows_8bpp[j].last_fetched = dnow();\n\n\t\t\t/* translate x y to be WRT the root window (not parent) */\n\t\t\txtranslate(win, window, 0, 0, &x, &y, &w, 1);\n\t\t\twindows_8bpp[j].x = x;\n\t\t\twindows_8bpp[j].y = y;\n\n\t\t\tif (newc || now_vis) {\nif (db24) fprintf(stderr, \"new/now_vis: 0x%lx %d/%d\\n\", win, newc, now_vis);\n\t\t\t\t/* mark it immediately if a new one: */\n\t\t\t\tX_UNLOCK;\t/* dont forget the giant lock */\n\t\t\t\tmark_rect_as_modified(x, y, x + attr->width,\n\t\t\t\t    y + attr->height, 0);\n\t\t\t\tX_LOCK;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Error: could not find a slot.\n\t\t\t * perhaps keep age and expire old ones??\n\t\t\t */\nif (db24) fprintf(stderr, \"multivis: CANNOT STORE 0x%lx j=%d\\n\", win, j);\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\nif (db24 > 1) fprintf(stderr, \"          ------------ 0x%lx i=%d\\n\", windows_8bpp[i].win, i);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_depth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "674-705",
    "snippet": "static int check_depth(Window win, Window top, int doall) {\n\tXWindowAttributes attr, *pattr;\n\n\t/* first see if it is (still) a valid window: */\nMV_count++;\n\n\tif (cache_win > 0.0) {\n\t\tpattr = vw_lookup(win);\n\t\tif (pattr == NULL) {\n\t\t\treturn 1;\t/* indicate done */\n\t\t}\n\t} else {\n\t\tif (! valid_window(win, &attr, 1)) {\n\t\t\treturn 1;\t/* indicate done */\n\t\t}\n\t\tpattr = &attr;\n\t}\n\n\tif (! doall && pattr->map_state != IsViewable) {\n\t\t/*\n\t\t * store results anyway...  this may lead to table\n\t\t * filling up, but currently this allows us to update\n\t\t * state of onetime mapped windows.\n\t\t */\n\t\tcheck_depth_win(win, top, pattr);\n\t\treturn 1;\t/* indicate done */\n\t} else if (check_depth_win(win, top, pattr)) {\n\t\treturn 1;\t/* indicate done */\n\t} else {\n\t\treturn 0;\t/* indicate not done */\n\t}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_depth_win",
          "args": [
            "win",
            "top",
            "pattr"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "check_depth_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "707-816",
          "snippet": "static int check_depth_win(Window win, Window top, XWindowAttributes *attr) {\n\tint store_it = 0;\n\t/*\n\t * only store windows with depth not equal to the default visual's\n\t * depth note some windows can have depth == 0 ... (skip them).\n\t */\n\tif (attr->depth > 0) {\n\t\tif (depth == 24 && attr->depth != 24) {\n\t\t\tstore_it = 1;\n\t\t} else if (depth <= 16 && root_cmap && attr->colormap != root_cmap) {\n\t\t\tstore_it = 1;\n\t\t}\n\t}\n\n\tif (store_it) {\n\t\tint i, j = -1, none = -1, nomap = -1;\n\t\tint newc = 0;\n\t\tif (attr->map_state == IsViewable) {\n\t\t\t/* count the visible ones: */\n\t\t\tmultivis_count++;\n\t\t\tif (attr->depth == 24) {\n\t\t\t\tmultivis_24count++;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx %d\\n\", win, attr->depth);\n\t\t}\n\n\t\t/* try to find a table slot for this window: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tif (none < 0 && windows_8bpp[i].win == None) {\n\t\t\t\t/* found first None */\n\t\t\t\tnone = i;\n\t\t\t}\n\t\t\tif (windows_8bpp[i].win == win) {\n\t\t\t\t/* found myself */\n\t\t\t\tj = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nomap < 0 && windows_8bpp[i].win != None &&\n\t\t\t    windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t/* found first unmapped */\n\t\t\t\tnomap = i;\n\t\t\t}\n\t\t}\n\t\tif (j < 0) {\n\t\t\tif (attr->map_state != IsViewable) {\n\t\t\t\t/* no slot and not visible: not worth keeping */\n\t\t\t\treturn 1;\n\t\t\t} else if (none >= 0) {\n\t\t\t\t/* put it in the first None slot */\n\t\t\t\tj = none;\n\t\t\t\tnewc = 1;\n\t\t\t} else if (nomap >=0) {\n\t\t\t\t/* put it in the first unmapped slot */\n\t\t\t\tj = nomap;\n\t\t\t}\n\t\t\t/* otherwise we cannot store it... */\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx ms: %d j: %d no: %d nm: %d dep=%d\\n\", win, attr->map_state, j, none, nomap, attr->depth);\n\n\t\t/* store if if we found a slot j: */\n\t\tif (j >= 0) {\n\t\t\tWindow w;\n\t\t\tint x, y;\n\t\t\tint now_vis = 0;\n\n\t\t\tif (attr->map_state == IsViewable &&\n\t\t\t    windows_8bpp[j].map_state != IsViewable) {\n\t\t\t\tnow_vis = 1;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: STORE 0x%lx j: %3d ms: %d dep=%d\\n\", win, j, attr->map_state, attr->depth);\n\t\t\twindows_8bpp[j].win = win;\n\t\t\twindows_8bpp[j].top = top;\n\t\t\twindows_8bpp[j].depth = attr->depth;\n\t\t\twindows_8bpp[j].map_state = attr->map_state;\n\t\t\twindows_8bpp[j].cmap = attr->colormap;\n\t\t\twindows_8bpp[j].map_installed = attr->map_installed;\n\t\t\twindows_8bpp[j].w = attr->width;\n\t\t\twindows_8bpp[j].h = attr->height;\n\t\t\twindows_8bpp[j].fetched = 1;\n\t\t\twindows_8bpp[j].last_fetched = dnow();\n\n\t\t\t/* translate x y to be WRT the root window (not parent) */\n\t\t\txtranslate(win, window, 0, 0, &x, &y, &w, 1);\n\t\t\twindows_8bpp[j].x = x;\n\t\t\twindows_8bpp[j].y = y;\n\n\t\t\tif (newc || now_vis) {\nif (db24) fprintf(stderr, \"new/now_vis: 0x%lx %d/%d\\n\", win, newc, now_vis);\n\t\t\t\t/* mark it immediately if a new one: */\n\t\t\t\tX_UNLOCK;\t/* dont forget the giant lock */\n\t\t\t\tmark_rect_as_modified(x, y, x + attr->width,\n\t\t\t\t    y + attr->height, 0);\n\t\t\t\tX_LOCK;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Error: could not find a slot.\n\t\t\t * perhaps keep age and expire old ones??\n\t\t\t */\nif (db24) fprintf(stderr, \"multivis: CANNOT STORE 0x%lx j=%d\\n\", win, j);\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\nif (db24 > 1) fprintf(stderr, \"          ------------ 0x%lx i=%d\\n\", windows_8bpp[i].win, i);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [
            "int multivis_count = 0;",
            "int multivis_24count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nint multivis_count = 0;\nint multivis_24count = 0;\n\nstatic int check_depth_win(Window win, Window top, XWindowAttributes *attr) {\n\tint store_it = 0;\n\t/*\n\t * only store windows with depth not equal to the default visual's\n\t * depth note some windows can have depth == 0 ... (skip them).\n\t */\n\tif (attr->depth > 0) {\n\t\tif (depth == 24 && attr->depth != 24) {\n\t\t\tstore_it = 1;\n\t\t} else if (depth <= 16 && root_cmap && attr->colormap != root_cmap) {\n\t\t\tstore_it = 1;\n\t\t}\n\t}\n\n\tif (store_it) {\n\t\tint i, j = -1, none = -1, nomap = -1;\n\t\tint newc = 0;\n\t\tif (attr->map_state == IsViewable) {\n\t\t\t/* count the visible ones: */\n\t\t\tmultivis_count++;\n\t\t\tif (attr->depth == 24) {\n\t\t\t\tmultivis_24count++;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx %d\\n\", win, attr->depth);\n\t\t}\n\n\t\t/* try to find a table slot for this window: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tif (none < 0 && windows_8bpp[i].win == None) {\n\t\t\t\t/* found first None */\n\t\t\t\tnone = i;\n\t\t\t}\n\t\t\tif (windows_8bpp[i].win == win) {\n\t\t\t\t/* found myself */\n\t\t\t\tj = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nomap < 0 && windows_8bpp[i].win != None &&\n\t\t\t    windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t/* found first unmapped */\n\t\t\t\tnomap = i;\n\t\t\t}\n\t\t}\n\t\tif (j < 0) {\n\t\t\tif (attr->map_state != IsViewable) {\n\t\t\t\t/* no slot and not visible: not worth keeping */\n\t\t\t\treturn 1;\n\t\t\t} else if (none >= 0) {\n\t\t\t\t/* put it in the first None slot */\n\t\t\t\tj = none;\n\t\t\t\tnewc = 1;\n\t\t\t} else if (nomap >=0) {\n\t\t\t\t/* put it in the first unmapped slot */\n\t\t\t\tj = nomap;\n\t\t\t}\n\t\t\t/* otherwise we cannot store it... */\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx ms: %d j: %d no: %d nm: %d dep=%d\\n\", win, attr->map_state, j, none, nomap, attr->depth);\n\n\t\t/* store if if we found a slot j: */\n\t\tif (j >= 0) {\n\t\t\tWindow w;\n\t\t\tint x, y;\n\t\t\tint now_vis = 0;\n\n\t\t\tif (attr->map_state == IsViewable &&\n\t\t\t    windows_8bpp[j].map_state != IsViewable) {\n\t\t\t\tnow_vis = 1;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: STORE 0x%lx j: %3d ms: %d dep=%d\\n\", win, j, attr->map_state, attr->depth);\n\t\t\twindows_8bpp[j].win = win;\n\t\t\twindows_8bpp[j].top = top;\n\t\t\twindows_8bpp[j].depth = attr->depth;\n\t\t\twindows_8bpp[j].map_state = attr->map_state;\n\t\t\twindows_8bpp[j].cmap = attr->colormap;\n\t\t\twindows_8bpp[j].map_installed = attr->map_installed;\n\t\t\twindows_8bpp[j].w = attr->width;\n\t\t\twindows_8bpp[j].h = attr->height;\n\t\t\twindows_8bpp[j].fetched = 1;\n\t\t\twindows_8bpp[j].last_fetched = dnow();\n\n\t\t\t/* translate x y to be WRT the root window (not parent) */\n\t\t\txtranslate(win, window, 0, 0, &x, &y, &w, 1);\n\t\t\twindows_8bpp[j].x = x;\n\t\t\twindows_8bpp[j].y = y;\n\n\t\t\tif (newc || now_vis) {\nif (db24) fprintf(stderr, \"new/now_vis: 0x%lx %d/%d\\n\", win, newc, now_vis);\n\t\t\t\t/* mark it immediately if a new one: */\n\t\t\t\tX_UNLOCK;\t/* dont forget the giant lock */\n\t\t\t\tmark_rect_as_modified(x, y, x + attr->width,\n\t\t\t\t    y + attr->height, 0);\n\t\t\t\tX_LOCK;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Error: could not find a slot.\n\t\t\t * perhaps keep age and expire old ones??\n\t\t\t */\nif (db24) fprintf(stderr, \"multivis: CANNOT STORE 0x%lx j=%d\\n\", win, j);\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\nif (db24 > 1) fprintf(stderr, \"          ------------ 0x%lx i=%d\\n\", windows_8bpp[i].win, i);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&attr",
            "1"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "vw_lookup",
          "args": [
            "win"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "vw_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "620-672",
          "snippet": "static XWindowAttributes *vw_lookup(Window win) {\n\tstatic double last_purge = 0.0;\n\tdouble now;\n\tint i, j, k;\n\n\tif (win == None) {\n\t\treturn NULL;\n\t}\n\n\tnow = dnow();\n\tif (now > last_purge + cache_win) {\n\t\tlast_purge = now;\n\t\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\t\tvw_cache_win[i] = None;\n\t\t}\n\t}\n\n\tj = -1;\n\tk = -1;\n\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\tif (vw_cache_win[i] == win) {\n\t\t\tj = i;\n\t\t\tbreak;\n\t\t} else if (vw_cache_win[i] == None) {\n\t\t\tk = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (j >= 0) {\nMV_hit++;\n\t\treturn vw_cache_attr+j;\n\t\t\n\t} else if (k >= 0) {\n\t\tXWindowAttributes attr2;\n\t\tint rc = valid_window(win, &attr2, 1);\n\t\tif (rc) {\n\t\t\tvw_cache_win[k] = win;\n\t\t\tset_attr(&attr2, k);\n\t\t\treturn vw_cache_attr+k;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* Full */\n\t\tint rc = valid_window(win, &wattr, 1);\n\t\tif (rc) {\n\t\t\treturn &wattr;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define VW_CACHE_MAX 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define VW_CACHE_MAX 1024\n\nstatic XWindowAttributes *vw_lookup(Window win) {\n\tstatic double last_purge = 0.0;\n\tdouble now;\n\tint i, j, k;\n\n\tif (win == None) {\n\t\treturn NULL;\n\t}\n\n\tnow = dnow();\n\tif (now > last_purge + cache_win) {\n\t\tlast_purge = now;\n\t\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\t\tvw_cache_win[i] = None;\n\t\t}\n\t}\n\n\tj = -1;\n\tk = -1;\n\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\tif (vw_cache_win[i] == win) {\n\t\t\tj = i;\n\t\t\tbreak;\n\t\t} else if (vw_cache_win[i] == None) {\n\t\t\tk = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (j >= 0) {\nMV_hit++;\n\t\treturn vw_cache_attr+j;\n\t\t\n\t} else if (k >= 0) {\n\t\tXWindowAttributes attr2;\n\t\tint rc = valid_window(win, &attr2, 1);\n\t\tif (rc) {\n\t\t\tvw_cache_win[k] = win;\n\t\t\tset_attr(&attr2, k);\n\t\t\treturn vw_cache_attr+k;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* Full */\n\t\tint rc = valid_window(win, &wattr, 1);\n\t\tif (rc) {\n\t\t\treturn &wattr;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int check_depth(Window win, Window top, int doall) {\n\tXWindowAttributes attr, *pattr;\n\n\t/* first see if it is (still) a valid window: */\nMV_count++;\n\n\tif (cache_win > 0.0) {\n\t\tpattr = vw_lookup(win);\n\t\tif (pattr == NULL) {\n\t\t\treturn 1;\t/* indicate done */\n\t\t}\n\t} else {\n\t\tif (! valid_window(win, &attr, 1)) {\n\t\t\treturn 1;\t/* indicate done */\n\t\t}\n\t\tpattr = &attr;\n\t}\n\n\tif (! doall && pattr->map_state != IsViewable) {\n\t\t/*\n\t\t * store results anyway...  this may lead to table\n\t\t * filling up, but currently this allows us to update\n\t\t * state of onetime mapped windows.\n\t\t */\n\t\tcheck_depth_win(win, top, pattr);\n\t\treturn 1;\t/* indicate done */\n\t} else if (check_depth_win(win, top, pattr)) {\n\t\treturn 1;\t/* indicate done */\n\t} else {\n\t\treturn 0;\t/* indicate not done */\n\t}\n}"
  },
  {
    "function_name": "vw_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "620-672",
    "snippet": "static XWindowAttributes *vw_lookup(Window win) {\n\tstatic double last_purge = 0.0;\n\tdouble now;\n\tint i, j, k;\n\n\tif (win == None) {\n\t\treturn NULL;\n\t}\n\n\tnow = dnow();\n\tif (now > last_purge + cache_win) {\n\t\tlast_purge = now;\n\t\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\t\tvw_cache_win[i] = None;\n\t\t}\n\t}\n\n\tj = -1;\n\tk = -1;\n\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\tif (vw_cache_win[i] == win) {\n\t\t\tj = i;\n\t\t\tbreak;\n\t\t} else if (vw_cache_win[i] == None) {\n\t\t\tk = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (j >= 0) {\nMV_hit++;\n\t\treturn vw_cache_attr+j;\n\t\t\n\t} else if (k >= 0) {\n\t\tXWindowAttributes attr2;\n\t\tint rc = valid_window(win, &attr2, 1);\n\t\tif (rc) {\n\t\t\tvw_cache_win[k] = win;\n\t\t\tset_attr(&attr2, k);\n\t\t\treturn vw_cache_attr+k;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* Full */\n\t\tint rc = valid_window(win, &wattr, 1);\n\t\tif (rc) {\n\t\t\treturn &wattr;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define VW_CACHE_MAX 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "win",
            "&wattr",
            "1"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_attr",
          "args": [
            "&attr2",
            "k"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "set_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "606-609",
          "snippet": "static void set_attr(XWindowAttributes *attr, int j) {\n\tmemcpy((void *) (vw_cache_attr+j), (void *) attr,\n\t    sizeof(XWindowAttributes));\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_attr(XWindowAttributes *attr, int j) {\n\tmemcpy((void *) (vw_cache_attr+j), (void *) attr,\n\t    sizeof(XWindowAttributes));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define VW_CACHE_MAX 1024\n\nstatic XWindowAttributes *vw_lookup(Window win) {\n\tstatic double last_purge = 0.0;\n\tdouble now;\n\tint i, j, k;\n\n\tif (win == None) {\n\t\treturn NULL;\n\t}\n\n\tnow = dnow();\n\tif (now > last_purge + cache_win) {\n\t\tlast_purge = now;\n\t\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\t\tvw_cache_win[i] = None;\n\t\t}\n\t}\n\n\tj = -1;\n\tk = -1;\n\tfor (i=0; i<VW_CACHE_MAX; i++) {\n\t\tif (vw_cache_win[i] == win) {\n\t\t\tj = i;\n\t\t\tbreak;\n\t\t} else if (vw_cache_win[i] == None) {\n\t\t\tk = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (j >= 0) {\nMV_hit++;\n\t\treturn vw_cache_attr+j;\n\t\t\n\t} else if (k >= 0) {\n\t\tXWindowAttributes attr2;\n\t\tint rc = valid_window(win, &attr2, 1);\n\t\tif (rc) {\n\t\t\tvw_cache_win[k] = win;\n\t\t\tset_attr(&attr2, k);\n\t\t\treturn vw_cache_attr+k;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* Full */\n\t\tint rc = valid_window(win, &wattr, 1);\n\t\tif (rc) {\n\t\t\treturn &wattr;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "611-615",
    "snippet": "static int get_attr(XWindowAttributes *attr, int j) {\n\tmemcpy((void *) attr, (void *) (vw_cache_attr+j),\n\t    sizeof(XWindowAttributes));\n\treturn 1;\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) attr",
            "(void *) (vw_cache_attr+j)",
            "sizeof(XWindowAttributes)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int get_attr(XWindowAttributes *attr, int j) {\n\tmemcpy((void *) attr, (void *) (vw_cache_attr+j),\n\t    sizeof(XWindowAttributes));\n\treturn 1;\n}"
  },
  {
    "function_name": "set_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "606-609",
    "snippet": "static void set_attr(XWindowAttributes *attr, int j) {\n\tmemcpy((void *) (vw_cache_attr+j), (void *) attr,\n\t    sizeof(XWindowAttributes));\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) (vw_cache_attr+j)",
            "(void *) attr",
            "sizeof(XWindowAttributes)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_attr(XWindowAttributes *attr, int j) {\n\tmemcpy((void *) (vw_cache_attr+j), (void *) attr,\n\t    sizeof(XWindowAttributes));\n}"
  },
  {
    "function_name": "check_for_multivis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "304-600",
    "snippet": "void check_for_multivis(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXWindowAttributes attr;\n\tint doall = 0;\n\tint k, i, cnt, diff;\n\tstatic int first = 1;\n\tstatic Window *stack_old = NULL;\n\tstatic int stack_old_len = 0;\n\tstatic double last_parse = 0.0;\n\tstatic double last_update = 0.0;\n\tstatic double last_clear = 0.0;\n\tstatic double last_poll = 0.0;\n\tstatic double last_fixup = 0.0;\n\tstatic double last_call = 0.0;\n\tstatic double last_query = 0.0;\n\tdouble now = dnow();\n\tdouble delay;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_parse + 1.0) {\n\t\tlast_parse = now;\n\t\tparse_cmap8to24();\n\t}\nif (db24 > 2) fprintf(stderr, \" check_for_multivis: %.4f\\n\", now - last_call);\n\tlast_call = now;\n\n\tif (first) {\n\t\tint i;\n\t\t/* initialize 8bpp window table: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) \t{\n\t\t\twindows_8bpp[i].win = None;\n\t\t\twindows_8bpp[i].top = None;\n\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\twindows_8bpp[i].clip_region = NULL;\n\t\t}\n\t\tset_poll_fb();\n\n\t\tfirst = 0;\n\t\tdoall = 1;\t/* fetch everything first time */\n\t}\n\n\tif (wireframe_in_progress) {\n\t\treturn;\n\t}\n\n\tset_root_cmap();\n\n\t/*\n\t * allocate an \"old stack\" list of all toplevels.  we compare\n\t * this to the current stack to guess stacking order changes.\n\t */\n\tif (!stack_old || stack_old_len < stack_list_len) {\n\t\tint n = stack_list_len;\n\t\tif (n < 256) {\n\t\t\tn = 256;\n\t\t}\n\t\tif (stack_old) {\n\t\t\tfree(stack_old);\n\t\t}\n\t\tstack_old = (Window *) calloc(n*sizeof(Window), 1);\n\t\tstack_old_len = n;\n\t}\n\n\t/* fill the old stack with visible windows: */\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid &&\n\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\tstack_old[cnt++] = stack_list[k].win;\n\t\t}\n\t}\n\n\t/* snapshot + update the current stacking order: */\n\t/* TUNABLE */\n\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\tdelay = 3.0 * poll_8to24_delay;\n\t} else {\n\t\tdelay = 3.0 * POLL_8TO24_DELAY;\t/* 0.15 */\n\t}\n\tif (doall || now > last_update + delay) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tupdate_stack_list();\n\t\tlast_update = now;\n\t}\n\n\t/* look for differences in the visible toplevels: */\n\tdiff = 0;\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid && stack_list[k].map_state ==\n\t\t    IsViewable) {\n\t\t\tif (stack_old[cnt] != stack_list[k].win) {\n\t\t\t\tdiff = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tmultivis_count = 0;\n\tmultivis_24count = 0;\n\n\t/*\n\t * every 10 seconds we try to clean out and also refresh the window\n\t * info in the 8bpp window table:\n\t */\n\tif (now > last_clear + 10) {\n\t\tlast_clear = now;\n\t\tX_LOCK;\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tWindow w = windows_8bpp[i].win;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\t/* catch windows that went away: */\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\n\tMV_count = 0;\n\tMV_hit = 0;\n\tMV_start = dnow();\n\n\tset_root_cmap();\n\n\t/* loop over all toplevels, both 8 and 24 depths: */\n\n\tX_LOCK;\t/* a giant lock around the whole activity */\n\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow r, parent;\n\t\tWindow *list0;\n\t\tStatus rc;\n\t\tunsigned int nc0;\n\t\tint i1;\n\t\tXErrorHandler old_handler;\n\t\tdouble delay;\n\n\t\tWindow win = stack_list[k].win;\n\n\t\t/* TUNABLE */\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay = 1.5 * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay = 1.5 * POLL_8TO24_DELAY;\t/* 0.075 */\n\t\t}\n\n\t\tif (now < last_query + delay) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\tint i;\n\t\t\t/*\n\t\t\t * if the toplevel became unmapped, mark it\n\t\t\t * for the children as well...\n\t\t\t */\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].top == win) {\n\t\t\t\t\twindows_8bpp[i].map_state =\n\t\t\t\t\t    stack_list[k].map_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (check_depth(win, win, doall)) {\n\t\t\t/*\n\t\t\t * returns 1 if no need to recurse down e.g. It\n\t\t\t * is 8bpp and we assume all lower ones are too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* we recurse up to two levels down from stack_list windows */\n\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\trc = XQueryTree_wr(dpy, win, &r, &parent, &list0, &nc0);\n\t\tXSetErrorHandler(old_handler);\n\n\t\tif (! rc || trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\tcontinue;\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t\t/* loop over grandchildren of rootwin: */\n\t\tfor (i1=0; i1 < (int) nc0; i1++) {\n\t\t\tWindow win1 = list0[i1];\n\t\t\tWindow *list1;\n\t\t\tunsigned int nc1;\n\t\t\tint i2;\n\n\t\t\tif (check_depth(win1, win, doall)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (level2_8to24) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\t\t\trc = XQueryTree_wr(dpy, win1, &r, &parent, &list1, &nc1);\n\t\t\tXSetErrorHandler(old_handler);\n\n\t\t\tif (! rc || trapped_xerror) {\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\n\t\t\t/* loop over great-grandchildren of rootwin: */\n\t\t\tfor (i2=0; i2< (int) nc1; i2++) {\n\t\t\t\tWindow win2 = list1[i2];\n\n\t\t\t\tif (check_depth(win2, win, doall)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* more? Which wm does this? */\n\t\t\t}\n\t\t\tif (nc1) {\n\t\t\t\tXFree_wr(list1);\n\t\t\t}\n\t\t}\n\t\tif (nc0) {\n\t\t\tXFree_wr(list0);\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tlast_query = dnow();\n\nMV_glob += MV_count;\nif (0) fprintf(stderr, \"MV_count: %d hit: %d %.4f  %10.2f\\n\", MV_count, MV_hit, last_query - MV_start, MV_glob / (last_query - x11vnc_start));\n\n\tif (screen_fixup_8 > 0.0 && now > last_fixup + screen_fixup_8) {\n\t\tlast_fixup = now;\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (poll_8to24_delay > 0.0) {\n\t\tint area = -1;\n\t\tint validate = 0;\n\n\t\tif (diff && multivis_count) {\n\t\t\tvalidate = 1;\n\t\t}\n\t\tif (now > last_poll + poll_8to24_delay) {\n\t\t\tsraRegionPtr mod;\n\n\t\t\tlast_poll = now;\n\t\t\tmod = sraRgnCreate();\n\t\t\tarea = poll_8bpp(mod, validate);\n\t\t\tif (depth == 24) {\n\t\t\t\tpoll_8bpp_complement(mod);\n\t\t\t}\n\t\t\tmark_rgn_rects(mod);\n\t\t\tsraRgnDestroy(mod);\n\t\t}\n\t\tif (0 && area < dpy_x * dpy_y / 2 && diff && multivis_count) {\n\t\t\tmark_8bpp(MARK_8BPP_POINTER);\n\t\t\tlast_poll = now;\n\t\t}\n\n\t} else if (diff && multivis_count) {\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (depth <= 16 && multivis_24count) {\n\t\tstatic double last_check = 0.0;\n\t\tif (now > last_check + 0.4) {\n\t\t\tlast_check = now;\n\t\t\tif (check_pointer_in_depth24()) {\n\t\t\t\tlast_poll = now;\n\t\t\t}\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done: %.4f\\n\", dnow() - last_query);\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MAX_8BPP_WINDOWS 64"
    ],
    "globals_used": [
      "int multivis_count = 0;",
      "int multivis_24count = 0;",
      "void check_for_multivis(void);",
      "void mark_8bpp(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"done: %.4f\\n\"",
            "dnow() - last_query"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_pointer_in_depth24",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "check_pointer_in_depth24",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "190-233",
          "snippet": "static int check_pointer_in_depth24(void) {\n\tint tries = 0, in_24 = 0;\n\tXWindowAttributes attr;\n\tWindow c, w;\n\tdouble now = dnow();\n\n\tc = window;\n\n\tRAWFB_RET(0)\n\n\tif (now > last_keyboard_time + 1.0 && now > last_pointer_time + 1.0) {\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\twhile (c && tries++ < 3) {\n\t\tc = query_pointer(c);\n\t\tif (valid_window(c, &attr, 1)) \t{\n\t\t\tif (attr.depth == 24) {\n\t\t\t\tin_24 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\tif (in_24) {\n\t\tint x1, y1, x2, y2;\n\t\tX_LOCK;\n\t\txtranslate(c, window, 0, 0, &x1, &y1, &w, 1);\n\t\tX_UNLOCK;\n\t\tx2 = x1 + attr.width;\n\t\ty2 = y1 + attr.height;\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\nif (db24 > 1) fprintf(stderr, \"check_pointer_in_depth24 %d %d %d %d\\n\", x1, y1, x2, y2);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int check_pointer_in_depth24(void) {\n\tint tries = 0, in_24 = 0;\n\tXWindowAttributes attr;\n\tWindow c, w;\n\tdouble now = dnow();\n\n\tc = window;\n\n\tRAWFB_RET(0)\n\n\tif (now > last_keyboard_time + 1.0 && now > last_pointer_time + 1.0) {\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\twhile (c && tries++ < 3) {\n\t\tc = query_pointer(c);\n\t\tif (valid_window(c, &attr, 1)) \t{\n\t\t\tif (attr.depth == 24) {\n\t\t\t\tin_24 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\tif (in_24) {\n\t\tint x1, y1, x2, y2;\n\t\tX_LOCK;\n\t\txtranslate(c, window, 0, 0, &x1, &y1, &w, 1);\n\t\tX_UNLOCK;\n\t\tx2 = x1 + attr.width;\n\t\ty2 = y1 + attr.height;\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\nif (db24 > 1) fprintf(stderr, \"check_pointer_in_depth24 %d %d %d %d\\n\", x1, y1, x2, y2);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_8bpp",
          "args": [
            "MARK_8BPP_ALL"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "mark_8bpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "2056-2152",
          "snippet": "void mark_8bpp(int mode) {\n\tint i, cnt = 0;\n\tWindow top = None;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || !cmap8to24_fb) {\n\t\treturn;\n\t}\n\t\n\tif (mode == MARK_8BPP_TOP) {\n\t\tint k;\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t\ttop = swin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (top != None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* for each mapped 8bpp window, mark it changed: */\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tint x1, y1, x2, y2, w, h, f = 32;\n\n\t\tf = 0;\t/* skip fuzz, may bring in other windows... */\n\n\t\tif (windows_8bpp[i].win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mode == MARK_8BPP_TOP) {\n\t\t\tif (windows_8bpp[i].top != top) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint vw = 0;\n\n\t\t\tX_LOCK;\n\t\t\tvw = valid_window(windows_8bpp[i].win, &attr, 1);\n\t\t\tX_UNLOCK;\n\t\t\tif (vw) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tx1 = windows_8bpp[i].x;\n\t\ty1 = windows_8bpp[i].y;\n\t\tw  = windows_8bpp[i].w;\n\t\th  = windows_8bpp[i].h;\n\n\t\tx2 = x1 + w;\n\t\ty2 = y1 + h;\n\n\t\tif (mode == MARK_8BPP_POINTER) {\n\t\t\tint b = 32;\t/* apply some fuzz for wm border */\n\t\t\tif (cursor_x < x1 - b || cursor_y < y1 - b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cursor_x > x2 + b || cursor_y > y2 + b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* apply fuzz f around each one; constrain to screen */\n\t\tx1 = nfix(x1 - f, dpy_x);\n\t\ty1 = nfix(y1 - f, dpy_y);\n\t\tx2 = nfix(x2 + f, dpy_x+1);\n\t\ty2 = nfix(y2 + f, dpy_y+1);\n\nif (db24 > 1) fprintf(stderr, \"mark_8bpp: 0x%lx %d %d %d %d\\n\", windows_8bpp[i].win, x1, y1, x2, y2);\n\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\tcnt++;\n\t}\n\tif (cnt) {\n\t\t/* push it to viewers if possible. */\n\t\trfbPE(-1);\n\t}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [
            "void mark_8bpp(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nvoid mark_8bpp(int);\n\nvoid mark_8bpp(int mode) {\n\tint i, cnt = 0;\n\tWindow top = None;\n\n\tRAWFB_RET_VOID\n\n\tif (! cmap8to24 || !cmap8to24_fb) {\n\t\treturn;\n\t}\n\t\n\tif (mode == MARK_8BPP_TOP) {\n\t\tint k;\n\t\tfor (k = stack_list_num - 1; k >= 0; k--) {\n\t\t\tWindow swin = stack_list[k].win;\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].win == None) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (swin == windows_8bpp[i].top) {\n\t\t\t\t\ttop = swin;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (top != None) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* for each mapped 8bpp window, mark it changed: */\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tint x1, y1, x2, y2, w, h, f = 32;\n\n\t\tf = 0;\t/* skip fuzz, may bring in other windows... */\n\n\t\tif (windows_8bpp[i].win == None) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (mode == MARK_8BPP_TOP) {\n\t\t\tif (windows_8bpp[i].top != top) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tXWindowAttributes attr;\n\t\t\tint vw = 0;\n\n\t\t\tX_LOCK;\n\t\t\tvw = valid_window(windows_8bpp[i].win, &attr, 1);\n\t\t\tX_UNLOCK;\n\t\t\tif (vw) {\n\t\t\t\tif (attr.map_state != IsViewable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tx1 = windows_8bpp[i].x;\n\t\ty1 = windows_8bpp[i].y;\n\t\tw  = windows_8bpp[i].w;\n\t\th  = windows_8bpp[i].h;\n\n\t\tx2 = x1 + w;\n\t\ty2 = y1 + h;\n\n\t\tif (mode == MARK_8BPP_POINTER) {\n\t\t\tint b = 32;\t/* apply some fuzz for wm border */\n\t\t\tif (cursor_x < x1 - b || cursor_y < y1 - b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cursor_x > x2 + b || cursor_y > y2 + b) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* apply fuzz f around each one; constrain to screen */\n\t\tx1 = nfix(x1 - f, dpy_x);\n\t\ty1 = nfix(y1 - f, dpy_y);\n\t\tx2 = nfix(x2 + f, dpy_x+1);\n\t\ty2 = nfix(y2 + f, dpy_y+1);\n\nif (db24 > 1) fprintf(stderr, \"mark_8bpp: 0x%lx %d %d %d %d\\n\", windows_8bpp[i].win, x1, y1, x2, y2);\n\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\t\tcnt++;\n\t}\n\tif (cnt) {\n\t\t/* push it to viewers if possible. */\n\t\trfbPE(-1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "mod"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rgn_rects",
          "args": [
            "mod"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rgn_rects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1189-1206",
          "snippet": "static void mark_rgn_rects(sraRegionPtr mod) {\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint area = 0;\n\n\tif (sraRgnEmpty(mod)) {\n\t\treturn;\n\t}\n\t\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tmark_rect_as_modified(rect.x1, rect.y1, rect.x2, rect.y2, 0);\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\nif (db24 > 1) fprintf(stderr, \" mark_rgn_rects area: %d\\n\", area);\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void mark_rgn_rects(sraRegionPtr mod) {\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint area = 0;\n\n\tif (sraRgnEmpty(mod)) {\n\t\treturn;\n\t}\n\t\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tmark_rect_as_modified(rect.x1, rect.y1, rect.x2, rect.y2, 0);\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\nif (db24 > 1) fprintf(stderr, \" mark_rgn_rects area: %d\\n\", area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_8bpp_complement",
          "args": [
            "mod"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "poll_8bpp_complement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1145-1187",
          "snippet": "static void poll_8bpp_complement(sraRegionPtr mod) {\n\tint i, y, ysh;\n\tstatic int ycnt = 0;\n\tsraRegionPtr disp, line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\n\tdisp = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tysh = scanlines[(ycnt++) % NSCAN];\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tcontinue;\t\n\t\t}\n\t\tsraRgnSubtract(disp, reg);\n\t}\n\n\ty = ysh;\n\twhile (y < dpy_y) {\n\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\tif (sraRgnAnd(line, disp)) {\n\t\t\titer = sraRgnGetIterator(line);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\tpoll_line_complement(rect.x1, rect.x2,\n\t\t\t\t    rect.y1, mod);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\t\t}\n\n\t\tsraRgnDestroy(line);\n\n\t\ty += NSCAN;\n\t}\n\n\tsraRgnDestroy(disp);\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nstatic void poll_8bpp_complement(sraRegionPtr mod) {\n\tint i, y, ysh;\n\tstatic int ycnt = 0;\n\tsraRegionPtr disp, line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\n\tdisp = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\n\tysh = scanlines[(ycnt++) % NSCAN];\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (windows_8bpp[i].map_state != IsViewable) {\n\t\t\tcontinue;\t\n\t\t}\n\t\tsraRgnSubtract(disp, reg);\n\t}\n\n\ty = ysh;\n\twhile (y < dpy_y) {\n\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\tif (sraRgnAnd(line, disp)) {\n\t\t\titer = sraRgnGetIterator(line);\n\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\tpoll_line_complement(rect.x1, rect.x2,\n\t\t\t\t    rect.y1, mod);\n\t\t\t}\n\t\t\tsraRgnReleaseIterator(iter);\n\t\t}\n\n\t\tsraRgnDestroy(line);\n\n\t\ty += NSCAN;\n\t}\n\n\tsraRgnDestroy(disp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_8bpp",
          "args": [
            "mod",
            "validate"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "poll_8bpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "1084-1143",
          "snippet": "static int poll_8bpp(sraRegionPtr mod, int validate) {\n\tint i, y, ysh, map_count;\n\tstatic int ycnt = 0;\n\tsraRegionPtr line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint br = 0, area = 0;\n\tstatic double last_call = 0.0;\n\t\n\tmap_count = get_8bpp_regions(validate);\n\nif (db24 > 1) fprintf(stderr, \"poll_8bpp mc: %d\\n\", map_count);\n\n\tif (! map_count) {\n\t\treturn 0;\n\t}\n\n\tset_poll_fb();\n\n\tysh = scanlines[(ycnt++) % NSCAN];\nif (db24 > 2) fprintf(stderr, \"poll_8bpp: ysh: %2d  %.4f\\n\", ysh, dnow() - last_call);\n\tlast_call = dnow();\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg || sraRgnEmpty(reg)) {\n\t\t\tcontinue;\n\t\t}\n\t\ty = ysh;\n\t\twhile (y < dpy_y) {\n\t\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\t\tif (sraRgnAnd(line, reg)) {\n\t\t\t\titer = sraRgnGetIterator(line);\n\t\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t\tif (! poll_line(rect.x1, rect.x2,\n\t\t\t\t\t    rect.y1, i, mod)) {\n\t\t\t\t\t\tbr = 1;\n\t\t\t\t\t\tbreak;\t/* exception */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsraRgnReleaseIterator(iter);\n\t\t\t}\n\n\t\t\tsraRgnDestroy(line);\n\t\t\ty += NSCAN;\n\t\t\tif (br) break;\n\t\t}\n\t\tif (br) break;\n\t}\n\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\n\treturn area;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nstatic int poll_8bpp(sraRegionPtr mod, int validate) {\n\tint i, y, ysh, map_count;\n\tstatic int ycnt = 0;\n\tsraRegionPtr line;\n\tsraRect rect;\n\tsraRectangleIterator *iter;\n\tint br = 0, area = 0;\n\tstatic double last_call = 0.0;\n\t\n\tmap_count = get_8bpp_regions(validate);\n\nif (db24 > 1) fprintf(stderr, \"poll_8bpp mc: %d\\n\", map_count);\n\n\tif (! map_count) {\n\t\treturn 0;\n\t}\n\n\tset_poll_fb();\n\n\tysh = scanlines[(ycnt++) % NSCAN];\nif (db24 > 2) fprintf(stderr, \"poll_8bpp: ysh: %2d  %.4f\\n\", ysh, dnow() - last_call);\n\tlast_call = dnow();\n\n\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\tsraRegionPtr reg = windows_8bpp[i].clip_region;\n\n\t\tif (! reg || sraRgnEmpty(reg)) {\n\t\t\tcontinue;\n\t\t}\n\t\ty = ysh;\n\t\twhile (y < dpy_y) {\n\t\t\tline = sraRgnCreateRect(0, y, dpy_x, y+1);\n\n\t\t\tif (sraRgnAnd(line, reg)) {\n\t\t\t\titer = sraRgnGetIterator(line);\n\t\t\t\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\t\t\t\tif (! poll_line(rect.x1, rect.x2,\n\t\t\t\t\t    rect.y1, i, mod)) {\n\t\t\t\t\t\tbr = 1;\n\t\t\t\t\t\tbreak;\t/* exception */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsraRgnReleaseIterator(iter);\n\t\t\t}\n\n\t\t\tsraRgnDestroy(line);\n\t\t\ty += NSCAN;\n\t\t\tif (br) break;\n\t\t}\n\t\tif (br) break;\n\t}\n\n\titer = sraRgnGetIterator(mod);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tarea += nabs((rect.x2 - rect.x1)*(rect.y2 - rect.y1));\n\t}\n\tsraRgnReleaseIterator(iter);\n\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"MV_count: %d hit: %d %.4f  %10.2f\\n\"",
            "MV_count",
            "MV_hit",
            "last_query - MV_start",
            "MV_glob / (last_query - x11vnc_start)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFree_wr",
          "args": [
            "list0"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "XFree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1664-1676",
          "snippet": "int XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void XTestDiscard_wr(Display *dpy);",
            "int XFree_wr(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nvoid XTestDiscard_wr(Display *dpy);\nint XFree_wr(void *data);\n\nint XFree_wr(void *data) {\n\tif (data == NULL) {\n\t\treturn 1;\n\t}\n\tif (! dpy) {\n\t\treturn 1;\n\t}\n#if NO_X11\n\treturn 1;\n#else\n\treturn XFree(data);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_depth",
          "args": [
            "win2",
            "win",
            "doall"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "check_depth_win",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "707-816",
          "snippet": "static int check_depth_win(Window win, Window top, XWindowAttributes *attr) {\n\tint store_it = 0;\n\t/*\n\t * only store windows with depth not equal to the default visual's\n\t * depth note some windows can have depth == 0 ... (skip them).\n\t */\n\tif (attr->depth > 0) {\n\t\tif (depth == 24 && attr->depth != 24) {\n\t\t\tstore_it = 1;\n\t\t} else if (depth <= 16 && root_cmap && attr->colormap != root_cmap) {\n\t\t\tstore_it = 1;\n\t\t}\n\t}\n\n\tif (store_it) {\n\t\tint i, j = -1, none = -1, nomap = -1;\n\t\tint newc = 0;\n\t\tif (attr->map_state == IsViewable) {\n\t\t\t/* count the visible ones: */\n\t\t\tmultivis_count++;\n\t\t\tif (attr->depth == 24) {\n\t\t\t\tmultivis_24count++;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx %d\\n\", win, attr->depth);\n\t\t}\n\n\t\t/* try to find a table slot for this window: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tif (none < 0 && windows_8bpp[i].win == None) {\n\t\t\t\t/* found first None */\n\t\t\t\tnone = i;\n\t\t\t}\n\t\t\tif (windows_8bpp[i].win == win) {\n\t\t\t\t/* found myself */\n\t\t\t\tj = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nomap < 0 && windows_8bpp[i].win != None &&\n\t\t\t    windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t/* found first unmapped */\n\t\t\t\tnomap = i;\n\t\t\t}\n\t\t}\n\t\tif (j < 0) {\n\t\t\tif (attr->map_state != IsViewable) {\n\t\t\t\t/* no slot and not visible: not worth keeping */\n\t\t\t\treturn 1;\n\t\t\t} else if (none >= 0) {\n\t\t\t\t/* put it in the first None slot */\n\t\t\t\tj = none;\n\t\t\t\tnewc = 1;\n\t\t\t} else if (nomap >=0) {\n\t\t\t\t/* put it in the first unmapped slot */\n\t\t\t\tj = nomap;\n\t\t\t}\n\t\t\t/* otherwise we cannot store it... */\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx ms: %d j: %d no: %d nm: %d dep=%d\\n\", win, attr->map_state, j, none, nomap, attr->depth);\n\n\t\t/* store if if we found a slot j: */\n\t\tif (j >= 0) {\n\t\t\tWindow w;\n\t\t\tint x, y;\n\t\t\tint now_vis = 0;\n\n\t\t\tif (attr->map_state == IsViewable &&\n\t\t\t    windows_8bpp[j].map_state != IsViewable) {\n\t\t\t\tnow_vis = 1;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: STORE 0x%lx j: %3d ms: %d dep=%d\\n\", win, j, attr->map_state, attr->depth);\n\t\t\twindows_8bpp[j].win = win;\n\t\t\twindows_8bpp[j].top = top;\n\t\t\twindows_8bpp[j].depth = attr->depth;\n\t\t\twindows_8bpp[j].map_state = attr->map_state;\n\t\t\twindows_8bpp[j].cmap = attr->colormap;\n\t\t\twindows_8bpp[j].map_installed = attr->map_installed;\n\t\t\twindows_8bpp[j].w = attr->width;\n\t\t\twindows_8bpp[j].h = attr->height;\n\t\t\twindows_8bpp[j].fetched = 1;\n\t\t\twindows_8bpp[j].last_fetched = dnow();\n\n\t\t\t/* translate x y to be WRT the root window (not parent) */\n\t\t\txtranslate(win, window, 0, 0, &x, &y, &w, 1);\n\t\t\twindows_8bpp[j].x = x;\n\t\t\twindows_8bpp[j].y = y;\n\n\t\t\tif (newc || now_vis) {\nif (db24) fprintf(stderr, \"new/now_vis: 0x%lx %d/%d\\n\", win, newc, now_vis);\n\t\t\t\t/* mark it immediately if a new one: */\n\t\t\t\tX_UNLOCK;\t/* dont forget the giant lock */\n\t\t\t\tmark_rect_as_modified(x, y, x + attr->width,\n\t\t\t\t    y + attr->height, 0);\n\t\t\t\tX_LOCK;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Error: could not find a slot.\n\t\t\t * perhaps keep age and expire old ones??\n\t\t\t */\nif (db24) fprintf(stderr, \"multivis: CANNOT STORE 0x%lx j=%d\\n\", win, j);\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\nif (db24 > 1) fprintf(stderr, \"          ------------ 0x%lx i=%d\\n\", windows_8bpp[i].win, i);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MAX_8BPP_WINDOWS 64"
          ],
          "globals_used": [
            "int multivis_count = 0;",
            "int multivis_24count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nint multivis_count = 0;\nint multivis_24count = 0;\n\nstatic int check_depth_win(Window win, Window top, XWindowAttributes *attr) {\n\tint store_it = 0;\n\t/*\n\t * only store windows with depth not equal to the default visual's\n\t * depth note some windows can have depth == 0 ... (skip them).\n\t */\n\tif (attr->depth > 0) {\n\t\tif (depth == 24 && attr->depth != 24) {\n\t\t\tstore_it = 1;\n\t\t} else if (depth <= 16 && root_cmap && attr->colormap != root_cmap) {\n\t\t\tstore_it = 1;\n\t\t}\n\t}\n\n\tif (store_it) {\n\t\tint i, j = -1, none = -1, nomap = -1;\n\t\tint newc = 0;\n\t\tif (attr->map_state == IsViewable) {\n\t\t\t/* count the visible ones: */\n\t\t\tmultivis_count++;\n\t\t\tif (attr->depth == 24) {\n\t\t\t\tmultivis_24count++;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx %d\\n\", win, attr->depth);\n\t\t}\n\n\t\t/* try to find a table slot for this window: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tif (none < 0 && windows_8bpp[i].win == None) {\n\t\t\t\t/* found first None */\n\t\t\t\tnone = i;\n\t\t\t}\n\t\t\tif (windows_8bpp[i].win == win) {\n\t\t\t\t/* found myself */\n\t\t\t\tj = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nomap < 0 && windows_8bpp[i].win != None &&\n\t\t\t    windows_8bpp[i].map_state != IsViewable) {\n\t\t\t\t/* found first unmapped */\n\t\t\t\tnomap = i;\n\t\t\t}\n\t\t}\n\t\tif (j < 0) {\n\t\t\tif (attr->map_state != IsViewable) {\n\t\t\t\t/* no slot and not visible: not worth keeping */\n\t\t\t\treturn 1;\n\t\t\t} else if (none >= 0) {\n\t\t\t\t/* put it in the first None slot */\n\t\t\t\tj = none;\n\t\t\t\tnewc = 1;\n\t\t\t} else if (nomap >=0) {\n\t\t\t\t/* put it in the first unmapped slot */\n\t\t\t\tj = nomap;\n\t\t\t}\n\t\t\t/* otherwise we cannot store it... */\n\t\t}\n\nif (db24 > 1) fprintf(stderr, \"multivis: 0x%lx ms: %d j: %d no: %d nm: %d dep=%d\\n\", win, attr->map_state, j, none, nomap, attr->depth);\n\n\t\t/* store if if we found a slot j: */\n\t\tif (j >= 0) {\n\t\t\tWindow w;\n\t\t\tint x, y;\n\t\t\tint now_vis = 0;\n\n\t\t\tif (attr->map_state == IsViewable &&\n\t\t\t    windows_8bpp[j].map_state != IsViewable) {\n\t\t\t\tnow_vis = 1;\n\t\t\t}\nif (db24 > 1) fprintf(stderr, \"multivis: STORE 0x%lx j: %3d ms: %d dep=%d\\n\", win, j, attr->map_state, attr->depth);\n\t\t\twindows_8bpp[j].win = win;\n\t\t\twindows_8bpp[j].top = top;\n\t\t\twindows_8bpp[j].depth = attr->depth;\n\t\t\twindows_8bpp[j].map_state = attr->map_state;\n\t\t\twindows_8bpp[j].cmap = attr->colormap;\n\t\t\twindows_8bpp[j].map_installed = attr->map_installed;\n\t\t\twindows_8bpp[j].w = attr->width;\n\t\t\twindows_8bpp[j].h = attr->height;\n\t\t\twindows_8bpp[j].fetched = 1;\n\t\t\twindows_8bpp[j].last_fetched = dnow();\n\n\t\t\t/* translate x y to be WRT the root window (not parent) */\n\t\t\txtranslate(win, window, 0, 0, &x, &y, &w, 1);\n\t\t\twindows_8bpp[j].x = x;\n\t\t\twindows_8bpp[j].y = y;\n\n\t\t\tif (newc || now_vis) {\nif (db24) fprintf(stderr, \"new/now_vis: 0x%lx %d/%d\\n\", win, newc, now_vis);\n\t\t\t\t/* mark it immediately if a new one: */\n\t\t\t\tX_UNLOCK;\t/* dont forget the giant lock */\n\t\t\t\tmark_rect_as_modified(x, y, x + attr->width,\n\t\t\t\t    y + attr->height, 0);\n\t\t\t\tX_LOCK;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Error: could not find a slot.\n\t\t\t * perhaps keep age and expire old ones??\n\t\t\t */\nif (db24) fprintf(stderr, \"multivis: CANNOT STORE 0x%lx j=%d\\n\", win, j);\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\nif (db24 > 1) fprintf(stderr, \"          ------------ 0x%lx i=%d\\n\", windows_8bpp[i].win, i);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XSetErrorHandler",
          "args": [
            "old_handler"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "XSetErrorHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/nox11_funcs.h",
          "lines": "2819-2821",
          "snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "XErrorHandler XSetErrorHandler (XErrorHandler h) {\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XQueryTree_wr",
          "args": [
            "dpy",
            "win1",
            "&r",
            "&parent",
            "&list1",
            "&nc1"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "XQueryTree_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "1640-1662",
          "snippet": "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Bool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);",
            "int XCloseDisplay_wr(Display *display);",
            "Status XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nBool XTestCompareCurrentCursorWithWindow_wr(Display* dpy, Window w);\nint XCloseDisplay_wr(Display *display);\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return);\n\nStatus XQueryTree_wr(Display *display, Window w, Window *root_return,\n    Window *parent_return, Window **children_return,\n    unsigned int *nchildren_return) {\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_xquerytree(w, root_return, parent_return,\n\t\t    children_return, nchildren_return);\n\t}\n#endif\n#if NO_X11\n\tif (!display || !w || !root_return || !parent_return\n\t    || !children_return || !nchildren_return) {}\n\treturn (Status) 0;\n#else\n\tif (! display) {\n\t\treturn (Status) 0;\n\t}\n\treturn XQueryTree(display, w, root_return, parent_return,\n\t    children_return, nchildren_return);\n#endif\t/* NO_X11 */\n    \t\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_root_cmap",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "set_root_cmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "100-178",
          "snippet": "static void set_root_cmap(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic time_t last_set = 0;\n\ttime_t now = time(NULL);\n\tXWindowAttributes attr;\n\tstatic XColor *color = NULL;\n\tint redo = 0;\n\tint ncolor = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (depth > 16) {\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\n\tif (!root_rgb) {\n\t\troot_rgb = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t}\n\tif (!color) {\n\t\tcolor = (XColor *) malloc(ncolor * sizeof(XColor));\n\t}\n\n\tif (now > last_set + 10) {\n\t\tredo = 1;\n\t}\n\tif (! root_cmap || redo) {\n\t\tX_LOCK;\n\t\tif (! valid_window(window, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t\tif (attr.colormap) {\n\t\t\tint i, ncells = ncolor;\n\n\t\t\tif (depth < 8) {\n\t\t\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\t\t}\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tcolor[i].pixel = i;\n\t\t\t\tcolor[i].pad = 0;\n\t\t\t}\n\t\t\tlast_set = now;\n\t\t\troot_cmap = attr.colormap;\n\t\t\tXQueryColors(dpy, root_cmap, color, ncells);\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tunsigned int red, green, blue;\n\t\t\t\t/* strip out highest 8 bits of values: */\n\t\t\t\tred   = (color[i].red   & 0xff00) >> 8;\n\t\t\t\tgreen = (color[i].green & 0xff00) >> 8;\n\t\t\t\tblue  = (color[i].blue  & 0xff00) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * the maxes should be at 255 already,\n\t\t\t\t * but just in case...\n\t\t\t\t */\n\t\t\t\tred   = (main_red_max   * red  )/255;\n\t\t\t\tgreen = (main_green_max * green)/255;\n\t\t\t\tblue  = (main_blue_max  * blue )/255;\n\n\t\t\t\t/* shift them over and or together for value */\n\t\t\t\tred   = red    << main_red_shift;\n\t\t\t\tgreen = green  << main_green_shift;\n\t\t\t\tblue  = blue   << main_blue_shift;\n\n\t\t\t\t/* store it in the array to be used later */\n\t\t\t\troot_rgb[i] = red | green | blue;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define NCOLOR 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define NCOLOR 256\n\nstatic void set_root_cmap(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic time_t last_set = 0;\n\ttime_t now = time(NULL);\n\tXWindowAttributes attr;\n\tstatic XColor *color = NULL;\n\tint redo = 0;\n\tint ncolor = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (depth > 16) {\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\n\tif (!root_rgb) {\n\t\troot_rgb = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t}\n\tif (!color) {\n\t\tcolor = (XColor *) malloc(ncolor * sizeof(XColor));\n\t}\n\n\tif (now > last_set + 10) {\n\t\tredo = 1;\n\t}\n\tif (! root_cmap || redo) {\n\t\tX_LOCK;\n\t\tif (! valid_window(window, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t\tif (attr.colormap) {\n\t\t\tint i, ncells = ncolor;\n\n\t\t\tif (depth < 8) {\n\t\t\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\t\t}\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tcolor[i].pixel = i;\n\t\t\t\tcolor[i].pad = 0;\n\t\t\t}\n\t\t\tlast_set = now;\n\t\t\troot_cmap = attr.colormap;\n\t\t\tXQueryColors(dpy, root_cmap, color, ncells);\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tunsigned int red, green, blue;\n\t\t\t\t/* strip out highest 8 bits of values: */\n\t\t\t\tred   = (color[i].red   & 0xff00) >> 8;\n\t\t\t\tgreen = (color[i].green & 0xff00) >> 8;\n\t\t\t\tblue  = (color[i].blue  & 0xff00) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * the maxes should be at 255 already,\n\t\t\t\t * but just in case...\n\t\t\t\t */\n\t\t\t\tred   = (main_red_max   * red  )/255;\n\t\t\t\tgreen = (main_green_max * green)/255;\n\t\t\t\tblue  = (main_blue_max  * blue )/255;\n\n\t\t\t\t/* shift them over and or together for value */\n\t\t\t\tred   = red    << main_red_shift;\n\t\t\t\tgreen = green  << main_green_shift;\n\t\t\t\tblue  = blue   << main_blue_shift;\n\n\t\t\t\t/* store it in the array to be used later */\n\t\t\t\troot_rgb[i] = red | green | blue;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "w",
            "&attr",
            "1"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stack_list",
          "args": [],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "update_stack_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "307-353",
          "snippet": "void update_stack_list(void) {\n\tint k;\n\tdouble now;\n\tXWindowAttributes attr;\n\tint boff, bwin;\n\n\tif (! stack_list) {\n\t\treturn;\n\t}\n\tif (! stack_list_num) {\n\t\treturn;\n\t}\n\n\tdtime0(&now);\n\n\tboff = get_boff();\n\tbwin = get_bwin();\n\t\n\tX_LOCK;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow win = stack_list[k].win;\n\t\tif (win != None && boff <= (int) win && (int) win < boff + bwin) {\n\t\t\t;\t/* special, blackout */\n\t\t} else if (!valid_window(win, &attr, 1)) {\n\t\t\tstack_list[k].valid = 0;\n\t\t} else {\n\t\t\tstack_list[k].valid = 1;\n\t\t\tstack_list[k].x = attr.x;\n\t\t\tstack_list[k].y = attr.y;\n\t\t\tstack_list[k].width = attr.width;\n\t\t\tstack_list[k].height = attr.height;\n\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\tstack_list[k].depth = attr.depth;\n\t\t\tstack_list[k].class = attr.class;\n\t\t\tstack_list[k].backing_store = attr.backing_store;\n\t\t\tstack_list[k].map_state = attr.map_state;\n\n\t\t\t/* root_x, root_y not used for stack_list usage: */\n\t\t\tstack_list[k].rx = -1;\n\t\t\tstack_list[k].ry = -1;\n\t\t}\n\t\tstack_list[k].fetched = 1;\n\t\tstack_list[k].time = now;\n\t}\n\tX_UNLOCK;\nif (0) fprintf(stderr, \"update_stack_list[%d]: %.4f  %.4f\\n\", stack_list_num, now - x11vnc_start, dtime(&now));\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *stack_list = NULL;",
            "int stack_list_num = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_num = 0;\n\nvoid update_stack_list(void) {\n\tint k;\n\tdouble now;\n\tXWindowAttributes attr;\n\tint boff, bwin;\n\n\tif (! stack_list) {\n\t\treturn;\n\t}\n\tif (! stack_list_num) {\n\t\treturn;\n\t}\n\n\tdtime0(&now);\n\n\tboff = get_boff();\n\tbwin = get_bwin();\n\t\n\tX_LOCK;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow win = stack_list[k].win;\n\t\tif (win != None && boff <= (int) win && (int) win < boff + bwin) {\n\t\t\t;\t/* special, blackout */\n\t\t} else if (!valid_window(win, &attr, 1)) {\n\t\t\tstack_list[k].valid = 0;\n\t\t} else {\n\t\t\tstack_list[k].valid = 1;\n\t\t\tstack_list[k].x = attr.x;\n\t\t\tstack_list[k].y = attr.y;\n\t\t\tstack_list[k].width = attr.width;\n\t\t\tstack_list[k].height = attr.height;\n\t\t\tstack_list[k].border_width = attr.border_width;\n\t\t\tstack_list[k].depth = attr.depth;\n\t\t\tstack_list[k].class = attr.class;\n\t\t\tstack_list[k].backing_store = attr.backing_store;\n\t\t\tstack_list[k].map_state = attr.map_state;\n\n\t\t\t/* root_x, root_y not used for stack_list usage: */\n\t\t\tstack_list[k].rx = -1;\n\t\t\tstack_list[k].ry = -1;\n\t\t}\n\t\tstack_list[k].fetched = 1;\n\t\tstack_list[k].time = now;\n\t}\n\tX_UNLOCK;\nif (0) fprintf(stderr, \"update_stack_list[%d]: %.4f  %.4f\\n\", stack_list_num, now - x11vnc_start, dtime(&now));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snapshot_stack_list",
          "args": [
            "0",
            "0.0"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "snapshot_stack_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "192-293",
          "snippet": "void snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "winattr_t *stack_list = NULL;",
            "int stack_list_len = 0;",
            "int stack_list_num = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nwinattr_t *stack_list = NULL;\nint stack_list_len = 0;\nint stack_list_num = 0;\n\nvoid snapshot_stack_list(int free_only, double allowed_age) {\n\tstatic double last_snap = 0.0, last_free = 0.0;\n\tdouble now; \n\tint num, rc, i, j;\n\tunsigned int ui;\n\tWindow r, w;\n\tWindow *list;\n\n\tif (! stack_list) {\n\t\tstack_list = (winattr_t *) malloc(256*sizeof(winattr_t));\n\t\tstack_list_num = 0;\n\t\tstack_list_len = 256;\n\t}\n\n\tdtime0(&now);\n\tif (free_only) {\n\t\t/* we really don't free it, just reset to zero windows */\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\treturn;\n\t}\n\n\tif (stack_list_num && now < last_snap + allowed_age) {\n\t\treturn;\n\t}\n\n\tstack_list_num = 0;\n\tlast_free = now;\n\n#ifdef MACOSX\n\tif (! macosx_console) {\n\t\tRAWFB_RET_VOID\n\t}\n#else\n\tRAWFB_RET_VOID\n#endif\n\n#if NO_X11 && !defined(MACOSX)\n\tnum = rc = i = j = 0;\t/* compiler warnings */\n\tui = 0;\n\tr = w = None;\n\tlist = NULL;\n\treturn;\n#else\n\n\tX_LOCK;\n\t/* no need to trap error since rootwin */\n\trc = XQueryTree_wr(dpy, rootwin, &r, &w, &list, &ui);\n\tnum = (int) ui;\n\n\tif (! rc) {\n\t\tstack_list_num = 0;\n\t\tlast_free = now;\n\t\tlast_snap = 0.0;\n\t\tX_UNLOCK;\n\t\treturn;\n\t}\n\n\tlast_snap = now;\n\tif (num + blackouts > stack_list_len) {\n\t\tint n = 2 * (num + blackouts);\n\t\tfree(stack_list);\n\t\tstack_list = (winattr_t *) malloc(n*sizeof(winattr_t));\n\t\tstack_list_len = n;\n\t}\n\tj = 0;\n\tfor (i=0; i<num; i++) {\n\t\tstack_list[j].win = list[i];\n\t\tstack_list[j].fetched = 0;\n\t\tstack_list[j].valid = 0;\n\t\tstack_list[j].time = now;\n\t\tj++;\n\t}\n\tfor (i=0; i<blackouts; i++) {\n\t\tstack_list[j].win = get_boff() + 1;\n\t\tstack_list[j].fetched = 1;\n\t\tstack_list[j].valid = 1;\n\t\tstack_list[j].x = blackr[i].x1;\n\t\tstack_list[j].y = blackr[i].y1;\n\t\tstack_list[j].width  = blackr[i].x2 - blackr[i].x1;\n\t\tstack_list[j].height = blackr[i].y2 - blackr[i].y1;\n\t\tstack_list[j].time = now;\n\t\tstack_list[j].map_state = IsViewable;\n\t\tstack_list[j].rx = -1;\n\t\tstack_list[j].ry = -1;\n\t\tj++;\n\nif (0) fprintf(stderr, \"blackr: %d %dx%d+%d+%d\\n\", i,\n\tstack_list[j-1].width, stack_list[j-1].height,\n\tstack_list[j-1].x, stack_list[j-1].y);\n\n\t}\n\tstack_list_num = num + blackouts;\n\tif (debug_wireframe > 1) {\n\t\tfprintf(stderr, \"snapshot_stack_list: num=%d len=%d\\n\",\n\t\t    stack_list_num, stack_list_len);\n\t}\n\n\tXFree_wr(list);\n\tX_UNLOCK;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "n*sizeof(Window)",
            "1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "stack_old"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_poll_fb",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "set_poll_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "285-297",
          "snippet": "static void set_poll_fb(void) {\n\t/* create polling framebuffers or recreate if too small. */\n\n\tif (! xgetimage_8to24) {\n\t\treturn;\t\t/* this saves a bit of RAM */\n\t}\n\tpfb(4, &poll24_fb, &poll24_fb_w, &poll24_fb_h);\n\tif (depth > 8 && depth <= 16) {\n\t\tpfb(2, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\t/* 2X for rare 16bpp colormap case */\n\t} else {\n\t\tpfb(1, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\n\t}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_poll_fb(void) {\n\t/* create polling framebuffers or recreate if too small. */\n\n\tif (! xgetimage_8to24) {\n\t\treturn;\t\t/* this saves a bit of RAM */\n\t}\n\tpfb(4, &poll24_fb, &poll24_fb_w, &poll24_fb_h);\n\tif (depth > 8 && depth <= 16) {\n\t\tpfb(2, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\t/* 2X for rare 16bpp colormap case */\n\t} else {\n\t\tpfb(1, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\" check_for_multivis: %.4f\\n\"",
            "now - last_call"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_cmap8to24",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "parse_cmap8to24",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "235-268",
          "snippet": "static void parse_cmap8to24(void) {\n\tif (cmap8to24_str) {\n\t\tchar *p, *str = strdup(cmap8to24_str);\n\t\tp = strtok(str, \",\");\n\t\t/* defaults: */\n\t\tdb24 = 0;\n\t\txgetimage_8to24 = 1;\n\t\tpoll_8to24_delay = POLL_8TO24_DELAY;\n\t\tlevel2_8to24 = 0;\n\t\tcache_win = 0.0;\n\t\twhile (p) {\n\t\t\tif (strstr(p, \"dbg=\") == p) {\n\t\t\t\tdb24 = atoi(p + strlen(\"dbg=\"));\n\t\t\t} else if (strstr(p, \"poll=\") == p) {\n\t\t\t\tpoll_8to24_delay = atof(p + strlen(\"poll=\"));\n\t\t\t} else if (strstr(p, \"cachewin=\") == p) {\n\t\t\t\tcache_win = atof(p + strlen(\"cachewin=\"));\n\t\t\t} else if (!strcmp(p, \"nogetimage\")) {\n\t\t\t\txgetimage_8to24 = 0;\n\t\t\t} else if (!strcmp(p, \"level2\")) {\n\t\t\t\tlevel2_8to24 = 1;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tif (getenv(\"DEBUG_8TO24\") != NULL) {\n\t\t\tdb24 = atoi(getenv(\"DEBUG_8TO24\"));\n\t\t}\n\t\tif (getenv(\"NOXGETIMAGE_8TO24\") != NULL) {\n\t\t\txgetimage_8to24 = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void parse_cmap8to24(void) {\n\tif (cmap8to24_str) {\n\t\tchar *p, *str = strdup(cmap8to24_str);\n\t\tp = strtok(str, \",\");\n\t\t/* defaults: */\n\t\tdb24 = 0;\n\t\txgetimage_8to24 = 1;\n\t\tpoll_8to24_delay = POLL_8TO24_DELAY;\n\t\tlevel2_8to24 = 0;\n\t\tcache_win = 0.0;\n\t\twhile (p) {\n\t\t\tif (strstr(p, \"dbg=\") == p) {\n\t\t\t\tdb24 = atoi(p + strlen(\"dbg=\"));\n\t\t\t} else if (strstr(p, \"poll=\") == p) {\n\t\t\t\tpoll_8to24_delay = atof(p + strlen(\"poll=\"));\n\t\t\t} else if (strstr(p, \"cachewin=\") == p) {\n\t\t\t\tcache_win = atof(p + strlen(\"cachewin=\"));\n\t\t\t} else if (!strcmp(p, \"nogetimage\")) {\n\t\t\t\txgetimage_8to24 = 0;\n\t\t\t} else if (!strcmp(p, \"level2\")) {\n\t\t\t\tlevel2_8to24 = 1;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tif (getenv(\"DEBUG_8TO24\") != NULL) {\n\t\t\tdb24 = atoi(getenv(\"DEBUG_8TO24\"));\n\t\t}\n\t\tif (getenv(\"NOXGETIMAGE_8TO24\") != NULL) {\n\t\t\txgetimage_8to24 = 0;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define MAX_8BPP_WINDOWS 64\n\nint multivis_count = 0;\nint multivis_24count = 0;\nvoid check_for_multivis(void);\nvoid mark_8bpp(int);\n\nvoid check_for_multivis(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tXWindowAttributes attr;\n\tint doall = 0;\n\tint k, i, cnt, diff;\n\tstatic int first = 1;\n\tstatic Window *stack_old = NULL;\n\tstatic int stack_old_len = 0;\n\tstatic double last_parse = 0.0;\n\tstatic double last_update = 0.0;\n\tstatic double last_clear = 0.0;\n\tstatic double last_poll = 0.0;\n\tstatic double last_fixup = 0.0;\n\tstatic double last_call = 0.0;\n\tstatic double last_query = 0.0;\n\tdouble now = dnow();\n\tdouble delay;\n\n\tRAWFB_RET_VOID\n\n\tif (now > last_parse + 1.0) {\n\t\tlast_parse = now;\n\t\tparse_cmap8to24();\n\t}\nif (db24 > 2) fprintf(stderr, \" check_for_multivis: %.4f\\n\", now - last_call);\n\tlast_call = now;\n\n\tif (first) {\n\t\tint i;\n\t\t/* initialize 8bpp window table: */\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) \t{\n\t\t\twindows_8bpp[i].win = None;\n\t\t\twindows_8bpp[i].top = None;\n\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\twindows_8bpp[i].clip_region = NULL;\n\t\t}\n\t\tset_poll_fb();\n\n\t\tfirst = 0;\n\t\tdoall = 1;\t/* fetch everything first time */\n\t}\n\n\tif (wireframe_in_progress) {\n\t\treturn;\n\t}\n\n\tset_root_cmap();\n\n\t/*\n\t * allocate an \"old stack\" list of all toplevels.  we compare\n\t * this to the current stack to guess stacking order changes.\n\t */\n\tif (!stack_old || stack_old_len < stack_list_len) {\n\t\tint n = stack_list_len;\n\t\tif (n < 256) {\n\t\t\tn = 256;\n\t\t}\n\t\tif (stack_old) {\n\t\t\tfree(stack_old);\n\t\t}\n\t\tstack_old = (Window *) calloc(n*sizeof(Window), 1);\n\t\tstack_old_len = n;\n\t}\n\n\t/* fill the old stack with visible windows: */\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid &&\n\t\t    stack_list[k].map_state == IsViewable) {\n\t\t\tstack_old[cnt++] = stack_list[k].win;\n\t\t}\n\t}\n\n\t/* snapshot + update the current stacking order: */\n\t/* TUNABLE */\n\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\tdelay = 3.0 * poll_8to24_delay;\n\t} else {\n\t\tdelay = 3.0 * POLL_8TO24_DELAY;\t/* 0.15 */\n\t}\n\tif (doall || now > last_update + delay) {\n\t\tsnapshot_stack_list(0, 0.0);\n\t\tupdate_stack_list();\n\t\tlast_update = now;\n\t}\n\n\t/* look for differences in the visible toplevels: */\n\tdiff = 0;\n\tcnt = 0;\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tif (stack_list[k].valid && stack_list[k].map_state ==\n\t\t    IsViewable) {\n\t\t\tif (stack_old[cnt] != stack_list[k].win) {\n\t\t\t\tdiff = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tmultivis_count = 0;\n\tmultivis_24count = 0;\n\n\t/*\n\t * every 10 seconds we try to clean out and also refresh the window\n\t * info in the 8bpp window table:\n\t */\n\tif (now > last_clear + 10) {\n\t\tlast_clear = now;\n\t\tX_LOCK;\n\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\tWindow w = windows_8bpp[i].win;\n\t\t\tif (! valid_window(w, &attr, 1)) {\n\t\t\t\t/* catch windows that went away: */\n\t\t\t\twindows_8bpp[i].win = None;\n\t\t\t\twindows_8bpp[i].top = None;\n\t\t\t\twindows_8bpp[i].map_state = IsUnmapped;\n\t\t\t\twindows_8bpp[i].cmap = (Colormap) 0;\n\t\t\t\twindows_8bpp[i].fetched = 0;\n\t\t\t\twindows_8bpp[i].last_fetched = -1.0;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n\n\tMV_count = 0;\n\tMV_hit = 0;\n\tMV_start = dnow();\n\n\tset_root_cmap();\n\n\t/* loop over all toplevels, both 8 and 24 depths: */\n\n\tX_LOCK;\t/* a giant lock around the whole activity */\n\n\tfor (k=0; k < stack_list_num; k++) {\n\t\tWindow r, parent;\n\t\tWindow *list0;\n\t\tStatus rc;\n\t\tunsigned int nc0;\n\t\tint i1;\n\t\tXErrorHandler old_handler;\n\t\tdouble delay;\n\n\t\tWindow win = stack_list[k].win;\n\n\t\t/* TUNABLE */\n\t\tif (poll_8to24_delay >= POLL_8TO24_DELAY) {\n\t\t\tdelay = 1.5 * poll_8to24_delay;\n\t\t} else {\n\t\t\tdelay = 1.5 * POLL_8TO24_DELAY;\t/* 0.075 */\n\t\t}\n\n\t\tif (now < last_query + delay) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (win == None) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stack_list[k].map_state != IsViewable) {\n\t\t\tint i;\n\t\t\t/*\n\t\t\t * if the toplevel became unmapped, mark it\n\t\t\t * for the children as well...\n\t\t\t */\n\t\t\tfor (i=0; i < MAX_8BPP_WINDOWS; i++) {\n\t\t\t\tif (windows_8bpp[i].top == win) {\n\t\t\t\t\twindows_8bpp[i].map_state =\n\t\t\t\t\t    stack_list[k].map_state;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (check_depth(win, win, doall)) {\n\t\t\t/*\n\t\t\t * returns 1 if no need to recurse down e.g. It\n\t\t\t * is 8bpp and we assume all lower ones are too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* we recurse up to two levels down from stack_list windows */\n\n\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\ttrapped_xerror = 0;\n\t\trc = XQueryTree_wr(dpy, win, &r, &parent, &list0, &nc0);\n\t\tXSetErrorHandler(old_handler);\n\n\t\tif (! rc || trapped_xerror) {\n\t\t\ttrapped_xerror = 0;\n\t\t\tcontinue;\n\t\t}\n\t\ttrapped_xerror = 0;\n\n\t\t/* loop over grandchildren of rootwin: */\n\t\tfor (i1=0; i1 < (int) nc0; i1++) {\n\t\t\tWindow win1 = list0[i1];\n\t\t\tWindow *list1;\n\t\t\tunsigned int nc1;\n\t\t\tint i2;\n\n\t\t\tif (check_depth(win1, win, doall)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (level2_8to24) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\told_handler = XSetErrorHandler(trap_xerror);\n\t\t\ttrapped_xerror = 0;\n\t\t\trc = XQueryTree_wr(dpy, win1, &r, &parent, &list1, &nc1);\n\t\t\tXSetErrorHandler(old_handler);\n\n\t\t\tif (! rc || trapped_xerror) {\n\t\t\t\ttrapped_xerror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttrapped_xerror = 0;\n\n\t\t\t/* loop over great-grandchildren of rootwin: */\n\t\t\tfor (i2=0; i2< (int) nc1; i2++) {\n\t\t\t\tWindow win2 = list1[i2];\n\n\t\t\t\tif (check_depth(win2, win, doall)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* more? Which wm does this? */\n\t\t\t}\n\t\t\tif (nc1) {\n\t\t\t\tXFree_wr(list1);\n\t\t\t}\n\t\t}\n\t\tif (nc0) {\n\t\t\tXFree_wr(list0);\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tlast_query = dnow();\n\nMV_glob += MV_count;\nif (0) fprintf(stderr, \"MV_count: %d hit: %d %.4f  %10.2f\\n\", MV_count, MV_hit, last_query - MV_start, MV_glob / (last_query - x11vnc_start));\n\n\tif (screen_fixup_8 > 0.0 && now > last_fixup + screen_fixup_8) {\n\t\tlast_fixup = now;\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (poll_8to24_delay > 0.0) {\n\t\tint area = -1;\n\t\tint validate = 0;\n\n\t\tif (diff && multivis_count) {\n\t\t\tvalidate = 1;\n\t\t}\n\t\tif (now > last_poll + poll_8to24_delay) {\n\t\t\tsraRegionPtr mod;\n\n\t\t\tlast_poll = now;\n\t\t\tmod = sraRgnCreate();\n\t\t\tarea = poll_8bpp(mod, validate);\n\t\t\tif (depth == 24) {\n\t\t\t\tpoll_8bpp_complement(mod);\n\t\t\t}\n\t\t\tmark_rgn_rects(mod);\n\t\t\tsraRgnDestroy(mod);\n\t\t}\n\t\tif (0 && area < dpy_x * dpy_y / 2 && diff && multivis_count) {\n\t\t\tmark_8bpp(MARK_8BPP_POINTER);\n\t\t\tlast_poll = now;\n\t\t}\n\n\t} else if (diff && multivis_count) {\n\t\tmark_8bpp(MARK_8BPP_ALL);\n\t\tlast_poll = now;\n\n\t} else if (depth <= 16 && multivis_24count) {\n\t\tstatic double last_check = 0.0;\n\t\tif (now > last_check + 0.4) {\n\t\t\tlast_check = now;\n\t\t\tif (check_pointer_in_depth24()) {\n\t\t\t\tlast_poll = now;\n\t\t\t}\n\t\t}\n\t}\nif (0) fprintf(stderr, \"done: %.4f\\n\", dnow() - last_query);\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "set_poll_fb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "285-297",
    "snippet": "static void set_poll_fb(void) {\n\t/* create polling framebuffers or recreate if too small. */\n\n\tif (! xgetimage_8to24) {\n\t\treturn;\t\t/* this saves a bit of RAM */\n\t}\n\tpfb(4, &poll24_fb, &poll24_fb_w, &poll24_fb_h);\n\tif (depth > 8 && depth <= 16) {\n\t\tpfb(2, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\t/* 2X for rare 16bpp colormap case */\n\t} else {\n\t\tpfb(1, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\n\t}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfb",
          "args": [
            "1",
            "&poll8_fb",
            "&poll8_fb_w",
            "&poll8_fb_h"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "pfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
          "lines": "274-283",
          "snippet": "static void pfb(int fac, char **fb, int *w, int *h)  {\n\tif (! *fb || *w != dpy_x || *h != dpy_y) {\n\t\tif (*fb) {\n\t\t\tfree(*fb);\n\t\t}\n\t\t*fb = (char *) calloc(fac * dpy_x * dpy_y, 1);\n\t\t*w = dpy_x;\n\t\t*h = dpy_y;\n\t}\n}",
          "includes": [
            "#include \"xwrappers.h\"",
            "#include \"win_utils.h\"",
            "#include \"util.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void pfb(int fac, char **fb, int *w, int *h)  {\n\tif (! *fb || *w != dpy_x || *h != dpy_y) {\n\t\tif (*fb) {\n\t\t\tfree(*fb);\n\t\t}\n\t\t*fb = (char *) calloc(fac * dpy_x * dpy_y, 1);\n\t\t*w = dpy_x;\n\t\t*h = dpy_y;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void set_poll_fb(void) {\n\t/* create polling framebuffers or recreate if too small. */\n\n\tif (! xgetimage_8to24) {\n\t\treturn;\t\t/* this saves a bit of RAM */\n\t}\n\tpfb(4, &poll24_fb, &poll24_fb_w, &poll24_fb_h);\n\tif (depth > 8 && depth <= 16) {\n\t\tpfb(2, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\t/* 2X for rare 16bpp colormap case */\n\t} else {\n\t\tpfb(1, &poll8_fb,  &poll8_fb_w,  &poll8_fb_h);\n\t}\n}"
  },
  {
    "function_name": "pfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "274-283",
    "snippet": "static void pfb(int fac, char **fb, int *w, int *h)  {\n\tif (! *fb || *w != dpy_x || *h != dpy_y) {\n\t\tif (*fb) {\n\t\t\tfree(*fb);\n\t\t}\n\t\t*fb = (char *) calloc(fac * dpy_x * dpy_y, 1);\n\t\t*w = dpy_x;\n\t\t*h = dpy_y;\n\t}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "fac * dpy_x * dpy_y",
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*fb"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void pfb(int fac, char **fb, int *w, int *h)  {\n\tif (! *fb || *w != dpy_x || *h != dpy_y) {\n\t\tif (*fb) {\n\t\t\tfree(*fb);\n\t\t}\n\t\t*fb = (char *) calloc(fac * dpy_x * dpy_y, 1);\n\t\t*w = dpy_x;\n\t\t*h = dpy_y;\n\t}\n}"
  },
  {
    "function_name": "parse_cmap8to24",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "235-268",
    "snippet": "static void parse_cmap8to24(void) {\n\tif (cmap8to24_str) {\n\t\tchar *p, *str = strdup(cmap8to24_str);\n\t\tp = strtok(str, \",\");\n\t\t/* defaults: */\n\t\tdb24 = 0;\n\t\txgetimage_8to24 = 1;\n\t\tpoll_8to24_delay = POLL_8TO24_DELAY;\n\t\tlevel2_8to24 = 0;\n\t\tcache_win = 0.0;\n\t\twhile (p) {\n\t\t\tif (strstr(p, \"dbg=\") == p) {\n\t\t\t\tdb24 = atoi(p + strlen(\"dbg=\"));\n\t\t\t} else if (strstr(p, \"poll=\") == p) {\n\t\t\t\tpoll_8to24_delay = atof(p + strlen(\"poll=\"));\n\t\t\t} else if (strstr(p, \"cachewin=\") == p) {\n\t\t\t\tcache_win = atof(p + strlen(\"cachewin=\"));\n\t\t\t} else if (!strcmp(p, \"nogetimage\")) {\n\t\t\t\txgetimage_8to24 = 0;\n\t\t\t} else if (!strcmp(p, \"level2\")) {\n\t\t\t\tlevel2_8to24 = 1;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tif (getenv(\"DEBUG_8TO24\") != NULL) {\n\t\t\tdb24 = atoi(getenv(\"DEBUG_8TO24\"));\n\t\t}\n\t\tif (getenv(\"NOXGETIMAGE_8TO24\") != NULL) {\n\t\t\txgetimage_8to24 = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"NOXGETIMAGE_8TO24\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"DEBUG_8TO24\")"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_8TO24\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DEBUG_8TO24\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"level2\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"nogetimage\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p + strlen(\"cachewin=\")"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"cachewin=\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"cachewin=\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "p + strlen(\"poll=\")"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"poll=\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"poll=\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p + strlen(\"dbg=\")"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"dbg=\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"dbg=\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cmap8to24_str"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic void parse_cmap8to24(void) {\n\tif (cmap8to24_str) {\n\t\tchar *p, *str = strdup(cmap8to24_str);\n\t\tp = strtok(str, \",\");\n\t\t/* defaults: */\n\t\tdb24 = 0;\n\t\txgetimage_8to24 = 1;\n\t\tpoll_8to24_delay = POLL_8TO24_DELAY;\n\t\tlevel2_8to24 = 0;\n\t\tcache_win = 0.0;\n\t\twhile (p) {\n\t\t\tif (strstr(p, \"dbg=\") == p) {\n\t\t\t\tdb24 = atoi(p + strlen(\"dbg=\"));\n\t\t\t} else if (strstr(p, \"poll=\") == p) {\n\t\t\t\tpoll_8to24_delay = atof(p + strlen(\"poll=\"));\n\t\t\t} else if (strstr(p, \"cachewin=\") == p) {\n\t\t\t\tcache_win = atof(p + strlen(\"cachewin=\"));\n\t\t\t} else if (!strcmp(p, \"nogetimage\")) {\n\t\t\t\txgetimage_8to24 = 0;\n\t\t\t} else if (!strcmp(p, \"level2\")) {\n\t\t\t\tlevel2_8to24 = 1;\n\t\t\t}\n\t\t\tp = strtok(NULL, \",\");\n\t\t}\n\t\tfree(str);\n\t} else {\n\t\tif (getenv(\"DEBUG_8TO24\") != NULL) {\n\t\t\tdb24 = atoi(getenv(\"DEBUG_8TO24\"));\n\t\t}\n\t\tif (getenv(\"NOXGETIMAGE_8TO24\") != NULL) {\n\t\t\txgetimage_8to24 = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_pointer_in_depth24",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "190-233",
    "snippet": "static int check_pointer_in_depth24(void) {\n\tint tries = 0, in_24 = 0;\n\tXWindowAttributes attr;\n\tWindow c, w;\n\tdouble now = dnow();\n\n\tc = window;\n\n\tRAWFB_RET(0)\n\n\tif (now > last_keyboard_time + 1.0 && now > last_pointer_time + 1.0) {\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\twhile (c && tries++ < 3) {\n\t\tc = query_pointer(c);\n\t\tif (valid_window(c, &attr, 1)) \t{\n\t\t\tif (attr.depth == 24) {\n\t\t\t\tin_24 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\tif (in_24) {\n\t\tint x1, y1, x2, y2;\n\t\tX_LOCK;\n\t\txtranslate(c, window, 0, 0, &x1, &y1, &w, 1);\n\t\tX_UNLOCK;\n\t\tx2 = x1 + attr.width;\n\t\ty2 = y1 + attr.height;\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\nif (db24 > 1) fprintf(stderr, \"check_pointer_in_depth24 %d %d %d %d\\n\", x1, y1, x2, y2);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"check_pointer_in_depth24 %d %d %d %d\\n\"",
            "x1",
            "y1",
            "x2",
            "y2"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_rect_as_modified",
          "args": [
            "x1",
            "y1",
            "x2",
            "y2",
            "0"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "mark_rect_as_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "1643-1682",
          "snippet": "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force);\n\nvoid mark_rect_as_modified(int x1, int y1, int x2, int y2, int force) {\n\n\tif (damage_time != 0) {\n\t\t/*\n\t\t * This is not XDAMAGE, rather a hack for testing\n\t\t * where we allow the framebuffer to be corrupted for\n\t\t * damage_delay seconds.\n\t\t */\n\t\tint debug = 0;\n\t\tif (time(NULL) > damage_time + damage_delay) {\n\t\t\tif (! quiet) {\n\t\t\t\trfbLog(\"damaging turned off.\\n\");\n\t\t\t}\n\t\t\tdamage_time = 0;\n\t\t\tdamage_delay = 0;\n\t\t} else {\n\t\t\tif (debug) {\n\t\t\t\trfbLog(\"damaging viewer fb by not marking \"\n\t\t\t\t    \"rect: %d,%d,%d,%d\\n\", x1, y1, x2, y2);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tif (rfb_fb == main_fb || force) {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t\treturn;\n\t}\n\n\tif (cmap8to24) {\n\t\tbpp8to24(x1, y1, x2, y2);\n\t}\n\n\tif (scaling) {\n\t\tscale_and_mark_rect(x1, y1, x2, y2, 1);\n\t} else {\n\t\tmark_wrapper(x1, y1, x2, y2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2",
            "dpy_y+1"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtranslate",
          "args": [
            "c",
            "window",
            "0",
            "0",
            "&x1",
            "&y1",
            "&w",
            "1"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "xtranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "142-173",
          "snippet": "Bool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nBool xtranslate(Window src, Window dst, int src_x, int src_y, int *dst_x,\n    int *dst_y, Window *child, int bequiet) {\n\tXErrorHandler old_handler = NULL;\n\tBool ok = False;\n\n\tRAWFB_RET(False)\n#if NO_X11\n\tnox11_exit(1);\n\tif (!src || !dst || !src_x || !src_y || !dst_x || !dst_y || !child || !bequiet) {}\n\tif (!old_handler || !ok) {}\n\treturn False;\n#else\n\n\ttrapped_xerror = 0;\n\told_handler = XSetErrorHandler(trap_xerror);\n\tif (XTranslateCoordinates(dpy, src, dst, src_x, src_y, dst_x,\n\t    dst_y, child)) {\n\t\tok = True;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"xtranslate: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), src);\n\t\t}\n\t\tok = False;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "c",
            "&attr",
            "1"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "query_pointer",
          "args": [
            "c"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "query_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "355-384",
          "snippet": "Window query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nWindow query_pointer(Window start) {\n\tint rx, ry;\n#if !NO_X11\n\tWindow r, c;\t/* compiler warnings */\n\tint wx, wy;\n\tunsigned int mask;\n#endif\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\tmacosx_get_cursor_pos(&rx, &ry);\n\t}\n#endif\n\n\tRAWFB_RET(None)\n\n#if NO_X11\n\tif (!start) { rx = ry = 0; }\n\treturn None;\n#else\n\tif (start == None) {\n\t\tstart = rootwin;\n\t}\n\tif (XQueryPointer_wr(dpy, start, &r, &c, &rx, &ry, &wx, &wy, &mask)) {\n\t\treturn c;\n\t} else {\n\t\treturn None;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nstatic int check_pointer_in_depth24(void) {\n\tint tries = 0, in_24 = 0;\n\tXWindowAttributes attr;\n\tWindow c, w;\n\tdouble now = dnow();\n\n\tc = window;\n\n\tRAWFB_RET(0)\n\n\tif (now > last_keyboard_time + 1.0 && now > last_pointer_time + 1.0) {\n\t\treturn 0;\n\t}\n\n\tX_LOCK;\n\twhile (c && tries++ < 3) {\n\t\tc = query_pointer(c);\n\t\tif (valid_window(c, &attr, 1)) \t{\n\t\t\tif (attr.depth == 24) {\n\t\t\t\tin_24 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\tif (in_24) {\n\t\tint x1, y1, x2, y2;\n\t\tX_LOCK;\n\t\txtranslate(c, window, 0, 0, &x1, &y1, &w, 1);\n\t\tX_UNLOCK;\n\t\tx2 = x1 + attr.width;\n\t\ty2 = y1 + attr.height;\n\t\tx1 = nfix(x1, dpy_x);\n\t\ty1 = nfix(y1, dpy_y);\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\tmark_rect_as_modified(x1, y1, x2, y2, 0);\n\nif (db24 > 1) fprintf(stderr, \"check_pointer_in_depth24 %d %d %d %d\\n\", x1, y1, x2, y2);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_root_cmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "100-178",
    "snippet": "static void set_root_cmap(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic time_t last_set = 0;\n\ttime_t now = time(NULL);\n\tXWindowAttributes attr;\n\tstatic XColor *color = NULL;\n\tint redo = 0;\n\tint ncolor = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (depth > 16) {\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\n\tif (!root_rgb) {\n\t\troot_rgb = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t}\n\tif (!color) {\n\t\tcolor = (XColor *) malloc(ncolor * sizeof(XColor));\n\t}\n\n\tif (now > last_set + 10) {\n\t\tredo = 1;\n\t}\n\tif (! root_cmap || redo) {\n\t\tX_LOCK;\n\t\tif (! valid_window(window, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t\tif (attr.colormap) {\n\t\t\tint i, ncells = ncolor;\n\n\t\t\tif (depth < 8) {\n\t\t\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\t\t}\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tcolor[i].pixel = i;\n\t\t\t\tcolor[i].pad = 0;\n\t\t\t}\n\t\t\tlast_set = now;\n\t\t\troot_cmap = attr.colormap;\n\t\t\tXQueryColors(dpy, root_cmap, color, ncells);\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tunsigned int red, green, blue;\n\t\t\t\t/* strip out highest 8 bits of values: */\n\t\t\t\tred   = (color[i].red   & 0xff00) >> 8;\n\t\t\t\tgreen = (color[i].green & 0xff00) >> 8;\n\t\t\t\tblue  = (color[i].blue  & 0xff00) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * the maxes should be at 255 already,\n\t\t\t\t * but just in case...\n\t\t\t\t */\n\t\t\t\tred   = (main_red_max   * red  )/255;\n\t\t\t\tgreen = (main_green_max * green)/255;\n\t\t\t\tblue  = (main_blue_max  * blue )/255;\n\n\t\t\t\t/* shift them over and or together for value */\n\t\t\t\tred   = red    << main_red_shift;\n\t\t\t\tgreen = green  << main_green_shift;\n\t\t\t\tblue  = blue   << main_blue_shift;\n\n\t\t\t\t/* store it in the array to be used later */\n\t\t\t\troot_rgb[i] = red | green | blue;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define NCOLOR 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XQueryColors",
          "args": [
            "dpy",
            "root_cmap",
            "color",
            "ncells"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CellsOfScreen",
          "args": [
            "ScreenOfDisplay(dpy, scr)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScreenOfDisplay",
          "args": [
            "dpy",
            "scr"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_window",
          "args": [
            "window",
            "&attr",
            "1"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "valid_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/win_utils.c",
          "lines": "92-140",
          "snippet": "int valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"win_utils.h\"",
            "#include \"macosx.h\"",
            "#include \"xrandr.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"cleanup.h\"",
            "#include \"winattr_t.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win_utils.h\"\n#include \"macosx.h\"\n#include \"xrandr.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"cleanup.h\"\n#include \"winattr_t.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nint valid_window(Window win, XWindowAttributes *attr_ret, int bequiet) {\n\tXWindowAttributes attr, *pattr;\n#if !NO_X11\n\tXErrorHandler old_handler;\n\tint ok = 0;\n#endif\n\n\tif (attr_ret == NULL) {\n\t\tpattr = &attr;\n\t} else {\n\t\tpattr = attr_ret;\n\t}\n\n\tif (win == None) {\n\t\treturn 0;\n\t}\n\n#ifdef MACOSX\n\tif (macosx_console) {\n\t\treturn macosx_valid_window(win, attr_ret);\n\t}\n#endif\n\n\tRAWFB_RET(0)\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!win || !attr_ret || !bequiet) {}\n\treturn 0;\n#else\n\n\told_handler = XSetErrorHandler(trap_xerror);\n\ttrapped_xerror = 0;\n\tif (XGetWindowAttributes(dpy, win, pattr)) {\n\t\tok = 1;\n\t}\n\tif (trapped_xerror && trapped_xerror_event) {\n\t\tif (! quiet && ! bequiet) {\n\t\t\trfbLog(\"valid_window: trapped XError: %s (0x%lx)\\n\",\n\t\t\t    xerror_string(trapped_xerror_event), win);\n\t\t}\n\t\tok = 0;\n\t}\n\tXSetErrorHandler(old_handler);\n\ttrapped_xerror = 0;\n\t\n\treturn ok;\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ncolor * sizeof(XColor)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ncolor * sizeof(unsigned int)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\n#define NCOLOR 256\n\nstatic void set_root_cmap(void) {\n#if NO_X11\n\tRAWFB_RET_VOID\n\treturn;\n#else\n\tstatic time_t last_set = 0;\n\ttime_t now = time(NULL);\n\tXWindowAttributes attr;\n\tstatic XColor *color = NULL;\n\tint redo = 0;\n\tint ncolor = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (depth > 16) {\n\t\tncolor = NCOLOR;\n\t} else if (depth > 8) {\n\t\tncolor = 1 << depth;\n\t} else {\n\t\tncolor = NCOLOR;\n\t}\n\n\tif (!root_rgb) {\n\t\troot_rgb = (unsigned int *) malloc(ncolor * sizeof(unsigned int));\n\t}\n\tif (!color) {\n\t\tcolor = (XColor *) malloc(ncolor * sizeof(XColor));\n\t}\n\n\tif (now > last_set + 10) {\n\t\tredo = 1;\n\t}\n\tif (! root_cmap || redo) {\n\t\tX_LOCK;\n\t\tif (! valid_window(window, &attr, 1)) {\n\t\t\tX_UNLOCK;\n\t\t\treturn;\n\t\t}\n\t\tif (attr.colormap) {\n\t\t\tint i, ncells = ncolor;\n\n\t\t\tif (depth < 8) {\n\t\t\t\tncells = CellsOfScreen(ScreenOfDisplay(dpy, scr));\n\t\t\t}\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tcolor[i].pixel = i;\n\t\t\t\tcolor[i].pad = 0;\n\t\t\t}\n\t\t\tlast_set = now;\n\t\t\troot_cmap = attr.colormap;\n\t\t\tXQueryColors(dpy, root_cmap, color, ncells);\n\t\t\tfor (i=0; i < ncells; i++) {\n\t\t\t\tunsigned int red, green, blue;\n\t\t\t\t/* strip out highest 8 bits of values: */\n\t\t\t\tred   = (color[i].red   & 0xff00) >> 8;\n\t\t\t\tgreen = (color[i].green & 0xff00) >> 8;\n\t\t\t\tblue  = (color[i].blue  & 0xff00) >> 8;\n\n\t\t\t\t/*\n\t\t\t\t * the maxes should be at 255 already,\n\t\t\t\t * but just in case...\n\t\t\t\t */\n\t\t\t\tred   = (main_red_max   * red  )/255;\n\t\t\t\tgreen = (main_green_max * green)/255;\n\t\t\t\tblue  = (main_blue_max  * blue )/255;\n\n\t\t\t\t/* shift them over and or together for value */\n\t\t\t\tred   = red    << main_red_shift;\n\t\t\t\tgreen = green  << main_green_shift;\n\t\t\t\tblue  = blue   << main_blue_shift;\n\n\t\t\t\t/* store it in the array to be used later */\n\t\t\t\troot_rgb[i] = red | green | blue;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t}\n#endif\t/* NO_X11 */\n}"
  },
  {
    "function_name": "mark_8bpp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "51-51",
    "snippet": "void mark_8bpp(int x) {}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void mark_8bpp(int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid mark_8bpp(int);\n\nvoid mark_8bpp(int x) {}"
  },
  {
    "function_name": "bpp8to24",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "50-50",
    "snippet": "void bpp8to24(int x, int y, int z, int t) {}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void bpp8to24(int, int, int, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid bpp8to24(int, int, int, int);\n\nvoid bpp8to24(int x, int y, int z, int t) {}"
  },
  {
    "function_name": "check_for_multivis",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/8to24.c",
    "lines": "49-49",
    "snippet": "void check_for_multivis(void) {}",
    "includes": [
      "#include \"xwrappers.h\"",
      "#include \"win_utils.h\"",
      "#include \"util.h\"",
      "#include \"scan.h\"",
      "#include \"cleanup.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void check_for_multivis(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xwrappers.h\"\n#include \"win_utils.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n\nvoid check_for_multivis(void);\n\nvoid check_for_multivis(void) {}"
  }
]