[
  {
    "function_name": "check_xdamage_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "810-838",
    "snippet": "void check_xdamage_state(void) {\n\tif (! xdamage_present) {\n\t\treturn;\n\t}\n\t/*\n\t * Create or destroy the Damage object as needed, we don't want\n\t * one if no clients are connected.\n\t */\n\tif (xdamage_crazy_time > 0.0 && dnow() < xdamage_crazy_time + xdamage_crazy_delay) {\n\t\treturn;\n\t}\n\tif (client_count && use_xdamage) {\n\t\tcreate_xdamage_if_needed(0);\n\t\tif (xdamage_scheduled_mark > 0.0 && dnow() >\n\t\t    xdamage_scheduled_mark) {\n\t\t\tif (xdamage_scheduled_mark_region) {\n\t\t\t\tmark_region_for_xdamage(\n\t\t\t\t    xdamage_scheduled_mark_region);\n\t\t\t\tsraRgnDestroy(xdamage_scheduled_mark_region);\n\t\t\t\txdamage_scheduled_mark_region = NULL;\n\t\t\t} else {\n\t\t\t\tmark_for_xdamage(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t\txdamage_scheduled_mark = 0.0;\n\t\t}\n\t} else {\n\t\tdestroy_xdamage_if_needed();\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int use_xdamage = XDAMAGE;",
      "int xdamage_present = 0;",
      "double xdamage_scheduled_mark = 0.0;",
      "double xdamage_crazy_time = 0.0;",
      "double xdamage_crazy_delay = 300.0;",
      "sraRegionPtr xdamage_scheduled_mark_region = NULL;",
      "void destroy_xdamage_if_needed(void);",
      "void check_xdamage_state(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_xdamage_if_needed",
          "args": [],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_xdamage_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "787-808",
          "snippet": "void destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void destroy_xdamage_if_needed(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid destroy_xdamage_if_needed(void);\n\nvoid destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_for_xdamage",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "mark_for_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2409-2425",
          "snippet": "void mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\n\nvoid mark_for_xdamage(int x, int y, int w, int h) {\n\tint tx1, ty1, tx2, ty2;\n\tsraRegionPtr tmpregion;\n\n\tif (! use_xdamage) {\n\t\treturn;\n\t}\n\n\ttx1 = nfix(x, dpy_x);\n\tty1 = nfix(y, dpy_y);\n\ttx2 = nfix(x + w, dpy_x+1);\n\tty2 = nfix(y + h, dpy_y+1);\n\n\ttmpregion = sraRgnCreateRect(tx1, ty1, tx2, ty2);\n\tadd_region_xdamage(tmpregion);\n\tsraRgnDestroy(tmpregion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "xdamage_scheduled_mark_region"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_region_for_xdamage",
          "args": [
            "xdamage_scheduled_mark_region"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "mark_region_for_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2427-2439",
          "snippet": "void mark_region_for_xdamage(sraRegionPtr region) {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\titer = sraRgnGetIterator(region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x1 = rect.x1;\n\t\tint y1 = rect.y1;\n\t\tint x2 = rect.x2;\n\t\tint y2 = rect.y2;\n\t\tmark_for_xdamage(x1, y1, x2 - x1, y2 - y1);\n\t}\n\tsraRgnReleaseIterator(iter);\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_region_for_xdamage(sraRegionPtr region);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_region_for_xdamage(sraRegionPtr region);\n\nvoid mark_region_for_xdamage(sraRegionPtr region) {\n\tsraRectangleIterator *iter;\n\tsraRect rect;\n\titer = sraRgnGetIterator(region);\n\twhile (sraRgnIteratorNext(iter, &rect)) {\n\t\tint x1 = rect.x1;\n\t\tint y1 = rect.y1;\n\t\tint x2 = rect.x2;\n\t\tint y2 = rect.y2;\n\t\tmark_for_xdamage(x1, y1, x2 - x1, y2 - y1);\n\t}\n\tsraRgnReleaseIterator(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_xdamage_if_needed",
          "args": [
            "0"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "create_xdamage_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "770-785",
          "snippet": "void create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void create_xdamage_if_needed(int force);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid create_xdamage_if_needed(int force);\n\nvoid create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_scheduled_mark = 0.0;\ndouble xdamage_crazy_time = 0.0;\ndouble xdamage_crazy_delay = 300.0;\nsraRegionPtr xdamage_scheduled_mark_region = NULL;\nvoid destroy_xdamage_if_needed(void);\nvoid check_xdamage_state(void);\n\nvoid check_xdamage_state(void) {\n\tif (! xdamage_present) {\n\t\treturn;\n\t}\n\t/*\n\t * Create or destroy the Damage object as needed, we don't want\n\t * one if no clients are connected.\n\t */\n\tif (xdamage_crazy_time > 0.0 && dnow() < xdamage_crazy_time + xdamage_crazy_delay) {\n\t\treturn;\n\t}\n\tif (client_count && use_xdamage) {\n\t\tcreate_xdamage_if_needed(0);\n\t\tif (xdamage_scheduled_mark > 0.0 && dnow() >\n\t\t    xdamage_scheduled_mark) {\n\t\t\tif (xdamage_scheduled_mark_region) {\n\t\t\t\tmark_region_for_xdamage(\n\t\t\t\t    xdamage_scheduled_mark_region);\n\t\t\t\tsraRgnDestroy(xdamage_scheduled_mark_region);\n\t\t\t\txdamage_scheduled_mark_region = NULL;\n\t\t\t} else {\n\t\t\t\tmark_for_xdamage(0, 0, dpy_x, dpy_y);\n\t\t\t}\n\t\t\txdamage_scheduled_mark = 0.0;\n\t\t}\n\t} else {\n\t\tdestroy_xdamage_if_needed();\n\t}\n}"
  },
  {
    "function_name": "destroy_xdamage_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "787-808",
    "snippet": "void destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void destroy_xdamage_if_needed(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"destroyed xdamage object: 0x%lx\\n\"",
            "xdamage"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xdamage_base_event_type+XDamageNotify",
            "&ev"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDamageDestroy",
          "args": [
            "dpy",
            "xdamage"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid destroy_xdamage_if_needed(void);\n\nvoid destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}"
  },
  {
    "function_name": "create_xdamage_if_needed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "770-785",
    "snippet": "void create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void create_xdamage_if_needed(int force);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"created   xdamage object: 0x%lx\\n\"",
            "xdamage"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDamageSubtract",
          "args": [
            "dpy",
            "xdamage",
            "None",
            "None"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDamageCreate",
          "args": [
            "dpy",
            "window",
            "XDamageReportRawRectangles"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid create_xdamage_if_needed(int force);\n\nvoid create_xdamage_if_needed(int force) {\n\n\tRAWFB_RET_VOID\n\n\tif (force) {}\n\n#if HAVE_LIBXDAMAGE\n\tif (! xdamage || force) {\n\t\tX_LOCK;\n\t\txdamage = XDamageCreate(dpy, window, XDamageReportRawRectangles); \n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t\tX_UNLOCK;\n\t\trfbLog(\"created   xdamage object: 0x%lx\\n\", xdamage);\n\t}\n#endif\n}"
  },
  {
    "function_name": "initialize_xdamage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "736-768",
    "snippet": "void initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int use_xdamage = XDAMAGE;",
      "int xdamage_present = 0;",
      "double xdamage_memory = 1.0;",
      "sraRegionPtr *xdamage_regions = NULL;",
      "int xdamage_ticker = 0;",
      "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
      "int collect_xdamage(int scancnt, int call);",
      "void initialize_xdamage(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnMakeEmpty",
          "args": [
            "*ptr"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nreg * sizeof(sraRegionPtr)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "xdamage_regions"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "*ptr"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nvoid initialize_xdamage(void);\n\nvoid initialize_xdamage(void) {\n\tsraRegionPtr *ptr;\n\tint i, nreg;\n\n\tif (! xdamage_present) {\n\t\tuse_xdamage = 0;\n\t}\n\tif (xdamage_regions)  {\n\t\tptr = xdamage_regions;\n\t\twhile (*ptr != NULL) {\n\t\t\tsraRgnDestroy(*ptr);\n\t\t\tptr++;\n\t\t}\n\t\tfree(xdamage_regions);\n\t\txdamage_regions = NULL;\n\t}\n\tif (use_xdamage) {\n\t\tnreg = (xdamage_memory * NSCAN) + 2;\n\t\txdamage_regions = (sraRegionPtr *)\n\t\t    malloc(nreg * sizeof(sraRegionPtr));\n\t\tfor (i = 0; i < nreg; i++) {\n\t\t\tptr = xdamage_regions+i;\n\t\t\tif (i == nreg - 1) {\n\t\t\t\t*ptr = NULL;\n\t\t\t} else {\n\t\t\t\t*ptr = sraRgnCreate();\n\t\t\t\tsraRgnMakeEmpty(*ptr);\n\t\t\t}\n\t\t}\n\t\t/* set so will be 0 in first collect_xdamage call */\n\t\txdamage_ticker = -1;\n\t}\n}"
  },
  {
    "function_name": "xdamage_hint_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "638-734",
    "snippet": "int xdamage_hint_skip(int y) {\n\tstatic sraRegionPtr scanline = NULL;\n\tstatic sraRegionPtr tmpl_y = NULL;\n\tint fast_tmpl = 1;\n\tsraRegionPtr reg, tmpl;\n\tint ret, i, n, nreg;\n#ifndef NO_NCACHE\n\tstatic int ncache_no_skip = 0;\n\tstatic double last_ncache_no_skip = 0.0;\n\tstatic double last_ncache_no_skip_long = 0.0, ncache_fac = 0.25;\n#endif\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\n\tif (! scanline) {\n\t\t/* keep it around to avoid malloc etc, recreate */\n\t\tscanline = sraRgnCreate();\n\t}\n\tif (! tmpl_y) {\n\t\ttmpl_y = sraRgnCreateRect(0, 0, dpy_x, 1);\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tif (ncache_no_skip == 0) {\n\t\t\tdouble now = g_now;\n\t\t\tif (now > last_ncache_no_skip + 8.0) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_bs_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_su_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_copyrect + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t}\n\t\t\tif (ncache_no_skip) {\n\t\t\t\tlast_ncache_no_skip = dnow();\n\t\t\t\tif (now > last_ncache_no_skip_long + 60.0) {\n\t\t\t\t\tncache_fac = 2.0;\n\t\t\t\t\tlast_ncache_no_skip_long = now;\n\t\t\t\t} else {\n\t\t\t\t\tncache_fac = 0.25;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ncache_no_skip++ >= ncache_fac*nreg + 4) {\n\t\t\t\tncache_no_skip = 0;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, y);\n\t\ttmpl = tmpl_y;\n\t} else {\n\t\ttmpl = sraRgnCreateRect(0, y, dpy_x, y+1);\n\t}\n\n\tret = 1;\n\tfor (i=0; i<nreg; i++) {\n\t\t/* go back thru the history starting at most recent */\n\t\tn = (xdamage_ticker + nreg - i) % nreg;\n\t\treg = xdamage_regions[n];  \n\t\tif (reg == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sraRgnEmpty(reg)) {\n\t\t\t/* checking for emptiness is very fast */\n\t\t\tcontinue;\n\t\t}\n\t\tsraRgnMakeEmpty(scanline);\n\t\tsraRgnOr(scanline, tmpl);\n\t\tif (sraRgnAnd(scanline, reg)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, -y);\n\t} else {\n\t\tsraRgnDestroy(tmpl);\n\t}\nif (0) fprintf(stderr, \"xdamage_hint_skip: %d -> %d\\n\", y, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int use_xdamage = XDAMAGE;",
      "int xdamage_present = 0;",
      "double xdamage_memory = 1.0;",
      "sraRegionPtr *xdamage_regions = NULL;",
      "int xdamage_ticker = 0;",
      "int xdamage_hint_skip(int y);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xdamage_hint_skip: %d -> %d\\n\"",
            "y",
            "ret"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpl"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "tmpl_y",
            "0",
            "-y"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnAnd",
          "args": [
            "scanline",
            "reg"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "scanline",
            "tmpl"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnMakeEmpty",
          "args": [
            "scanline"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnEmpty",
          "args": [
            "reg"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "y",
            "dpy_x",
            "y+1"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOffset",
          "args": [
            "tmpl_y",
            "0",
            "y"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "1"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreate",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint xdamage_hint_skip(int y);\n\nint xdamage_hint_skip(int y) {\n\tstatic sraRegionPtr scanline = NULL;\n\tstatic sraRegionPtr tmpl_y = NULL;\n\tint fast_tmpl = 1;\n\tsraRegionPtr reg, tmpl;\n\tint ret, i, n, nreg;\n#ifndef NO_NCACHE\n\tstatic int ncache_no_skip = 0;\n\tstatic double last_ncache_no_skip = 0.0;\n\tstatic double last_ncache_no_skip_long = 0.0, ncache_fac = 0.25;\n#endif\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\t/* cannot skip */\n\t}\n\n\tif (! scanline) {\n\t\t/* keep it around to avoid malloc etc, recreate */\n\t\tscanline = sraRgnCreate();\n\t}\n\tif (! tmpl_y) {\n\t\ttmpl_y = sraRgnCreateRect(0, 0, dpy_x, 1);\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n#ifndef NO_NCACHE\n\tif (ncache > 0) {\n\t\tif (ncache_no_skip == 0) {\n\t\t\tdouble now = g_now;\n\t\t\tif (now > last_ncache_no_skip + 8.0) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_bs_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_su_restore + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t} else if (now < last_copyrect + 0.5) {\n\t\t\t\tncache_no_skip = 1;\n\t\t\t}\n\t\t\tif (ncache_no_skip) {\n\t\t\t\tlast_ncache_no_skip = dnow();\n\t\t\t\tif (now > last_ncache_no_skip_long + 60.0) {\n\t\t\t\t\tncache_fac = 2.0;\n\t\t\t\t\tlast_ncache_no_skip_long = now;\n\t\t\t\t} else {\n\t\t\t\t\tncache_fac = 0.25;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ncache_no_skip++ >= ncache_fac*nreg + 4) {\n\t\t\t\tncache_no_skip = 0;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, y);\n\t\ttmpl = tmpl_y;\n\t} else {\n\t\ttmpl = sraRgnCreateRect(0, y, dpy_x, y+1);\n\t}\n\n\tret = 1;\n\tfor (i=0; i<nreg; i++) {\n\t\t/* go back thru the history starting at most recent */\n\t\tn = (xdamage_ticker + nreg - i) % nreg;\n\t\treg = xdamage_regions[n];  \n\t\tif (reg == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sraRgnEmpty(reg)) {\n\t\t\t/* checking for emptiness is very fast */\n\t\t\tcontinue;\n\t\t}\n\t\tsraRgnMakeEmpty(scanline);\n\t\tsraRgnOr(scanline, tmpl);\n\t\tif (sraRgnAnd(scanline, reg)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fast_tmpl) {\n\t\tsraRgnOffset(tmpl_y, 0, -y);\n\t} else {\n\t\tsraRgnDestroy(tmpl);\n\t}\nif (0) fprintf(stderr, \"xdamage_hint_skip: %d -> %d\\n\", y, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "collect_xdamage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "390-636",
    "snippet": "int collect_xdamage(int scancnt, int call) {\n#if HAVE_LIBXDAMAGE\n\tXDamageNotifyEvent *dev;\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tint x, y, w, h, x2, y2;\n\tint i, dup, next = 0, dup_max = 0;\n#define DUPSZ 32\n\tint dup_x[DUPSZ], dup_y[DUPSZ], dup_w[DUPSZ], dup_h[DUPSZ];\n\tdouble tm, dt;\n\tint mark_all = 0, retries = 0, too_many = 1000, tot_ev = 0;\n\n\tRAWFB_RET(0)\n\n\tif (scancnt) {} /* unused vars warning: */\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\n\tX_LOCK;\nif (0)\tXFlush_wr(dpy);\nif (0)\tXEventsQueued(dpy, QueuedAfterFlush);\n\n\tcome_back_for_more:\n\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t/*\n\t\t * TODO max cut off time in this loop?\n\t\t * Could check QLength and if huge just mark the whole\n\t\t * screen.\n\t\t */\n\t\tecount++;\n\t\ttot_ev++;\n\n\t\tif (mark_all) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ecount == too_many) {\n\t\t\tint nqa = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (nqa >= too_many) {\n\t\t\t\tstatic double last_msg = 0.0;\n\t\t\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\tsraRgnOr(reg, tmpregion);\n\t\t\t\tsraRgnDestroy(tmpregion);\n\t\t\t\tif (dnow() > last_msg + xdamage_crazy_delay) {\n\t\t\t\t\trfbLog(\"collect_xdamage: too many xdamage events %d+%d\\n\", ecount, nqa);\n\t\t\t\t\tlast_msg = dnow();\n\t\t\t\t}\n\t\t\t\tmark_all = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ev.type != xdamage_base_event_type + XDamageNotify) {\n\t\t\tbreak;\n\t\t}\n\t\tdev = (XDamageNotifyEvent *) &ev;\n\t\tif (dev->damage != xdamage) {\n\t\t\tcontinue;\t/* not ours! */\n\t\t}\n\n\t\tx = dev->area.x;\n\t\ty = dev->area.y;\n\t\tw = dev->area.width;\n\t\th = dev->area.height;\n\n\t\t/*\n\t\t * we try to manually remove some duplicates because\n\t\t * certain activities can lead to many 10's of dups\n\t\t * in a row.  The region work can be costly and reg is\n\t\t * later used in xdamage_hint_skip loops, so it is good\n\t\t * to skip them if possible.\n\t\t */\n\t\tdup = 0;\n\t\tfor (i=0; i < dup_max; i++) {\n\t\t\tif (dup_x[i] == x && dup_y[i] == y && dup_w[i] == w &&\n\t\t\t    dup_h[i] == h) {\n\t\t\t\tdup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dup) {\n\t\t\tdcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dup_max < DUPSZ) {\n\t\t\tnext = dup_max;\n\t\t\tdup_max++;\n\t\t} else {\n\t\t\tnext = (next+1) % DUPSZ;\n\t\t}\n\t\tdup_x[next] = x;\n\t\tdup_y[next] = y;\n\t\tdup_w[next] = w;\n\t\tdup_h[next] = h;\n\n\t\t/* translate if needed */\n\t\tif (clipshift) {\n\t\t\t/* set coords relative to fb origin */\n\t\t\tif (0 && rootshift) {\n\t\t\t\t/*\n\t\t\t\t * Note: not needed because damage is\n\t\t\t\t * relative to subwin, not rootwin.\n\t\t\t\t */\n\t\t\t\tx = x - off_x;\n\t\t\t\ty = y - off_y;\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\tx = x - coff_x;\n\t\t\t\ty = y - coff_y;\n\t\t\t}\n\n\t\t\tx2 = x + w;\t\t/* upper point */\n\t\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\t\tx2 = nfix(x2, dpy_x+1);\n\t\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\t\n\t\t\ty2 = y + h;\n\t\t\ty  = nfix(y,  dpy_y);\n\t\t\ty2 = nfix(y2, dpy_y+1);\n\t\t\th = y2 - y;\n\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (debug_xdamage > 2) {\n\t\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t\t    \" %d  dups: %d  %s\\n\", w, h, x, y, w*h, dcount,\n\t\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\");\n\t\t}\n\n\t\trecord_desired_xdamage_rect(x, y, w, h);\n\n\t\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\t\tsraRgnOr(reg, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t\trect_count++;\n\t\tccount++;\n\t}\n\n\tif (mark_all) {\n\t\tif (ecount + XEventsQueued(dpy, QueuedAlready) >= 3 * too_many && retries < 3) {\n\t\t\tretries++;\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(20 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tecount = 0;\n\t\t\tgoto come_back_for_more;\n\t\t}\n\t}\n\n\t/* clear the whole damage region for next time. XXX check */\n\tif (call == 1) {\n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t}\n\tX_UNLOCK;\n\n\tif (tot_ev > 20 * too_many) {\n\t\trfbLog(\"collect_xdamage: xdamage has gone crazy (screensaver or game?) ev: %d ret: %d\\n\", tot_ev, retries);\n\t\trfbLog(\"collect_xdamage: disabling xdamage for %d seconds.\\n\", (int) xdamage_crazy_delay);\n\t\tdestroy_xdamage_if_needed();\n\t\tX_LOCK;\n\t\tXSync(dpy, False);\n\t\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t;\n\t\t}\n\t\tX_UNLOCK;\n\t\txdamage_crazy_time = dnow();\n\t}\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n#else\n\tif (0) scancnt++;\t/* compiler warnings */\n\tif (0) call++;\n\tif (0) record_desired_xdamage_rect(0, 0, 0, 0);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define DUPSZ 32"
    ],
    "globals_used": [
      "int use_xdamage = XDAMAGE;",
      "int xdamage_present = 0;",
      "double xdamage_memory = 1.0;",
      "double xdamage_crazy_time = 0.0;",
      "double xdamage_crazy_delay = 300.0;",
      "sraRegionPtr *xdamage_regions = NULL;",
      "int xdamage_ticker = 0;",
      "int XD_skip = 0, XD_tot = 0, XD_des = 0;",
      "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
      "int collect_xdamage(int scancnt, int call);",
      "int xdamage_hint_skip(int y);",
      "void destroy_xdamage_if_needed(void);",
      "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "record_desired_xdamage_rect",
          "args": [
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "record_desired_xdamage_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "79-189",
          "snippet": "static void record_desired_xdamage_rect(int x, int y, int w, int h) {\n\t/*\n\t * Unfortunately we currently can't trust an xdamage event\n\t * to correspond to real screen damage.  E.g. focus-in for\n\t * mozilla (depending on wm) will mark the whole toplevel\n\t * area as damaged, when only the border has changed.\n\t * Similar things for terminal windows.\n\t *\n\t * This routine uses some heuristics to detect small enough\n\t * damage regions that we will not have a performance problem\n\t * if we believe them even though they are wrong.  We record\n\t * the corresponding tiles the damage regions touch.\n\t */\n\tint dt_x, dt_y, nt_x1, nt_y1, nt_x2, nt_y2, nt;\n\tint ix, iy, cnt = 0;\n\tint area = w*h, always_accept = 0;\n\t/*\n\t * XXX: not working yet, slow and overlaps with scan_display()\n\t * probably slow because tall skinny rectangles very inefficient\n\t * in general and in direct_fb_copy() (100X slower then horizontal).\n\t */\n\tint use_direct_fb_copy = 0;\n\tint wh_min, wh_max;\n\tstatic int first = 1, udfb = 0;\n\n\t/* compiler warning: */\n\tnt_x1 = 0; nt_y1 = 0; nt_x2 = 0; nt_y2 = 0;\n\n\tif (first) {\n\t\tif (getenv(\"XD_DFC\")) {\n\t\t\tudfb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\tif (udfb) {\n\t\tuse_direct_fb_copy = 1;\n\t}\n\n\tif (xdamage_max_area <= 0) {\n\t\talways_accept = 1;\n\t}\n\n\tif (!always_accept && area > xdamage_max_area) {\n\t\treturn;\n\t}\n\n\tdt_x = w / tile_x;\n\tdt_y = h / tile_y;\n\n\tif (w < h) {\n\t\twh_min = w;\n\t\twh_max = h;\n\t} else {\n\t\twh_min = h;\n\t\twh_max = w;\n\t}\n\n\tif (!always_accept && dt_y >= 3 && area > 4000)  {\n\t\t/*\n\t\t * if it is real it should be caught by a normal scanline\n\t\t * poll, but we might as well keep if small (tall line?).\n\t\t */\n\t\treturn;\n\t}\n\t\n\tif (use_direct_fb_copy) {\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else if (0 && wh_min < tile_x/4 && wh_max > 30 * wh_min) {\n\t\t/* try it for long, skinny rects, XXX still no good */\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else {\n\n\t\tif (ntiles_x == 0 || ntiles_y == 0) {\n\t\t\t/* too early. */\n\t\t\treturn;\n\t\t}\n\t\tnt_x1 = nfix(  (x)/tile_x, ntiles_x);\n\t\tnt_x2 = nfix((x+w)/tile_x, ntiles_x);\n\t\tnt_y1 = nfix(  (y)/tile_y, ntiles_y);\n\t\tnt_y2 = nfix((y+h)/tile_y, ntiles_y);\n\n\t\t/*\n\t\t * loop over the rectangle of tiles (1 tile for a small\n\t\t * input rect).\n\t\t */\n\t\tfor (ix = nt_x1; ix <= nt_x2; ix++) {\n\t\t\tfor (iy = nt_y1; iy <= nt_y2; iy++) {\n\t\t\t\tnt = ix + iy * ntiles_x;\n\t\t\t\tcnt++;\n\t\t\t\tif (! tile_has_xdamage_diff[nt]) {\n\t\t\t\t\tXD_des++;\n\t\t\t\t\ttile_has_xdamage_diff[nt] = 1;\n\t\t\t\t}\n\t\t\t\t/* not used: */\n\t\t\t\ttile_row_has_xdamage_diff[iy] = 1;\n\t\t\t\txdamage_tile_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (debug_xdamage > 1) {\n\t\tfprintf(stderr, \"xdamage: desired: %dx%d+%d+%d\\tA: %6d  tiles=\"\n\t\t    \"%02d-%02d/%02d-%02d  tilecnt: %d\\n\", w, h, x, y,\n\t\t    w * h, nt_x1, nt_x2, nt_y1, nt_y2, cnt);\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xdamage_tile_count = 0, xdamage_direct_count = 0;",
            "int xdamage_hint_skip(int y);",
            "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xdamage_tile_count = 0, xdamage_direct_count = 0;\nint xdamage_hint_skip(int y);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h) {\n\t/*\n\t * Unfortunately we currently can't trust an xdamage event\n\t * to correspond to real screen damage.  E.g. focus-in for\n\t * mozilla (depending on wm) will mark the whole toplevel\n\t * area as damaged, when only the border has changed.\n\t * Similar things for terminal windows.\n\t *\n\t * This routine uses some heuristics to detect small enough\n\t * damage regions that we will not have a performance problem\n\t * if we believe them even though they are wrong.  We record\n\t * the corresponding tiles the damage regions touch.\n\t */\n\tint dt_x, dt_y, nt_x1, nt_y1, nt_x2, nt_y2, nt;\n\tint ix, iy, cnt = 0;\n\tint area = w*h, always_accept = 0;\n\t/*\n\t * XXX: not working yet, slow and overlaps with scan_display()\n\t * probably slow because tall skinny rectangles very inefficient\n\t * in general and in direct_fb_copy() (100X slower then horizontal).\n\t */\n\tint use_direct_fb_copy = 0;\n\tint wh_min, wh_max;\n\tstatic int first = 1, udfb = 0;\n\n\t/* compiler warning: */\n\tnt_x1 = 0; nt_y1 = 0; nt_x2 = 0; nt_y2 = 0;\n\n\tif (first) {\n\t\tif (getenv(\"XD_DFC\")) {\n\t\t\tudfb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\tif (udfb) {\n\t\tuse_direct_fb_copy = 1;\n\t}\n\n\tif (xdamage_max_area <= 0) {\n\t\talways_accept = 1;\n\t}\n\n\tif (!always_accept && area > xdamage_max_area) {\n\t\treturn;\n\t}\n\n\tdt_x = w / tile_x;\n\tdt_y = h / tile_y;\n\n\tif (w < h) {\n\t\twh_min = w;\n\t\twh_max = h;\n\t} else {\n\t\twh_min = h;\n\t\twh_max = w;\n\t}\n\n\tif (!always_accept && dt_y >= 3 && area > 4000)  {\n\t\t/*\n\t\t * if it is real it should be caught by a normal scanline\n\t\t * poll, but we might as well keep if small (tall line?).\n\t\t */\n\t\treturn;\n\t}\n\t\n\tif (use_direct_fb_copy) {\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else if (0 && wh_min < tile_x/4 && wh_max > 30 * wh_min) {\n\t\t/* try it for long, skinny rects, XXX still no good */\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else {\n\n\t\tif (ntiles_x == 0 || ntiles_y == 0) {\n\t\t\t/* too early. */\n\t\t\treturn;\n\t\t}\n\t\tnt_x1 = nfix(  (x)/tile_x, ntiles_x);\n\t\tnt_x2 = nfix((x+w)/tile_x, ntiles_x);\n\t\tnt_y1 = nfix(  (y)/tile_y, ntiles_y);\n\t\tnt_y2 = nfix((y+h)/tile_y, ntiles_y);\n\n\t\t/*\n\t\t * loop over the rectangle of tiles (1 tile for a small\n\t\t * input rect).\n\t\t */\n\t\tfor (ix = nt_x1; ix <= nt_x2; ix++) {\n\t\t\tfor (iy = nt_y1; iy <= nt_y2; iy++) {\n\t\t\t\tnt = ix + iy * ntiles_x;\n\t\t\t\tcnt++;\n\t\t\t\tif (! tile_has_xdamage_diff[nt]) {\n\t\t\t\t\tXD_des++;\n\t\t\t\t\ttile_has_xdamage_diff[nt] = 1;\n\t\t\t\t}\n\t\t\t\t/* not used: */\n\t\t\t\ttile_row_has_xdamage_diff[iy] = 1;\n\t\t\t\txdamage_tile_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (debug_xdamage > 1) {\n\t\tfprintf(stderr, \"xdamage: desired: %dx%d+%d+%d\\tA: %6d  tiles=\"\n\t\t    \"%02d-%02d/%02d-%02d  tilecnt: %d\\n\", w, h, x, y,\n\t\t    w * h, nt_x1, nt_x2, nt_y1, nt_y2, cnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\"",
            "XD_skip",
            "XD_tot",
            "rat",
            "rect_count",
            "XD_des"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"collect_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\"",
            "call",
            "dt",
            "tm - x11vnc_start",
            "ecount",
            "dcount",
            "ccount",
            "xdamage_direct_count"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xdamage_base_event_type+XDamageNotify",
            "&ev"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XSync",
          "args": [
            "dpy",
            "False"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_xdamage_if_needed",
          "args": [],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_xdamage_if_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "787-808",
          "snippet": "void destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void destroy_xdamage_if_needed(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid destroy_xdamage_if_needed(void);\n\nvoid destroy_xdamage_if_needed(void) {\n\n\tRAWFB_RET_VOID\n\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXEvent ev;\n\t\tX_LOCK;\n\t\tXDamageDestroy(dpy, xdamage);\n\t\tXFlush_wr(dpy);\n\t\tif (xdamage_base_event_type) {\n\t\t\twhile (XCheckTypedEvent(dpy,\n\t\t\t    xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tX_UNLOCK;\n\t\trfbLog(\"destroyed xdamage object: 0x%lx\\n\", xdamage);\n\t\txdamage = 0;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"collect_xdamage: disabling xdamage for %d seconds.\\n\"",
            "(int) xdamage_crazy_delay"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"collect_xdamage: xdamage has gone crazy (screensaver or game?) ev: %d ret: %d\\n\"",
            "tot_ev",
            "retries"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDamageSubtract",
          "args": [
            "dpy",
            "xdamage",
            "None",
            "None"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20 * 1000"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "dpy",
            "QueuedAlready"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "reg",
            "tmpregion"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t\t    \" %d  dups: %d  %s\\n\"",
            "w",
            "h",
            "x",
            "y",
            "w*h",
            "dcount",
            "(w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2",
            "dpy_y+1"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"collect_xdamage: too many xdamage events %d+%d\\n\"",
            "ecount",
            "nqa"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "reg",
            "tmpregion"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "dpy",
            "QueuedAlready"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xdamage_base_event_type+XDamageNotify",
            "&ev"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XEventsQueued",
          "args": [
            "dpy",
            "QueuedAfterFlush"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnMakeEmpty",
          "args": [
            "reg"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAWFB_RET",
          "args": [
            "0"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\n#define DUPSZ 32\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\ndouble xdamage_memory = 1.0;\ndouble xdamage_crazy_time = 0.0;\ndouble xdamage_crazy_delay = 300.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint XD_skip = 0, XD_tot = 0, XD_des = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nint xdamage_hint_skip(int y);\nvoid destroy_xdamage_if_needed(void);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nint collect_xdamage(int scancnt, int call) {\n#if HAVE_LIBXDAMAGE\n\tXDamageNotifyEvent *dev;\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tint x, y, w, h, x2, y2;\n\tint i, dup, next = 0, dup_max = 0;\n#define DUPSZ 32\n\tint dup_x[DUPSZ], dup_y[DUPSZ], dup_w[DUPSZ], dup_h[DUPSZ];\n\tdouble tm, dt;\n\tint mark_all = 0, retries = 0, too_many = 1000, tot_ev = 0;\n\n\tRAWFB_RET(0)\n\n\tif (scancnt) {} /* unused vars warning: */\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\n\tX_LOCK;\nif (0)\tXFlush_wr(dpy);\nif (0)\tXEventsQueued(dpy, QueuedAfterFlush);\n\n\tcome_back_for_more:\n\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t/*\n\t\t * TODO max cut off time in this loop?\n\t\t * Could check QLength and if huge just mark the whole\n\t\t * screen.\n\t\t */\n\t\tecount++;\n\t\ttot_ev++;\n\n\t\tif (mark_all) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ecount == too_many) {\n\t\t\tint nqa = XEventsQueued(dpy, QueuedAlready);\n\t\t\tif (nqa >= too_many) {\n\t\t\t\tstatic double last_msg = 0.0;\n\t\t\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\t\t\tsraRgnOr(reg, tmpregion);\n\t\t\t\tsraRgnDestroy(tmpregion);\n\t\t\t\tif (dnow() > last_msg + xdamage_crazy_delay) {\n\t\t\t\t\trfbLog(\"collect_xdamage: too many xdamage events %d+%d\\n\", ecount, nqa);\n\t\t\t\t\tlast_msg = dnow();\n\t\t\t\t}\n\t\t\t\tmark_all = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (ev.type != xdamage_base_event_type + XDamageNotify) {\n\t\t\tbreak;\n\t\t}\n\t\tdev = (XDamageNotifyEvent *) &ev;\n\t\tif (dev->damage != xdamage) {\n\t\t\tcontinue;\t/* not ours! */\n\t\t}\n\n\t\tx = dev->area.x;\n\t\ty = dev->area.y;\n\t\tw = dev->area.width;\n\t\th = dev->area.height;\n\n\t\t/*\n\t\t * we try to manually remove some duplicates because\n\t\t * certain activities can lead to many 10's of dups\n\t\t * in a row.  The region work can be costly and reg is\n\t\t * later used in xdamage_hint_skip loops, so it is good\n\t\t * to skip them if possible.\n\t\t */\n\t\tdup = 0;\n\t\tfor (i=0; i < dup_max; i++) {\n\t\t\tif (dup_x[i] == x && dup_y[i] == y && dup_w[i] == w &&\n\t\t\t    dup_h[i] == h) {\n\t\t\t\tdup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dup) {\n\t\t\tdcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (dup_max < DUPSZ) {\n\t\t\tnext = dup_max;\n\t\t\tdup_max++;\n\t\t} else {\n\t\t\tnext = (next+1) % DUPSZ;\n\t\t}\n\t\tdup_x[next] = x;\n\t\tdup_y[next] = y;\n\t\tdup_w[next] = w;\n\t\tdup_h[next] = h;\n\n\t\t/* translate if needed */\n\t\tif (clipshift) {\n\t\t\t/* set coords relative to fb origin */\n\t\t\tif (0 && rootshift) {\n\t\t\t\t/*\n\t\t\t\t * Note: not needed because damage is\n\t\t\t\t * relative to subwin, not rootwin.\n\t\t\t\t */\n\t\t\t\tx = x - off_x;\n\t\t\t\ty = y - off_y;\n\t\t\t}\n\t\t\tif (clipshift) {\n\t\t\t\tx = x - coff_x;\n\t\t\t\ty = y - coff_y;\n\t\t\t}\n\n\t\t\tx2 = x + w;\t\t/* upper point */\n\t\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\t\tx2 = nfix(x2, dpy_x+1);\n\t\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\t\n\t\t\ty2 = y + h;\n\t\t\ty  = nfix(y,  dpy_y);\n\t\t\ty2 = nfix(y2, dpy_y+1);\n\t\t\th = y2 - y;\n\n\t\t\tif (w <= 0 || h <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (debug_xdamage > 2) {\n\t\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t\t    \" %d  dups: %d  %s\\n\", w, h, x, y, w*h, dcount,\n\t\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\");\n\t\t}\n\n\t\trecord_desired_xdamage_rect(x, y, w, h);\n\n\t\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\t\tsraRgnOr(reg, tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t\trect_count++;\n\t\tccount++;\n\t}\n\n\tif (mark_all) {\n\t\tif (ecount + XEventsQueued(dpy, QueuedAlready) >= 3 * too_many && retries < 3) {\n\t\t\tretries++;\n\t\t\tXFlush_wr(dpy);\n\t\t\tusleep(20 * 1000);\n\t\t\tXFlush_wr(dpy);\n\t\t\tecount = 0;\n\t\t\tgoto come_back_for_more;\n\t\t}\n\t}\n\n\t/* clear the whole damage region for next time. XXX check */\n\tif (call == 1) {\n\t\tXDamageSubtract(dpy, xdamage, None, None);\n\t}\n\tX_UNLOCK;\n\n\tif (tot_ev > 20 * too_many) {\n\t\trfbLog(\"collect_xdamage: xdamage has gone crazy (screensaver or game?) ev: %d ret: %d\\n\", tot_ev, retries);\n\t\trfbLog(\"collect_xdamage: disabling xdamage for %d seconds.\\n\", (int) xdamage_crazy_delay);\n\t\tdestroy_xdamage_if_needed();\n\t\tX_LOCK;\n\t\tXSync(dpy, False);\n\t\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\t\t;\n\t\t}\n\t\tX_UNLOCK;\n\t\txdamage_crazy_time = dnow();\n\t}\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n#else\n\tif (0) scancnt++;\t/* compiler warnings */\n\tif (0) call++;\n\tif (0) record_desired_xdamage_rect(0, 0, 0, 0);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "collect_non_X_xdamage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "260-388",
    "snippet": "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int use_xdamage = XDAMAGE;",
      "double xdamage_memory = 1.0;",
      "sraRegionPtr *xdamage_regions = NULL;",
      "int xdamage_ticker = 0;",
      "int XD_skip = 0, XD_tot = 0, XD_des = 0;",
      "int collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);",
      "int collect_xdamage(int scancnt, int call);",
      "int xdamage_hint_skip(int y);",
      "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\"",
            "XD_skip",
            "XD_tot",
            "rat",
            "rect_count",
            "XD_des"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\"",
            "call",
            "dt",
            "tm - x11vnc_start",
            "ecount",
            "dcount",
            "ccount",
            "xdamage_direct_count"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtime",
          "args": [
            "&tm"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "dtime0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "429-432",
          "snippet": "double dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dtime(double *);",
            "double dtime0(double *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dtime(double *);\ndouble dtime0(double *);\n\ndouble dtime0(double *t_old) {\n\t*t_old = 0.0;\n\treturn dtime(t_old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fb_push",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "fb_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "2170-2205",
          "snippet": "void fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fb_push(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid fb_push(void);\n\nvoid fb_push(void) {\n\tint req0, mod0, cpy0, req1, mod1, cpy1, ncli;\n\tint db = (debug_scroll || debug_wireframe);\n\trfbClientIteratorPtr i;\n\trfbClientPtr cl;\n\n\tif (use_threads) {\n\t\treturn;\n\t}\n\t\nif (db)\tget_client_regions(&req0, &mod0, &cpy0, &ncli);\n\n\ti = rfbGetClientIterator(screen);\n\twhile( (cl = rfbClientIteratorNext(i)) ) {\n\t\tif (use_threads) LOCK(cl->updateMutex);\n\t\tif (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&\n\t\t    !sraRgnEmpty(cl->requestedRegion)) {\n\t\t\tif (!rfbSendFramebufferUpdate(cl, cl->modifiedRegion)) {\n\t\t\t\tfprintf(stderr, \"*** rfbSendFramebufferUpdate *FAILED* #1\\n\");\n\t\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen not zero: %d\\n\", cl->ublen);\n\t\t\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cl->ublen) fprintf(stderr, \"*** fb_push ublen NOT ZERO: %d\\n\", cl->ublen);\n\t\t}\n\t\tif (use_threads) UNLOCK(cl->updateMutex);\n\t}\n\trfbReleaseClientIterator(i);\n\nif (db) {\n\tget_client_regions(&req1, &mod1, &cpy1, &ncli);\n\tfprintf(stderr, \"\\nFB_push: req: %d/%d  mod: %d/%d  cpy: %d/%d  %.4f\\n\",\n\treq0, req1, mod0, mod1, cpy0, cpy1, dnowx());\n}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "reg",
            "tmpregion"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_desired_xdamage_rect",
          "args": [
            "x",
            "y",
            "w",
            "h"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "record_desired_xdamage_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "79-189",
          "snippet": "static void record_desired_xdamage_rect(int x, int y, int w, int h) {\n\t/*\n\t * Unfortunately we currently can't trust an xdamage event\n\t * to correspond to real screen damage.  E.g. focus-in for\n\t * mozilla (depending on wm) will mark the whole toplevel\n\t * area as damaged, when only the border has changed.\n\t * Similar things for terminal windows.\n\t *\n\t * This routine uses some heuristics to detect small enough\n\t * damage regions that we will not have a performance problem\n\t * if we believe them even though they are wrong.  We record\n\t * the corresponding tiles the damage regions touch.\n\t */\n\tint dt_x, dt_y, nt_x1, nt_y1, nt_x2, nt_y2, nt;\n\tint ix, iy, cnt = 0;\n\tint area = w*h, always_accept = 0;\n\t/*\n\t * XXX: not working yet, slow and overlaps with scan_display()\n\t * probably slow because tall skinny rectangles very inefficient\n\t * in general and in direct_fb_copy() (100X slower then horizontal).\n\t */\n\tint use_direct_fb_copy = 0;\n\tint wh_min, wh_max;\n\tstatic int first = 1, udfb = 0;\n\n\t/* compiler warning: */\n\tnt_x1 = 0; nt_y1 = 0; nt_x2 = 0; nt_y2 = 0;\n\n\tif (first) {\n\t\tif (getenv(\"XD_DFC\")) {\n\t\t\tudfb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\tif (udfb) {\n\t\tuse_direct_fb_copy = 1;\n\t}\n\n\tif (xdamage_max_area <= 0) {\n\t\talways_accept = 1;\n\t}\n\n\tif (!always_accept && area > xdamage_max_area) {\n\t\treturn;\n\t}\n\n\tdt_x = w / tile_x;\n\tdt_y = h / tile_y;\n\n\tif (w < h) {\n\t\twh_min = w;\n\t\twh_max = h;\n\t} else {\n\t\twh_min = h;\n\t\twh_max = w;\n\t}\n\n\tif (!always_accept && dt_y >= 3 && area > 4000)  {\n\t\t/*\n\t\t * if it is real it should be caught by a normal scanline\n\t\t * poll, but we might as well keep if small (tall line?).\n\t\t */\n\t\treturn;\n\t}\n\t\n\tif (use_direct_fb_copy) {\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else if (0 && wh_min < tile_x/4 && wh_max > 30 * wh_min) {\n\t\t/* try it for long, skinny rects, XXX still no good */\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else {\n\n\t\tif (ntiles_x == 0 || ntiles_y == 0) {\n\t\t\t/* too early. */\n\t\t\treturn;\n\t\t}\n\t\tnt_x1 = nfix(  (x)/tile_x, ntiles_x);\n\t\tnt_x2 = nfix((x+w)/tile_x, ntiles_x);\n\t\tnt_y1 = nfix(  (y)/tile_y, ntiles_y);\n\t\tnt_y2 = nfix((y+h)/tile_y, ntiles_y);\n\n\t\t/*\n\t\t * loop over the rectangle of tiles (1 tile for a small\n\t\t * input rect).\n\t\t */\n\t\tfor (ix = nt_x1; ix <= nt_x2; ix++) {\n\t\t\tfor (iy = nt_y1; iy <= nt_y2; iy++) {\n\t\t\t\tnt = ix + iy * ntiles_x;\n\t\t\t\tcnt++;\n\t\t\t\tif (! tile_has_xdamage_diff[nt]) {\n\t\t\t\t\tXD_des++;\n\t\t\t\t\ttile_has_xdamage_diff[nt] = 1;\n\t\t\t\t}\n\t\t\t\t/* not used: */\n\t\t\t\ttile_row_has_xdamage_diff[iy] = 1;\n\t\t\t\txdamage_tile_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (debug_xdamage > 1) {\n\t\tfprintf(stderr, \"xdamage: desired: %dx%d+%d+%d\\tA: %6d  tiles=\"\n\t\t    \"%02d-%02d/%02d-%02d  tilecnt: %d\\n\", w, h, x, y,\n\t\t    w * h, nt_x1, nt_x2, nt_y1, nt_y2, cnt);\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xdamage_tile_count = 0, xdamage_direct_count = 0;",
            "int xdamage_hint_skip(int y);",
            "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xdamage_tile_count = 0, xdamage_direct_count = 0;\nint xdamage_hint_skip(int y);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h) {\n\t/*\n\t * Unfortunately we currently can't trust an xdamage event\n\t * to correspond to real screen damage.  E.g. focus-in for\n\t * mozilla (depending on wm) will mark the whole toplevel\n\t * area as damaged, when only the border has changed.\n\t * Similar things for terminal windows.\n\t *\n\t * This routine uses some heuristics to detect small enough\n\t * damage regions that we will not have a performance problem\n\t * if we believe them even though they are wrong.  We record\n\t * the corresponding tiles the damage regions touch.\n\t */\n\tint dt_x, dt_y, nt_x1, nt_y1, nt_x2, nt_y2, nt;\n\tint ix, iy, cnt = 0;\n\tint area = w*h, always_accept = 0;\n\t/*\n\t * XXX: not working yet, slow and overlaps with scan_display()\n\t * probably slow because tall skinny rectangles very inefficient\n\t * in general and in direct_fb_copy() (100X slower then horizontal).\n\t */\n\tint use_direct_fb_copy = 0;\n\tint wh_min, wh_max;\n\tstatic int first = 1, udfb = 0;\n\n\t/* compiler warning: */\n\tnt_x1 = 0; nt_y1 = 0; nt_x2 = 0; nt_y2 = 0;\n\n\tif (first) {\n\t\tif (getenv(\"XD_DFC\")) {\n\t\t\tudfb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\tif (udfb) {\n\t\tuse_direct_fb_copy = 1;\n\t}\n\n\tif (xdamage_max_area <= 0) {\n\t\talways_accept = 1;\n\t}\n\n\tif (!always_accept && area > xdamage_max_area) {\n\t\treturn;\n\t}\n\n\tdt_x = w / tile_x;\n\tdt_y = h / tile_y;\n\n\tif (w < h) {\n\t\twh_min = w;\n\t\twh_max = h;\n\t} else {\n\t\twh_min = h;\n\t\twh_max = w;\n\t}\n\n\tif (!always_accept && dt_y >= 3 && area > 4000)  {\n\t\t/*\n\t\t * if it is real it should be caught by a normal scanline\n\t\t * poll, but we might as well keep if small (tall line?).\n\t\t */\n\t\treturn;\n\t}\n\t\n\tif (use_direct_fb_copy) {\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else if (0 && wh_min < tile_x/4 && wh_max > 30 * wh_min) {\n\t\t/* try it for long, skinny rects, XXX still no good */\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else {\n\n\t\tif (ntiles_x == 0 || ntiles_y == 0) {\n\t\t\t/* too early. */\n\t\t\treturn;\n\t\t}\n\t\tnt_x1 = nfix(  (x)/tile_x, ntiles_x);\n\t\tnt_x2 = nfix((x+w)/tile_x, ntiles_x);\n\t\tnt_y1 = nfix(  (y)/tile_y, ntiles_y);\n\t\tnt_y2 = nfix((y+h)/tile_y, ntiles_y);\n\n\t\t/*\n\t\t * loop over the rectangle of tiles (1 tile for a small\n\t\t * input rect).\n\t\t */\n\t\tfor (ix = nt_x1; ix <= nt_x2; ix++) {\n\t\t\tfor (iy = nt_y1; iy <= nt_y2; iy++) {\n\t\t\t\tnt = ix + iy * ntiles_x;\n\t\t\t\tcnt++;\n\t\t\t\tif (! tile_has_xdamage_diff[nt]) {\n\t\t\t\t\tXD_des++;\n\t\t\t\t\ttile_has_xdamage_diff[nt] = 1;\n\t\t\t\t}\n\t\t\t\t/* not used: */\n\t\t\t\ttile_row_has_xdamage_diff[iy] = 1;\n\t\t\t\txdamage_tile_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (debug_xdamage > 1) {\n\t\tfprintf(stderr, \"xdamage: desired: %dx%d+%d+%d\\tA: %6d  tiles=\"\n\t\t    \"%02d-%02d/%02d-%02d  tilecnt: %d\\n\", w, h, x, y,\n\t\t    w * h, nt_x1, nt_x2, nt_y1, nt_y2, cnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\"",
            "w",
            "h",
            "x",
            "y",
            "w*h",
            "dcount",
            "(w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\"",
            "(void *)reg"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "y2",
            "dpy_y+1"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnMakeEmpty",
          "args": [
            "reg"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\"",
            "x_in",
            "y_in",
            "w_in",
            "h_in",
            "call",
            "use_xdamage"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nint XD_skip = 0, XD_tot = 0, XD_des = 0;\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call);\nint collect_xdamage(int scancnt, int call);\nint xdamage_hint_skip(int y);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nint collect_non_X_xdamage(int x_in, int y_in, int w_in, int h_in, int call) {\n\tsraRegionPtr tmpregion;\n\tsraRegionPtr reg;\n\tstatic int rect_count = 0;\n\tint nreg, ccount = 0, dcount = 0, ecount = 0;\n\tstatic time_t last_rpt = 0;\n\ttime_t now;\n\tdouble tm, dt;\n\tint x, y, w, h, x2, y2;\n\nif (call && debug_xdamage > 1) fprintf(stderr, \"collect_non_X_xdamage: %d %d %d %d - %d / %d\\n\", x_in, y_in, w_in, h_in, call, use_xdamage);\n\n\tif (! use_xdamage) {\n\t\treturn 0;\n\t}\n\tif (! xdamage_regions) {\n\t\treturn 0;\n\t}\n\n\tdtime0(&tm);\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\n\tif (call == 0) {\n\t\txdamage_ticker = (xdamage_ticker+1) % nreg;\n\t\txdamage_direct_count = 0;\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t\tif (reg != NULL) {\n\t\t\tsraRgnMakeEmpty(reg);\n\t\t}\n\t} else {\n\t\tif (xdamage_ticker < 0) {\n\t\t\txdamage_ticker = 0;\n\t\t}\n\t\treg = xdamage_regions[xdamage_ticker];  \n\t}\n\tif (reg == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (x_in < 0) {\n\t\treturn 0;\n\t}\n\n\n\tx = x_in;\n\ty = y_in;\n\tw = w_in;\n\th = h_in;\n\n\t/* translate if needed */\n\tif (clipshift) {\n\t\t/* set coords relative to fb origin */\n\t\tif (0 && rootshift) {\n\t\t\t/*\n\t\t\t * Note: not needed because damage is\n\t\t\t * relative to subwin, not rootwin.\n\t\t\t */\n\t\t\tx = x - off_x;\n\t\t\ty = y - off_y;\n\t\t}\n\t\tif (clipshift) {\n\t\t\tx = x - coff_x;\n\t\t\ty = y - coff_y;\n\t\t}\n\n\t\tx2 = x + w;\t\t/* upper point */\n\t\tx  = nfix(x,  dpy_x);\t/* place both in fb area */\n\t\tx2 = nfix(x2, dpy_x+1);\n\t\tw = x2 - x;\t\t/* recompute w */\n\t\t\n\t\ty2 = y + h;\n\t\ty  = nfix(y,  dpy_y);\n\t\ty2 = nfix(y2, dpy_y+1);\n\t\th = y2 - y;\n\n\t\tif (w <= 0 || h <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (debug_xdamage > 2) {\n\t\tfprintf(stderr, \"xdamage: -> event %dx%d+%d+%d area:\"\n\t\t    \" %d  dups: %d  %s reg: %p\\n\", w, h, x, y, w*h, dcount,\n\t\t    (w*h > xdamage_max_area) ? \"TOO_BIG\" : \"\", (void *)reg);\n\t}\n\n\trecord_desired_xdamage_rect(x, y, w, h);\n\n\ttmpregion = sraRgnCreateRect(x, y, x + w, y + h); \n\tsraRgnOr(reg, tmpregion);\n\tsraRgnDestroy(tmpregion);\n\trect_count++;\n\tccount++;\n\n\tif (0 && xdamage_direct_count) {\n\t\tfb_push();\n\t}\n\n\tdt = dtime(&tm);\n\tif ((debug_tiles > 1 && ecount) || (debug_tiles && ecount > 200)\n\t    || debug_xdamage > 1) {\n\t\tfprintf(stderr, \"collect_non_X_xdamage(%d): %.4f t: %.4f ev/dup/accept\"\n\t\t    \"/direct %d/%d/%d/%d\\n\", call, dt, tm - x11vnc_start, ecount,\n\t\t    dcount, ccount, xdamage_direct_count); \n\t}\n\tnow = time(NULL);\n\tif (! last_rpt) {\n\t\tlast_rpt = now;\n\t}\n\tif (now > last_rpt + 15) {\n\t\tdouble rat = -1.0;\n\n\t\tif (XD_tot) {\n\t\t\trat = ((double) XD_skip)/XD_tot;\n\t\t}\n\t\tif (debug_tiles || debug_xdamage) {\n\t\t\tfprintf(stderr, \"xdamage: == scanline skip/tot: \"\n\t\t\t    \"%04d/%04d =%.3f  rects: %d  desired: %d\\n\",\n\t\t\t    XD_skip, XD_tot, rat, rect_count, XD_des);\n\t\t}\n\t\t\t\n\t\tXD_skip = 0;\n\t\tXD_tot  = 0;\n\t\tXD_des  = 0;\n\t\trect_count = 0;\n\t\tlast_rpt = now;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_xdamage_mark_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "212-258",
    "snippet": "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int use_xdamage = XDAMAGE;",
      "int xdamage_present = 0;",
      "void clear_xdamage_mark_region(sraRegionPtr markregion, int flush);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_region_xdamage",
          "args": [
            "markregion"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "add_region_xdamage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
          "lines": "191-210",
          "snippet": "void add_region_xdamage(sraRegionPtr new_region) {\n\tsraRegionPtr reg;\n\tint prev_tick, nreg;\n\n\tif (! xdamage_regions) {\n\t\treturn;\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\tprev_tick = xdamage_ticker - 1;\n\tif (prev_tick < 0) {\n\t\tprev_tick = nreg - 1;\n\t}\n\n\treg = xdamage_regions[prev_tick];  \n\tif (reg != NULL && new_region != NULL) {\nif (debug_xdamage > 1) fprintf(stderr, \"add_region_xdamage: prev_tick: %d reg %p  new_region %p\\n\", prev_tick, (void *)reg, (void *)new_region);\n\t\tsraRgnOr(reg, new_region);\n\t}\n}",
          "includes": [
            "#include \"unixpw.h\"",
            "#include \"userinput.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "double xdamage_memory = 1.0;",
            "sraRegionPtr *xdamage_regions = NULL;",
            "int xdamage_ticker = 0;",
            "void add_region_xdamage(sraRegionPtr new_region);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nvoid add_region_xdamage(sraRegionPtr new_region);\n\nvoid add_region_xdamage(sraRegionPtr new_region) {\n\tsraRegionPtr reg;\n\tint prev_tick, nreg;\n\n\tif (! xdamage_regions) {\n\t\treturn;\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\tprev_tick = xdamage_ticker - 1;\n\tif (prev_tick < 0) {\n\t\tprev_tick = nreg - 1;\n\t}\n\n\treg = xdamage_regions[prev_tick];  \n\tif (reg != NULL && new_region != NULL) {\nif (debug_xdamage > 1) fprintf(stderr, \"add_region_xdamage: prev_tick: %d reg %p  new_region %p\\n\", prev_tick, (void *)reg, (void *)new_region);\n\t\tsraRgnOr(reg, new_region);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sraRgnDestroy",
          "args": [
            "tmpregion"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sraRgnCreateRect",
          "args": [
            "0",
            "0",
            "dpy_x",
            "dpy_y"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"clear_xdamage_mark_region: %d\\n\"",
            "count"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDamageSubtract",
          "args": [
            "dpy",
            "xdamage",
            "None",
            "None"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XCheckTypedEvent",
          "args": [
            "dpy",
            "xdamage_base_event_type+XDamageNotify",
            "&ev"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFlush_wr",
          "args": [
            "dpy"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "XFlush_wr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xwrappers.c",
          "lines": "154-165",
          "snippet": "int XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}",
          "includes": [
            "#include \"nox11_funcs.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xi2_devices.h\"",
            "#include \"macosx.h\"",
            "#include \"cleanup.h\"",
            "#include \"connections.h\"",
            "#include \"xevents.h\"",
            "#include \"keyboard.h\"",
            "#include \"xrecord.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int XFlush_wr(Display *disp);",
            "Bool XShmQueryExtension_wr(Display *disp);",
            "int XShmGetEventBase_wr(Display *disp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nox11_funcs.h\"\n#include \"xwrappers.h\"\n#include \"xi2_devices.h\"\n#include \"macosx.h\"\n#include \"cleanup.h\"\n#include \"connections.h\"\n#include \"xevents.h\"\n#include \"keyboard.h\"\n#include \"xrecord.h\"\n#include \"x11vnc.h\"\n\nint XFlush_wr(Display *disp);\nBool XShmQueryExtension_wr(Display *disp);\nint XShmGetEventBase_wr(Display *disp);\n\nint XFlush_wr(Display *disp) {\n#if NO_X11\n\tif (!disp) {}\n\treturn 1;\n#else\n\tif (disp) {\n\t\treturn XFlush(disp);\n\t} else {\n\t\treturn 1;\n\t}\n#endif\t/* NO_X11 */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint use_xdamage = XDAMAGE;\nint xdamage_present = 0;\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush);\n\nvoid clear_xdamage_mark_region(sraRegionPtr markregion, int flush) {\n#if HAVE_LIBXDAMAGE\n\tXEvent ev;\n\tsraRegionPtr tmpregion;\n\tint count = 0;\n\n\tRAWFB_RET_VOID\n\n\tif (! xdamage_present || ! use_xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage) {\n\t\treturn;\n\t}\n\tif (! xdamage_base_event_type) {\n\t\treturn;\n\t}\n\tif (unixpw_in_progress) return;\n\n\tX_LOCK;\n\tif (flush) {\n\t\tXFlush_wr(dpy);\n\t}\n\twhile (XCheckTypedEvent(dpy, xdamage_base_event_type+XDamageNotify, &ev)) {\n\t\tcount++;\n\t}\n\t/* clear the whole damage region */\n\tXDamageSubtract(dpy, xdamage, None, None);\n\tX_UNLOCK;\n\n\tif (debug_tiles || debug_xdamage) {\n\t\tfprintf(stderr, \"clear_xdamage_mark_region: %d\\n\", count);\n\t}\n\n\tif (! markregion) {\n\t\t/* NULL means mark the whole display */\n\t\ttmpregion = sraRgnCreateRect(0, 0, dpy_x, dpy_y);\n\t\tadd_region_xdamage(tmpregion);\n\t\tsraRgnDestroy(tmpregion);\n\t} else {\n\t\tadd_region_xdamage(markregion);\n\t}\n#else\n\tif (0) flush++;        /* compiler warnings */\n\tif (0) markregion = NULL;   \n#endif\n}"
  },
  {
    "function_name": "add_region_xdamage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "191-210",
    "snippet": "void add_region_xdamage(sraRegionPtr new_region) {\n\tsraRegionPtr reg;\n\tint prev_tick, nreg;\n\n\tif (! xdamage_regions) {\n\t\treturn;\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\tprev_tick = xdamage_ticker - 1;\n\tif (prev_tick < 0) {\n\t\tprev_tick = nreg - 1;\n\t}\n\n\treg = xdamage_regions[prev_tick];  \n\tif (reg != NULL && new_region != NULL) {\nif (debug_xdamage > 1) fprintf(stderr, \"add_region_xdamage: prev_tick: %d reg %p  new_region %p\\n\", prev_tick, (void *)reg, (void *)new_region);\n\t\tsraRgnOr(reg, new_region);\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "double xdamage_memory = 1.0;",
      "sraRegionPtr *xdamage_regions = NULL;",
      "int xdamage_ticker = 0;",
      "void add_region_xdamage(sraRegionPtr new_region);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sraRgnOr",
          "args": [
            "reg",
            "new_region"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"add_region_xdamage: prev_tick: %d reg %p  new_region %p\\n\"",
            "prev_tick",
            "(void *)reg",
            "(void *)new_region"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\ndouble xdamage_memory = 1.0;\nsraRegionPtr *xdamage_regions = NULL;\nint xdamage_ticker = 0;\nvoid add_region_xdamage(sraRegionPtr new_region);\n\nvoid add_region_xdamage(sraRegionPtr new_region) {\n\tsraRegionPtr reg;\n\tint prev_tick, nreg;\n\n\tif (! xdamage_regions) {\n\t\treturn;\n\t}\n\n\tnreg = (xdamage_memory * NSCAN) + 1;\n\tprev_tick = xdamage_ticker - 1;\n\tif (prev_tick < 0) {\n\t\tprev_tick = nreg - 1;\n\t}\n\n\treg = xdamage_regions[prev_tick];  \n\tif (reg != NULL && new_region != NULL) {\nif (debug_xdamage > 1) fprintf(stderr, \"add_region_xdamage: prev_tick: %d reg %p  new_region %p\\n\", prev_tick, (void *)reg, (void *)new_region);\n\t\tsraRgnOr(reg, new_region);\n\t}\n}"
  },
  {
    "function_name": "record_desired_xdamage_rect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/xdamage.c",
    "lines": "79-189",
    "snippet": "static void record_desired_xdamage_rect(int x, int y, int w, int h) {\n\t/*\n\t * Unfortunately we currently can't trust an xdamage event\n\t * to correspond to real screen damage.  E.g. focus-in for\n\t * mozilla (depending on wm) will mark the whole toplevel\n\t * area as damaged, when only the border has changed.\n\t * Similar things for terminal windows.\n\t *\n\t * This routine uses some heuristics to detect small enough\n\t * damage regions that we will not have a performance problem\n\t * if we believe them even though they are wrong.  We record\n\t * the corresponding tiles the damage regions touch.\n\t */\n\tint dt_x, dt_y, nt_x1, nt_y1, nt_x2, nt_y2, nt;\n\tint ix, iy, cnt = 0;\n\tint area = w*h, always_accept = 0;\n\t/*\n\t * XXX: not working yet, slow and overlaps with scan_display()\n\t * probably slow because tall skinny rectangles very inefficient\n\t * in general and in direct_fb_copy() (100X slower then horizontal).\n\t */\n\tint use_direct_fb_copy = 0;\n\tint wh_min, wh_max;\n\tstatic int first = 1, udfb = 0;\n\n\t/* compiler warning: */\n\tnt_x1 = 0; nt_y1 = 0; nt_x2 = 0; nt_y2 = 0;\n\n\tif (first) {\n\t\tif (getenv(\"XD_DFC\")) {\n\t\t\tudfb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\tif (udfb) {\n\t\tuse_direct_fb_copy = 1;\n\t}\n\n\tif (xdamage_max_area <= 0) {\n\t\talways_accept = 1;\n\t}\n\n\tif (!always_accept && area > xdamage_max_area) {\n\t\treturn;\n\t}\n\n\tdt_x = w / tile_x;\n\tdt_y = h / tile_y;\n\n\tif (w < h) {\n\t\twh_min = w;\n\t\twh_max = h;\n\t} else {\n\t\twh_min = h;\n\t\twh_max = w;\n\t}\n\n\tif (!always_accept && dt_y >= 3 && area > 4000)  {\n\t\t/*\n\t\t * if it is real it should be caught by a normal scanline\n\t\t * poll, but we might as well keep if small (tall line?).\n\t\t */\n\t\treturn;\n\t}\n\t\n\tif (use_direct_fb_copy) {\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else if (0 && wh_min < tile_x/4 && wh_max > 30 * wh_min) {\n\t\t/* try it for long, skinny rects, XXX still no good */\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else {\n\n\t\tif (ntiles_x == 0 || ntiles_y == 0) {\n\t\t\t/* too early. */\n\t\t\treturn;\n\t\t}\n\t\tnt_x1 = nfix(  (x)/tile_x, ntiles_x);\n\t\tnt_x2 = nfix((x+w)/tile_x, ntiles_x);\n\t\tnt_y1 = nfix(  (y)/tile_y, ntiles_y);\n\t\tnt_y2 = nfix((y+h)/tile_y, ntiles_y);\n\n\t\t/*\n\t\t * loop over the rectangle of tiles (1 tile for a small\n\t\t * input rect).\n\t\t */\n\t\tfor (ix = nt_x1; ix <= nt_x2; ix++) {\n\t\t\tfor (iy = nt_y1; iy <= nt_y2; iy++) {\n\t\t\t\tnt = ix + iy * ntiles_x;\n\t\t\t\tcnt++;\n\t\t\t\tif (! tile_has_xdamage_diff[nt]) {\n\t\t\t\t\tXD_des++;\n\t\t\t\t\ttile_has_xdamage_diff[nt] = 1;\n\t\t\t\t}\n\t\t\t\t/* not used: */\n\t\t\t\ttile_row_has_xdamage_diff[iy] = 1;\n\t\t\t\txdamage_tile_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (debug_xdamage > 1) {\n\t\tfprintf(stderr, \"xdamage: desired: %dx%d+%d+%d\\tA: %6d  tiles=\"\n\t\t    \"%02d-%02d/%02d-%02d  tilecnt: %d\\n\", w, h, x, y,\n\t\t    w * h, nt_x1, nt_x2, nt_y1, nt_y2, cnt);\n\t}\n}",
    "includes": [
      "#include \"unixpw.h\"",
      "#include \"userinput.h\"",
      "#include \"xwrappers.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xdamage_tile_count = 0, xdamage_direct_count = 0;",
      "int xdamage_hint_skip(int y);",
      "static void record_desired_xdamage_rect(int x, int y, int w, int h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"xdamage: desired: %dx%d+%d+%d\\tA: %6d  tiles=\"\n\t\t    \"%02d-%02d/%02d-%02d  tilecnt: %d\\n\"",
            "w",
            "h",
            "x",
            "y",
            "w * h",
            "nt_x1",
            "nt_x2",
            "nt_y1",
            "nt_y2",
            "cnt"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfix",
          "args": [
            "(y+h)/tile_y",
            "ntiles_y"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "nfix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "95-102",
          "snippet": "int nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nint nfix(int i, int n);\nint nabs(int n);\n\nint nfix(int i, int n) {\n\tif (i < 0) {\n\t\ti = 0;\n\t} else if (i >= n) {\n\t\ti = n - 1;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "direct_fb_copy",
          "args": [
            "x",
            "y",
            "x + w",
            "y + h",
            "1"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "direct_fb_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "1066-1180",
          "snippet": "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int direct_fb_copy(int x1, int y1, int x2, int y2, int mark);",
            "static void scale_mark(int x1, int y1, int x2, int y2, int mark);",
            "static int scrollability(Window win, int set);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark);\nstatic void scale_mark(int x1, int y1, int x2, int y2, int mark);\nstatic int scrollability(Window win, int set);\n\nint direct_fb_copy(int x1, int y1, int x2, int y2, int mark) {\n\tchar *src, *dst;\n\tint y, pixelsize = bpp/8;\n\tint xmin = -1, xmax = -1, ymin = -1, ymax = -1;\n\tint do_cmp = 2;\n\tdouble tm;\n\tint db = 0;\n\nif (db) dtime0(&tm);\n\n\tx1 = nfix(x1, dpy_x);\n\ty1 = nfix(y1, dpy_y);\n\tx2 = nfix(x2, dpy_x+1);\n\ty2 = nfix(y2, dpy_y+1);\n\n\tif (x1 == x2) {\n\t\treturn 1;\n\t}\n\tif (y1 == y2) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\tfor (y = y1; y < y2; y++) {\n\t\tXRANDR_SET_TRAP_RET(0, \"direct_fb_copy-set\");\n\t\tcopy_image(scanline, x1, y, x2 - x1, 1);\n\t\tXRANDR_CHK_TRAP_RET(0, \"direct_fb_copy-chk\");\n\t\t\n\t\tsrc = scanline->data;\n\t\tdst = main_fb + y * main_bytes_per_line + x1 * pixelsize;\n\n\t\tif (do_cmp == 0 || !mark) {\n\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\n\t\t} else if (do_cmp == 1) {\n\t\t\tif (memcmp(dst, src, (x2 - x1)*pixelsize)) {\n\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\tymin = y;\n\t\t\t\t}\n\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\tymax = y;\n\t\t\t\t}\n\t\t\t\tmemcpy(dst, src, (x2 - x1)*pixelsize);\n\t\t\t}\n\n\t\t} else if (do_cmp == 2) {\n\t\t\tint n, shift, xlo, xhi, k, block = 32;\n\t\t\tchar *dst2, *src2;\n\n\t\t\tfor (k=0; k*block < (x2 - x1); k++) {\n\t\t\t\tshift = k*block;\n\t\t\t\txlo = x1  + shift;\n\t\t\t\txhi = xlo + block;\n\t\t\t\tif (xhi > x2) {\n\t\t\t\t\txhi = x2;\n\t\t\t\t}\n\t\t\t\tn = xhi - xlo;\n\t\t\t\tif (n < 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsrc2 = src + shift*pixelsize;\n\t\t\t\tdst2 = dst + shift*pixelsize;\n\t\t\t\tif (memcmp(dst2, src2, n*pixelsize)) {\n\t\t\t\t\tif (ymin == -1 || y < ymin) {\n\t\t\t\t\t\tymin = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (ymax == -1 || y > ymax) {\n\t\t\t\t\t\tymax = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmin == -1 || xlo < xmin) {\n\t\t\t\t\t\txmin = xlo;\n\t\t\t\t\t}\n\t\t\t\t\tif (xmax == -1 || xhi > xmax) {\n\t\t\t\t\t\txmax = xhi;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(dst2, src2, n*pixelsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tX_UNLOCK;\n\n\tif (do_cmp == 0) {\n\t\txmin = x1;\n\t\tymin = y1;\n\t\txmax = x2;\n\t\tymax = y2;\n\t} else if (do_cmp == 1) {\n\t\txmin = x1;\n\t\txmax = x2;\n\t}\n\n\tif (xmin < 0 || ymin < 0 || xmax < 0 || xmin < 0) {\n\t\t/* no diffs */\n\t\treturn 1;\n\t}\n\n\tif (xmax < x2) {\n\t\txmax++;\n\t}\n\tif (ymax < y2) {\n\t\tymax++;\n\t}\n\n\tif (mark) {\n\t\tmark_rect_as_modified(xmin, ymin, xmax, ymax, 0);\n\t}\n\n if (db) {\n\tfprintf(stderr, \"direct_fb_copy: %dx%d+%d+%d - %d  %.4f\\n\",\n\t\tx2 - x1, y2 - y1, x1, y1, mark, dtime(&tm));\n }\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XD_DFC\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"unixpw.h\"\n#include \"userinput.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nint xdamage_tile_count = 0, xdamage_direct_count = 0;\nint xdamage_hint_skip(int y);\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h);\n\nstatic void record_desired_xdamage_rect(int x, int y, int w, int h) {\n\t/*\n\t * Unfortunately we currently can't trust an xdamage event\n\t * to correspond to real screen damage.  E.g. focus-in for\n\t * mozilla (depending on wm) will mark the whole toplevel\n\t * area as damaged, when only the border has changed.\n\t * Similar things for terminal windows.\n\t *\n\t * This routine uses some heuristics to detect small enough\n\t * damage regions that we will not have a performance problem\n\t * if we believe them even though they are wrong.  We record\n\t * the corresponding tiles the damage regions touch.\n\t */\n\tint dt_x, dt_y, nt_x1, nt_y1, nt_x2, nt_y2, nt;\n\tint ix, iy, cnt = 0;\n\tint area = w*h, always_accept = 0;\n\t/*\n\t * XXX: not working yet, slow and overlaps with scan_display()\n\t * probably slow because tall skinny rectangles very inefficient\n\t * in general and in direct_fb_copy() (100X slower then horizontal).\n\t */\n\tint use_direct_fb_copy = 0;\n\tint wh_min, wh_max;\n\tstatic int first = 1, udfb = 0;\n\n\t/* compiler warning: */\n\tnt_x1 = 0; nt_y1 = 0; nt_x2 = 0; nt_y2 = 0;\n\n\tif (first) {\n\t\tif (getenv(\"XD_DFC\")) {\n\t\t\tudfb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\tif (udfb) {\n\t\tuse_direct_fb_copy = 1;\n\t}\n\n\tif (xdamage_max_area <= 0) {\n\t\talways_accept = 1;\n\t}\n\n\tif (!always_accept && area > xdamage_max_area) {\n\t\treturn;\n\t}\n\n\tdt_x = w / tile_x;\n\tdt_y = h / tile_y;\n\n\tif (w < h) {\n\t\twh_min = w;\n\t\twh_max = h;\n\t} else {\n\t\twh_min = h;\n\t\twh_max = w;\n\t}\n\n\tif (!always_accept && dt_y >= 3 && area > 4000)  {\n\t\t/*\n\t\t * if it is real it should be caught by a normal scanline\n\t\t * poll, but we might as well keep if small (tall line?).\n\t\t */\n\t\treturn;\n\t}\n\t\n\tif (use_direct_fb_copy) {\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else if (0 && wh_min < tile_x/4 && wh_max > 30 * wh_min) {\n\t\t/* try it for long, skinny rects, XXX still no good */\n\t\tX_UNLOCK;\n\t\tdirect_fb_copy(x, y, x + w, y + h, 1);\n\t\txdamage_direct_count++;\n\t\tX_LOCK;\n\t} else {\n\n\t\tif (ntiles_x == 0 || ntiles_y == 0) {\n\t\t\t/* too early. */\n\t\t\treturn;\n\t\t}\n\t\tnt_x1 = nfix(  (x)/tile_x, ntiles_x);\n\t\tnt_x2 = nfix((x+w)/tile_x, ntiles_x);\n\t\tnt_y1 = nfix(  (y)/tile_y, ntiles_y);\n\t\tnt_y2 = nfix((y+h)/tile_y, ntiles_y);\n\n\t\t/*\n\t\t * loop over the rectangle of tiles (1 tile for a small\n\t\t * input rect).\n\t\t */\n\t\tfor (ix = nt_x1; ix <= nt_x2; ix++) {\n\t\t\tfor (iy = nt_y1; iy <= nt_y2; iy++) {\n\t\t\t\tnt = ix + iy * ntiles_x;\n\t\t\t\tcnt++;\n\t\t\t\tif (! tile_has_xdamage_diff[nt]) {\n\t\t\t\t\tXD_des++;\n\t\t\t\t\ttile_has_xdamage_diff[nt] = 1;\n\t\t\t\t}\n\t\t\t\t/* not used: */\n\t\t\t\ttile_row_has_xdamage_diff[iy] = 1;\n\t\t\t\txdamage_tile_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (debug_xdamage > 1) {\n\t\tfprintf(stderr, \"xdamage: desired: %dx%d+%d+%d\\tA: %6d  tiles=\"\n\t\t    \"%02d-%02d/%02d-%02d  tilecnt: %d\\n\", w, h, x, y,\n\t\t    w * h, nt_x1, nt_x2, nt_y1, nt_y2, cnt);\n\t}\n}"
  }
]