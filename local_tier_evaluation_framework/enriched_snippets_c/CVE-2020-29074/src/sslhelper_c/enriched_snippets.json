[
  {
    "function_name": "symmetric_encryption_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "4391-4417",
    "snippet": "static void symmetric_encryption_xfer(int csock, int s_in, int s_out) {\n\tchar tmp[100];\n\tchar *cipher, *keyfile, *q;\n\n\tif (! enc_str) {\n\t\treturn;\n\t}\n\tcipher = (char *) malloc(strlen(enc_str) + 100);\n\tq = strchr(enc_str, ':');\n\tif (!q) return;\n\t*q = '\\0';\n\tif (getenv(\"X11VNC_USE_ULTRADSM_IV\")) {\n\t\tsprintf(cipher, \"rev:%s\", enc_str);\n\t} else {\n\t\tsprintf(cipher, \"noultra:rev:%s\", enc_str);\n\t}\n\tkeyfile = strdup(q+1);\n\t*q = ':';\n\n\n\t/* TBD: s_in != s_out */\n\tif (s_out) {}\n\n\tsprintf(tmp, \"fd=%d,%d\", s_in, csock);\n\n\tenc_do(cipher, keyfile, \"-1\", tmp);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enc_do",
          "args": [
            "cipher",
            "keyfile",
            "\"-1\"",
            "tmp"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "enc_do",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/enc.h",
          "lines": "347-611",
          "snippet": "extern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\n\tstruct stat sb;\n\tchar *q, *p, *connect_host;\n\tchar tmp[16];\n\tint fd, len = 0, listen_port = 0, connect_port, mbits;\n\n\tq = ciph;\n\n\t/* check for noultra mode: */\n\tif (strstr(q, \"noultra:\") == q) {\n\t\tnoultra = 1;\n\t\tq += strlen(\"noultra:\");\n\t}\n\n\t/* check for reverse mode: */\n\tif (strstr(q, \"rev:\") == q) {\n\t\treverse = 1;\n\t\tq += strlen(\"rev:\");\n\t}\n\n\t/* work out which cipher and set Cipher to the selected one. */\n\tif (!strcasecmp(q, \"msrc4\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t} else if (!strcasecmp(q, \"msrc4_sc\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\t\tmsrc4_sc = 1;\t\t\t/* no salt/iv workaround */\n\n\t} else if (strstr(q, \"arc4\") == q) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t} else if (strstr(q, \"aesv2\") == q || strstr(q, \"aes-ofb\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t} else if (strstr(q, \"aes-cfb\") == q) {\n\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t} else if (strstr(q, \"aes256\") == q) {\n\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t} else if (strstr(q, \"blowfish\") == q) {\n\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t} else if (strstr(q, \"3des\") == q) {\n\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t} else if (strstr(q, \"securevnc\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\tsecurevnc = 1;\n\n\t} else if (strstr(q, \"none\") == q || strstr(q, \"relay\") == q) {\n\t\tcipher = \"none\";\n\n\t} else if (strstr(q, \"showcert\") == q) {\n\t\tcipher = \"showcert\";\n\n\t} else if (strstr(q, \".\") == q) {\n\t\t/* otherwise, try to guess cipher from key filename: */\n\t\tif (strstr(keyfile, \"arc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t\t} else if (strstr(keyfile, \"rc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t\t} else if (strstr(keyfile, \"aesv2.key\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t\t} else if (strstr(keyfile, \"aes-cfb.key\")) {\n\t\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t\t} else if (strstr(keyfile, \"aes256.key\")) {\n\t\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t\t} else if (strstr(keyfile, \"blowfish.key\")) {\n\t\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t\t} else if (strstr(keyfile, \"3des.key\")) {\n\t\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t\t} else if (strstr(keyfile, \"securevnc.\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\t\tsecurevnc = 1;\n\n\t\t} else {\n\t\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\texit(1);\n\t}\n\n\t/* set the default message digest (md5) */\n\tif (!securevnc) {\n\t\tDigest = EVP_md5();\n\t} else {\n\t\tDigest = EVP_sha1();\n\t}\n\n\t/*\n\t * Look for user specified salt and IV sizes at the end\n\t * ( ciph@salt,iv and ciph@[md+]salt,iv ):\n\t */\n\tp = strchr(q, '@');\n\tif (p) {\n\t\tint s, v;\n\t\tp++;\n\t\tif (strstr(p, \"md5+\") == p) {\n\t\t\tDigest = EVP_md5();        p += strlen(\"md5+\");\n#if OPENSSL_VERSION_NUMBER < 0x10100000L && !defined OPENSSL_NO_SHA0\n\t\t} else if (strstr(p, \"sha+\") == p) {\n\t\t\tDigest = EVP_sha();        p += strlen(\"sha+\");\n#endif\n\t\t} else if (strstr(p, \"sha1+\") == p) {\n\t\t\tDigest = EVP_sha1();       p += strlen(\"sha1+\");\n\t\t} else if (strstr(p, \"ripe+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripe+\");\n\t\t} else if (strstr(p, \"ripemd160+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripemd160+\");\n\t\t}\n\t\tif (sscanf(p, \"%d,%d\", &s, &v) == 2) {\n\t\t\t/* cipher@n,m */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (0 <= v && v <= EVP_MAX_IV_LENGTH) {\n\t\t\t\tivec_size = v;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid IV size: %d\\n\",\n\t\t\t\t    prog, v);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (sscanf(p, \"%d\", &s) == 1) {\n\t\t\t/* cipher@n */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (salt_size == -1) {\n\t\t\t/* let salt = -1 mean skip both MD5 and salt */\n\t\t\tnomd = 1;\n\t\t\tsalt_size = 0;\n\t\t}\n\t}\n\n\t/* port to listen on (0 => stdio, negative => localhost) */\n\tif (lport != NULL) {\n\t\tlisten_port = atoi(lport);\n\t}\n\n\t/* extract remote hostname and port */\n\tq = strrchr(rhp, ':');\n\tif (q) {\n\t\tconnect_port = atoi(q+1);\n\t\t*q = '\\0';\n\t} else {\n\t\t/* otherwise guess VNC display 0 ... */\n\t\tconnect_port = 5900;\n\t}\n\tconnect_host = strdup(rhp);\n\n\t/* check for and read in the key file */\n\tmemset(keydata, 0, sizeof(keydata));\n\n\tif (!strcmp(cipher, \"none\")) {\n\t\tgoto readed_in;\n\t}\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto readed_in;\n\t}\n\n\tif (securevnc) {\n\t\t/* note the keyfile for rsa verification later */\n\t\tif (keyfile != NULL && strcasecmp(keyfile, \"none\")) {\n\t\t\tsecurevnc_file = keyfile;\n\t\t}\n\t\tgoto readed_in;\n\t}\n\n\tif (stat(keyfile, &sb) != 0) {\n\t\tif (strstr(keyfile, \"pw=\") == keyfile) {\n\t\t\t/* user specified key/password on cmdline */\n\t\t\tint i;\n\t\t\tlen = 0;\n\t\t\tpw_in = 1;\n\t\t\tfor (i=0; i < (int) strlen(keyfile); i++) {\n\t\t\t\t/* load the string to keydata: */\n\t\t\t\tint n = i + strlen(\"pw=\");\n\t\t\t\tkeydata[i] = keyfile[n];\n\t\t\t\tif (keyfile[n] == '\\0') break;\n\t\t\t\tlen++;\n\t\t\t\tif (i > 100) break;\n\t\t\t}\n\t\t\tgoto readed_in;\n\t\t}\n\t\t/* otherwise invalid file */\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tif (sb.st_size > 1024) {\n\t\tfprintf(stderr, \"%s: key file too big.\\n\", prog);\n\t\texit(1);\n\t}\n\tfd = open(keyfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\texit(1);\n\t}\n\n\t/* read it all in */\n\tlen = (int) read(fd, keydata, (size_t) sb.st_size);\n\tif (len != sb.st_size) {\n\t\tperror(\"read\");\n\t\tfprintf(stderr, \"%s, could not read key file.\\n\", prog);\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\treaded_in:\n\n\n\t/* check for ultravnc msrc4 format 'rc4.key' */\n\tmbits = 0;\n\tif (strstr(keydata, \"128 bit\") == keydata) {\n\t\tmbits = 128;\n\t} else if (strstr(keydata, \" 56 bit\") == keydata) {\n\t\tmbits = 56;\n\t} else if (strstr(keydata, \" 40 bit\") == keydata) {\n\t\tmbits = 40;\n\t}\n\tif (mbits > 0) {\n\t\t/* 4 is for int key length, 12 is for BLOBHEADER. */\n\t\tint i, offset = strlen(\"xxx bit\") + 4 + 12;\n\n\t\t/* the key is stored in reverse order! */\n\t\tlen = mbits/8;\n\t\tfor (i=0; i < len; i++) {\n\t\t\ttmp[i] = keydata[offset + len - i - 1];\n\t\t}\n\n\t\t/* clear keydata and then copy the reversed bytes there: */\n\t\tmemset(keydata, 0, sizeof(keydata));\n\t\tmemcpy(keydata, tmp, len);\n\t}\n\n\tkeydata_len = len;\n\n\t/* initialize random */\n\tRAND_poll();\n\n\t/*\n\t * Setup connections, then transfer data when they are all\n\t * hooked up.\n\t */\n\tenc_connections(listen_port, connect_host, connect_port);\n}",
          "includes": [
            "#  include \"dbg.h\"",
            "#include <openssl/rsa.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/evp.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SALT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include \"dbg.h\"\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/rand.h>\n#include <openssl/evp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define SALT 16\n\nextern void enc_do(char *ciph, char *keyfile, char *lport, char *rhp) { \n\n\tstruct stat sb;\n\tchar *q, *p, *connect_host;\n\tchar tmp[16];\n\tint fd, len = 0, listen_port = 0, connect_port, mbits;\n\n\tq = ciph;\n\n\t/* check for noultra mode: */\n\tif (strstr(q, \"noultra:\") == q) {\n\t\tnoultra = 1;\n\t\tq += strlen(\"noultra:\");\n\t}\n\n\t/* check for reverse mode: */\n\tif (strstr(q, \"rev:\") == q) {\n\t\treverse = 1;\n\t\tq += strlen(\"rev:\");\n\t}\n\n\t/* work out which cipher and set Cipher to the selected one. */\n\tif (!strcasecmp(q, \"msrc4\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t} else if (!strcasecmp(q, \"msrc4_sc\")) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\t\tmsrc4_sc = 1;\t\t\t/* no salt/iv workaround */\n\n\t} else if (strstr(q, \"arc4\") == q) {\n\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t} else if (strstr(q, \"aesv2\") == q || strstr(q, \"aes-ofb\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t} else if (strstr(q, \"aes-cfb\") == q) {\n\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t} else if (strstr(q, \"aes256\") == q) {\n\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t} else if (strstr(q, \"blowfish\") == q) {\n\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t} else if (strstr(q, \"3des\") == q) {\n\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t} else if (strstr(q, \"securevnc\") == q) {\n\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\tsecurevnc = 1;\n\n\t} else if (strstr(q, \"none\") == q || strstr(q, \"relay\") == q) {\n\t\tcipher = \"none\";\n\n\t} else if (strstr(q, \"showcert\") == q) {\n\t\tcipher = \"showcert\";\n\n\t} else if (strstr(q, \".\") == q) {\n\t\t/* otherwise, try to guess cipher from key filename: */\n\t\tif (strstr(keyfile, \"arc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"arc4\";\n\n\t\t} else if (strstr(keyfile, \"rc4.key\")) {\n\t\t\tCipher = EVP_rc4();\t\tcipher = \"msrc4\";\n\n\t\t} else if (strstr(keyfile, \"aesv2.key\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"aesv2\";\n\n\t\t} else if (strstr(keyfile, \"aes-cfb.key\")) {\n\t\t\tCipher = EVP_aes_128_cfb();\tcipher = \"aes-cfb\";\n\n\t\t} else if (strstr(keyfile, \"aes256.key\")) {\n\t\t\tCipher = EVP_aes_256_cfb();\tcipher = \"aes256\";\n\n\t\t} else if (strstr(keyfile, \"blowfish.key\")) {\n\t\t\tCipher = EVP_bf_cfb();\t\tcipher = \"blowfish\";\n\n\t\t} else if (strstr(keyfile, \"3des.key\")) {\n\t\t\tCipher = EVP_des_ede3_cfb();\tcipher = \"3des\";\n\n\t\t} else if (strstr(keyfile, \"securevnc.\")) {\n\t\t\tCipher = EVP_aes_128_ofb();\tcipher = \"securevnc\";\n\t\t\tsecurevnc = 1;\n\n\t\t} else {\n\t\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"cannot figure out cipher, supply 'msrc4', 'arc4', or 'aesv2' ...\\n\");\n\t\texit(1);\n\t}\n\n\t/* set the default message digest (md5) */\n\tif (!securevnc) {\n\t\tDigest = EVP_md5();\n\t} else {\n\t\tDigest = EVP_sha1();\n\t}\n\n\t/*\n\t * Look for user specified salt and IV sizes at the end\n\t * ( ciph@salt,iv and ciph@[md+]salt,iv ):\n\t */\n\tp = strchr(q, '@');\n\tif (p) {\n\t\tint s, v;\n\t\tp++;\n\t\tif (strstr(p, \"md5+\") == p) {\n\t\t\tDigest = EVP_md5();        p += strlen(\"md5+\");\n#if OPENSSL_VERSION_NUMBER < 0x10100000L && !defined OPENSSL_NO_SHA0\n\t\t} else if (strstr(p, \"sha+\") == p) {\n\t\t\tDigest = EVP_sha();        p += strlen(\"sha+\");\n#endif\n\t\t} else if (strstr(p, \"sha1+\") == p) {\n\t\t\tDigest = EVP_sha1();       p += strlen(\"sha1+\");\n\t\t} else if (strstr(p, \"ripe+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripe+\");\n\t\t} else if (strstr(p, \"ripemd160+\") == p) {\n\t\t\tDigest = EVP_ripemd160();  p += strlen(\"ripemd160+\");\n\t\t}\n\t\tif (sscanf(p, \"%d,%d\", &s, &v) == 2) {\n\t\t\t/* cipher@n,m */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (0 <= v && v <= EVP_MAX_IV_LENGTH) {\n\t\t\t\tivec_size = v;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid IV size: %d\\n\",\n\t\t\t\t    prog, v);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else if (sscanf(p, \"%d\", &s) == 1) {\n\t\t\t/* cipher@n */\n\t\t\tif (-1 <= s && s <= SALT) {\n\t\t\t\tsalt_size = s;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: invalid salt size: %d\\n\",\n\t\t\t\t    prog, s);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (salt_size == -1) {\n\t\t\t/* let salt = -1 mean skip both MD5 and salt */\n\t\t\tnomd = 1;\n\t\t\tsalt_size = 0;\n\t\t}\n\t}\n\n\t/* port to listen on (0 => stdio, negative => localhost) */\n\tif (lport != NULL) {\n\t\tlisten_port = atoi(lport);\n\t}\n\n\t/* extract remote hostname and port */\n\tq = strrchr(rhp, ':');\n\tif (q) {\n\t\tconnect_port = atoi(q+1);\n\t\t*q = '\\0';\n\t} else {\n\t\t/* otherwise guess VNC display 0 ... */\n\t\tconnect_port = 5900;\n\t}\n\tconnect_host = strdup(rhp);\n\n\t/* check for and read in the key file */\n\tmemset(keydata, 0, sizeof(keydata));\n\n\tif (!strcmp(cipher, \"none\")) {\n\t\tgoto readed_in;\n\t}\n\tif (!strcmp(cipher, \"showcert\")) {\n\t\tgoto readed_in;\n\t}\n\n\tif (securevnc) {\n\t\t/* note the keyfile for rsa verification later */\n\t\tif (keyfile != NULL && strcasecmp(keyfile, \"none\")) {\n\t\t\tsecurevnc_file = keyfile;\n\t\t}\n\t\tgoto readed_in;\n\t}\n\n\tif (stat(keyfile, &sb) != 0) {\n\t\tif (strstr(keyfile, \"pw=\") == keyfile) {\n\t\t\t/* user specified key/password on cmdline */\n\t\t\tint i;\n\t\t\tlen = 0;\n\t\t\tpw_in = 1;\n\t\t\tfor (i=0; i < (int) strlen(keyfile); i++) {\n\t\t\t\t/* load the string to keydata: */\n\t\t\t\tint n = i + strlen(\"pw=\");\n\t\t\t\tkeydata[i] = keyfile[n];\n\t\t\t\tif (keyfile[n] == '\\0') break;\n\t\t\t\tlen++;\n\t\t\t\tif (i > 100) break;\n\t\t\t}\n\t\t\tgoto readed_in;\n\t\t}\n\t\t/* otherwise invalid file */\n\t\tperror(\"stat\");\n\t\texit(1);\n\t}\n\tif (sb.st_size > 1024) {\n\t\tfprintf(stderr, \"%s: key file too big.\\n\", prog);\n\t\texit(1);\n\t}\n\tfd = open(keyfile, O_RDONLY);\n\tif (fd < 0) {\n\t\tperror(\"open\");\n\t\texit(1);\n\t}\n\n\t/* read it all in */\n\tlen = (int) read(fd, keydata, (size_t) sb.st_size);\n\tif (len != sb.st_size) {\n\t\tperror(\"read\");\n\t\tfprintf(stderr, \"%s, could not read key file.\\n\", prog);\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\treaded_in:\n\n\n\t/* check for ultravnc msrc4 format 'rc4.key' */\n\tmbits = 0;\n\tif (strstr(keydata, \"128 bit\") == keydata) {\n\t\tmbits = 128;\n\t} else if (strstr(keydata, \" 56 bit\") == keydata) {\n\t\tmbits = 56;\n\t} else if (strstr(keydata, \" 40 bit\") == keydata) {\n\t\tmbits = 40;\n\t}\n\tif (mbits > 0) {\n\t\t/* 4 is for int key length, 12 is for BLOBHEADER. */\n\t\tint i, offset = strlen(\"xxx bit\") + 4 + 12;\n\n\t\t/* the key is stored in reverse order! */\n\t\tlen = mbits/8;\n\t\tfor (i=0; i < len; i++) {\n\t\t\ttmp[i] = keydata[offset + len - i - 1];\n\t\t}\n\n\t\t/* clear keydata and then copy the reversed bytes there: */\n\t\tmemset(keydata, 0, sizeof(keydata));\n\t\tmemcpy(keydata, tmp, len);\n\t}\n\n\tkeydata_len = len;\n\n\t/* initialize random */\n\tRAND_poll();\n\n\t/*\n\t * Setup connections, then transfer data when they are all\n\t * hooked up.\n\t */\n\tenc_connections(listen_port, connect_host, connect_port);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"fd=%d,%d\"",
            "s_in",
            "csock"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "q+1"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cipher",
            "\"noultra:rev:%s\"",
            "enc_str"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cipher",
            "\"rev:%s\"",
            "enc_str"
          ],
          "line": 4403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_USE_ULTRADSM_IV\""
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "enc_str",
            "':'"
          ],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(enc_str) + 100"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "enc_str"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nstatic void symmetric_encryption_xfer(int csock, int s_in, int s_out) {\n\tchar tmp[100];\n\tchar *cipher, *keyfile, *q;\n\n\tif (! enc_str) {\n\t\treturn;\n\t}\n\tcipher = (char *) malloc(strlen(enc_str) + 100);\n\tq = strchr(enc_str, ':');\n\tif (!q) return;\n\t*q = '\\0';\n\tif (getenv(\"X11VNC_USE_ULTRADSM_IV\")) {\n\t\tsprintf(cipher, \"rev:%s\", enc_str);\n\t} else {\n\t\tsprintf(cipher, \"noultra:rev:%s\", enc_str);\n\t}\n\tkeyfile = strdup(q+1);\n\t*q = ':';\n\n\n\t/* TBD: s_in != s_out */\n\tif (s_out) {}\n\n\tsprintf(tmp, \"fd=%d,%d\", s_in, csock);\n\n\tenc_do(cipher, keyfile, \"-1\", tmp);\n}"
  },
  {
    "function_name": "raw_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "4286-4373",
    "snippet": "void raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define FORK_OK"
    ],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s_out"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw_xfer done:  %d <- %d\\n\"",
            "csock",
            "s_in"
          ],
          "line": 4367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "par",
            "&status",
            "WNOHANG"
          ],
          "line": 4366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "par",
            "SIGTERM"
          ],
          "line": 4365
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250*1000"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\"",
            "csock",
            "s_in",
            "m",
            "n",
            "errno"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "csock",
            "src",
            "len"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "s_in",
            "buf",
            "sz"
          ],
          "line": 4342
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw_xfer start: %d <- %d\\n\"",
            "csock",
            "s_in"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50*1000"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw_xfer done:  %d -> %d\\n\"",
            "csock",
            "s_out"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250*1000"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\"",
            "csock",
            "s_out",
            "m",
            "n",
            "errno"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"raw_xfer start: %d -> %d/%d\\n\"",
            "csock",
            "s_in",
            "s_out"
          ],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_DEBUG_RAW_XFER\")"
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_RAW_XFER\""
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_RAW_XFER\""
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nvoid raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}"
  },
  {
    "function_name": "accept_openssl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "3302-4284",
    "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define HAVE_LIBSSL 0",
      "#define LIBVNCSERVER_HAVE_LIBSSL 0",
      "#define ABSIZE 16384",
      "#define OPENSSL_REVERSE 6",
      "#define OPENSSL_HTTPS6  5",
      "#define OPENSSL_HTTPS   4",
      "#define OPENSSL_VNC6    3",
      "#define OPENSSL_VNC     2",
      "#define OPENSSL_INETD   1"
    ],
    "globals_used": [
      "int openssl_sock = -1;",
      "int openssl_sock6 = -1;",
      "int https_sock = -1;",
      "int https_sock6 = -1;",
      "pid_t openssl_last_helper_pid = 0;",
      "char *openssl_last_ip = NULL;",
      "static char *certret = NULL;",
      "static int certret_fd = -1;",
      "static mode_t omode;",
      "char *certret_str = NULL;",
      "static char *dhret = NULL;",
      "static int dhret_fd = -1;",
      "char *dhret_str = NULL;",
      "char *new_dh_params = NULL;",
      "void raw_xfer(int csock, int s_in, int s_out);",
      "static char *get_input(char *tag, char **in);",
      "void ssl_helper_pid(pid_t pid, int sock);",
      "void accept_openssl(int mode, int presock);",
      "static void lose_ram(void);",
      "static int vencrypt_selected = 0;",
      "static int anontls_selected = 0;",
      "static int csock_timeout_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 4278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "SIGTERM"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "vsock"
          ],
          "line": 4275
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: rfbNewClient failed.\\n\""
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "progress_client",
          "args": [],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "progress_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/user.c",
          "lines": "2891-2919",
          "snippet": "void progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}",
          "includes": [
            "#include \"avahi.h\"",
            "#include \"sslhelper.h\"",
            "#include \"remote.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"inet.h\"",
            "#include \"connections.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"scan.h\"",
            "#include \"cleanup.h\"",
            "#include \"solid.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void progress_client(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"avahi.h\"\n#include \"sslhelper.h\"\n#include \"remote.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"inet.h\"\n#include \"connections.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"scan.h\"\n#include \"cleanup.h\"\n#include \"solid.h\"\n#include \"x11vnc.h\"\n\nvoid progress_client(void);\n\nvoid progress_client(void) {\n\tint i, j = 0, progressed = 0, db = 0;\n\tdouble start = dnow();\n\tif (getenv(\"PROGRESS_CLIENT_DBG\")) {\n\t\trfbLog(\"progress_client: begin\\n\");\n\t\tdb = 1;\n\t}\n\tfor (i = 0; i < 15; i++) {\n\t\tif (latest_client) {\n\t\t\tfor (j = 0; j < 10; j++) {\n\t\t\t\tif (latest_client->state != RFB_PROTOCOL_VERSION) {\n\t\t\t\t\tprogressed = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (db) rfbLog(\"progress_client: calling-1 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\t\t\trfbCFD(1);\n\t\t\t}\n\t\t}\n\t\tif (progressed) {\n\t\t\tbreak;\n\t\t}\n\t\tif (db) rfbLog(\"progress_client: calling-2 rfbCFD(1) %.6f\\n\", dnow()-start);\n\t\trfbCFD(1);\n\t}\n\tif (!quiet) {\n\t\trfbLog(\"client progressed=%d in %d/%d %.6f s\\n\",\n\t\t    progressed, i, j, dnow() - start);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbStartOnHoldClient",
          "args": [
            "client"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbAuthNewClient",
          "args": [
            "client"
          ],
          "line": 4266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "badnews",
          "args": [
            "\"3 accept_openssl\""
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "badnews",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "691-696",
          "snippet": "static void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbCloseClient",
          "args": [
            "client"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_vencrypt_auth",
          "args": [
            "client",
            "vencrypt_sel"
          ],
          "line": 4256
        },
        "resolved": true,
        "details": {
          "function_name": "finish_vencrypt_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1431-1443",
          "snippet": "static int finish_vencrypt_auth(rfbClientPtr client, int subtype) {\n\n\tif (subtype == rfbVencryptTlsNone || subtype == rfbVencryptX509None) {\n\t\treturn finish_auth(client, \"None\");\n\t} else if (subtype == rfbVencryptTlsVnc || subtype == rfbVencryptX509Vnc) {\n\t\treturn finish_auth(client, \"Vnc\");\n\t} else if (subtype == rfbVencryptTlsPlain || subtype == rfbVencryptX509Plain) {\n\t\treturn finish_auth(client, \"Plain\");\n\t} else {\n\t\trfbLog(\"finish_vencrypt_auth: unknown sub-type: %d\\n\", subtype);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define rfbVencryptX509Plain\t262",
            "#define rfbVencryptX509Vnc\t261",
            "#define rfbVencryptX509None\t260",
            "#define rfbVencryptTlsPlain\t259",
            "#define rfbVencryptTlsVnc\t258",
            "#define rfbVencryptTlsNone\t257"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define rfbVencryptX509Plain\t262\n#define rfbVencryptX509Vnc\t261\n#define rfbVencryptX509None\t260\n#define rfbVencryptTlsPlain\t259\n#define rfbVencryptTlsVnc\t258\n#define rfbVencryptTlsNone\t257\n\nstatic int finish_vencrypt_auth(rfbClientPtr client, int subtype) {\n\n\tif (subtype == rfbVencryptTlsNone || subtype == rfbVencryptX509None) {\n\t\treturn finish_auth(client, \"None\");\n\t} else if (subtype == rfbVencryptTlsVnc || subtype == rfbVencryptX509Vnc) {\n\t\treturn finish_auth(client, \"Vnc\");\n\t} else if (subtype == rfbVencryptTlsPlain || subtype == rfbVencryptX509Plain) {\n\t\treturn finish_auth(client, \"Plain\");\n\t} else {\n\t\trfbLog(\"finish_vencrypt_auth: unknown sub-type: %d\\n\", subtype);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "openssl_last_ip"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "openssl_last_ip",
            "\"0123456789\""
          ],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"accept_openssl: new_client %p\\n\"",
            "(void *) new_client"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"accept_openssl: new_client %p\\n\"",
            "(void *) screen->newClientHook"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"accept_openssl: client %p\\n\"",
            "(void *) client"
          ],
          "line": 4241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "openssl_last_ip"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "client->host"
          ],
          "line": 4237
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_client",
          "args": [
            "vsock",
            "0"
          ],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3826-3845",
          "snippet": "rfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "rfbClientPtr create_new_client(int sock, int start_thread);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nrfbClientPtr create_new_client(int sock, int start_thread);\n\nrfbClientPtr create_new_client(int sock, int start_thread) {\n\trfbClientPtr cl;\n\n\tif (!screen) {\n\t\treturn NULL;\n\t}\n\n\tcl = rfbNewClient(screen, sock);\n\n\tif (cl == NULL) {\n\t\treturn NULL;\t\n\t}\n\tif (use_threads) {\n\t\tcl->onHold = FALSE;\n\t\tif (start_thread) {\n\t\t\trfbStartOnHoldClient(cl);\n\t\t}\n\t}\n\treturn cl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssl_helper_pid",
          "args": [
            "pid",
            "vsock"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2999-3117",
          "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: handshake with helper process[%d] succeeded.\\n\"",
            "pid"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"accept_openssl: cookie good: %s\\n\"",
            "cookie"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbPE",
          "args": [
            "10000"
          ],
          "line": 4193
        },
        "resolved": true,
        "details": {
          "function_name": "rfbPE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "561-619",
          "snippet": "int rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [
            "#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */"
          ],
          "globals_used": [
            "int nfix(int i, int n);",
            "int nabs(int n);",
            "double dnow(void);",
            "int rfbPE(long usec);",
            "void rfbCFD(long usec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\n#define USEC_MAX 999999\t\t/* libvncsever assumes < 1 second */\n\nint nfix(int i, int n);\nint nabs(int n);\ndouble dnow(void);\nint rfbPE(long usec);\nvoid rfbCFD(long usec);\n\nint rfbPE(long usec) {\n\tint uip0 = unixpw_in_progress;\n\tstatic int check_rate = -1;\n\tint res = 0;\n\tif (! screen) {\n\t\treturn res;\n\t}\n \tif (unixpw && unixpw_in_progress && !unixpw_in_rfbPE) {\n\t\trfbLog(\"unixpw_in_rfbPE: skipping rfbPE\\n\");\n \t\treturn res;\n \t}\n\n\tif (debug_tiles > 2) {\n\t\tdouble tm = dnow();\n\t\tfprintf(stderr, \"rfbPE(%d)  t: %.4f\\n\",\n\t\t    (int) usec, tm - x11vnc_start);\n\t}\n\n\tif (usec > USEC_MAX) {\n\t\tusec = USEC_MAX;\n\t}\n\tif (! use_threads) {\n\t\trfbBool r;\n\t\tr = rfbProcessEvents(screen, usec);\n\t\tif (r) {\n\t\t\tres = 1;\n\t\t}\n\t}\n\n \tif (unixpw && unixpw_in_progress && !uip0) {\n\t\tif (!unixpw_in_rfbPE) {\n\t\t\trfbLog(\"rfbPE: got new client in non-rfbPE\\n\");\n\t\t\t;\t/* this is new unixpw client  */\n\t\t}\n \t}\n\n\tif (ipv6_listen) {\n\t\tcheck_ipv6_listen(usec);\n\t}\n\tif (unix_sock) {\n\t\tcheck_unix_sock(usec);\n\t}\n\tif (check_rate != 0) {\n\t\tif (check_rate < 0) {\n\t\t\tif (getenv(\"CHECK_RATE\")) {\n\t\t\t\tcheck_rate = 1;\n\t\t\t} else {\n\t\t\t\tcheck_rate = 0;\n\t\t\t}\n\t\t}\n\t\tif (check_rate && !all_input && x11vnc_current < last_client + 45)  {\n\t\t\tcheck_allinput_rate();\n\t\t}\n\t}\n\tif (all_input) {\n\t\tdo_allinput(usec);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\"",
            "pid",
            "dnow() - start"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: httpSock for helper[%d] went away\\n\"",
            "pid"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: helper[%d] pid finished\\n\"",
            "pid"
          ],
          "line": 4178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: screen->port %d for helper[%d]\\n\"",
            "screen->port",
            "pid"
          ],
          "line": 4167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_local_port",
          "args": [
            "fd"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "get_local_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "230-232",
          "snippet": "int get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_local_port(int sock) {\n\treturn get_port(sock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\")"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_INETD_PORT\""
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_INETD_PORT\""
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\"",
            "pid",
            "dnow() - start"
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: httpSock for helper[%d] went away\\n\"",
            "pid"
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: helper[%d] pid finished\\n\"",
            "pid"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: -httpsredir guess port: %d  helper[%d]\\n\"",
            "screen->port",
            "pid"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"HP=%d,\"",
            "&p"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcookie",
            "\"HP=\""
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"***********************************************************\\n\""
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\""
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\""
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\""
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\""
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\""
          ],
          "line": 4088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\""
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"***********************************************************\\n\""
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"helper[%d]:\\n\"",
            "pid"
          ],
          "line": 4085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcookie",
            "\"VncViewer.class\""
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"last_get: '%s'\\n\"",
            "last_get"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "last_get",
            "rcookie",
            "100"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\"",
            "pid"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atof",
          "args": [
            "getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\""
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\""
          ],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcookie",
            "uniq"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"'%s'\\n'%s'\\n\"",
            "cookie",
            "rcookie"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\"",
            "pid",
            "n"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cookie",
            "rcookie",
            "n"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\"",
            "anontls_sel",
            "pid"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"ANONTLS=%d,\"",
            "&anontls_sel"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcookie",
            "\"ANONTLS=\""
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\"",
            "vencrypt_sel",
            "pid"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\"VENCRYPT=%d,\"",
            "&vencrypt_sel"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcookie",
            "\"VENCRYPT=\""
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cookie",
            "q"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcookie",
            "\"RB=\""
          ],
          "line": 4040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "rcookie",
            "uniq"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cookie:  %s\\n\"",
            "cookie"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"rcookie: %s\\n\"",
            "rcookie"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dhret_str"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"dhret_str[%d]:\\n%s\\n\"",
            "(int) sbuf.st_size",
            "dhret_str"
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dhret_str",
            "\"NOCERT\""
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "dhret"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "dhret_fd",
            "dhret_str",
            "sbuf.st_size"
          ],
          "line": 4013
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sbuf.st_size+1",
            "1"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dhret",
            "&sbuf"
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"certret_str[%d]:\\n%s\\n\"",
            "(int) sbuf.st_size",
            "certret_str"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "certret_str",
            "\"NOCERT\""
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "certret"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sbuf.st_size+1",
            "1"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"read\""
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"accept_openssl: vsock: %d\\n\"",
            "vsock"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "dhret"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "certret"
          ],
          "line": 3967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "WNOHANG"
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"accept\""
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\"",
            "pid"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "csock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "csock_timeout"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"helper process is: %d\\n\"",
            "pid"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "50 * 1000"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\"",
            "getpid()"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssl_xfer",
          "args": [
            "vncsock",
            "s_in",
            "s_out",
            "0"
          ],
          "line": 3929
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2232-2628",
          "snippet": "static void ssl_xfer(int csock, int s_in, int s_out, int is_https) {\n\tint dbxfer = 0, db = 0, check_pending, fdmax, nfd, n, i, err;\n\tchar cbuf[ABSIZE], sbuf[ABSIZE];\n\tint  cptr, sptr, c_rd, c_wr, s_rd, s_wr;\n\tfd_set rd, wr;\n\tstruct timeval tv;\n\tint ssock, cnt = 0, ndata = 0;\n\n\t/*\n\t * we want to switch to a longer timeout for long term VNC\n\t * connections (in case the network is not working for periods of\n\t * time), but we also want the timeout shorter at the beginning\n\t * in case the client went away.\n\t */\n\tdouble start, now;\n\tint tv_https_early = 60;\n\tint tv_https_later = 20;\n\tint tv_vnc_early = 40;\n\tint tv_vnc_later = 43200;\t/* was 300, stunnel: 43200 */\n\tint tv_cutover = 70;\n\tint tv_closing = 60;\n\tint tv_use;\n\n\tif (dbxfer) {\n\t\traw_xfer(csock, s_in, s_out);\n\t\treturn;\n\t}\n\tif (enc_str != NULL) {\n\t\tif (!strcmp(enc_str, \"none\")) {\n\t\t\tusleep(250*1000);\n\t\t\trfbLog(\"doing '-enc none' raw transfer (no encryption)\\n\"); \n\t\t\traw_xfer(csock, s_in, s_out);\n\t\t} else {\n\t\t\tsymmetric_encryption_xfer(csock, s_in, s_out);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\n\tif (db) fprintf(stderr, \"ssl_xfer begin\\n\");\n\n\tstart = dnow();\n\tif (is_https) {\n\t\ttv_use = tv_https_early;\n\t} else {\n\t\ttv_use = tv_vnc_early;\n\t}\n\t\n\n\t/*\n\t * csock: clear text socket with libvncserver.    \"C\"\n\t * ssock: ssl data socket with remote vnc viewer. \"S\"\n\t *\n\t * to cover inetd mode, we have s_in and s_out, but in non-inetd\n\t * mode they both ssock.\n\t *\n\t * cbuf[] is data from csock that we have read but not passed on to ssl \n\t * sbuf[] is data from ssl that we have read but not passed on to csock \n\t */\n\tfor (i=0; i<ABSIZE; i++) {\n\t\tcbuf[i] = '\\0';\n\t\tsbuf[i] = '\\0';\n\t}\n\t\t\n\tif (s_out > s_in) {\n\t\tssock = s_out;\n\t} else {\n\t\tssock = s_in;\n\t}\n\n\tif (csock > ssock) {\n\t\tfdmax = csock; \n\t} else {\n\t\tfdmax = ssock; \n\t}\n\n\tc_rd = 1;\t/* clear text (libvncserver) socket open for reading */\n\tc_wr = 1;\t/* clear text (libvncserver) socket open for writing */\n\ts_rd = 1;\t/* ssl data (remote client)  socket open for reading */\n\ts_wr = 1;\t/* ssl data (remote client)  socket open for writing */\n\n\tcptr = 0;\t/* offsets into ABSIZE buffers */\n\tsptr = 0;\n\n\tif (vencrypt_selected > 0 || anontls_selected > 0) {\n\t\tchar tmp[16];\n\t\t/* read and discard the extra RFB version */\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tread(csock, tmp, 12);\n\t\tif (0) fprintf(stderr, \"extra: %s\\n\", tmp);\n\t}\n\n\twhile (1) {\n\t\tint c_to_s, s_to_c, closing;\n\n\t\tif ( s_wr && (c_rd || cptr > 0) ) {\n\t\t\t/* \n\t\t\t * S is writable and \n\t\t\t * C is readable or some cbuf data remaining\n\t\t\t */\n\t\t\tc_to_s = 1;\n\t\t} else {\n\t\t\tc_to_s = 0;\n\t\t}\n\n\t\tif ( c_wr && (s_rd || sptr > 0) ) {\n\t\t\t/* \n\t\t\t * C is writable and \n\t\t\t * S is readable or some sbuf data remaining\n\t\t\t */\n\t\t\ts_to_c = 1;\n\t\t} else {\n\t\t\ts_to_c = 0;\n\t\t}\n\n\t\tif (! c_to_s && ! s_to_c) {\n\t\t\t/*\n\t\t\t * nothing can be sent either direction.\n\t\t\t * break out of the loop to finish all work.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\n\t\t/* set up the fd sets for the two sockets for read & write: */\n\n\t\tFD_ZERO(&rd);\n\n\t\tif (c_rd && cptr < ABSIZE) {\n\t\t\t/* we could read more from C since cbuf is not full */\n\t\t\tFD_SET(csock, &rd);\n\t\t}\n\t\tif (s_rd) {\n\t\t\t/*\n\t\t\t * we could read more from S since sbuf not full,\n\t\t\t * OR ssl is waiting for more BIO to be able to\n\t\t\t * read and we have some C data still buffered.\n\t\t\t */\n\t\t\tif (sptr < ABSIZE || (cptr > 0 && SSL_want_read(ssl))) {\n\t\t\t\tFD_SET(s_in, &rd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFD_ZERO(&wr);\n\n\t\tif (c_wr && sptr > 0) {\n\t\t\t/* we could write more to C since sbuf is not empty */\n\t\t\tFD_SET(csock, &wr);\n\t\t}\n\t\tif (s_wr) {\n\t\t\t/*\n\t\t\t * we could write more to S since cbuf not empty,\n\t\t\t * OR ssl is waiting for more BIO to be able\n\t\t\t * write and we haven't filled up sbuf yet.\n\t\t\t */\n\t\t\tif (cptr > 0 || (sptr < ABSIZE && SSL_want_write(ssl))) {\n\t\t\t\tFD_SET(s_out, &wr);\n\t\t\t}\n\t\t}\n\n\t\tnow = dnow();\n\t\tif (tv_cutover && now > start + tv_cutover) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: tv_cutover: %d\\n\", getpid(),\n\t\t\t    tv_cutover);\n\t\t\ttv_cutover = 0;\n\t\t\tif (is_https) {\n\t\t\t\ttv_use = tv_https_later;\n\t\t\t} else {\n\t\t\t\ttv_use = tv_vnc_later;\n\t\t\t}\n\t\t\t/* try to clean out some zombies if we can. */\n\t\t\tssl_helper_pid(0, -2);\n\t\t}\n\t\tif (ssl_timeout_secs > 0) {\n\t\t\ttv_use = ssl_timeout_secs;\n\t\t}\n\n\t\tif ( (s_rd && c_rd) || cptr || sptr) {\n\t\t\tclosing = 0;\n\t\t} else {\n\t\t\tclosing = 1;\n\t\t\ttv_use = tv_closing;\n\t\t}\n\n\t\ttv.tv_sec  = tv_use;\n\t\ttv.tv_usec = 0;\n\n\t\t/*  do the select, repeat if interrupted */\n\t\tdo {\n\t\t\tif (ssl_timeout_secs == 0) {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, NULL);\n\t\t\t} else {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, &tv);\n\t\t\t}\n\t\t} while (nfd < 0 && errno == EINTR);\n\n\t\tif (db > 1) fprintf(stderr, \"nfd: %d\\n\", nfd);\n\nif (0) fprintf(stderr, \"nfd[%d]: %d  w/r csock: %d %d s_in: %d %d\\n\", getpid(), nfd, FD_ISSET(csock, &wr), FD_ISSET(csock, &rd), FD_ISSET(s_out, &wr), FD_ISSET(s_in, &rd)); \n\n\t\tif (nfd < 0) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: select error: %d\\n\", getpid(), nfd);\n\t\t\tperror(\"select\");\n\t\t\t/* connection finished */\n\t\t\tgoto done;\t\n\t\t}\n\n\t\tif (nfd == 0) {\n\t\t\tif (!closing && tv_cutover && ndata > 25000) {\n\t\t\t\tstatic int cn = 0;\n\t\t\t\t/* probably ok, early windows iconify */\n\t\t\t\tif (cn++ < 2) {\n\t\t\t\t\trfbLog(\"SSL: ssl_xfer[%d]: early time\"\n\t\t\t\t\t    \"out: %d\\n\", getpid(), ndata);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: connection timedout. %d  tv_use: %d\\n\",\n\t\t\t    getpid(), ndata, tv_use);\n\t\t\t/* connection finished */\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* used to see if SSL_pending() should be checked: */\n\t\tcheck_pending = 0;\n/* AUDIT */\n\n\t\tif (c_wr && FD_ISSET(csock, &wr)) {\n\n\t\t\t/* try to write some of our sbuf to C: */\n\t\t\tn = write(csock, sbuf, sptr); \n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* connection finished XXX double check */\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* shift over the data in sbuf by n */\n\t\t\t\tmemmove(sbuf, sbuf + n, sptr - n);\n\t\t\t\tif (sptr == ABSIZE) {\n\t\t\t\t\tcheck_pending = 1;\n\t\t\t\t}\n\t\t\t\tsptr -= n;\n\n\t\t\t\tif (! s_rd && sptr == 0) {\n\t\t\t\t\t/* finished sending last of sbuf */\n\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\tc_wr = 0;\n\t\t\t\t}\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_wr) {\n\t\t\tif ((cptr > 0 && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (SSL_want_read(ssl) && FD_ISSET(s_in, &rd))) {\n\n\t\t\t\t/* try to write some of our cbuf to S: */\n\n\t\t\t\tn = SSL_write(ssl, cbuf, cptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* shift over the data in cbuf by n */\n\t\t\t\t\tmemmove(cbuf, cbuf + n, cptr - n);\n\t\t\t\t\tcptr -= n;\n\n\t\t\t\t\tif (! c_rd && cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* finished sending last cbuf */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0 && errno != EINTR) {\n\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t/* proceed */\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S finished */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c_rd && FD_ISSET(csock, &rd)) {\n\n\n\t\t\t/* try to read some data from C into our cbuf */\n\n\t\t\tn = read(csock, cbuf + cptr, ABSIZE - cptr);\n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* C is EOF */\n\t\t\t\tc_rd = 0;\n\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* good */\n\n\t\t\t\tcptr += n;\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_rd) {\n\t\t\tif ((sptr < ABSIZE && FD_ISSET(s_in, &rd)) ||\n\t\t\t    (SSL_want_write(ssl) && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (check_pending && SSL_pending(ssl))) {\n\n\t\t\t\t/* try to read some data from S into our sbuf */\n\n\t\t\t\tn = SSL_read(ssl, sbuf + sptr, ABSIZE - sptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* good */\n\n\t\t\t\t\tsptr += n;\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0) {\n\t\t\t\t\t\tif(errno != EINTR) {\n\t\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* proceed */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* S finished */\n\t\t\t\t\t\ts_rd = 0;\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S is EOF */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (sptr == 0 && c_wr) {\n\t\t\t\t\t\t/* and no more in sbuf to send */\n\t\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\t\tc_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdone:\n\trfbLog(\"SSL: ssl_xfer[%d]: closing sockets %d, %d, %d\\n\",\n\t\t\t    getpid(), csock, s_in, s_out);\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n\treturn;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSL_ERROR_NONE 0",
            "#define ABSIZE 16384"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSL_ERROR_NONE 0\n#define ABSIZE 16384\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\n\nstatic void ssl_xfer(int csock, int s_in, int s_out, int is_https) {\n\tint dbxfer = 0, db = 0, check_pending, fdmax, nfd, n, i, err;\n\tchar cbuf[ABSIZE], sbuf[ABSIZE];\n\tint  cptr, sptr, c_rd, c_wr, s_rd, s_wr;\n\tfd_set rd, wr;\n\tstruct timeval tv;\n\tint ssock, cnt = 0, ndata = 0;\n\n\t/*\n\t * we want to switch to a longer timeout for long term VNC\n\t * connections (in case the network is not working for periods of\n\t * time), but we also want the timeout shorter at the beginning\n\t * in case the client went away.\n\t */\n\tdouble start, now;\n\tint tv_https_early = 60;\n\tint tv_https_later = 20;\n\tint tv_vnc_early = 40;\n\tint tv_vnc_later = 43200;\t/* was 300, stunnel: 43200 */\n\tint tv_cutover = 70;\n\tint tv_closing = 60;\n\tint tv_use;\n\n\tif (dbxfer) {\n\t\traw_xfer(csock, s_in, s_out);\n\t\treturn;\n\t}\n\tif (enc_str != NULL) {\n\t\tif (!strcmp(enc_str, \"none\")) {\n\t\t\tusleep(250*1000);\n\t\t\trfbLog(\"doing '-enc none' raw transfer (no encryption)\\n\"); \n\t\t\traw_xfer(csock, s_in, s_out);\n\t\t} else {\n\t\t\tsymmetric_encryption_xfer(csock, s_in, s_out);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\n\tif (db) fprintf(stderr, \"ssl_xfer begin\\n\");\n\n\tstart = dnow();\n\tif (is_https) {\n\t\ttv_use = tv_https_early;\n\t} else {\n\t\ttv_use = tv_vnc_early;\n\t}\n\t\n\n\t/*\n\t * csock: clear text socket with libvncserver.    \"C\"\n\t * ssock: ssl data socket with remote vnc viewer. \"S\"\n\t *\n\t * to cover inetd mode, we have s_in and s_out, but in non-inetd\n\t * mode they both ssock.\n\t *\n\t * cbuf[] is data from csock that we have read but not passed on to ssl \n\t * sbuf[] is data from ssl that we have read but not passed on to csock \n\t */\n\tfor (i=0; i<ABSIZE; i++) {\n\t\tcbuf[i] = '\\0';\n\t\tsbuf[i] = '\\0';\n\t}\n\t\t\n\tif (s_out > s_in) {\n\t\tssock = s_out;\n\t} else {\n\t\tssock = s_in;\n\t}\n\n\tif (csock > ssock) {\n\t\tfdmax = csock; \n\t} else {\n\t\tfdmax = ssock; \n\t}\n\n\tc_rd = 1;\t/* clear text (libvncserver) socket open for reading */\n\tc_wr = 1;\t/* clear text (libvncserver) socket open for writing */\n\ts_rd = 1;\t/* ssl data (remote client)  socket open for reading */\n\ts_wr = 1;\t/* ssl data (remote client)  socket open for writing */\n\n\tcptr = 0;\t/* offsets into ABSIZE buffers */\n\tsptr = 0;\n\n\tif (vencrypt_selected > 0 || anontls_selected > 0) {\n\t\tchar tmp[16];\n\t\t/* read and discard the extra RFB version */\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tread(csock, tmp, 12);\n\t\tif (0) fprintf(stderr, \"extra: %s\\n\", tmp);\n\t}\n\n\twhile (1) {\n\t\tint c_to_s, s_to_c, closing;\n\n\t\tif ( s_wr && (c_rd || cptr > 0) ) {\n\t\t\t/* \n\t\t\t * S is writable and \n\t\t\t * C is readable or some cbuf data remaining\n\t\t\t */\n\t\t\tc_to_s = 1;\n\t\t} else {\n\t\t\tc_to_s = 0;\n\t\t}\n\n\t\tif ( c_wr && (s_rd || sptr > 0) ) {\n\t\t\t/* \n\t\t\t * C is writable and \n\t\t\t * S is readable or some sbuf data remaining\n\t\t\t */\n\t\t\ts_to_c = 1;\n\t\t} else {\n\t\t\ts_to_c = 0;\n\t\t}\n\n\t\tif (! c_to_s && ! s_to_c) {\n\t\t\t/*\n\t\t\t * nothing can be sent either direction.\n\t\t\t * break out of the loop to finish all work.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\n\t\t/* set up the fd sets for the two sockets for read & write: */\n\n\t\tFD_ZERO(&rd);\n\n\t\tif (c_rd && cptr < ABSIZE) {\n\t\t\t/* we could read more from C since cbuf is not full */\n\t\t\tFD_SET(csock, &rd);\n\t\t}\n\t\tif (s_rd) {\n\t\t\t/*\n\t\t\t * we could read more from S since sbuf not full,\n\t\t\t * OR ssl is waiting for more BIO to be able to\n\t\t\t * read and we have some C data still buffered.\n\t\t\t */\n\t\t\tif (sptr < ABSIZE || (cptr > 0 && SSL_want_read(ssl))) {\n\t\t\t\tFD_SET(s_in, &rd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFD_ZERO(&wr);\n\n\t\tif (c_wr && sptr > 0) {\n\t\t\t/* we could write more to C since sbuf is not empty */\n\t\t\tFD_SET(csock, &wr);\n\t\t}\n\t\tif (s_wr) {\n\t\t\t/*\n\t\t\t * we could write more to S since cbuf not empty,\n\t\t\t * OR ssl is waiting for more BIO to be able\n\t\t\t * write and we haven't filled up sbuf yet.\n\t\t\t */\n\t\t\tif (cptr > 0 || (sptr < ABSIZE && SSL_want_write(ssl))) {\n\t\t\t\tFD_SET(s_out, &wr);\n\t\t\t}\n\t\t}\n\n\t\tnow = dnow();\n\t\tif (tv_cutover && now > start + tv_cutover) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: tv_cutover: %d\\n\", getpid(),\n\t\t\t    tv_cutover);\n\t\t\ttv_cutover = 0;\n\t\t\tif (is_https) {\n\t\t\t\ttv_use = tv_https_later;\n\t\t\t} else {\n\t\t\t\ttv_use = tv_vnc_later;\n\t\t\t}\n\t\t\t/* try to clean out some zombies if we can. */\n\t\t\tssl_helper_pid(0, -2);\n\t\t}\n\t\tif (ssl_timeout_secs > 0) {\n\t\t\ttv_use = ssl_timeout_secs;\n\t\t}\n\n\t\tif ( (s_rd && c_rd) || cptr || sptr) {\n\t\t\tclosing = 0;\n\t\t} else {\n\t\t\tclosing = 1;\n\t\t\ttv_use = tv_closing;\n\t\t}\n\n\t\ttv.tv_sec  = tv_use;\n\t\ttv.tv_usec = 0;\n\n\t\t/*  do the select, repeat if interrupted */\n\t\tdo {\n\t\t\tif (ssl_timeout_secs == 0) {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, NULL);\n\t\t\t} else {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, &tv);\n\t\t\t}\n\t\t} while (nfd < 0 && errno == EINTR);\n\n\t\tif (db > 1) fprintf(stderr, \"nfd: %d\\n\", nfd);\n\nif (0) fprintf(stderr, \"nfd[%d]: %d  w/r csock: %d %d s_in: %d %d\\n\", getpid(), nfd, FD_ISSET(csock, &wr), FD_ISSET(csock, &rd), FD_ISSET(s_out, &wr), FD_ISSET(s_in, &rd)); \n\n\t\tif (nfd < 0) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: select error: %d\\n\", getpid(), nfd);\n\t\t\tperror(\"select\");\n\t\t\t/* connection finished */\n\t\t\tgoto done;\t\n\t\t}\n\n\t\tif (nfd == 0) {\n\t\t\tif (!closing && tv_cutover && ndata > 25000) {\n\t\t\t\tstatic int cn = 0;\n\t\t\t\t/* probably ok, early windows iconify */\n\t\t\t\tif (cn++ < 2) {\n\t\t\t\t\trfbLog(\"SSL: ssl_xfer[%d]: early time\"\n\t\t\t\t\t    \"out: %d\\n\", getpid(), ndata);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: connection timedout. %d  tv_use: %d\\n\",\n\t\t\t    getpid(), ndata, tv_use);\n\t\t\t/* connection finished */\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* used to see if SSL_pending() should be checked: */\n\t\tcheck_pending = 0;\n/* AUDIT */\n\n\t\tif (c_wr && FD_ISSET(csock, &wr)) {\n\n\t\t\t/* try to write some of our sbuf to C: */\n\t\t\tn = write(csock, sbuf, sptr); \n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* connection finished XXX double check */\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* shift over the data in sbuf by n */\n\t\t\t\tmemmove(sbuf, sbuf + n, sptr - n);\n\t\t\t\tif (sptr == ABSIZE) {\n\t\t\t\t\tcheck_pending = 1;\n\t\t\t\t}\n\t\t\t\tsptr -= n;\n\n\t\t\t\tif (! s_rd && sptr == 0) {\n\t\t\t\t\t/* finished sending last of sbuf */\n\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\tc_wr = 0;\n\t\t\t\t}\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_wr) {\n\t\t\tif ((cptr > 0 && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (SSL_want_read(ssl) && FD_ISSET(s_in, &rd))) {\n\n\t\t\t\t/* try to write some of our cbuf to S: */\n\n\t\t\t\tn = SSL_write(ssl, cbuf, cptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* shift over the data in cbuf by n */\n\t\t\t\t\tmemmove(cbuf, cbuf + n, cptr - n);\n\t\t\t\t\tcptr -= n;\n\n\t\t\t\t\tif (! c_rd && cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* finished sending last cbuf */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0 && errno != EINTR) {\n\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t/* proceed */\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S finished */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c_rd && FD_ISSET(csock, &rd)) {\n\n\n\t\t\t/* try to read some data from C into our cbuf */\n\n\t\t\tn = read(csock, cbuf + cptr, ABSIZE - cptr);\n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* C is EOF */\n\t\t\t\tc_rd = 0;\n\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* good */\n\n\t\t\t\tcptr += n;\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_rd) {\n\t\t\tif ((sptr < ABSIZE && FD_ISSET(s_in, &rd)) ||\n\t\t\t    (SSL_want_write(ssl) && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (check_pending && SSL_pending(ssl))) {\n\n\t\t\t\t/* try to read some data from S into our sbuf */\n\n\t\t\t\tn = SSL_read(ssl, sbuf + sptr, ABSIZE - sptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* good */\n\n\t\t\t\t\tsptr += n;\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0) {\n\t\t\t\t\t\tif(errno != EINTR) {\n\t\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* proceed */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* S finished */\n\t\t\t\t\t\ts_rd = 0;\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S is EOF */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (sptr == 0 && c_wr) {\n\t\t\t\t\t\t/* and no more in sbuf to send */\n\t\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\t\tc_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdone:\n\trfbLog(\"SSL: ssl_xfer[%d]: closing sockets %d, %d, %d\\n\",\n\t\t\t    getpid(), csock, s_in, s_out);\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "vncsock",
            "cookie",
            "strlen(cookie)"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\"",
            "getpid()"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 3904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\" HTTP/\""
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sending http buffer httpsock: %d n=%d\\n'%s'\\n\"",
            "httpsock",
            "n",
            "buf"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_EXTRA_HTTPS_PARAMS\""
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl_helper[%d]: httpsock: %d %d\\n\"",
            "getpid()",
            "httpsock",
            "n"
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: exit case 5.\\n\"",
            "getpid()"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Could not connect to httpd socket!\\n\""
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect_tcp",
          "args": [
            "iface",
            "hport"
          ],
          "line": 3877
        },
        "resolved": true,
        "details": {
          "function_name": "connect_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "716-893",
          "snippet": "int connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *host2ip(char *host);",
            "int ipv6_ip(char *host);",
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *host2ip(char *host);\nint ipv6_ip(char *host);\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint connect_tcp(char *host, int port) {\n\tdouble t0 = dnow();\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\trfbLog(\"connect_tcp: trying:   %s %d\\n\", host, port);\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for connect_tcp.\\n\");\n\t\t}\n\t} else {\n\t\tfd = rfbConnectToTcpAddr(host, port);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\trfbLogPerror(\"connect_tcp: connection failed\");\n\n\tif (dnow() - t0 < 4.0) {\n\t\trfbLog(\"connect_tcp: re-trying %s %d\\n\", host, port);\n\t\tusleep (100 * 1000);\n\t\tif (!fail4) {\n\t\t\tfd = rfbConnectToTcpAddr(host, port);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\trfbLogPerror(\"connect_tcp: connection failed\");\n\t\t}\n\t}\n\n\tif (fd < 0 && !noipv6) {\n#if X11VNC_IPV6\n\t\tint err;\n\t\tstruct addrinfo *ai;\n\t\tstruct addrinfo hints;\n\t\tchar service[32], *host2, *q;\n\n\t\trfbLog(\"connect_tcp: trying IPv6 %s %d\\n\", host, port);\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\tsprintf(service, \"%d\", port);\n\n\t\thints.ai_family = AF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t\tif(ipv6_ip(host)) {\n#ifdef AI_NUMERICHOST\n\t\t\trfbLog(\"connect_tcp[ipv6]: setting AI_NUMERICHOST for %s\\n\", host);\n\t\t\thints.ai_flags |= AI_NUMERICHOST;\n#endif\n\t\t}\n#ifdef AI_NUMERICSERV\n\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\n\t\tif (!strcmp(host, \"127.0.0.1\")) {\n\t\t\thost2 = strdup(\"::1\");\n\t\t} else if (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\n\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t\tusleep(100 * 1000);\n\t\t\terr = getaddrinfo(host2, service, &hints, &ai);\n\t\t}\n\t\tfree(host2);\n\n\t\tif (err != 0) {\n\t\t\trfbLog(\"connect_tcp[ipv6]: getaddrinfo[%d]: %s\\n\", err, gai_strerror(err));\n\t\t} else {\n\t\t\tstruct addrinfo *ap = ai;\n\t\t\twhile (ap != NULL) {\n\t\t\t\tint sock;\n\n\t\t\t\tif (fail4) {\n\t\t\t\t\tstruct sockaddr_in6 *s6ptr;\n\t\t\t\t\tif (ap->ai_family != AF_INET6) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping AF_INET address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#ifdef IN6_IS_ADDR_V4MAPPED\n\t\t\t\t\ts6ptr = (struct sockaddr_in6 *) ap->ai_addr;\n\t\t\t\t\tif (IN6_IS_ADDR_V4MAPPED(&(s6ptr->sin6_addr))) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: skipping V4MAPPED address under -noipv4\\n\");\n\t\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\tsock = socket(ap->ai_family, ap->ai_socktype, ap->ai_protocol);\n\n\t\t\t\tif (sock == -1) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: socket\");\n\t\t\t\t\tif (0) rfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tint res = -1, dmsg = 0;\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying sock=%d fam=%d proto=%d using %s\\n\",\n\t\t\t\t\t    sock, ap->ai_family, ap->ai_protocol, s);\n\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\t\t\t\t\tif (res != 0) {\n\t\t\t\t\t\tint zero = 0;\n\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tdmsg = 1;\n\t\t\t\t\t\tif (setsockopt(sock, SOL_IPV6, IPV6_V6ONLY, (char *)&zero, sizeof(zero)) == 0) {\n\t\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: trying again with IPV6_V6ONLY=0\\n\");\n\t\t\t\t\t\t\tres = connect(sock, ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\t\t\tdmsg = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv6]: setsockopt IPV6_V6ONLY\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\trfbLog(\"connect_tcp[ipv6]: connect OK\\n\");\n\t\t\t\t\t\tfd = sock;\n\t\t\t\t\t\tif (!ipv6_client_ip_str) {\n\t\t\t\t\t\t\tipv6_client_ip_str = strdup(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dmsg) rfbLogPerror(\"connect_tcp[ipv6]: connect\");\n\t\t\t\t\t\tclose(sock);\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t}\n\t\t\t\tap = ap->ai_next;\n\t\t\t}\n\t\t\tfreeaddrinfo(ai);\n\t\t}\n#endif\n\t}\n\tif (fd < 0 && !fail4) {\n\t\t/* this is a kludge for IPv4-only machines getting v4mapped string. */\n\t\tchar *q, *host2;\n\t\tif (host[0] == '[') {\n\t\t\thost2 = strdup(host+1);\n\t\t} else {\n\t\t\thost2 = strdup(host);\n\t\t}\n\t\tq = strrchr(host2, ']');\n\t\tif (q) {\n\t\t\t*q = '\\0';\n\t\t}\n\t\tif (strstr(host2, \"::ffff:\") == host2 || strstr(host2, \"::FFFF:\") == host2) {\n\t\t\tchar *host3 = host2 + strlen(\"::ffff:\");\n\t\t\tif (dotted_ip(host3, 0)) {\n\t\t\t\trfbLog(\"connect_tcp[ipv4]: trying fallback to IPv4 for %s\\n\", host2);\n\t\t\t\tfd = rfbConnectToTcpAddr(host3, port);\n\t\t\t\tif (fd < 0) {\n\t\t\t\t\trfbLogPerror(\"connect_tcp[ipv4]: connection failed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(host2);\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "150*1000"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"iface: %s:%d\\n\"",
            "iface",
            "hport"
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "iface",
            "\"\""
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "in"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_NONE"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"close vncsock: %d\\n\"",
            "vncsock"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "150*1000"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tbuf"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tbuf",
            "cookie"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tbuf",
            "str"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "str",
            "\"HTTP/\""
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 3840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"HTTP/\""
          ],
          "line": 3834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tbuf",
            "num"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "num",
            "\"HP=%d,\"",
            "fport"
          ],
          "line": 3830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"port=%d,\"",
            "&p"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"PORT=%d,\"",
            "&p"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "q",
            "\":%d\"",
            "&p"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"Host:\""
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\"\\n\""
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"Host:\""
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"port=\""
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"PORT=\""
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tbuf",
            "uniq"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\"",
            "getpid()"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tbuf"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "tbuf",
            "cookie"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tbuf",
            "uniq"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_shutdown",
          "args": [
            "ssl"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_write",
          "args": [
            "ssl",
            "reply",
            "strlen(reply)"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reply"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reply"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-- %s\\n\"",
            "buf"
          ],
          "line": 3771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Handling Check HTTPS request via https GET. [%d]\\n\"",
            "getpid()"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"/check.https.proxy.connection\""
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf2",
            "\"\\r\\n\\r\\n\""
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"buf2: '%s'\\n\"",
            "buf2"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_read",
          "args": [
            "ssl",
            "buf2 + ptr",
            "1"
          ],
          "line": 3748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(8192+1)",
            "1"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_write",
          "args": [
            "ssl",
            "reply",
            "strlen(reply)"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reply"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reply"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"/reverse.proxy\""
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"-- %s\\n\"",
            "buf"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Handling VNC request via https GET. [%d]\\n\"",
            "getpid()"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buf",
            "\"/request.https.vnc.connection\""
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"buf: '%s'\\n\"",
            "buf"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"is_http: %d n: %d\\n\"",
            "is_http",
            "n"
          ],
          "line": 3715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"is_http err: %d n: %d\\n\"",
            "is_http",
            "n"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watch_for_http_traffic",
          "args": [
            "buf",
            "&n",
            "s_in"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "watch_for_http_traffic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3177-3266",
          "snippet": "static int watch_for_http_traffic(char *buf_a, int *n_a, int raw_sock) {\n\tint is_http, err, n, n2;\n\tchar *buf;\n\tint db = 0;\n\t/*\n\t * sniff the first couple bytes of the stream and try to see\n\t * if it is http or not.  if we read them OK, we must read the\n\t * rest of the available data otherwise we may deadlock.\n\t * what has been read is returned in buf_a and n_a.\n\t * *buf_a is ABSIZE+1 long and zeroed.\n\t */\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\tif (! buf_a || ! n_a) {\n\t\treturn 0;\n\t}\n\n\tbuf = (char *) calloc((ABSIZE+1), 1);\n\t*n_a = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn = read(raw_sock, buf, 2);\n\t\terr = SSL_ERROR_NONE;\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn = SSL_read(ssl, buf, 2);\n\t\terr = SSL_get_error(ssl, n);\n#else\n\t\terr = n = 0;\n\t\tbadnews(\"1 in watch_for_http_traffic\");\n#endif\n\t}\n\n\tif (err != SSL_ERROR_NONE || n < 2) {\n\t\tif (n > 0) {\n\t\t\tstrncpy(buf_a, buf, n);\n\t\t\t*n_a = n;\n\t\t}\n\t\tif (db) fprintf(stderr, \"watch_for_http_traffic ssl err: %d/%d\\n\", err, n);\n\t\treturn -1;\n\t}\n\n\t/* look for GET, HEAD, POST, CONNECT */\n\tis_http = 0;\n\tif (!strncmp(\"GE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"HE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"PO\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"CO\", buf, 2)) {\n\t\tis_http = 1;\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic read: '%s' %d\\n\", buf, n);\n\n\t/*\n\t * better read all we can and fwd it along to avoid blocking\n\t * in ssl_xfer().\n\t */\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn2 = read(raw_sock, buf + n, ABSIZE - n);\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn2 = SSL_read(ssl, buf + n, ABSIZE - n);\n#else\n\t\tn2 = 0;\n\t\tbadnews(\"2 in watch_for_http_traffic\");\n#endif\n\t}\n\tif (n2 >= 0) {\n\t\tn += n2;\n\t}\n\n\t*n_a = n;\n\n\tif (db) fprintf(stderr, \"watch_for_http_traffic readmore: %d\\n\", n2);\n\n\tif (n > 0) {\n\t\tmemcpy(buf_a, buf, n);\n\t}\n\tif (db > 1) {\n\t\tfprintf(stderr, \"watch_for_http_traffic readmore: \");\n\t\twrite(2, buf_a, *n_a);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic return: %d\\n\", is_http);\n\treturn is_http;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSL_ERROR_NONE 0",
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384"
          ],
          "globals_used": [
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSL_ERROR_NONE 0\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n\nstatic char *get_input(char *tag, char **in);\n\nstatic int watch_for_http_traffic(char *buf_a, int *n_a, int raw_sock) {\n\tint is_http, err, n, n2;\n\tchar *buf;\n\tint db = 0;\n\t/*\n\t * sniff the first couple bytes of the stream and try to see\n\t * if it is http or not.  if we read them OK, we must read the\n\t * rest of the available data otherwise we may deadlock.\n\t * what has been read is returned in buf_a and n_a.\n\t * *buf_a is ABSIZE+1 long and zeroed.\n\t */\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\tif (! buf_a || ! n_a) {\n\t\treturn 0;\n\t}\n\n\tbuf = (char *) calloc((ABSIZE+1), 1);\n\t*n_a = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn = read(raw_sock, buf, 2);\n\t\terr = SSL_ERROR_NONE;\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn = SSL_read(ssl, buf, 2);\n\t\terr = SSL_get_error(ssl, n);\n#else\n\t\terr = n = 0;\n\t\tbadnews(\"1 in watch_for_http_traffic\");\n#endif\n\t}\n\n\tif (err != SSL_ERROR_NONE || n < 2) {\n\t\tif (n > 0) {\n\t\t\tstrncpy(buf_a, buf, n);\n\t\t\t*n_a = n;\n\t\t}\n\t\tif (db) fprintf(stderr, \"watch_for_http_traffic ssl err: %d/%d\\n\", err, n);\n\t\treturn -1;\n\t}\n\n\t/* look for GET, HEAD, POST, CONNECT */\n\tis_http = 0;\n\tif (!strncmp(\"GE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"HE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"PO\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"CO\", buf, 2)) {\n\t\tis_http = 1;\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic read: '%s' %d\\n\", buf, n);\n\n\t/*\n\t * better read all we can and fwd it along to avoid blocking\n\t * in ssl_xfer().\n\t */\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn2 = read(raw_sock, buf + n, ABSIZE - n);\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn2 = SSL_read(ssl, buf + n, ABSIZE - n);\n#else\n\t\tn2 = 0;\n\t\tbadnews(\"2 in watch_for_http_traffic\");\n#endif\n\t}\n\tif (n2 >= 0) {\n\t\tn += n2;\n\t}\n\n\t*n_a = n;\n\n\tif (db) fprintf(stderr, \"watch_for_http_traffic readmore: %d\\n\", n2);\n\n\tif (n > 0) {\n\t\tmemcpy(buf_a, buf, n);\n\t}\n\tif (db > 1) {\n\t\tfprintf(stderr, \"watch_for_http_traffic readmore: \");\n\t\twrite(2, buf_a, *n_a);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic return: %d\\n\", is_http);\n\treturn is_http;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watch_for_http_traffic\\n\""
          ],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ssl_readable",
          "args": [
            "s_in",
            "last_https",
            "last_get",
            "mode"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "is_ssl_readable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3119-3175",
          "snippet": "static int is_ssl_readable(int s_in, double last_https, char *last_get,\n    int mode) {\n\tint nfd, db = 0;\n\tstruct timeval tv;\n\tfd_set rd;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/*\n\t * we'll do a select() on s_in for reading.  this is not an\n\t * absolute proof that SSL_read is ready (XXX use SSL utility).\n\t */\n\ttv.tv_sec  = 2;\n\ttv.tv_usec = 0;\n\n\tif (mode == OPENSSL_INETD) {\n\t\t/*\n\t\t * https via inetd is icky because x11vnc is restarted\n\t\t * for each socket (and some clients send requests\n\t\t * rapid fire).\n\t\t */\n\t\ttv.tv_sec = 4;\n\t}\n\n\t/*\n\t * increase the timeout if we know HTTP traffic has occurred\n\t * recently:\n\t */\n\tif (dnow() < last_https + 30.0) {\n\t\ttv.tv_sec = 10;\n\t\tif (last_get && strstr(last_get, \"VncViewer\")) {\n\t\t\ttv.tv_sec = 5;\n\t\t}\n\t}\n\tif (getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\")) {\n\t\ttv.tv_sec  = atoi(getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\"));\n\t}\nif (db) fprintf(stderr, \"tv_sec: %d - '%s'\\n\", (int) tv.tv_sec, last_get);\n\n\tFD_ZERO(&rd);\n\tFD_SET(s_in, &rd);\n\n\tif (db) fprintf(stderr, \"is_ssl_readable: begin  select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\tdo {\n\t\tnfd = select(s_in+1, &rd, NULL, NULL, &tv);\n\t} while (nfd < 0 && errno == EINTR);\n\tif (db) fprintf(stderr, \"is_ssl_readable: finish select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\n\tif (db) fprintf(stderr, \"https nfd: %d\\n\", nfd);\n\n\tif (nfd <= 0 || ! FD_ISSET(s_in, &rd)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_INETD   1\n\nstatic int is_ssl_readable(int s_in, double last_https, char *last_get,\n    int mode) {\n\tint nfd, db = 0;\n\tstruct timeval tv;\n\tfd_set rd;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/*\n\t * we'll do a select() on s_in for reading.  this is not an\n\t * absolute proof that SSL_read is ready (XXX use SSL utility).\n\t */\n\ttv.tv_sec  = 2;\n\ttv.tv_usec = 0;\n\n\tif (mode == OPENSSL_INETD) {\n\t\t/*\n\t\t * https via inetd is icky because x11vnc is restarted\n\t\t * for each socket (and some clients send requests\n\t\t * rapid fire).\n\t\t */\n\t\ttv.tv_sec = 4;\n\t}\n\n\t/*\n\t * increase the timeout if we know HTTP traffic has occurred\n\t * recently:\n\t */\n\tif (dnow() < last_https + 30.0) {\n\t\ttv.tv_sec = 10;\n\t\tif (last_get && strstr(last_get, \"VncViewer\")) {\n\t\t\ttv.tv_sec = 5;\n\t\t}\n\t}\n\tif (getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\")) {\n\t\ttv.tv_sec  = atoi(getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\"));\n\t}\nif (db) fprintf(stderr, \"tv_sec: %d - '%s'\\n\", (int) tv.tv_sec, last_get);\n\n\tFD_ZERO(&rd);\n\tFD_SET(s_in, &rd);\n\n\tif (db) fprintf(stderr, \"is_ssl_readable: begin  select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\tdo {\n\t\tnfd = select(s_in+1, &rd, NULL, NULL, &tv);\n\t} while (nfd < 0 && errno == EINTR);\n\tif (db) fprintf(stderr, \"is_ssl_readable: finish select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\n\tif (db) fprintf(stderr, \"https nfd: %d\\n\", nfd);\n\n\tif (nfd <= 0 || ! FD_ISSET(s_in, &rd)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(2*ABSIZE+1)",
            "1"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(ABSIZE+1)",
            "1"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\"",
            "getpid()"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\"",
            "getpid()"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tbuf",
            "\"%s,ANONTLS=%d,%s\"",
            "uniq",
            "anontls_selected",
            "cookie"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(cookie) + 100"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tbuf",
            "\"%s,VENCRYPT=%d,%s\"",
            "uniq",
            "vencrypt_selected",
            "cookie"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(cookie) + 100"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cookie"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\"",
            "getpid()"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssl_init",
          "args": [
            "s_in",
            "s_out",
            "skip_vnc_tls",
            "last_https"
          ],
          "line": 3618
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2010-2228",
          "snippet": "static int ssl_init(int s_in, int s_out, int skip_vnc_tls, double last_https) {\n\tunsigned char *sid = (unsigned char *) \"x11vnc SID\";\n\tchar *name = NULL;\n\tint peerport = 0;\n\tint db = 0, rc, err;\n\tint ssock = s_in;\n\tdouble start = dnow();\n\tint timeout = 20;\n\n\tif (enc_str != NULL) {\n\t\treturn 1;\n\t}\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\tusleep(100 * 1000);\n\tif (getenv(\"SSL_INIT_TIMEOUT\")) {\n\t\ttimeout = atoi(getenv(\"SSL_INIT_TIMEOUT\"));\n\t} else if (client_connect != NULL && strstr(client_connect, \"repeater\")) {\n\t\trfbLog(\"SSL: ssl_init[%d]: detected 'repeater' in connect string.\\n\", getpid());\n\t\trfbLog(\"SSL: setting timeout to 1 hour: -env SSL_INIT_TIMEOUT=3600\\n\");\n\t\trfbLog(\"SSL: use that option to set a different timeout value,\\n\");\n\t\trfbLog(\"SSL: however note that with Windows UltraVNC repeater it\\n\");\n\t\trfbLog(\"SSL: may timeout before your setting due to other reasons.\\n\");\n\t\ttimeout = 3600;\n\t}\n\n\tif (skip_vnc_tls) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: HTTPS mode, skipping check_vnc_tls_mode()\\n\",\n\t\t    getpid());\n\t} else if (!check_vnc_tls_mode(s_in, s_out, last_https)) {\n\t\treturn 0;\n\t}\n\trfbLog(\"SSL: ssl_init[%d]: %d/%d initialization timeout: %d secs.\\n\",\n\t    getpid(), s_in, s_out, timeout);\n\n\tssl = SSL_new(ctx);\n\tif (ssl == NULL) {\n\t\tfprintf(stderr, \"SSL_new failed\\n\");\n\t\treturn 0;\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 1\\n\");\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (s_in == s_out) {\n\t\tif (! SSL_set_fd(ssl, ssock)) {\n\t\t\tfprintf(stderr, \"SSL_set_fd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (! SSL_set_rfd(ssl, s_in)) {\n\t\t\tfprintf(stderr, \"SSL_set_rfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (! SSL_set_wfd(ssl, s_out)) {\n\t\t\tfprintf(stderr, \"SSL_set_wfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 2\\n\");\n\n\tif (ssl_client_mode) {\n\t\tSSL_set_connect_state(ssl);\n\t} else {\n\t\tSSL_set_accept_state(ssl);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 3\\n\");\n\n\tname = get_remote_host(ssock);\n\tpeerport = get_remote_port(ssock);\n\n\tif (!strcmp(name, \"0.0.0.0\") && openssl_last_ip != NULL) {\n\t\tname = strdup(openssl_last_ip);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 4\\n\");\n\n\twhile (1) {\n\n\t\tsignal(SIGALRM, ssl_timeout);\n\t\talarm(timeout);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_connect...\\n\");\n\t\t\trc = SSL_connect(ssl);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_accept...\\n\");\n\t\t\trc = SSL_accept(ssl);\n\t\t}\n\t\terr = SSL_get_error(ssl, rc);\n\n\t\talarm(0);\n\t\tsignal(SIGALRM, SIG_DFL);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"SSL_connect %d/%d\\n\", rc, err);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"SSL_accept %d/%d\\n\", rc, err);\n\t\t}\n\t\tif (err == SSL_ERROR_NONE) {\n\t\t\tbreak;\n\t\t} else if (err == SSL_ERROR_WANT_READ) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_READ\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 1\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\t\t\t\n\t\t} else if (err == SSL_ERROR_WANT_WRITE) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_WRITE\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 2\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_SYSCALL\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 3\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_ZERO_RETURN\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 4\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (rc < 0) {\n\t\t\tunsigned long err;\n\t\t\tint cnt = 0;\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() *FATAL: %d SSL FAILED\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", rc);\n\t\t\twhile ((err = ERR_get_error()) != 0) {\n\t\t\t\trfbLog(\"SSL: %s\\n\", ERR_error_string(err, NULL));\n\t\t\t\tif (cnt++ > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (dnow() > start + 3.0) {\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: timeout looping %s() \"\n\t\t\t    \"fatal.\\n\", getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\");\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else {\n\t\t\tBIO *bio = SSL_get_rbio(ssl);\n\t\t\tif (bio == NULL) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is null. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (BIO_eof(bio)) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is EOF. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\n\tif (ssl_client_mode) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_connect() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_accept() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t}\n\n\tpr_ssl_info(0);\n\n\tif (SSL_get_verify_result(ssl) == X509_V_OK) {\n\t\tX509 *x;\n\t\tFILE *cr = NULL;\n\t\tif (certret != NULL) {\n\t\t\tcr = fopen(certret, \"w\");\n\t\t}\n\t\t\n\t\tx = SSL_get_peer_certificate(ssl);\t\n\t\tif (x == NULL) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 peer cert is null\\n\", getpid(), name);\n\t\t\tif (cr != NULL) {\n\t\t\t\tfprintf(cr, \"NOCERT\\n\");\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 cert is:\\n\", getpid(), name);\n#if HAVE_X509_PRINT_EX_FP\n\t\t\tX509_print_ex_fp(stderr, x, 0, XN_FLAG_MULTILINE);\n#endif\n\t\t\tif (cr != NULL) {\n#if HAVE_X509_PRINT_EX_FP\n\t\t\t\tX509_print_ex_fp(cr, x, 0, XN_FLAG_MULTILINE);\n#else\n\t\t\t\trfbLog(\"** not compiled with libssl X509_print_ex_fp() function **\\n\");\n\t\t\t\tif (users_list && strstr(users_list, \"sslpeer=\")) {\n\t\t\t\t\trfbLog(\"** -users sslpeer= will not work! **\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t}\n\t}\n\tfree(name);\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define SSL_ERROR_NONE 0"
          ],
          "globals_used": [
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSL_ERROR_NONE 0\n\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\n\nstatic int ssl_init(int s_in, int s_out, int skip_vnc_tls, double last_https) {\n\tunsigned char *sid = (unsigned char *) \"x11vnc SID\";\n\tchar *name = NULL;\n\tint peerport = 0;\n\tint db = 0, rc, err;\n\tint ssock = s_in;\n\tdouble start = dnow();\n\tint timeout = 20;\n\n\tif (enc_str != NULL) {\n\t\treturn 1;\n\t}\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\tusleep(100 * 1000);\n\tif (getenv(\"SSL_INIT_TIMEOUT\")) {\n\t\ttimeout = atoi(getenv(\"SSL_INIT_TIMEOUT\"));\n\t} else if (client_connect != NULL && strstr(client_connect, \"repeater\")) {\n\t\trfbLog(\"SSL: ssl_init[%d]: detected 'repeater' in connect string.\\n\", getpid());\n\t\trfbLog(\"SSL: setting timeout to 1 hour: -env SSL_INIT_TIMEOUT=3600\\n\");\n\t\trfbLog(\"SSL: use that option to set a different timeout value,\\n\");\n\t\trfbLog(\"SSL: however note that with Windows UltraVNC repeater it\\n\");\n\t\trfbLog(\"SSL: may timeout before your setting due to other reasons.\\n\");\n\t\ttimeout = 3600;\n\t}\n\n\tif (skip_vnc_tls) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: HTTPS mode, skipping check_vnc_tls_mode()\\n\",\n\t\t    getpid());\n\t} else if (!check_vnc_tls_mode(s_in, s_out, last_https)) {\n\t\treturn 0;\n\t}\n\trfbLog(\"SSL: ssl_init[%d]: %d/%d initialization timeout: %d secs.\\n\",\n\t    getpid(), s_in, s_out, timeout);\n\n\tssl = SSL_new(ctx);\n\tif (ssl == NULL) {\n\t\tfprintf(stderr, \"SSL_new failed\\n\");\n\t\treturn 0;\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 1\\n\");\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (s_in == s_out) {\n\t\tif (! SSL_set_fd(ssl, ssock)) {\n\t\t\tfprintf(stderr, \"SSL_set_fd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (! SSL_set_rfd(ssl, s_in)) {\n\t\t\tfprintf(stderr, \"SSL_set_rfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (! SSL_set_wfd(ssl, s_out)) {\n\t\t\tfprintf(stderr, \"SSL_set_wfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 2\\n\");\n\n\tif (ssl_client_mode) {\n\t\tSSL_set_connect_state(ssl);\n\t} else {\n\t\tSSL_set_accept_state(ssl);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 3\\n\");\n\n\tname = get_remote_host(ssock);\n\tpeerport = get_remote_port(ssock);\n\n\tif (!strcmp(name, \"0.0.0.0\") && openssl_last_ip != NULL) {\n\t\tname = strdup(openssl_last_ip);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 4\\n\");\n\n\twhile (1) {\n\n\t\tsignal(SIGALRM, ssl_timeout);\n\t\talarm(timeout);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_connect...\\n\");\n\t\t\trc = SSL_connect(ssl);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_accept...\\n\");\n\t\t\trc = SSL_accept(ssl);\n\t\t}\n\t\terr = SSL_get_error(ssl, rc);\n\n\t\talarm(0);\n\t\tsignal(SIGALRM, SIG_DFL);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"SSL_connect %d/%d\\n\", rc, err);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"SSL_accept %d/%d\\n\", rc, err);\n\t\t}\n\t\tif (err == SSL_ERROR_NONE) {\n\t\t\tbreak;\n\t\t} else if (err == SSL_ERROR_WANT_READ) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_READ\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 1\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\t\t\t\n\t\t} else if (err == SSL_ERROR_WANT_WRITE) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_WRITE\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 2\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_SYSCALL\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 3\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_ZERO_RETURN\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 4\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (rc < 0) {\n\t\t\tunsigned long err;\n\t\t\tint cnt = 0;\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() *FATAL: %d SSL FAILED\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", rc);\n\t\t\twhile ((err = ERR_get_error()) != 0) {\n\t\t\t\trfbLog(\"SSL: %s\\n\", ERR_error_string(err, NULL));\n\t\t\t\tif (cnt++ > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (dnow() > start + 3.0) {\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: timeout looping %s() \"\n\t\t\t    \"fatal.\\n\", getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\");\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else {\n\t\t\tBIO *bio = SSL_get_rbio(ssl);\n\t\t\tif (bio == NULL) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is null. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (BIO_eof(bio)) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is EOF. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\n\tif (ssl_client_mode) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_connect() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_accept() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t}\n\n\tpr_ssl_info(0);\n\n\tif (SSL_get_verify_result(ssl) == X509_V_OK) {\n\t\tX509 *x;\n\t\tFILE *cr = NULL;\n\t\tif (certret != NULL) {\n\t\t\tcr = fopen(certret, \"w\");\n\t\t}\n\t\t\n\t\tx = SSL_get_peer_certificate(ssl);\t\n\t\tif (x == NULL) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 peer cert is null\\n\", getpid(), name);\n\t\t\tif (cr != NULL) {\n\t\t\t\tfprintf(cr, \"NOCERT\\n\");\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 cert is:\\n\", getpid(), name);\n#if HAVE_X509_PRINT_EX_FP\n\t\t\tX509_print_ex_fp(stderr, x, 0, XN_FLAG_MULTILINE);\n#endif\n\t\t\tif (cr != NULL) {\n#if HAVE_X509_PRINT_EX_FP\n\t\t\t\tX509_print_ex_fp(cr, x, 0, XN_FLAG_MULTILINE);\n#else\n\t\t\t\trfbLog(\"** not compiled with libssl X509_print_ex_fp() function **\\n\");\n\t\t\t\tif (users_list && strstr(users_list, \"sslpeer=\")) {\n\t\t\t\t\trfbLog(\"** -users sslpeer= will not work! **\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t}\n\t}\n\tfree(name);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdout"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"vncsock %d\\n\"",
            "vncsock"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\"",
            "getpid()"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\"",
            "getpid()",
            "cport"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 3603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lose_ram",
          "args": [],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "lose_ram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2986-2995",
          "snippet": "static void lose_ram(void) {\n\t/*\n\t * for a forked child that will be around for a long time\n\t * without doing exec().  we really should re-exec, but a pain\n\t * to redo all SSL ctx.\n\t */\n\tfree_old_fb();\n\n\tfree_tiles();\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void lose_ram(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void lose_ram(void);\n\nstatic void lose_ram(void) {\n\t/*\n\t * for a forked child that will be around for a long time\n\t * without doing exec().  we really should re-exec, but a pain\n\t * to redo all SSL ctx.\n\t */\n\tfree_old_fb();\n\n\tfree_tiles();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_signals",
          "args": [],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "unset_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "742-752",
          "snippet": "void unset_signals(void) {\n\tsignal(SIGHUP,  SIG_DFL);\n\tsignal(SIGINT,  SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGABRT, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGBUS,  SIG_DFL);\n\tsignal(SIGSEGV, SIG_DFL);\n\tsignal(SIGFPE,  SIG_DFL);\n\tsignal(SIGPIPE, SIG_DFL);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void unset_signals(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid unset_signals(void);\n\nvoid unset_signals(void) {\n\tsignal(SIGHUP,  SIG_DFL);\n\tsignal(SIGINT,  SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGABRT, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGBUS,  SIG_DFL);\n\tsignal(SIGSEGV, SIG_DFL);\n\tsignal(SIGFPE,  SIG_DFL);\n\tsignal(SIGPIPE, SIG_DFL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"helper pid in: %d %d %d %d\\n\"",
            "f_in",
            "f_out",
            "sock",
            "listen"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdout"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fork\""
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: could not fork.\\n\""
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: helper for peerport %d is pid %d: \\n\"",
            "peerport",
            "(int) pid"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "omode"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "dhret"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/tmp/x11vnc-dhret.XXXXXX\""
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "omode"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "certret"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/tmp/x11vnc-certret.XXXXXX\""
          ],
          "line": 3518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\"",
            "name",
            "peerport"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\"",
            "name",
            "peerport"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "openssl_last_ip"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_remote_port",
          "args": [
            "fileno(stdin)"
          ],
          "line": 3492
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "226-228",
          "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_remote_host",
          "args": [
            "fileno(stdin)"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "258-260",
          "snippet": "char *get_remote_host(int sock) {\n\treturn get_host(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nchar *get_remote_host(int sock) {\n\treturn get_host(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ipv6_name"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ipv6_name"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cookie",
            "\"RB=%d%d%d%d%d%d/%f%f/%p\"",
            "rb[0]",
            "rb[1]",
            "rb[2]",
            "rb[3]",
            "rb[4]",
            "rb[5]",
            "dnow() - x11vnc_start",
            "x11vnc_start",
            "(void *)rb"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "rb",
            "6"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "6",
            "1"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"accept_openssl: csock: %d\\n\"",
            "csock"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: could not listen on port %d.\\n\"",
            "cport"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen_tcp",
          "args": [
            "cport",
            "htonl(INADDR_LOOPBACK)",
            "1"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "listen_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "895-938",
          "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);",
            "int listen_tcp(int port, in_addr_t iface, int try6);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"accept_openssl: cport: %d\\n\"",
            "cport"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: could not find open port.\\n\""
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: IPv6 port: %d\\n\"",
            "cport"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_free_port6",
          "args": [
            "20000",
            "22000"
          ],
          "line": 3440
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_port6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "431-447",
          "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int find_free_port(int start, int end);",
            "int find_free_port6(int start, int end);",
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: seeking IPv6 port.\\n\""
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: does not match -allow or other reason.\\n\""
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: denying client %s\\n\"",
            "openssl_last_ip"
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ssl_access",
          "args": [
            "openssl_last_ip"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "check_ssl_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3278-3300",
          "snippet": "static int check_ssl_access(char *addr) {\n\tstatic char *save_allow_once = NULL;\n\tstatic time_t time_allow_once = 0;\n\n\t/* due to \"Fetch Cert\" activities for SSL really need to \"allow twice\" */\n\tif (allow_once != NULL) {\n\t\tsave_allow_once = strdup(allow_once);\n\t\ttime_allow_once = time(NULL);\n\t} else if (save_allow_once != NULL) {\n\t\tif (getenv(\"X11VNC_NO_SSL_ALLOW_TWICE\")) {\n\t\t\t;\n\t\t} else if (time(NULL) < time_allow_once + 30) {\n\t\t\t/* give them 30 secs to check and save the fetched cert. */\n\t\t\tallow_once = save_allow_once; \n\t\t\trfbLog(\"SSL: Permitting 30 sec grace period for allowonce.\\n\");\n\t\t\trfbLog(\"SSL: Set X11VNC_NO_SSL_ALLOW_TWICE=1 to disable.\\n\");\n\t\t}\n\t\tsave_allow_once = NULL;\n\t\ttime_allow_once = 0;\n\t}\n\n\treturn check_access(addr);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int check_ssl_access(char *addr) {\n\tstatic char *save_allow_once = NULL;\n\tstatic time_t time_allow_once = 0;\n\n\t/* due to \"Fetch Cert\" activities for SSL really need to \"allow twice\" */\n\tif (allow_once != NULL) {\n\t\tsave_allow_once = strdup(allow_once);\n\t\ttime_allow_once = time(NULL);\n\t} else if (save_allow_once != NULL) {\n\t\tif (getenv(\"X11VNC_NO_SSL_ALLOW_TWICE\")) {\n\t\t\t;\n\t\t} else if (time(NULL) < time_allow_once + 30) {\n\t\t\t/* give them 30 secs to check and save the fetched cert. */\n\t\t\tallow_once = save_allow_once; \n\t\t\trfbLog(\"SSL: Permitting 30 sec grace period for allowonce.\\n\");\n\t\t\trfbLog(\"SSL: Set X11VNC_NO_SSL_ALLOW_TWICE=1 to disable.\\n\");\n\t\t}\n\t\tsave_allow_once = NULL;\n\t\ttime_allow_once = 0;\n\t}\n\n\treturn check_access(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL: accept_openssl: sock: %d\\n\"",
            "sock"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"accept\""
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: accept connection failed\\n\""
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "https_sock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ipv6_client_ip_str"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\"",
            "ipv6_client_ip_str"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"OPENSSL_REVERSE_DEBUG\""
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: connection failed\\n\""
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"unknown\""
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipv6_getipaddr",
          "args": [
            "(struct sockaddr *)&a6",
            "a6len"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "ipv6_getipaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "525-536",
          "snippet": "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);",
            "char *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nchar *ipv6_getnameinfo(struct sockaddr *paddr, int addrlen);\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen);\n\nchar *ipv6_getipaddr(struct sockaddr *paddr, int addrlen) {\n#if X11VNC_IPV6 && defined(NI_NUMERICHOST)\n\tchar name[200];\n\tif (noipv6) {\n\t\treturn strdup(\"unknown\");\n\t}\n\tif (getnameinfo(paddr, addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST) == 0) {\n\t\treturn strdup(name);\n\t}\n#endif\n\treturn strdup(\"unknown\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"accept\""
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: accept connection failed\\n\""
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "fd",
            "(struct sockaddr *)&a6",
            "&a6len"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"accept\""
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl: accept connection failed\\n\""
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "openssl_sock",
            "(struct sockaddr *)&addr",
            "&addrlen"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"ACCEPT_OPENSSL_DEBUG\")"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ACCEPT_OPENSSL_DEBUG\""
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ACCEPT_OPENSSL_DEBUG\""
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "check_ssl_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "3278-3300",
    "snippet": "static int check_ssl_access(char *addr) {\n\tstatic char *save_allow_once = NULL;\n\tstatic time_t time_allow_once = 0;\n\n\t/* due to \"Fetch Cert\" activities for SSL really need to \"allow twice\" */\n\tif (allow_once != NULL) {\n\t\tsave_allow_once = strdup(allow_once);\n\t\ttime_allow_once = time(NULL);\n\t} else if (save_allow_once != NULL) {\n\t\tif (getenv(\"X11VNC_NO_SSL_ALLOW_TWICE\")) {\n\t\t\t;\n\t\t} else if (time(NULL) < time_allow_once + 30) {\n\t\t\t/* give them 30 secs to check and save the fetched cert. */\n\t\t\tallow_once = save_allow_once; \n\t\t\trfbLog(\"SSL: Permitting 30 sec grace period for allowonce.\\n\");\n\t\t\trfbLog(\"SSL: Set X11VNC_NO_SSL_ALLOW_TWICE=1 to disable.\\n\");\n\t\t}\n\t\tsave_allow_once = NULL;\n\t\ttime_allow_once = 0;\n\t}\n\n\treturn check_access(addr);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_access",
          "args": [
            "addr"
          ],
          "line": 3299
        },
        "resolved": true,
        "details": {
          "function_name": "check_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "969-1141",
          "snippet": "int check_access(char *addr) {\n\tint allowed = 0;\n\tint ssl = 0;\n\tchar *p, *list;\n\n\tif (use_openssl || use_stunnel) {\n\t\tssl = 1;\n\t}\n\tif (deny_all) {\n\t\trfbLog(\"check_access: new connections are currently \"\n\t\t    \"blocked.\\n\");\n\t\treturn 0;\n\t}\n\tif (addr == NULL || *addr == '\\0') {\n\t\trfbLog(\"check_access: denying empty host IP address string.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (allow_list == NULL) {\n\t\t/* set to \"\" to possibly append allow_once */\n\t\tallow_list = strdup(\"\");\n\t}\n\tif (*allow_list == '\\0' && allow_once == NULL) {\n\t\t/* no constraints, accept it */\n\t\treturn 1;\n\t}\n\n\tif (strchr(allow_list, '/')) {\n\t\t/* a file of IP addresess or prefixes */\n\t\tint len, len2 = 0;\n\t\tstruct stat sbuf;\n\t\tFILE *in;\n\t\tchar line[1024], *q;\n\n\t\tif (stat(allow_list, &sbuf) != 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: failure stating file: %s\\n\",\n\t\t\t    allow_list);\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tlen = sbuf.st_size + 1;\t/* 1 more for '\\0' at end */\n\t\tif (allow_once) {\n\t\t\tlen2 = strlen(allow_once) + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen2 = strlen(\"127.0.0.1\") + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\t\n\t\tin = fopen(allow_list, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: cannot open: %s\\n\", allow_list);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif ( (q = strchr(line, '#')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strlen(list) + strlen(line) >=\n\t\t\t    (size_t) (len - len2)) {\n\t\t\t\t/* file grew since our stat() */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcat(list, line);\n\t\t}\n\t\tfclose(in);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, allow_once);\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t} else {\n\t\tint len = strlen(allow_list) + 1;\n\t\tif (allow_once) {\n\t\t\tlen += strlen(allow_once) + 1;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen += strlen(\"127.0.0.1\") + 1;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\tstrcat(list, allow_list);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, allow_once);\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t}\n\t}\n\n\tif (allow_once) {\n\t\tfree(allow_once);\n\t\tallow_once = NULL;\n\t}\n\t\n\tp = strtok(list, \", \\t\\n\\r\");\n\twhile (p) {\n\t\tchar *chk, *q, *r = NULL;\n\t\tif (*p == '\\0') {\n\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\tcontinue;\t\n\t\t}\n\t\tif (ipv6_ip(p)) {\n\t\t\tchk = p;\n\t\t} else if (! dotted_ip(p, 1)) {\n\t\t\tr = host2ip(p);\n\t\t\tif (r == NULL || *r == '\\0') {\n\t\t\t\trfbLog(\"check_access: bad lookup \\\"%s\\\"\\n\", p);\n\t\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"check_access: lookup %s -> %s\\n\", p, r);\n\t\t\tchk = r;\n\t\t} else {\n\t\t\tchk = p;\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_ACCESS\")) fprintf(stderr, \"chk: %s  part: %s  addr: %s\\n\", chk, p, addr);\n\n\t\tq = strstr(addr, chk);\n\t\tif (ipv6_ip(addr)) {\n\t\t\tif (!strcmp(chk, \"localhost\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"::1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"127.0.0.1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\t/* this if for host2ip(\"localhost\") */\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (q == addr) {\n\t\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (chk[strlen(chk)-1] != '.') {\n\t\t\tif (!strcmp(addr, chk)) {\n\t\t\t\tif (chk != p) {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s=%s\\n\", addr, chk, p);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s\\n\", addr, chk);\n\t\t\t\t}\n\t\t\t\tallowed = 1;\n\t\t\t} else if(!strcmp(chk, \"localhost\") && !strcmp(addr, \"127.0.0.1\")) {\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (q == addr) {\n\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\tallowed = 1;\n\t\t}\n\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\tif (r) {\n\t\t\tfree(r);\n\t\t}\n\t\tif (allowed) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(list);\n\treturn allowed;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int new_fb_size_clients(rfbScreenInfoPtr s);",
            "void client_gone(rfbClientPtr client);",
            "void client_gone_chat_helper(rfbClientPtr client);",
            "enum rfbNewClientAction new_client(rfbClientPtr client);",
            "enum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);",
            "rfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);",
            "int accept_client(rfbClientPtr client);",
            "int check_access(char *addr);",
            "void client_set_net(rfbClientPtr client);",
            "static void free_client_data(rfbClientPtr client);",
            "static int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);",
            "static void check_connect_file(char *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint new_fb_size_clients(rfbScreenInfoPtr s);\nvoid client_gone(rfbClientPtr client);\nvoid client_gone_chat_helper(rfbClientPtr client);\nenum rfbNewClientAction new_client(rfbClientPtr client);\nenum rfbNewClientAction new_client_chat_helper(rfbClientPtr client);\nrfbBool password_check_chat_helper(rfbClientPtr cl, const char* response, int len);\nint accept_client(rfbClientPtr client);\nint check_access(char *addr);\nvoid client_set_net(rfbClientPtr client);\nstatic void free_client_data(rfbClientPtr client);\nstatic int ugly_window(char *addr, char *userhost, int X, int Y,\n    int timeout, char *mode, int accept);\nstatic void check_connect_file(char *file);\n\nint check_access(char *addr) {\n\tint allowed = 0;\n\tint ssl = 0;\n\tchar *p, *list;\n\n\tif (use_openssl || use_stunnel) {\n\t\tssl = 1;\n\t}\n\tif (deny_all) {\n\t\trfbLog(\"check_access: new connections are currently \"\n\t\t    \"blocked.\\n\");\n\t\treturn 0;\n\t}\n\tif (addr == NULL || *addr == '\\0') {\n\t\trfbLog(\"check_access: denying empty host IP address string.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (allow_list == NULL) {\n\t\t/* set to \"\" to possibly append allow_once */\n\t\tallow_list = strdup(\"\");\n\t}\n\tif (*allow_list == '\\0' && allow_once == NULL) {\n\t\t/* no constraints, accept it */\n\t\treturn 1;\n\t}\n\n\tif (strchr(allow_list, '/')) {\n\t\t/* a file of IP addresess or prefixes */\n\t\tint len, len2 = 0;\n\t\tstruct stat sbuf;\n\t\tFILE *in;\n\t\tchar line[1024], *q;\n\n\t\tif (stat(allow_list, &sbuf) != 0) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: failure stating file: %s\\n\",\n\t\t\t    allow_list);\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tlen = sbuf.st_size + 1;\t/* 1 more for '\\0' at end */\n\t\tif (allow_once) {\n\t\t\tlen2 = strlen(allow_once) + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen2 = strlen(\"127.0.0.1\") + 2;\n\t\t\tlen += len2;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\t\n\t\tin = fopen(allow_list, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogEnable(1);\n\t\t\trfbLog(\"check_access: cannot open: %s\\n\", allow_list);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif ( (q = strchr(line, '#')) != NULL) {\n\t\t\t\t*q = '\\0';\n\t\t\t}\n\t\t\tif (strlen(list) + strlen(line) >=\n\t\t\t    (size_t) (len - len2)) {\n\t\t\t\t/* file grew since our stat() */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcat(list, line);\n\t\t}\n\t\tfclose(in);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, allow_once);\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \"\\n\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t\tstrcat(list, \"\\n\");\n\t\t}\n\t} else {\n\t\tint len = strlen(allow_list) + 1;\n\t\tif (allow_once) {\n\t\t\tlen += strlen(allow_once) + 1;\n\t\t}\n\t\tif (ssl) {\n\t\t\tlen += strlen(\"127.0.0.1\") + 1;\n\t\t}\n\t\tlist = (char *) malloc(len);\n\t\tlist[0] = '\\0';\n\t\tstrcat(list, allow_list);\n\t\tif (allow_once) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, allow_once);\n\t\t}\n\t\tif (ssl) {\n\t\t\tstrcat(list, \",\");\n\t\t\tstrcat(list, \"127.0.0.1\");\n\t\t}\n\t}\n\n\tif (allow_once) {\n\t\tfree(allow_once);\n\t\tallow_once = NULL;\n\t}\n\t\n\tp = strtok(list, \", \\t\\n\\r\");\n\twhile (p) {\n\t\tchar *chk, *q, *r = NULL;\n\t\tif (*p == '\\0') {\n\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\tcontinue;\t\n\t\t}\n\t\tif (ipv6_ip(p)) {\n\t\t\tchk = p;\n\t\t} else if (! dotted_ip(p, 1)) {\n\t\t\tr = host2ip(p);\n\t\t\tif (r == NULL || *r == '\\0') {\n\t\t\t\trfbLog(\"check_access: bad lookup \\\"%s\\\"\\n\", p);\n\t\t\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"check_access: lookup %s -> %s\\n\", p, r);\n\t\t\tchk = r;\n\t\t} else {\n\t\t\tchk = p;\n\t\t}\n\t\tif (getenv(\"X11VNC_DEBUG_ACCESS\")) fprintf(stderr, \"chk: %s  part: %s  addr: %s\\n\", chk, p, addr);\n\n\t\tq = strstr(addr, chk);\n\t\tif (ipv6_ip(addr)) {\n\t\t\tif (!strcmp(chk, \"localhost\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"::1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (!strcmp(chk, \"127.0.0.1\") && !strcmp(addr, \"::1\")) {\n\t\t\t\t/* this if for host2ip(\"localhost\") */\n\t\t\t\trfbLog(\"check_access: client addr %s is local.\\n\", addr);\n\t\t\t\tallowed = 1;\n\t\t\t} else if (q == addr) {\n\t\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (chk[strlen(chk)-1] != '.') {\n\t\t\tif (!strcmp(addr, chk)) {\n\t\t\t\tif (chk != p) {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s=%s\\n\", addr, chk, p);\n\t\t\t\t} else {\n\t\t\t\t\trfbLog(\"check_access: client %s \" \"matches host %s\\n\", addr, chk);\n\t\t\t\t}\n\t\t\t\tallowed = 1;\n\t\t\t} else if(!strcmp(chk, \"localhost\") && !strcmp(addr, \"127.0.0.1\")) {\n\t\t\t\tallowed = 1;\n\t\t\t}\n\t\t} else if (q == addr) {\n\t\t\trfbLog(\"check_access: client %s matches pattern %s\\n\", addr, chk);\n\t\t\tallowed = 1;\n\t\t}\n\t\tp = strtok(NULL, \", \\t\\n\\r\");\n\t\tif (r) {\n\t\t\tfree(r);\n\t\t}\n\t\tif (allowed) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(list);\n\treturn allowed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: Set X11VNC_NO_SSL_ALLOW_TWICE=1 to disable.\\n\""
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: Permitting 30 sec grace period for allowonce.\\n\""
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_NO_SSL_ALLOW_TWICE\""
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "allow_once"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int check_ssl_access(char *addr) {\n\tstatic char *save_allow_once = NULL;\n\tstatic time_t time_allow_once = 0;\n\n\t/* due to \"Fetch Cert\" activities for SSL really need to \"allow twice\" */\n\tif (allow_once != NULL) {\n\t\tsave_allow_once = strdup(allow_once);\n\t\ttime_allow_once = time(NULL);\n\t} else if (save_allow_once != NULL) {\n\t\tif (getenv(\"X11VNC_NO_SSL_ALLOW_TWICE\")) {\n\t\t\t;\n\t\t} else if (time(NULL) < time_allow_once + 30) {\n\t\t\t/* give them 30 secs to check and save the fetched cert. */\n\t\t\tallow_once = save_allow_once; \n\t\t\trfbLog(\"SSL: Permitting 30 sec grace period for allowonce.\\n\");\n\t\t\trfbLog(\"SSL: Set X11VNC_NO_SSL_ALLOW_TWICE=1 to disable.\\n\");\n\t\t}\n\t\tsave_allow_once = NULL;\n\t\ttime_allow_once = 0;\n\t}\n\n\treturn check_access(addr);\n}"
  },
  {
    "function_name": "csock_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "3270-3276",
    "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int csock_timeout_sock = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "csock_timeout_sock"
          ],
          "line": 3273
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sig: %d, csock_timeout.\\n\"",
            "sig"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
  },
  {
    "function_name": "watch_for_http_traffic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "3177-3266",
    "snippet": "static int watch_for_http_traffic(char *buf_a, int *n_a, int raw_sock) {\n\tint is_http, err, n, n2;\n\tchar *buf;\n\tint db = 0;\n\t/*\n\t * sniff the first couple bytes of the stream and try to see\n\t * if it is http or not.  if we read them OK, we must read the\n\t * rest of the available data otherwise we may deadlock.\n\t * what has been read is returned in buf_a and n_a.\n\t * *buf_a is ABSIZE+1 long and zeroed.\n\t */\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\tif (! buf_a || ! n_a) {\n\t\treturn 0;\n\t}\n\n\tbuf = (char *) calloc((ABSIZE+1), 1);\n\t*n_a = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn = read(raw_sock, buf, 2);\n\t\terr = SSL_ERROR_NONE;\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn = SSL_read(ssl, buf, 2);\n\t\terr = SSL_get_error(ssl, n);\n#else\n\t\terr = n = 0;\n\t\tbadnews(\"1 in watch_for_http_traffic\");\n#endif\n\t}\n\n\tif (err != SSL_ERROR_NONE || n < 2) {\n\t\tif (n > 0) {\n\t\t\tstrncpy(buf_a, buf, n);\n\t\t\t*n_a = n;\n\t\t}\n\t\tif (db) fprintf(stderr, \"watch_for_http_traffic ssl err: %d/%d\\n\", err, n);\n\t\treturn -1;\n\t}\n\n\t/* look for GET, HEAD, POST, CONNECT */\n\tis_http = 0;\n\tif (!strncmp(\"GE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"HE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"PO\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"CO\", buf, 2)) {\n\t\tis_http = 1;\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic read: '%s' %d\\n\", buf, n);\n\n\t/*\n\t * better read all we can and fwd it along to avoid blocking\n\t * in ssl_xfer().\n\t */\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn2 = read(raw_sock, buf + n, ABSIZE - n);\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn2 = SSL_read(ssl, buf + n, ABSIZE - n);\n#else\n\t\tn2 = 0;\n\t\tbadnews(\"2 in watch_for_http_traffic\");\n#endif\n\t}\n\tif (n2 >= 0) {\n\t\tn += n2;\n\t}\n\n\t*n_a = n;\n\n\tif (db) fprintf(stderr, \"watch_for_http_traffic readmore: %d\\n\", n2);\n\n\tif (n > 0) {\n\t\tmemcpy(buf_a, buf, n);\n\t}\n\tif (db > 1) {\n\t\tfprintf(stderr, \"watch_for_http_traffic readmore: \");\n\t\twrite(2, buf_a, *n_a);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic return: %d\\n\", is_http);\n\treturn is_http;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SSL_ERROR_NONE 0",
      "#define HAVE_LIBSSL 0",
      "#define LIBVNCSERVER_HAVE_LIBSSL 0",
      "#define ABSIZE 16384"
    ],
    "globals_used": [
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watch_for_http_traffic return: %d\\n\"",
            "is_http"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "2",
            "buf_a",
            "*n_a"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watch_for_http_traffic readmore: \""
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf_a",
            "buf",
            "n"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watch_for_http_traffic readmore: %d\\n\"",
            "n2"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "badnews",
          "args": [
            "\"2 in watch_for_http_traffic\""
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "badnews",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "691-696",
          "snippet": "static void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSL_read",
          "args": [
            "ssl",
            "buf + n",
            "ABSIZE - n"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "raw_sock",
            "buf + n",
            "ABSIZE - n"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watch_for_http_traffic read: '%s' %d\\n\"",
            "buf",
            "n"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"CO\"",
            "buf",
            "2"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"PO\"",
            "buf",
            "2"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"HE\"",
            "buf",
            "2"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"GE\"",
            "buf",
            "2"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"watch_for_http_traffic ssl err: %d/%d\\n\"",
            "err",
            "n"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf_a",
            "buf",
            "n"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_error",
          "args": [
            "ssl",
            "n"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_read",
          "args": [
            "ssl",
            "buf",
            "2"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "(ABSIZE+1)",
            "1"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"ACCEPT_OPENSSL_DEBUG\")"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ACCEPT_OPENSSL_DEBUG\""
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ACCEPT_OPENSSL_DEBUG\""
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSL_ERROR_NONE 0\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n\nstatic char *get_input(char *tag, char **in);\n\nstatic int watch_for_http_traffic(char *buf_a, int *n_a, int raw_sock) {\n\tint is_http, err, n, n2;\n\tchar *buf;\n\tint db = 0;\n\t/*\n\t * sniff the first couple bytes of the stream and try to see\n\t * if it is http or not.  if we read them OK, we must read the\n\t * rest of the available data otherwise we may deadlock.\n\t * what has been read is returned in buf_a and n_a.\n\t * *buf_a is ABSIZE+1 long and zeroed.\n\t */\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\tif (! buf_a || ! n_a) {\n\t\treturn 0;\n\t}\n\n\tbuf = (char *) calloc((ABSIZE+1), 1);\n\t*n_a = 0;\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn = read(raw_sock, buf, 2);\n\t\terr = SSL_ERROR_NONE;\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn = SSL_read(ssl, buf, 2);\n\t\terr = SSL_get_error(ssl, n);\n#else\n\t\terr = n = 0;\n\t\tbadnews(\"1 in watch_for_http_traffic\");\n#endif\n\t}\n\n\tif (err != SSL_ERROR_NONE || n < 2) {\n\t\tif (n > 0) {\n\t\t\tstrncpy(buf_a, buf, n);\n\t\t\t*n_a = n;\n\t\t}\n\t\tif (db) fprintf(stderr, \"watch_for_http_traffic ssl err: %d/%d\\n\", err, n);\n\t\treturn -1;\n\t}\n\n\t/* look for GET, HEAD, POST, CONNECT */\n\tis_http = 0;\n\tif (!strncmp(\"GE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"HE\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"PO\", buf, 2)) {\n\t\tis_http = 1;\n\t} else if (!strncmp(\"CO\", buf, 2)) {\n\t\tis_http = 1;\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic read: '%s' %d\\n\", buf, n);\n\n\t/*\n\t * better read all we can and fwd it along to avoid blocking\n\t * in ssl_xfer().\n\t */\n\n\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\tn2 = read(raw_sock, buf + n, ABSIZE - n);\n\t} else {\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL\n\t\tn2 = SSL_read(ssl, buf + n, ABSIZE - n);\n#else\n\t\tn2 = 0;\n\t\tbadnews(\"2 in watch_for_http_traffic\");\n#endif\n\t}\n\tif (n2 >= 0) {\n\t\tn += n2;\n\t}\n\n\t*n_a = n;\n\n\tif (db) fprintf(stderr, \"watch_for_http_traffic readmore: %d\\n\", n2);\n\n\tif (n > 0) {\n\t\tmemcpy(buf_a, buf, n);\n\t}\n\tif (db > 1) {\n\t\tfprintf(stderr, \"watch_for_http_traffic readmore: \");\n\t\twrite(2, buf_a, *n_a);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n\tif (db) fprintf(stderr, \"watch_for_http_traffic return: %d\\n\", is_http);\n\treturn is_http;\n}"
  },
  {
    "function_name": "is_ssl_readable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "3119-3175",
    "snippet": "static int is_ssl_readable(int s_in, double last_https, char *last_get,\n    int mode) {\n\tint nfd, db = 0;\n\tstruct timeval tv;\n\tfd_set rd;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/*\n\t * we'll do a select() on s_in for reading.  this is not an\n\t * absolute proof that SSL_read is ready (XXX use SSL utility).\n\t */\n\ttv.tv_sec  = 2;\n\ttv.tv_usec = 0;\n\n\tif (mode == OPENSSL_INETD) {\n\t\t/*\n\t\t * https via inetd is icky because x11vnc is restarted\n\t\t * for each socket (and some clients send requests\n\t\t * rapid fire).\n\t\t */\n\t\ttv.tv_sec = 4;\n\t}\n\n\t/*\n\t * increase the timeout if we know HTTP traffic has occurred\n\t * recently:\n\t */\n\tif (dnow() < last_https + 30.0) {\n\t\ttv.tv_sec = 10;\n\t\tif (last_get && strstr(last_get, \"VncViewer\")) {\n\t\t\ttv.tv_sec = 5;\n\t\t}\n\t}\n\tif (getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\")) {\n\t\ttv.tv_sec  = atoi(getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\"));\n\t}\nif (db) fprintf(stderr, \"tv_sec: %d - '%s'\\n\", (int) tv.tv_sec, last_get);\n\n\tFD_ZERO(&rd);\n\tFD_SET(s_in, &rd);\n\n\tif (db) fprintf(stderr, \"is_ssl_readable: begin  select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\tdo {\n\t\tnfd = select(s_in+1, &rd, NULL, NULL, &tv);\n\t} while (nfd < 0 && errno == EINTR);\n\tif (db) fprintf(stderr, \"is_ssl_readable: finish select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\n\tif (db) fprintf(stderr, \"https nfd: %d\\n\", nfd);\n\n\tif (nfd <= 0 || ! FD_ISSET(s_in, &rd)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define OPENSSL_INETD   1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_in",
            "&rd"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"https nfd: %d\\n\"",
            "nfd"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"is_ssl_readable: finish select(%d secs) %.6f\\n\"",
            "(int) tv.tv_sec",
            "dnow()"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "s_in+1",
            "&rd",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"is_ssl_readable: begin  select(%d secs) %.6f\\n\"",
            "(int) tv.tv_sec",
            "dnow()"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "s_in",
            "&rd"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rd"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"tv_sec: %d - '%s'\\n\"",
            "(int) tv.tv_sec",
            "last_get"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\")"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_HTTPS_VS_VNC_TIMEOUT\""
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_HTTPS_VS_VNC_TIMEOUT\""
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "last_get",
            "\"VncViewer\""
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"ACCEPT_OPENSSL_DEBUG\")"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ACCEPT_OPENSSL_DEBUG\""
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"ACCEPT_OPENSSL_DEBUG\""
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_INETD   1\n\nstatic int is_ssl_readable(int s_in, double last_https, char *last_get,\n    int mode) {\n\tint nfd, db = 0;\n\tstruct timeval tv;\n\tfd_set rd;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/*\n\t * we'll do a select() on s_in for reading.  this is not an\n\t * absolute proof that SSL_read is ready (XXX use SSL utility).\n\t */\n\ttv.tv_sec  = 2;\n\ttv.tv_usec = 0;\n\n\tif (mode == OPENSSL_INETD) {\n\t\t/*\n\t\t * https via inetd is icky because x11vnc is restarted\n\t\t * for each socket (and some clients send requests\n\t\t * rapid fire).\n\t\t */\n\t\ttv.tv_sec = 4;\n\t}\n\n\t/*\n\t * increase the timeout if we know HTTP traffic has occurred\n\t * recently:\n\t */\n\tif (dnow() < last_https + 30.0) {\n\t\ttv.tv_sec = 10;\n\t\tif (last_get && strstr(last_get, \"VncViewer\")) {\n\t\t\ttv.tv_sec = 5;\n\t\t}\n\t}\n\tif (getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\")) {\n\t\ttv.tv_sec  = atoi(getenv(\"X11VNC_HTTPS_VS_VNC_TIMEOUT\"));\n\t}\nif (db) fprintf(stderr, \"tv_sec: %d - '%s'\\n\", (int) tv.tv_sec, last_get);\n\n\tFD_ZERO(&rd);\n\tFD_SET(s_in, &rd);\n\n\tif (db) fprintf(stderr, \"is_ssl_readable: begin  select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\tdo {\n\t\tnfd = select(s_in+1, &rd, NULL, NULL, &tv);\n\t} while (nfd < 0 && errno == EINTR);\n\tif (db) fprintf(stderr, \"is_ssl_readable: finish select(%d secs) %.6f\\n\", (int) tv.tv_sec, dnow());\n\n\tif (db) fprintf(stderr, \"https nfd: %d\\n\", nfd);\n\n\tif (nfd <= 0 || ! FD_ISSET(s_in, &rd)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ssl_helper_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2999-3117",
    "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ssl_helper_pid(pid_t pid, int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "helpers[i]",
            "0"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "kill_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "674-684",
          "snippet": "static void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void kill_child (pid_t pid, int fd) {\n\tint status;\n\n\tslave_fd = -1;\n\talarm_fired = 0;\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t}\n\tkill(pid, SIGTERM);\n\twaitpid(pid, &status, WNOHANG); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  waitret1=%d\\n\"",
            "wret"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"waitpid(%d) 2\\n\"",
            "helpers[i]"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "helpers[i]",
            "&status",
            "WNOHANG"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl_helper_pid(%d, %d)\\n\"",
            "pid",
            "sock"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  waitret2=%d\\n\"",
            "wret"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "helpers[i]",
            "&status",
            "WNOHANG"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"  waitret1=%d\\n\"",
            "wret"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"waitpid(%d)\\n\"",
            "helpers[i]"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "helpers[i]",
            "&status",
            "WNOHANG"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20 * 1000"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sockets[i]"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSL_HELPER_PID_DB\""
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
  },
  {
    "function_name": "lose_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2986-2995",
    "snippet": "static void lose_ram(void) {\n\t/*\n\t * for a forked child that will be around for a long time\n\t * without doing exec().  we really should re-exec, but a pain\n\t * to redo all SSL ctx.\n\t */\n\tfree_old_fb();\n\n\tfree_tiles();\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void lose_ram(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_tiles",
          "args": [],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "free_tiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
          "lines": "160-201",
          "snippet": "void free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}",
          "includes": [
            "#include <default8x16.h>",
            "#include \"userinput.h\"",
            "#include \"macosx.h\"",
            "#include \"screen.h\"",
            "#include \"unixpw.h\"",
            "#include \"cleanup.h\"",
            "#include \"pointer.h\"",
            "#include \"screen.h\"",
            "#include \"8to24.h\"",
            "#include \"win_utils.h\"",
            "#include \"xrandr.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xinerama.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void free_tiles(void);",
            "static hint_t *hint_list;",
            "static region_t *tile_region;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid free_tiles(void);\nstatic hint_t *hint_list;\nstatic region_t *tile_region;\n\nvoid free_tiles(void) {\n\tif (tile_has_diff) {\n\t\tfree(tile_has_diff);\n\t\ttile_has_diff = NULL;\n\t}\n\tif (tile_has_xdamage_diff) {\n\t\tfree(tile_has_xdamage_diff);\n\t\ttile_has_xdamage_diff = NULL;\n\t}\n\tif (tile_row_has_xdamage_diff) {\n\t\tfree(tile_row_has_xdamage_diff);\n\t\ttile_row_has_xdamage_diff = NULL;\n\t}\n\tif (tile_tried) {\n\t\tfree(tile_tried);\n\t\ttile_tried = NULL;\n\t}\n\tif (tile_copied) {\n\t\tfree(tile_copied);\n\t\ttile_copied = NULL;\n\t}\n\tif (tile_blackout) {\n\t\tfree(tile_blackout);\n\t\ttile_blackout = NULL;\n\t}\n\tif (tile_region) {\n\t\tfree(tile_region);\n\t\ttile_region = NULL;\n\t}\n\tif (tile_row) {\n\t\tfree(tile_row);\n\t\ttile_row = NULL;\n\t}\n\tif (tile_row_shm) {\n\t\tfree(tile_row_shm);\n\t\ttile_row_shm = NULL;\n\t}\n\tif (hint_list) {\n\t\tfree(hint_list);\n\t\thint_list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_old_fb",
          "args": [],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "free_old_fb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "791-821",
          "snippet": "void free_old_fb(void) {\n\tchar *fbs[16];\n\tint i, j, nfb = 0, db = 0; \n\n\tfbs[nfb++] = main_fb;\t\tmain_fb = NULL;\n\tfbs[nfb++] = rfb_fb;\t\trfb_fb = NULL;\n\tfbs[nfb++] = cmap8to24_fb;\tcmap8to24_fb = NULL;\n\tfbs[nfb++] = snap_fb;\t\tsnap_fb = NULL;\n\tfbs[nfb++] = rot_fb;\t\trot_fb = NULL;\n\tfbs[nfb++] = raw_fb;\t\traw_fb = NULL;\n\n\tfor (i=0; i < nfb; i++) {\n\t\tchar *fb = fbs[i];\n\t\tint freeit = 1;\n\t\tif (! fb || fb < (char *) 0x10) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j < i; j++) {\n\t\t\tif (fb == fbs[j]) {\n\t\t\t\tfreeit = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (freeit) {\n\t\t\tif (db) fprintf(stderr, \"free: %i %p\\n\", i, fb);\n\t\t\tfree(fb);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skip: %i %p\\n\", i, fb);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void free_old_fb(void);",
            "void initialize_screen(int *argc, char **argv, XImage *fb);",
            "static void debug_colormap(XImage *fb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\nvoid free_old_fb(void);\nvoid initialize_screen(int *argc, char **argv, XImage *fb);\nstatic void debug_colormap(XImage *fb);\n\nvoid free_old_fb(void) {\n\tchar *fbs[16];\n\tint i, j, nfb = 0, db = 0; \n\n\tfbs[nfb++] = main_fb;\t\tmain_fb = NULL;\n\tfbs[nfb++] = rfb_fb;\t\trfb_fb = NULL;\n\tfbs[nfb++] = cmap8to24_fb;\tcmap8to24_fb = NULL;\n\tfbs[nfb++] = snap_fb;\t\tsnap_fb = NULL;\n\tfbs[nfb++] = rot_fb;\t\trot_fb = NULL;\n\tfbs[nfb++] = raw_fb;\t\traw_fb = NULL;\n\n\tfor (i=0; i < nfb; i++) {\n\t\tchar *fb = fbs[i];\n\t\tint freeit = 1;\n\t\tif (! fb || fb < (char *) 0x10) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0; j < i; j++) {\n\t\t\tif (fb == fbs[j]) {\n\t\t\t\tfreeit = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (freeit) {\n\t\t\tif (db) fprintf(stderr, \"free: %i %p\\n\", i, fb);\n\t\t\tfree(fb);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"skip: %i %p\\n\", i, fb);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void lose_ram(void);\n\nstatic void lose_ram(void) {\n\t/*\n\t * for a forked child that will be around for a long time\n\t * without doing exec().  we really should re-exec, but a pain\n\t * to redo all SSL ctx.\n\t */\n\tfree_old_fb();\n\n\tfree_tiles();\n}"
  },
  {
    "function_name": "https_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2902-2984",
    "snippet": "void https_port(int restart) {\n\tint sock, fd6 = -1;\n\tstatic int port = 0;\n\tstatic in_addr_t iface = INADDR_ANY;\n\n\t/* as openssl_port above: open a listening socket for pure https: */\n\tif (https_port_num < 0) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\trfbLog(\"https_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (! screen->httpDir) {\n\t\treturn;\n\t}\n\tif (screen->listenInterface) {\n\t\tiface = screen->listenInterface;\n\t}\n\n\tif (https_port_num == 0) {\n\t\thttps_port_num = find_free_port(5801, 5851);\n\t}\n\tif (ipv6_listen && https_port_num <= 0) {\n\t\thttps_port_num = find_free_port6(5801, 5851);\n\t}\n\tif (https_port_num <= 0) {\n\t\trfbLog(\"https_port: could not find port %d\\n\", https_port_num);\n\t\tclean_up_exit(1);\n\t}\n\tport = https_port_num;\n\n\tif (port <= 0) {\n\t\trfbLog(\"https_port: could not obtain listening port %d\\n\", port);\n\t\tif (!restart) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (https_sock >= 0) {\n\t\tclose(https_sock);\n\t\thttps_sock = -1;\n\t}\n\tif (https_sock6 >= 0) {\n\t\tclose(https_sock6);\n\t\thttps_sock6 = -1;\n\t}\n\tsock = listen_tcp(port, iface, 0);\n\tif (sock < 0) {\n\t\trfbLog(\"https_port: could not open port %d\\n\", port);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} \n\t\tif (fd6 < 0) {\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"https_port: trying IPv6 only mode.\\n\");\n\t}\n\trfbLog(\"https_port: listen on port/sock %d/%d\\n\", port, sock);\n\thttps_sock = sock;\n\n\tif (ipv6_listen) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"https_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\thttps_sock6 = fd6;\n\t\t}\n\t\tif (fd6 < 0 && https_sock < 0) {\n\t\t\trfbLog(\"https_port: could not listen on either IPv4 or IPv6.\\n\");\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int https_sock = -1;",
      "int https_sock6 = -1;",
      "void openssl_port(int restart);",
      "void https_port(int restart);",
      "void ssl_helper_pid(pid_t pid, int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: could not listen on either IPv4 or IPv6.\\n\""
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: listen on port/sock %d/%d (ipv6)\\n\"",
            "port",
            "fd6"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen6",
          "args": [
            "port"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "listen6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "538-653",
          "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: listen on port/sock %d/%d\\n\"",
            "port",
            "sock"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: trying IPv6 only mode.\\n\""
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: could not open port %d\\n\"",
            "port"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen_tcp",
          "args": [
            "port",
            "iface",
            "0"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "listen_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "895-938",
          "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);",
            "int listen_tcp(int port, in_addr_t iface, int try6);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "https_sock6"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: could not obtain listening port %d\\n\"",
            "port"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: could not find port %d\\n\"",
            "https_port_num"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_free_port6",
          "args": [
            "5801",
            "5851"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_port6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "431-447",
          "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int find_free_port(int start, int end);",
            "int find_free_port6(int start, int end);",
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"https_port: no screen!\\n\""
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint https_sock = -1;\nint https_sock6 = -1;\nvoid openssl_port(int restart);\nvoid https_port(int restart);\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid https_port(int restart) {\n\tint sock, fd6 = -1;\n\tstatic int port = 0;\n\tstatic in_addr_t iface = INADDR_ANY;\n\n\t/* as openssl_port above: open a listening socket for pure https: */\n\tif (https_port_num < 0) {\n\t\treturn;\n\t}\n\tif (! screen) {\n\t\trfbLog(\"https_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (! screen->httpDir) {\n\t\treturn;\n\t}\n\tif (screen->listenInterface) {\n\t\tiface = screen->listenInterface;\n\t}\n\n\tif (https_port_num == 0) {\n\t\thttps_port_num = find_free_port(5801, 5851);\n\t}\n\tif (ipv6_listen && https_port_num <= 0) {\n\t\thttps_port_num = find_free_port6(5801, 5851);\n\t}\n\tif (https_port_num <= 0) {\n\t\trfbLog(\"https_port: could not find port %d\\n\", https_port_num);\n\t\tclean_up_exit(1);\n\t}\n\tport = https_port_num;\n\n\tif (port <= 0) {\n\t\trfbLog(\"https_port: could not obtain listening port %d\\n\", port);\n\t\tif (!restart) {\n\t\t\tclean_up_exit(1);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (https_sock >= 0) {\n\t\tclose(https_sock);\n\t\thttps_sock = -1;\n\t}\n\tif (https_sock6 >= 0) {\n\t\tclose(https_sock6);\n\t\thttps_sock6 = -1;\n\t}\n\tsock = listen_tcp(port, iface, 0);\n\tif (sock < 0) {\n\t\trfbLog(\"https_port: could not open port %d\\n\", port);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} \n\t\tif (fd6 < 0) {\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t\trfbLog(\"https_port: trying IPv6 only mode.\\n\");\n\t}\n\trfbLog(\"https_port: listen on port/sock %d/%d\\n\", port, sock);\n\thttps_sock = sock;\n\n\tif (ipv6_listen) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\t;\n\t\t} else {\n\t\t\trfbLog(\"https_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\thttps_sock6 = fd6;\n\t\t}\n\t\tif (fd6 < 0 && https_sock < 0) {\n\t\t\trfbLog(\"https_port: could not listen on either IPv4 or IPv6.\\n\");\n\t\t\tif (!restart) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "openssl_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2793-2900",
    "snippet": "void openssl_port(int restart) {\n\tint sock = -1, shutdown = 0;\n\tstatic int port = -1;\n\tstatic in_addr_t iface = INADDR_ANY;\n\tint db = 0, fd6 = -1;\n\n\tif (! screen) {\n\t\trfbLog(\"openssl_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tssl_initialized = 1;\n\t\treturn;\n\t}\n\n\tif (ipv6_listen && screen->port <= 0) {\n\t\tif (got_rfbport) {\n\t\t\tscreen->port = got_rfbport_val;\n\t\t} else {\n\t\t\tint ap = 5900;\n\t\t\tif (auto_port > 0) {\n\t\t\t\tap = auto_port;\n\t\t\t}\n\t\t\tscreen->port = find_free_port6(ap, ap+200);\n\t\t}\n\t\trfbLog(\"openssl_port: reset port from 0 => %d\\n\", screen->port);\n\t}\n\n\tif (restart) {\n\t\tport = screen->port;\n\t} else if (screen->listenSock > -1 && screen->port > 0) {\n\t\tport = screen->port;\n\t\tshutdown = 1;\n\t} else if (ipv6_listen && screen->port > 0) {\n\t\tport = screen->port;\n\t} else if (screen->port == 0) {\n\t\tport = screen->port;\n\t}\n\n\tiface = screen->listenInterface;\n\n\tif (shutdown) {\n\t\tif (db) fprintf(stderr, \"shutting down %d/%d\\n\",\n\t\t    port, screen->listenSock);\n#if LIBVNCSERVER_HAS_SHUTDOWNSOCKETS\n\t\trfbShutdownSockets(screen);\n#endif\n\t}\n\n\tif (openssl_sock >= 0) {\n\t\tclose(openssl_sock);\n\t\topenssl_sock = -1;\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tclose(openssl_sock6);\n\t\topenssl_sock6 = -1;\n\t}\n\n\tif (port < 0) {\n\t\trfbLog(\"openssl_port: could not obtain listening port %d\\n\", port);\n\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t}\n\t\tclean_up_exit(1);\n\t} else if (port == 0) {\n\t\t/* no listen case, i.e. -connect */\n\t\tsock = -1;\n\t} else {\n\t\tsock = listen_tcp(port, iface, 0);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} else if (!got_rfbport && !got_ipv6_listen) {\n\t\t\tif (sock < 0) {\n\t\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t\t}\n\t\t}\n\t\tif (sock < 0) {\n\t\t\tif (fd6 < 0) {\n\t\t\t\trfbLog(\"openssl_port: could not reopen port %d\\n\", port);\n\t\t\t\tif (!restart) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trfbLog(\"openssl_port: Info: listening on IPv6 only.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\trfbLog(\"openssl_port: listen on port/sock %d/%d\\n\", port, sock);\n\tif (ipv6_listen && port > 0) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\tipv6_listen = 0;\n\t\t} else {\n\t\t\trfbLog(\"openssl_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\topenssl_sock6 = fd6;\n\t\t}\n\t}\n\tif (!quiet && sock >=0) {\n\t\tannounce(port, 1, NULL);\n\t}\n\topenssl_sock = sock;\n\topenssl_port_num = port;\n\n\tssl_initialized = 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int openssl_sock = -1;",
      "int openssl_sock6 = -1;",
      "int openssl_port_num = 0;",
      "void openssl_port(int restart);",
      "void https_port(int restart);",
      "void ssl_helper_pid(pid_t pid, int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "announce",
          "args": [
            "port",
            "1",
            "NULL"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "announce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/screen.c",
          "lines": "3797-3863",
          "snippet": "void announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}",
          "includes": [
            "#include <rfb/rfbclient.h>",
            "#include \"xi2_devices.h\"",
            "#include \"pm.h\"",
            "#include \"xrecord.h\"",
            "#include \"xrandr.h\"",
            "#include \"inet.h\"",
            "#include \"solid.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"linuxfb.h\"",
            "#include \"v4l.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"remote.h\"",
            "#include \"connections.h\"",
            "#include \"cursor.h\"",
            "#include \"keyboard.h\"",
            "#include \"pointer.h\"",
            "#include \"rates.h\"",
            "#include \"user.h\"",
            "#include \"scan.h\"",
            "#include \"userinput.h\"",
            "#include \"cleanup.h\"",
            "#include \"win_utils.h\"",
            "#include \"xdamage.h\"",
            "#include \"xinerama.h\"",
            "#include \"xwrappers.h\"",
            "#include \"xevents.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}"
          ],
          "globals_used": [
            "void announce(int lport, int ssl, char *iface);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <rfb/rfbclient.h>\n#include \"xi2_devices.h\"\n#include \"pm.h\"\n#include \"xrecord.h\"\n#include \"xrandr.h\"\n#include \"inet.h\"\n#include \"solid.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"linuxfb.h\"\n#include \"v4l.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"remote.h\"\n#include \"connections.h\"\n#include \"cursor.h\"\n#include \"keyboard.h\"\n#include \"pointer.h\"\n#include \"rates.h\"\n#include \"user.h\"\n#include \"scan.h\"\n#include \"userinput.h\"\n#include \"cleanup.h\"\n#include \"win_utils.h\"\n#include \"xdamage.h\"\n#include \"xinerama.h\"\n#include \"xwrappers.h\"\n#include \"xevents.h\"\n#include \"x11vnc.h\"\n\n#define DO_AVAHI \\\n\tif (avahi) { \\\n\t\tavahi_initialise(); \\\n\t\tavahi_advertise(vnc_desktop_name, host, lport); \\\n\t\tusleep(1000*1000); \\\n\t}\n\nvoid announce(int lport, int ssl, char *iface);\n\nvoid announce(int lport, int ssl, char *iface) {\n\t\n\tchar *host = this_host();\n\tchar *tvdt;\n\n\tif (remote_direct) {\n\t\treturn;\n\t}\n\n\tif (! ssl) {\n\t\ttvdt = \"The VNC desktop is:     \";\n\t} else {\n\t\tif (enc_str && !strcmp(enc_str, \"none\")) {\n\t\t\ttvdt = \"The VNC desktop is:     \";\n\t\t} else if (enc_str) {\n\t\t\ttvdt = \"The ENC VNC desktop is: \";\n\t\t} else {\n\t\t\ttvdt = \"The SSL VNC desktop is: \";\n\t\t}\n\t}\n\n\tif (iface != NULL && *iface != '\\0' && strcmp(iface, \"any\")) {\n\t\tfree(host);\n\t\thost = iface;\n\t}\n\tif (host != NULL) {\n\t\t/* note that vncviewer special cases 5900-5999 */\n\t\tint sz = 256;\n\t\tif (inetd) {\n\t\t\t;\t/* should not occur (port) */\n\t\t} else if (quiet) {\n\t\t\tif (lport >= 5900) {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport - 5900);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t} else {\n\t\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t\t    host, lport);\n\t\t\t\tDO_AVAHI\n\t\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt,\n\t\t\t\t    vnc_desktop_name);\n\t\t\t}\n\t\t} else if (lport >= 5900) {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport - 5900);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\tif (lport >= 6000) {\n\t\t\t\trfbLog(\"possible aliases:  %s:%d, \"\n\t\t\t\t    \"%s::%d\\n\", host, lport,\n\t\t\t\t    host, lport);\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(vnc_desktop_name, sz, \"%s:%d\",\n\t\t\t    host, lport);\n\t\t\tDO_AVAHI\n\t\t\tfprintf(stderr, \"\\n%s %s\\n\", tvdt, vnc_desktop_name);\n\t\t\trfbLog(\"possible alias:    %s::%d\\n\",\n\t\t\t    host, lport);\n\t\t}\n\n\t\tif (host != iface)\n\t\t\tfree(host);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: listen on port/sock %d/%d (ipv6)\\n\"",
            "port",
            "fd6"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen6",
          "args": [
            "port"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "listen6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "538-653",
          "snippet": "int listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int accept_unix(int s);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint accept_unix(int s);\nint connect_tcp(char *host, int port);\n\nint listen6(int port) {\n#if X11VNC_IPV6\n\tstruct sockaddr_in6 sin;\n\tint fd = -1, one = 1;\n\n\tif (noipv6) {\n\t\treturn -1;\n\t}\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\trfbLogPerror(\"listen6: socket\");\n\t\trfbLog(\"(Ignore the above error if this system is IPv4-only.)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt SO_REUSEADDR\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n#if defined(SOL_IPV6) && defined(IPV6_V6ONLY)\n\tif (setsockopt(fd, SOL_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n\t\trfbLogPerror(\"listen6: setsockopt IPV6_V6ONLY\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n#endif\n\n\tmemset((char *)&sin, 0, sizeof(sin));\n\tsin.sin6_family = AF_INET6;\n\tsin.sin6_port   = htons(port);\n\tsin.sin6_addr   = in6addr_any;\n\n\tif (listen_str6) {\n\t\tif (!strcmp(listen_str6, \"localhost\") || !strcmp(listen_str6, \"::1\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t} else {\n\t\t\tint err;\n\t\t\tstruct addrinfo *ai;\n\t\t\tstruct addrinfo hints;\n\t\t\tchar service[32];\n\n\t\t\tmemset(&hints, 0, sizeof(hints));\n\t\t\tsprintf(service, \"%d\", port);\n\n\t\t\thints.ai_family = AF_INET6;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n#ifdef AI_ADDRCONFIG\n\t\t\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n#ifdef AI_NUMERICHOST\n\t\t\tif(ipv6_ip(listen_str6)) {\n\t\t\t\thints.ai_flags |= AI_NUMERICHOST;\n\t\t\t}\n#endif\n#ifdef AI_NUMERICSERV\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n#endif\n\t\t\terr = getaddrinfo(listen_str6, service, &hints, &ai);\n\t\t\tif (err == 0) {\n\t\t\t\tstruct addrinfo *ap = ai;\n\t\t\t\terr = 1;\n\t\t\t\twhile (ap != NULL) {\n\t\t\t\t\tchar *s = ipv6_getipaddr(ap->ai_addr, ap->ai_addrlen);\n\t\t\t\t\tif (!s) s = strdup(\"unknown\");\n\n\t\t\t\t\trfbLog(\"listen6: checking: %s family: %d\\n\", s, ap->ai_family); \n\t\t\t\t\tif (ap->ai_family == AF_INET6) {\n\t\t\t\t\t\tmemcpy((char *)&sin, ap->ai_addr, sizeof(sin));\n\t\t\t\t\t\trfbLog(\"listen6: using:    %s scope_id: %d\\n\", s, sin.sin6_scope_id); \n\t\t\t\t\t\terr = 0;\n\t\t\t\t\t\tfree(s);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(s);\n\t\t\t\t\tap = ap->ai_next;\n\t\t\t\t}\n\t\t\t\tfreeaddrinfo(ai);\n\t\t\t}\n\n\t\t\tif (err != 0) {\n\t\t\t\trfbLog(\"Invalid or Unsupported -listen6 string: %s\\n\", listen_str6);\n\t\t\t\tclose(fd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (allow_list && !strcmp(allow_list, \"127.0.0.1\")) {\n\t\tsin.sin6_addr = in6addr_loopback;\n\t} else if (listen_str) {\n\t\tif (!strcmp(listen_str, \"localhost\")) {\n\t\t\tsin.sin6_addr = in6addr_loopback;\n\t\t}\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) < 0) {\n\t\trfbLogPerror(\"listen6: bind\"); \n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tif (listen(fd, 32) < 0) {\n\t\trfbLogPerror(\"listen6: listen\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n#else\n\tif (port) {}\n\treturn -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: listen on port/sock %d/%d\\n\"",
            "port",
            "sock"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: Info: listening on IPv6 only.\\n\""
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: could not reopen port %d\\n\"",
            "port"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: if this system is IPv6-only, use the -6 option\\n\""
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen_tcp",
          "args": [
            "port",
            "iface",
            "0"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "listen_tcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "895-938",
          "snippet": "int listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);",
            "int listen_tcp(int port, in_addr_t iface, int try6);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint listen6(int port);\nint connect_tcp(char *host, int port);\nint listen_tcp(int port, in_addr_t iface, int try6);\n\nint listen_tcp(int port, in_addr_t iface, int try6) {\n\tint fd = -1;\n\tint fail4 = noipv4;\n\tif (getenv(\"IPV4_FAILS\")) {\n\t\tfail4 = 2;\n\t}\n\n\tif (port <= 0 || 65535 < port) {\n\t\t/* for us, invalid port means do not listen. */\n\t\treturn -1;\n\t}\n\n\tif (fail4) {\n\t\tif (fail4 > 1) {\n\t\t\trfbLog(\"TESTING: IPV4_FAILS for listen_tcp: port=%d try6=%d\\n\", port, try6);\n\t\t}\n\t} else {\n\t\tfd = rfbListenOnTCPPort(port, iface);\n\t}\n\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\tif (fail4 > 1) {\n\t\trfbLogPerror(\"listen_tcp: listen failed\");\n\t}\n\n\tif (fd < 0 && try6 && ipv6_listen && !noipv6) {\n#if X11VNC_IPV6\n\t\tchar *save = listen_str6;\n\t\tif (iface == htonl(INADDR_LOOPBACK)) {\n\t\t\tlisten_str6 = \"localhost\";\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_loopback ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t} else if (iface == htonl(INADDR_ANY)) {\n\t\t\tlisten_str6 = NULL;\n\t\t\trfbLog(\"listen_tcp: retrying on IPv6 in6addr_any ...\\n\");\n\t\t\tfd = listen6(port);\n\t\t}\n\t\tlisten_str6 = save;\n#endif\n\t}\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: if this system is IPv6-only, use the -6 option\\n\""
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: could not obtain listening port %d\\n\"",
            "port"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "openssl_sock6"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbShutdownSockets",
          "args": [
            "screen"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"shutting down %d/%d\\n\"",
            "port",
            "screen->listenSock"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: reset port from 0 => %d\\n\"",
            "screen->port"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_free_port6",
          "args": [
            "ap",
            "ap+200"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "find_free_port6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "431-447",
          "snippet": "int find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);",
            "int find_free_port(int start, int end);",
            "int find_free_port6(int start, int end);",
            "int listen6(int port);",
            "int connect_tcp(char *host, int port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\nint find_free_port(int start, int end);\nint find_free_port6(int start, int end);\nint listen6(int port);\nint connect_tcp(char *host, int port);\n\nint find_free_port6(int start, int end) {\n\tint port;\n\tif (start <= 0) {\n\t\tstart = 1024;\n\t}\n\tif (end <= 0) {\n\t\tend = 65530;\n\t}\n\tfor (port = start; port <= end; port++)  {\n\t\tint sock = listen6(port);\n\t\tif (sock >= 0) {\n\t\t\tclose(sock);\n\t\t\treturn port;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_port: no screen!\\n\""
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint openssl_port_num = 0;\nvoid openssl_port(int restart);\nvoid https_port(int restart);\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid openssl_port(int restart) {\n\tint sock = -1, shutdown = 0;\n\tstatic int port = -1;\n\tstatic in_addr_t iface = INADDR_ANY;\n\tint db = 0, fd6 = -1;\n\n\tif (! screen) {\n\t\trfbLog(\"openssl_port: no screen!\\n\");\n\t\tclean_up_exit(1);\n\t}\n\tif (inetd) {\n\t\tssl_initialized = 1;\n\t\treturn;\n\t}\n\n\tif (ipv6_listen && screen->port <= 0) {\n\t\tif (got_rfbport) {\n\t\t\tscreen->port = got_rfbport_val;\n\t\t} else {\n\t\t\tint ap = 5900;\n\t\t\tif (auto_port > 0) {\n\t\t\t\tap = auto_port;\n\t\t\t}\n\t\t\tscreen->port = find_free_port6(ap, ap+200);\n\t\t}\n\t\trfbLog(\"openssl_port: reset port from 0 => %d\\n\", screen->port);\n\t}\n\n\tif (restart) {\n\t\tport = screen->port;\n\t} else if (screen->listenSock > -1 && screen->port > 0) {\n\t\tport = screen->port;\n\t\tshutdown = 1;\n\t} else if (ipv6_listen && screen->port > 0) {\n\t\tport = screen->port;\n\t} else if (screen->port == 0) {\n\t\tport = screen->port;\n\t}\n\n\tiface = screen->listenInterface;\n\n\tif (shutdown) {\n\t\tif (db) fprintf(stderr, \"shutting down %d/%d\\n\",\n\t\t    port, screen->listenSock);\n#if LIBVNCSERVER_HAS_SHUTDOWNSOCKETS\n\t\trfbShutdownSockets(screen);\n#endif\n\t}\n\n\tif (openssl_sock >= 0) {\n\t\tclose(openssl_sock);\n\t\topenssl_sock = -1;\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tclose(openssl_sock6);\n\t\topenssl_sock6 = -1;\n\t}\n\n\tif (port < 0) {\n\t\trfbLog(\"openssl_port: could not obtain listening port %d\\n\", port);\n\t\tif (!got_rfbport && !got_ipv6_listen) {\n\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t}\n\t\tclean_up_exit(1);\n\t} else if (port == 0) {\n\t\t/* no listen case, i.e. -connect */\n\t\tsock = -1;\n\t} else {\n\t\tsock = listen_tcp(port, iface, 0);\n\t\tif (ipv6_listen) {\n\t\t\tfd6 = listen6(port);\n\t\t} else if (!got_rfbport && !got_ipv6_listen) {\n\t\t\tif (sock < 0) {\n\t\t\t\trfbLog(\"openssl_port: if this system is IPv6-only, use the -6 option\\n\");\n\t\t\t}\n\t\t}\n\t\tif (sock < 0) {\n\t\t\tif (fd6 < 0) {\n\t\t\t\trfbLog(\"openssl_port: could not reopen port %d\\n\", port);\n\t\t\t\tif (!restart) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trfbLog(\"openssl_port: Info: listening on IPv6 only.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\trfbLog(\"openssl_port: listen on port/sock %d/%d\\n\", port, sock);\n\tif (ipv6_listen && port > 0) {\n\t\tif (fd6 < 0) {\n\t\t\tfd6 = listen6(port);\n\t\t}\n\t\tif (fd6 < 0) {\n\t\t\tipv6_listen = 0;\n\t\t} else {\n\t\t\trfbLog(\"openssl_port: listen on port/sock %d/%d (ipv6)\\n\",\n\t\t\t    port, fd6);\n\t\t\topenssl_sock6 = fd6;\n\t\t}\n\t}\n\tif (!quiet && sock >=0) {\n\t\tannounce(port, 1, NULL);\n\t}\n\topenssl_sock = sock;\n\topenssl_port_num = port;\n\n\tssl_initialized = 1;\n}"
  },
  {
    "function_name": "check_https",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2746-2791",
    "snippet": "void check_https(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = https_sock;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl || (https_sock < 0 && https_sock6 < 0)) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (https_sock >= 0) {\n\t\tFD_SET(https_sock, &fds);\n\t}\n\tif (https_sock6 >= 0) {\n\t\tFD_SET(https_sock6, &fds);\n\t\tif (https_sock6 > https_sock) {\n\t\t\tnmax = https_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (https_sock >= 0 && FD_ISSET(https_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS, -1);\n\t}\n\tif (https_sock6 >= 0 && FD_ISSET(https_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS6)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS6, -1);\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define OPENSSL_HTTPS6  5",
      "#define OPENSSL_HTTPS   4"
    ],
    "globals_used": [
      "int https_sock = -1;",
      "int https_sock6 = -1;",
      "void check_https(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "accept_openssl",
          "args": [
            "OPENSSL_HTTPS6",
            "-1"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl(OPENSSL_HTTPS6)\\n\""
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "https_sock6",
            "&fds"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl(OPENSSL_HTTPS)\\n\""
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "https_sock",
            "&fds"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "nmax+1",
            "&fds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "https_sock6",
            "&fds"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "https_sock",
            "&fds"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n\nint https_sock = -1;\nint https_sock6 = -1;\nvoid check_https(void);\n\nvoid check_https(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = https_sock;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl || (https_sock < 0 && https_sock6 < 0)) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (https_sock >= 0) {\n\t\tFD_SET(https_sock, &fds);\n\t}\n\tif (https_sock6 >= 0) {\n\t\tFD_SET(https_sock6, &fds);\n\t\tif (https_sock6 > https_sock) {\n\t\t\tnmax = https_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (https_sock >= 0 && FD_ISSET(https_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS, -1);\n\t}\n\tif (https_sock6 >= 0 && FD_ISSET(https_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_HTTPS6)\\n\");\n\t\taccept_openssl(OPENSSL_HTTPS6, -1);\n\t}\n}"
  },
  {
    "function_name": "check_openssl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2689-2744",
    "snippet": "void check_openssl(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = openssl_sock;\n\tstatic time_t last_waitall = 0;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl) {\n\t\treturn;\n\t}\n\n\tif (time(NULL) > last_waitall + 120) {\n\t\tlast_waitall = time(NULL);\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (openssl_sock >= 0) {\n\t\tFD_SET(openssl_sock, &fds);\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tFD_SET(openssl_sock6, &fds);\n\t\tif (openssl_sock6 > openssl_sock) {\n\t\t\tnmax = openssl_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (openssl_sock >= 0 && FD_ISSET(openssl_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC)\\n\");\n\t\taccept_openssl(OPENSSL_VNC, -1);\n\t}\n\tif (openssl_sock6 >= 0 && FD_ISSET(openssl_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC6)\\n\");\n\t\taccept_openssl(OPENSSL_VNC6, -1);\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define OPENSSL_VNC6    3",
      "#define OPENSSL_VNC     2"
    ],
    "globals_used": [
      "int openssl_sock = -1;",
      "int openssl_sock6 = -1;",
      "void check_openssl(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "accept_openssl",
          "args": [
            "OPENSSL_VNC6",
            "-1"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl(OPENSSL_VNC6)\\n\""
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "openssl_sock6",
            "&fds"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: accept_openssl(OPENSSL_VNC)\\n\""
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "openssl_sock",
            "&fds"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "nmax+1",
            "&fds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "openssl_sock6",
            "&fds"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "openssl_sock",
            "&fds"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssl_helper_pid",
          "args": [
            "0",
            "-2"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2999-3117",
          "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "csock_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3270-3276",
          "snippet": "static void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int csock_timeout_sock = -1;\n\nstatic void csock_timeout (int sig) {\n\trfbLog(\"sig: %d, csock_timeout.\\n\", sig);\n\tif (csock_timeout_sock >= 0) {\n\t\tclose(csock_timeout_sock);\n\t\tcsock_timeout_sock = -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nvoid check_openssl(void);\n\nvoid check_openssl(void) {\n\tfd_set fds;\n\tstruct timeval tv;\n\tint nfds, nmax = openssl_sock;\n\tstatic time_t last_waitall = 0;\n\tstatic double last_check = 0.0;\n\tdouble now;\n\n\tif (! use_openssl) {\n\t\treturn;\n\t}\n\n\tif (time(NULL) > last_waitall + 120) {\n\t\tlast_waitall = time(NULL);\n\t\tssl_helper_pid(0, -2);\t/* waitall */\n\t}\n\n\tif (openssl_sock < 0 && openssl_sock6 < 0) {\n\t\treturn;\n\t}\n\n\tnow = dnow();\n\tif (now < last_check + 0.5) {\n\t\treturn;\n\t}\n\tlast_check = now;\n\n\tFD_ZERO(&fds);\n\tif (openssl_sock >= 0) {\n\t\tFD_SET(openssl_sock, &fds);\n\t}\n\tif (openssl_sock6 >= 0) {\n\t\tFD_SET(openssl_sock6, &fds);\n\t\tif (openssl_sock6 > openssl_sock) {\n\t\t\tnmax = openssl_sock6;\n\t\t}\n\t}\n\n\ttv.tv_sec = 0;\n\ttv.tv_usec = 0;\n\n\tnfds = select(nmax+1, &fds, NULL, NULL, &tv);\n\n\tif (nfds <= 0) {\n\t\treturn;\n\t}\n\n\tif (openssl_sock >= 0 && FD_ISSET(openssl_sock, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC)\\n\");\n\t\taccept_openssl(OPENSSL_VNC, -1);\n\t}\n\tif (openssl_sock6 >= 0 && FD_ISSET(openssl_sock6, &fds)) {\n\t\trfbLog(\"SSL: accept_openssl(OPENSSL_VNC6)\\n\");\n\t\taccept_openssl(OPENSSL_VNC6, -1);\n\t}\n}"
  },
  {
    "function_name": "init_prng",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2631-2685",
    "snippet": "static void init_prng(void) {\n\tint db = 0, bytes, ubytes, fd;\n\tchar file[MSZ], dtmp[100];\n\tunsigned int sr;\n\n\tRAND_file_name(file, MSZ);\n\n\trfbLog(\"RAND_file_name: %s\\n\", file);\n\n\tbytes = RAND_load_file(file, -1);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\t\n\tubytes = RAND_load_file(\"/dev/urandom\", 64);\n\tbytes += ubytes;\n\tif (db) fprintf(stderr, \"bytes read: %d / %d\\n\", bytes, ubytes);\n\n\t/* mix in more predictable stuff as well for fallback */\n\tsprintf(dtmp, \"/tmp/p%.8f.XXXXXX\", dnow());\n\tfd = mkstemp(dtmp);\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t\tunlink(dtmp);\n\t}\n\tsprintf(dtmp, \"%d-%.8f\", (int) getpid(), dnow());\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\n\tif (!RAND_status()) {\n\t\tubytes = -1;\n\t\trfbLog(\"calling RAND_poll()\\n\");\n\t\tRAND_poll();\n\t}\n\t\n\tRAND_bytes((unsigned char *)&sr, 4);\n\tsrand(sr);\n\n\tif (bytes > 0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\",\n\t\t\t    bytes);\n\t\t}\n\t\tif (ubytes > 32 && rnow() < 0.25) {\n\t\t\tRAND_write_file(file);\n\t\t}\n\t\treturn;\n\t}\n\n\tbytes += RAND_load_file(\"/dev/random\", 8);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\tRAND_poll();\n\n\tif (! quiet) {\n\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\", bytes);\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define MSZ 4096"
    ],
    "globals_used": [
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialized PRNG with %d random bytes.\\n\"",
            "bytes"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_poll",
          "args": [],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bytes read: %d\\n\"",
            "bytes"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_load_file",
          "args": [
            "\"/dev/random\"",
            "8"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_write_file",
          "args": [
            "file"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rnow",
          "args": [],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "rnow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "443-452",
          "snippet": "double rnow(void) {\n\tdouble t = dnow();\n\tt = t - ((int) t); \n\tif (t > 1.0) {\n\t\tt = 1.0;\n\t} else if (t < 0.0) {\n\t\tt = 0.0;\n\t}\n\treturn t;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double rnow(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble rnow(void);\n\ndouble rnow(void) {\n\tdouble t = dnow();\n\tt = t - ((int) t); \n\tif (t > 1.0) {\n\t\tt = 1.0;\n\t} else if (t < 0.0) {\n\t\tt = 0.0;\n\t}\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"initialized PRNG with %d random bytes.\\n\"",
            "bytes"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srand",
          "args": [
            "sr"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "(unsigned char *)&sr",
            "4"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_poll",
          "args": [],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"calling RAND_poll()\\n\""
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_status",
          "args": [],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_add",
          "args": [
            "dtmp",
            "strlen(dtmp)",
            "0"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dtmp"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dtmp",
            "\"%d-%.8f\"",
            "(int) getpid()",
            "dnow()"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "dtmp"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_add",
          "args": [
            "dtmp",
            "strlen(dtmp)",
            "0"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dtmp"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "dtmp"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dtmp",
            "\"/tmp/p%.8f.XXXXXX\"",
            "dnow()"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bytes read: %d / %d\\n\"",
            "bytes",
            "ubytes"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_load_file",
          "args": [
            "\"/dev/urandom\"",
            "64"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bytes read: %d\\n\"",
            "bytes"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_load_file",
          "args": [
            "file",
            "-1"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"RAND_file_name: %s\\n\"",
            "file"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_file_name",
          "args": [
            "file",
            "MSZ"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define MSZ 4096\n\nstatic char *get_input(char *tag, char **in);\n\nstatic void init_prng(void) {\n\tint db = 0, bytes, ubytes, fd;\n\tchar file[MSZ], dtmp[100];\n\tunsigned int sr;\n\n\tRAND_file_name(file, MSZ);\n\n\trfbLog(\"RAND_file_name: %s\\n\", file);\n\n\tbytes = RAND_load_file(file, -1);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\t\n\tubytes = RAND_load_file(\"/dev/urandom\", 64);\n\tbytes += ubytes;\n\tif (db) fprintf(stderr, \"bytes read: %d / %d\\n\", bytes, ubytes);\n\n\t/* mix in more predictable stuff as well for fallback */\n\tsprintf(dtmp, \"/tmp/p%.8f.XXXXXX\", dnow());\n\tfd = mkstemp(dtmp);\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t\tunlink(dtmp);\n\t}\n\tsprintf(dtmp, \"%d-%.8f\", (int) getpid(), dnow());\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\n\tif (!RAND_status()) {\n\t\tubytes = -1;\n\t\trfbLog(\"calling RAND_poll()\\n\");\n\t\tRAND_poll();\n\t}\n\t\n\tRAND_bytes((unsigned char *)&sr, 4);\n\tsrand(sr);\n\n\tif (bytes > 0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\",\n\t\t\t    bytes);\n\t\t}\n\t\tif (ubytes > 32 && rnow() < 0.25) {\n\t\t\tRAND_write_file(file);\n\t\t}\n\t\treturn;\n\t}\n\n\tbytes += RAND_load_file(\"/dev/random\", 8);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\tRAND_poll();\n\n\tif (! quiet) {\n\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\", bytes);\n\t}\n}"
  },
  {
    "function_name": "ssl_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2232-2628",
    "snippet": "static void ssl_xfer(int csock, int s_in, int s_out, int is_https) {\n\tint dbxfer = 0, db = 0, check_pending, fdmax, nfd, n, i, err;\n\tchar cbuf[ABSIZE], sbuf[ABSIZE];\n\tint  cptr, sptr, c_rd, c_wr, s_rd, s_wr;\n\tfd_set rd, wr;\n\tstruct timeval tv;\n\tint ssock, cnt = 0, ndata = 0;\n\n\t/*\n\t * we want to switch to a longer timeout for long term VNC\n\t * connections (in case the network is not working for periods of\n\t * time), but we also want the timeout shorter at the beginning\n\t * in case the client went away.\n\t */\n\tdouble start, now;\n\tint tv_https_early = 60;\n\tint tv_https_later = 20;\n\tint tv_vnc_early = 40;\n\tint tv_vnc_later = 43200;\t/* was 300, stunnel: 43200 */\n\tint tv_cutover = 70;\n\tint tv_closing = 60;\n\tint tv_use;\n\n\tif (dbxfer) {\n\t\traw_xfer(csock, s_in, s_out);\n\t\treturn;\n\t}\n\tif (enc_str != NULL) {\n\t\tif (!strcmp(enc_str, \"none\")) {\n\t\t\tusleep(250*1000);\n\t\t\trfbLog(\"doing '-enc none' raw transfer (no encryption)\\n\"); \n\t\t\traw_xfer(csock, s_in, s_out);\n\t\t} else {\n\t\t\tsymmetric_encryption_xfer(csock, s_in, s_out);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\n\tif (db) fprintf(stderr, \"ssl_xfer begin\\n\");\n\n\tstart = dnow();\n\tif (is_https) {\n\t\ttv_use = tv_https_early;\n\t} else {\n\t\ttv_use = tv_vnc_early;\n\t}\n\t\n\n\t/*\n\t * csock: clear text socket with libvncserver.    \"C\"\n\t * ssock: ssl data socket with remote vnc viewer. \"S\"\n\t *\n\t * to cover inetd mode, we have s_in and s_out, but in non-inetd\n\t * mode they both ssock.\n\t *\n\t * cbuf[] is data from csock that we have read but not passed on to ssl \n\t * sbuf[] is data from ssl that we have read but not passed on to csock \n\t */\n\tfor (i=0; i<ABSIZE; i++) {\n\t\tcbuf[i] = '\\0';\n\t\tsbuf[i] = '\\0';\n\t}\n\t\t\n\tif (s_out > s_in) {\n\t\tssock = s_out;\n\t} else {\n\t\tssock = s_in;\n\t}\n\n\tif (csock > ssock) {\n\t\tfdmax = csock; \n\t} else {\n\t\tfdmax = ssock; \n\t}\n\n\tc_rd = 1;\t/* clear text (libvncserver) socket open for reading */\n\tc_wr = 1;\t/* clear text (libvncserver) socket open for writing */\n\ts_rd = 1;\t/* ssl data (remote client)  socket open for reading */\n\ts_wr = 1;\t/* ssl data (remote client)  socket open for writing */\n\n\tcptr = 0;\t/* offsets into ABSIZE buffers */\n\tsptr = 0;\n\n\tif (vencrypt_selected > 0 || anontls_selected > 0) {\n\t\tchar tmp[16];\n\t\t/* read and discard the extra RFB version */\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tread(csock, tmp, 12);\n\t\tif (0) fprintf(stderr, \"extra: %s\\n\", tmp);\n\t}\n\n\twhile (1) {\n\t\tint c_to_s, s_to_c, closing;\n\n\t\tif ( s_wr && (c_rd || cptr > 0) ) {\n\t\t\t/* \n\t\t\t * S is writable and \n\t\t\t * C is readable or some cbuf data remaining\n\t\t\t */\n\t\t\tc_to_s = 1;\n\t\t} else {\n\t\t\tc_to_s = 0;\n\t\t}\n\n\t\tif ( c_wr && (s_rd || sptr > 0) ) {\n\t\t\t/* \n\t\t\t * C is writable and \n\t\t\t * S is readable or some sbuf data remaining\n\t\t\t */\n\t\t\ts_to_c = 1;\n\t\t} else {\n\t\t\ts_to_c = 0;\n\t\t}\n\n\t\tif (! c_to_s && ! s_to_c) {\n\t\t\t/*\n\t\t\t * nothing can be sent either direction.\n\t\t\t * break out of the loop to finish all work.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\n\t\t/* set up the fd sets for the two sockets for read & write: */\n\n\t\tFD_ZERO(&rd);\n\n\t\tif (c_rd && cptr < ABSIZE) {\n\t\t\t/* we could read more from C since cbuf is not full */\n\t\t\tFD_SET(csock, &rd);\n\t\t}\n\t\tif (s_rd) {\n\t\t\t/*\n\t\t\t * we could read more from S since sbuf not full,\n\t\t\t * OR ssl is waiting for more BIO to be able to\n\t\t\t * read and we have some C data still buffered.\n\t\t\t */\n\t\t\tif (sptr < ABSIZE || (cptr > 0 && SSL_want_read(ssl))) {\n\t\t\t\tFD_SET(s_in, &rd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFD_ZERO(&wr);\n\n\t\tif (c_wr && sptr > 0) {\n\t\t\t/* we could write more to C since sbuf is not empty */\n\t\t\tFD_SET(csock, &wr);\n\t\t}\n\t\tif (s_wr) {\n\t\t\t/*\n\t\t\t * we could write more to S since cbuf not empty,\n\t\t\t * OR ssl is waiting for more BIO to be able\n\t\t\t * write and we haven't filled up sbuf yet.\n\t\t\t */\n\t\t\tif (cptr > 0 || (sptr < ABSIZE && SSL_want_write(ssl))) {\n\t\t\t\tFD_SET(s_out, &wr);\n\t\t\t}\n\t\t}\n\n\t\tnow = dnow();\n\t\tif (tv_cutover && now > start + tv_cutover) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: tv_cutover: %d\\n\", getpid(),\n\t\t\t    tv_cutover);\n\t\t\ttv_cutover = 0;\n\t\t\tif (is_https) {\n\t\t\t\ttv_use = tv_https_later;\n\t\t\t} else {\n\t\t\t\ttv_use = tv_vnc_later;\n\t\t\t}\n\t\t\t/* try to clean out some zombies if we can. */\n\t\t\tssl_helper_pid(0, -2);\n\t\t}\n\t\tif (ssl_timeout_secs > 0) {\n\t\t\ttv_use = ssl_timeout_secs;\n\t\t}\n\n\t\tif ( (s_rd && c_rd) || cptr || sptr) {\n\t\t\tclosing = 0;\n\t\t} else {\n\t\t\tclosing = 1;\n\t\t\ttv_use = tv_closing;\n\t\t}\n\n\t\ttv.tv_sec  = tv_use;\n\t\ttv.tv_usec = 0;\n\n\t\t/*  do the select, repeat if interrupted */\n\t\tdo {\n\t\t\tif (ssl_timeout_secs == 0) {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, NULL);\n\t\t\t} else {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, &tv);\n\t\t\t}\n\t\t} while (nfd < 0 && errno == EINTR);\n\n\t\tif (db > 1) fprintf(stderr, \"nfd: %d\\n\", nfd);\n\nif (0) fprintf(stderr, \"nfd[%d]: %d  w/r csock: %d %d s_in: %d %d\\n\", getpid(), nfd, FD_ISSET(csock, &wr), FD_ISSET(csock, &rd), FD_ISSET(s_out, &wr), FD_ISSET(s_in, &rd)); \n\n\t\tif (nfd < 0) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: select error: %d\\n\", getpid(), nfd);\n\t\t\tperror(\"select\");\n\t\t\t/* connection finished */\n\t\t\tgoto done;\t\n\t\t}\n\n\t\tif (nfd == 0) {\n\t\t\tif (!closing && tv_cutover && ndata > 25000) {\n\t\t\t\tstatic int cn = 0;\n\t\t\t\t/* probably ok, early windows iconify */\n\t\t\t\tif (cn++ < 2) {\n\t\t\t\t\trfbLog(\"SSL: ssl_xfer[%d]: early time\"\n\t\t\t\t\t    \"out: %d\\n\", getpid(), ndata);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: connection timedout. %d  tv_use: %d\\n\",\n\t\t\t    getpid(), ndata, tv_use);\n\t\t\t/* connection finished */\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* used to see if SSL_pending() should be checked: */\n\t\tcheck_pending = 0;\n/* AUDIT */\n\n\t\tif (c_wr && FD_ISSET(csock, &wr)) {\n\n\t\t\t/* try to write some of our sbuf to C: */\n\t\t\tn = write(csock, sbuf, sptr); \n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* connection finished XXX double check */\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* shift over the data in sbuf by n */\n\t\t\t\tmemmove(sbuf, sbuf + n, sptr - n);\n\t\t\t\tif (sptr == ABSIZE) {\n\t\t\t\t\tcheck_pending = 1;\n\t\t\t\t}\n\t\t\t\tsptr -= n;\n\n\t\t\t\tif (! s_rd && sptr == 0) {\n\t\t\t\t\t/* finished sending last of sbuf */\n\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\tc_wr = 0;\n\t\t\t\t}\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_wr) {\n\t\t\tif ((cptr > 0 && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (SSL_want_read(ssl) && FD_ISSET(s_in, &rd))) {\n\n\t\t\t\t/* try to write some of our cbuf to S: */\n\n\t\t\t\tn = SSL_write(ssl, cbuf, cptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* shift over the data in cbuf by n */\n\t\t\t\t\tmemmove(cbuf, cbuf + n, cptr - n);\n\t\t\t\t\tcptr -= n;\n\n\t\t\t\t\tif (! c_rd && cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* finished sending last cbuf */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0 && errno != EINTR) {\n\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t/* proceed */\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S finished */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c_rd && FD_ISSET(csock, &rd)) {\n\n\n\t\t\t/* try to read some data from C into our cbuf */\n\n\t\t\tn = read(csock, cbuf + cptr, ABSIZE - cptr);\n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* C is EOF */\n\t\t\t\tc_rd = 0;\n\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* good */\n\n\t\t\t\tcptr += n;\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_rd) {\n\t\t\tif ((sptr < ABSIZE && FD_ISSET(s_in, &rd)) ||\n\t\t\t    (SSL_want_write(ssl) && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (check_pending && SSL_pending(ssl))) {\n\n\t\t\t\t/* try to read some data from S into our sbuf */\n\n\t\t\t\tn = SSL_read(ssl, sbuf + sptr, ABSIZE - sptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* good */\n\n\t\t\t\t\tsptr += n;\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0) {\n\t\t\t\t\t\tif(errno != EINTR) {\n\t\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* proceed */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* S finished */\n\t\t\t\t\t\ts_rd = 0;\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S is EOF */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (sptr == 0 && c_wr) {\n\t\t\t\t\t\t/* and no more in sbuf to send */\n\t\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\t\tc_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdone:\n\trfbLog(\"SSL: ssl_xfer[%d]: closing sockets %d, %d, %d\\n\",\n\t\t\t    getpid(), csock, s_in, s_out);\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n\treturn;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SSL_ERROR_NONE 0",
      "#define ABSIZE 16384"
    ],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);",
      "static char *get_input(char *tag, char **in);",
      "static int vencrypt_selected = 0;",
      "static int anontls_selected = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s_out"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_xfer[%d]: closing sockets %d, %d, %d\\n\"",
            "getpid()",
            "csock",
            "s_in",
            "s_out"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "csock",
            "SHUT_WR"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_shutdown",
          "args": [
            "ssl"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_error",
          "args": [
            "ssl",
            "n"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_read",
          "args": [
            "ssl",
            "sbuf + sptr",
            "ABSIZE - sptr"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_pending",
          "args": [
            "ssl"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_out",
            "&wr"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_want_write",
          "args": [
            "ssl"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_in",
            "&rd"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_shutdown",
          "args": [
            "ssl"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "csock",
            "cbuf + cptr",
            "ABSIZE - cptr"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "csock",
            "&rd"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_shutdown",
          "args": [
            "ssl"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "cbuf",
            "cbuf + n",
            "cptr - n"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_error",
          "args": [
            "ssl",
            "n"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_write",
          "args": [
            "ssl",
            "cbuf",
            "cptr"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_in",
            "&rd"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_want_read",
          "args": [
            "ssl"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_out",
            "&wr"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "csock",
            "SHUT_WR"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "sbuf",
            "sbuf + n",
            "sptr - n"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "csock",
            "sbuf",
            "sptr"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "csock",
            "&wr"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_xfer[%d]: connection timedout. %d  tv_use: %d\\n\"",
            "getpid()",
            "ndata",
            "tv_use"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_xfer[%d]: early time\"\n\t\t\t\t\t    \"out: %d\\n\"",
            "getpid()",
            "ndata"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"select\""
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_xfer[%d]: select error: %d\\n\"",
            "getpid()",
            "nfd"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nfd[%d]: %d  w/r csock: %d %d s_in: %d %d\\n\"",
            "getpid()",
            "nfd",
            "FD_ISSET(csock, &wr)",
            "FD_ISSET(csock, &rd)",
            "FD_ISSET(s_out, &wr)",
            "FD_ISSET(s_in, &rd)"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_in",
            "&rd"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_out",
            "&wr"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "csock",
            "&rd"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "csock",
            "&wr"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"nfd: %d\\n\"",
            "nfd"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fdmax+1",
            "&rd",
            "&wr",
            "NULL",
            "&tv"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fdmax+1",
            "&rd",
            "&wr",
            "NULL",
            "NULL"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssl_helper_pid",
          "args": [
            "0",
            "-2"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_helper_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2999-3117",
          "snippet": "void ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nvoid ssl_helper_pid(pid_t pid, int sock) {\n#\tdefine HPSIZE 256\n\tstatic pid_t helpers[HPSIZE];\n\tstatic int   sockets[HPSIZE], first = 1;\n\tint i, empty, set, status;\n\tstatic int db = 0;\n\n\tif (first) {\n\t\tfor (i=0; i < HPSIZE; i++)  {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = 0;\n\t\t}\n\t\tif (getenv(\"SSL_HELPER_PID_DB\")) {\n\t\t\tdb = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n\n\n\tif (pid == 0) {\n\t\t/* killall or waitall */\n\t\tfor (i=0; i < HPSIZE; i++) {\n\t\t\tif (helpers[i] == 0) {\n\t\t\t\tsockets[i] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (kill(helpers[i], 0) == 0) {\n\t\t\t\tint kret = -2;\n\t\t\t\tpid_t wret;\n\t\t\t\tif (sock != -2) {\n\t\t\t\t\tif (sockets[i] >= 0) {\n\t\t\t\t\t\tclose(sockets[i]);\n\t\t\t\t\t}\n\t\t\t\t\tkret = kill(helpers[i], SIGTERM);\n\t\t\t\t\tif (kret == 0) {\n\t\t\t\t\t\tusleep(20 * 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d)\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n\n\t\t\t\tif (kret == 0 && wret != helpers[i]) {\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k=0; k < 10; k++) {\n\t\t\t\t\t\tusleep(100 * 1000);\n\t\t\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \nif (db) fprintf(stderr, \"  waitret2=%d\\n\", wret);\n\t\t\t\t\t\tif (wret == helpers[i]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (sock == -2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t}\n\t\treturn;\n\t}\n\nif (db) fprintf(stderr, \"ssl_helper_pid(%d, %d)\\n\", pid, sock);\n\n\t/* add (or delete for sock == -1) */\n\tset = 0;\n\tempty = -1;\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == pid) {\n\t\t\tif (sock == -1) {\n#if LIBVNCSERVER_HAVE_SYS_WAIT_H && HAVE_WAITPID\n\t\t\t\tpid_t wret;\n\t\t\t\twret = waitpid(helpers[i], &status, WNOHANG); \n\nif (db) fprintf(stderr, \"waitpid(%d) 2\\n\", helpers[i]);\nif (db) fprintf(stderr, \"  waitret1=%d\\n\", wret);\n#endif\n\t\t\t\thelpers[i] = 0;\n\t\t\t}\n\t\t\tsockets[i] = sock;\n\t\t\tset = 1;\n\t\t} else if (empty == -1 && helpers[i] == 0) {\n\t\t\tempty = i;\n\t\t}\n\t}\n\tif (set || sock == -1) {\n\t\treturn;\t/* done */\n\t}\n\n\t/* now try to store */\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t\treturn;\n\t}\n\tfor (i=0; i < HPSIZE; i++) {\n\t\tif (helpers[i] == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* clear out stale pids: */\n\t\tif (kill(helpers[i], 0) != 0) {\n\t\t\thelpers[i] = 0;\n\t\t\tsockets[i] = -1;\n\t\t\t\n\t\t\tif (empty == -1) {\n\t\t\t\tempty = i;\n\t\t\t}\n\t\t}\n\t}\n\tif (empty >= 0) {\n\t\thelpers[empty] = pid;\n\t\tsockets[empty] = sock;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_xfer[%d]: tv_cutover: %d\\n\"",
            "getpid()",
            "tv_cutover"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "s_out",
            "&wr"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_want_write",
          "args": [
            "ssl"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "csock",
            "&wr"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&wr"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "s_in",
            "&rd"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_want_read",
          "args": [
            "ssl"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "csock",
            "&rd"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rd"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"extra: %s\\n\"",
            "tmp"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmp",
            "0",
            "sizeof(tmp)"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl_xfer begin\\n\""
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"SSL_DEBUG\")"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSL_DEBUG\""
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSL_DEBUG\""
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symmetric_encryption_xfer",
          "args": [
            "csock",
            "s_in",
            "s_out"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "symmetric_encryption_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "4391-4417",
          "snippet": "static void symmetric_encryption_xfer(int csock, int s_in, int s_out) {\n\tchar tmp[100];\n\tchar *cipher, *keyfile, *q;\n\n\tif (! enc_str) {\n\t\treturn;\n\t}\n\tcipher = (char *) malloc(strlen(enc_str) + 100);\n\tq = strchr(enc_str, ':');\n\tif (!q) return;\n\t*q = '\\0';\n\tif (getenv(\"X11VNC_USE_ULTRADSM_IV\")) {\n\t\tsprintf(cipher, \"rev:%s\", enc_str);\n\t} else {\n\t\tsprintf(cipher, \"noultra:rev:%s\", enc_str);\n\t}\n\tkeyfile = strdup(q+1);\n\t*q = ':';\n\n\n\t/* TBD: s_in != s_out */\n\tif (s_out) {}\n\n\tsprintf(tmp, \"fd=%d,%d\", s_in, csock);\n\n\tenc_do(cipher, keyfile, \"-1\", tmp);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nstatic void symmetric_encryption_xfer(int csock, int s_in, int s_out) {\n\tchar tmp[100];\n\tchar *cipher, *keyfile, *q;\n\n\tif (! enc_str) {\n\t\treturn;\n\t}\n\tcipher = (char *) malloc(strlen(enc_str) + 100);\n\tq = strchr(enc_str, ':');\n\tif (!q) return;\n\t*q = '\\0';\n\tif (getenv(\"X11VNC_USE_ULTRADSM_IV\")) {\n\t\tsprintf(cipher, \"rev:%s\", enc_str);\n\t} else {\n\t\tsprintf(cipher, \"noultra:rev:%s\", enc_str);\n\t}\n\tkeyfile = strdup(q+1);\n\t*q = ':';\n\n\n\t/* TBD: s_in != s_out */\n\tif (s_out) {}\n\n\tsprintf(tmp, \"fd=%d,%d\", s_in, csock);\n\n\tenc_do(cipher, keyfile, \"-1\", tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_xfer",
          "args": [
            "csock",
            "s_in",
            "s_out"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "raw_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "4286-4373",
          "snippet": "void raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nvoid raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"doing '-enc none' raw transfer (no encryption)\\n\""
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250*1000"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSL_ERROR_NONE 0\n#define ABSIZE 16384\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\n\nstatic void ssl_xfer(int csock, int s_in, int s_out, int is_https) {\n\tint dbxfer = 0, db = 0, check_pending, fdmax, nfd, n, i, err;\n\tchar cbuf[ABSIZE], sbuf[ABSIZE];\n\tint  cptr, sptr, c_rd, c_wr, s_rd, s_wr;\n\tfd_set rd, wr;\n\tstruct timeval tv;\n\tint ssock, cnt = 0, ndata = 0;\n\n\t/*\n\t * we want to switch to a longer timeout for long term VNC\n\t * connections (in case the network is not working for periods of\n\t * time), but we also want the timeout shorter at the beginning\n\t * in case the client went away.\n\t */\n\tdouble start, now;\n\tint tv_https_early = 60;\n\tint tv_https_later = 20;\n\tint tv_vnc_early = 40;\n\tint tv_vnc_later = 43200;\t/* was 300, stunnel: 43200 */\n\tint tv_cutover = 70;\n\tint tv_closing = 60;\n\tint tv_use;\n\n\tif (dbxfer) {\n\t\traw_xfer(csock, s_in, s_out);\n\t\treturn;\n\t}\n\tif (enc_str != NULL) {\n\t\tif (!strcmp(enc_str, \"none\")) {\n\t\t\tusleep(250*1000);\n\t\t\trfbLog(\"doing '-enc none' raw transfer (no encryption)\\n\"); \n\t\t\traw_xfer(csock, s_in, s_out);\n\t\t} else {\n\t\t\tsymmetric_encryption_xfer(csock, s_in, s_out);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\n\tif (db) fprintf(stderr, \"ssl_xfer begin\\n\");\n\n\tstart = dnow();\n\tif (is_https) {\n\t\ttv_use = tv_https_early;\n\t} else {\n\t\ttv_use = tv_vnc_early;\n\t}\n\t\n\n\t/*\n\t * csock: clear text socket with libvncserver.    \"C\"\n\t * ssock: ssl data socket with remote vnc viewer. \"S\"\n\t *\n\t * to cover inetd mode, we have s_in and s_out, but in non-inetd\n\t * mode they both ssock.\n\t *\n\t * cbuf[] is data from csock that we have read but not passed on to ssl \n\t * sbuf[] is data from ssl that we have read but not passed on to csock \n\t */\n\tfor (i=0; i<ABSIZE; i++) {\n\t\tcbuf[i] = '\\0';\n\t\tsbuf[i] = '\\0';\n\t}\n\t\t\n\tif (s_out > s_in) {\n\t\tssock = s_out;\n\t} else {\n\t\tssock = s_in;\n\t}\n\n\tif (csock > ssock) {\n\t\tfdmax = csock; \n\t} else {\n\t\tfdmax = ssock; \n\t}\n\n\tc_rd = 1;\t/* clear text (libvncserver) socket open for reading */\n\tc_wr = 1;\t/* clear text (libvncserver) socket open for writing */\n\ts_rd = 1;\t/* ssl data (remote client)  socket open for reading */\n\ts_wr = 1;\t/* ssl data (remote client)  socket open for writing */\n\n\tcptr = 0;\t/* offsets into ABSIZE buffers */\n\tsptr = 0;\n\n\tif (vencrypt_selected > 0 || anontls_selected > 0) {\n\t\tchar tmp[16];\n\t\t/* read and discard the extra RFB version */\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tread(csock, tmp, 12);\n\t\tif (0) fprintf(stderr, \"extra: %s\\n\", tmp);\n\t}\n\n\twhile (1) {\n\t\tint c_to_s, s_to_c, closing;\n\n\t\tif ( s_wr && (c_rd || cptr > 0) ) {\n\t\t\t/* \n\t\t\t * S is writable and \n\t\t\t * C is readable or some cbuf data remaining\n\t\t\t */\n\t\t\tc_to_s = 1;\n\t\t} else {\n\t\t\tc_to_s = 0;\n\t\t}\n\n\t\tif ( c_wr && (s_rd || sptr > 0) ) {\n\t\t\t/* \n\t\t\t * C is writable and \n\t\t\t * S is readable or some sbuf data remaining\n\t\t\t */\n\t\t\ts_to_c = 1;\n\t\t} else {\n\t\t\ts_to_c = 0;\n\t\t}\n\n\t\tif (! c_to_s && ! s_to_c) {\n\t\t\t/*\n\t\t\t * nothing can be sent either direction.\n\t\t\t * break out of the loop to finish all work.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tcnt++;\n\n\t\t/* set up the fd sets for the two sockets for read & write: */\n\n\t\tFD_ZERO(&rd);\n\n\t\tif (c_rd && cptr < ABSIZE) {\n\t\t\t/* we could read more from C since cbuf is not full */\n\t\t\tFD_SET(csock, &rd);\n\t\t}\n\t\tif (s_rd) {\n\t\t\t/*\n\t\t\t * we could read more from S since sbuf not full,\n\t\t\t * OR ssl is waiting for more BIO to be able to\n\t\t\t * read and we have some C data still buffered.\n\t\t\t */\n\t\t\tif (sptr < ABSIZE || (cptr > 0 && SSL_want_read(ssl))) {\n\t\t\t\tFD_SET(s_in, &rd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFD_ZERO(&wr);\n\n\t\tif (c_wr && sptr > 0) {\n\t\t\t/* we could write more to C since sbuf is not empty */\n\t\t\tFD_SET(csock, &wr);\n\t\t}\n\t\tif (s_wr) {\n\t\t\t/*\n\t\t\t * we could write more to S since cbuf not empty,\n\t\t\t * OR ssl is waiting for more BIO to be able\n\t\t\t * write and we haven't filled up sbuf yet.\n\t\t\t */\n\t\t\tif (cptr > 0 || (sptr < ABSIZE && SSL_want_write(ssl))) {\n\t\t\t\tFD_SET(s_out, &wr);\n\t\t\t}\n\t\t}\n\n\t\tnow = dnow();\n\t\tif (tv_cutover && now > start + tv_cutover) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: tv_cutover: %d\\n\", getpid(),\n\t\t\t    tv_cutover);\n\t\t\ttv_cutover = 0;\n\t\t\tif (is_https) {\n\t\t\t\ttv_use = tv_https_later;\n\t\t\t} else {\n\t\t\t\ttv_use = tv_vnc_later;\n\t\t\t}\n\t\t\t/* try to clean out some zombies if we can. */\n\t\t\tssl_helper_pid(0, -2);\n\t\t}\n\t\tif (ssl_timeout_secs > 0) {\n\t\t\ttv_use = ssl_timeout_secs;\n\t\t}\n\n\t\tif ( (s_rd && c_rd) || cptr || sptr) {\n\t\t\tclosing = 0;\n\t\t} else {\n\t\t\tclosing = 1;\n\t\t\ttv_use = tv_closing;\n\t\t}\n\n\t\ttv.tv_sec  = tv_use;\n\t\ttv.tv_usec = 0;\n\n\t\t/*  do the select, repeat if interrupted */\n\t\tdo {\n\t\t\tif (ssl_timeout_secs == 0) {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, NULL);\n\t\t\t} else {\n\t\t\t\tnfd = select(fdmax+1, &rd, &wr, NULL, &tv);\n\t\t\t}\n\t\t} while (nfd < 0 && errno == EINTR);\n\n\t\tif (db > 1) fprintf(stderr, \"nfd: %d\\n\", nfd);\n\nif (0) fprintf(stderr, \"nfd[%d]: %d  w/r csock: %d %d s_in: %d %d\\n\", getpid(), nfd, FD_ISSET(csock, &wr), FD_ISSET(csock, &rd), FD_ISSET(s_out, &wr), FD_ISSET(s_in, &rd)); \n\n\t\tif (nfd < 0) {\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: select error: %d\\n\", getpid(), nfd);\n\t\t\tperror(\"select\");\n\t\t\t/* connection finished */\n\t\t\tgoto done;\t\n\t\t}\n\n\t\tif (nfd == 0) {\n\t\t\tif (!closing && tv_cutover && ndata > 25000) {\n\t\t\t\tstatic int cn = 0;\n\t\t\t\t/* probably ok, early windows iconify */\n\t\t\t\tif (cn++ < 2) {\n\t\t\t\t\trfbLog(\"SSL: ssl_xfer[%d]: early time\"\n\t\t\t\t\t    \"out: %d\\n\", getpid(), ndata);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trfbLog(\"SSL: ssl_xfer[%d]: connection timedout. %d  tv_use: %d\\n\",\n\t\t\t    getpid(), ndata, tv_use);\n\t\t\t/* connection finished */\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* used to see if SSL_pending() should be checked: */\n\t\tcheck_pending = 0;\n/* AUDIT */\n\n\t\tif (c_wr && FD_ISSET(csock, &wr)) {\n\n\t\t\t/* try to write some of our sbuf to C: */\n\t\t\tn = write(csock, sbuf, sptr); \n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* connection finished XXX double check */\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t/* shift over the data in sbuf by n */\n\t\t\t\tmemmove(sbuf, sbuf + n, sptr - n);\n\t\t\t\tif (sptr == ABSIZE) {\n\t\t\t\t\tcheck_pending = 1;\n\t\t\t\t}\n\t\t\t\tsptr -= n;\n\n\t\t\t\tif (! s_rd && sptr == 0) {\n\t\t\t\t\t/* finished sending last of sbuf */\n\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\tc_wr = 0;\n\t\t\t\t}\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_wr) {\n\t\t\tif ((cptr > 0 && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (SSL_want_read(ssl) && FD_ISSET(s_in, &rd))) {\n\n\t\t\t\t/* try to write some of our cbuf to S: */\n\n\t\t\t\tn = SSL_write(ssl, cbuf, cptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* shift over the data in cbuf by n */\n\t\t\t\t\tmemmove(cbuf, cbuf + n, cptr - n);\n\t\t\t\t\tcptr -= n;\n\n\t\t\t\t\tif (! c_rd && cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* finished sending last cbuf */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0 && errno != EINTR) {\n\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t\t/* proceed */\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S finished */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c_rd && FD_ISSET(csock, &rd)) {\n\n\n\t\t\t/* try to read some data from C into our cbuf */\n\n\t\t\tn = read(csock, cbuf + cptr, ABSIZE - cptr);\n\n\t\t\tif (n < 0) {\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/* proceed */\n\t\t\t} else if (n == 0) {\n\t\t\t\t/* C is EOF */\n\t\t\t\tc_rd = 0;\n\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\ts_wr = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* good */\n\n\t\t\t\tcptr += n;\n\t\t\t\tndata += n;\n\t\t\t}\n\t\t}\n\n\t\tif (s_rd) {\n\t\t\tif ((sptr < ABSIZE && FD_ISSET(s_in, &rd)) ||\n\t\t\t    (SSL_want_write(ssl) && FD_ISSET(s_out, &wr)) ||\n\t\t\t    (check_pending && SSL_pending(ssl))) {\n\n\t\t\t\t/* try to read some data from S into our sbuf */\n\n\t\t\t\tn = SSL_read(ssl, sbuf + sptr, ABSIZE - sptr);\n\t\t\t\terr = SSL_get_error(ssl, n);\n\n\t\t\t\tif (err == SSL_ERROR_NONE) {\n\t\t\t\t\t/* good */\n\n\t\t\t\t\tsptr += n;\n\t\t\t\t\tndata += n;\n\n\t\t\t\t} else if (err == SSL_ERROR_WANT_WRITE\n\t\t\t\t\t|| err == SSL_ERROR_WANT_READ\n\t\t\t\t\t|| err == SSL_ERROR_WANT_X509_LOOKUP) {\n\n\t\t\t\t\t\t;\t/* proceed */\n\n\t\t\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\t\t\t\t\tif (n < 0) {\n\t\t\t\t\t\tif(errno != EINTR) {\n\t\t\t\t\t\t\t/* connection finished */\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* proceed */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* S finished */\n\t\t\t\t\t\ts_rd = 0;\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\t\t\t\t\t/* S is EOF */\n\t\t\t\t\ts_rd = 0;\n\t\t\t\t\tif (cptr == 0 && s_wr) {\n\t\t\t\t\t\t/* and no more in cbuf to send */\n\t\t\t\t\t\tSSL_shutdown(ssl);\n\t\t\t\t\t\ts_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (sptr == 0 && c_wr) {\n\t\t\t\t\t\t/* and no more in sbuf to send */\n\t\t\t\t\t\tshutdown(csock, SHUT_WR);\n\t\t\t\t\t\tc_wr = 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (err == SSL_ERROR_SSL) {\n\t\t\t\t\t/* connection finished */\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdone:\n\trfbLog(\"SSL: ssl_xfer[%d]: closing sockets %d, %d, %d\\n\",\n\t\t\t    getpid(), csock, s_in, s_out);\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n\treturn;\n}"
  },
  {
    "function_name": "ssl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "2010-2228",
    "snippet": "static int ssl_init(int s_in, int s_out, int skip_vnc_tls, double last_https) {\n\tunsigned char *sid = (unsigned char *) \"x11vnc SID\";\n\tchar *name = NULL;\n\tint peerport = 0;\n\tint db = 0, rc, err;\n\tint ssock = s_in;\n\tdouble start = dnow();\n\tint timeout = 20;\n\n\tif (enc_str != NULL) {\n\t\treturn 1;\n\t}\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\tusleep(100 * 1000);\n\tif (getenv(\"SSL_INIT_TIMEOUT\")) {\n\t\ttimeout = atoi(getenv(\"SSL_INIT_TIMEOUT\"));\n\t} else if (client_connect != NULL && strstr(client_connect, \"repeater\")) {\n\t\trfbLog(\"SSL: ssl_init[%d]: detected 'repeater' in connect string.\\n\", getpid());\n\t\trfbLog(\"SSL: setting timeout to 1 hour: -env SSL_INIT_TIMEOUT=3600\\n\");\n\t\trfbLog(\"SSL: use that option to set a different timeout value,\\n\");\n\t\trfbLog(\"SSL: however note that with Windows UltraVNC repeater it\\n\");\n\t\trfbLog(\"SSL: may timeout before your setting due to other reasons.\\n\");\n\t\ttimeout = 3600;\n\t}\n\n\tif (skip_vnc_tls) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: HTTPS mode, skipping check_vnc_tls_mode()\\n\",\n\t\t    getpid());\n\t} else if (!check_vnc_tls_mode(s_in, s_out, last_https)) {\n\t\treturn 0;\n\t}\n\trfbLog(\"SSL: ssl_init[%d]: %d/%d initialization timeout: %d secs.\\n\",\n\t    getpid(), s_in, s_out, timeout);\n\n\tssl = SSL_new(ctx);\n\tif (ssl == NULL) {\n\t\tfprintf(stderr, \"SSL_new failed\\n\");\n\t\treturn 0;\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 1\\n\");\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (s_in == s_out) {\n\t\tif (! SSL_set_fd(ssl, ssock)) {\n\t\t\tfprintf(stderr, \"SSL_set_fd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (! SSL_set_rfd(ssl, s_in)) {\n\t\t\tfprintf(stderr, \"SSL_set_rfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (! SSL_set_wfd(ssl, s_out)) {\n\t\t\tfprintf(stderr, \"SSL_set_wfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 2\\n\");\n\n\tif (ssl_client_mode) {\n\t\tSSL_set_connect_state(ssl);\n\t} else {\n\t\tSSL_set_accept_state(ssl);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 3\\n\");\n\n\tname = get_remote_host(ssock);\n\tpeerport = get_remote_port(ssock);\n\n\tif (!strcmp(name, \"0.0.0.0\") && openssl_last_ip != NULL) {\n\t\tname = strdup(openssl_last_ip);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 4\\n\");\n\n\twhile (1) {\n\n\t\tsignal(SIGALRM, ssl_timeout);\n\t\talarm(timeout);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_connect...\\n\");\n\t\t\trc = SSL_connect(ssl);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_accept...\\n\");\n\t\t\trc = SSL_accept(ssl);\n\t\t}\n\t\terr = SSL_get_error(ssl, rc);\n\n\t\talarm(0);\n\t\tsignal(SIGALRM, SIG_DFL);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"SSL_connect %d/%d\\n\", rc, err);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"SSL_accept %d/%d\\n\", rc, err);\n\t\t}\n\t\tif (err == SSL_ERROR_NONE) {\n\t\t\tbreak;\n\t\t} else if (err == SSL_ERROR_WANT_READ) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_READ\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 1\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\t\t\t\n\t\t} else if (err == SSL_ERROR_WANT_WRITE) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_WRITE\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 2\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_SYSCALL\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 3\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_ZERO_RETURN\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 4\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (rc < 0) {\n\t\t\tunsigned long err;\n\t\t\tint cnt = 0;\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() *FATAL: %d SSL FAILED\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", rc);\n\t\t\twhile ((err = ERR_get_error()) != 0) {\n\t\t\t\trfbLog(\"SSL: %s\\n\", ERR_error_string(err, NULL));\n\t\t\t\tif (cnt++ > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (dnow() > start + 3.0) {\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: timeout looping %s() \"\n\t\t\t    \"fatal.\\n\", getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\");\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else {\n\t\t\tBIO *bio = SSL_get_rbio(ssl);\n\t\t\tif (bio == NULL) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is null. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (BIO_eof(bio)) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is EOF. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\n\tif (ssl_client_mode) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_connect() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_accept() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t}\n\n\tpr_ssl_info(0);\n\n\tif (SSL_get_verify_result(ssl) == X509_V_OK) {\n\t\tX509 *x;\n\t\tFILE *cr = NULL;\n\t\tif (certret != NULL) {\n\t\t\tcr = fopen(certret, \"w\");\n\t\t}\n\t\t\n\t\tx = SSL_get_peer_certificate(ssl);\t\n\t\tif (x == NULL) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 peer cert is null\\n\", getpid(), name);\n\t\t\tif (cr != NULL) {\n\t\t\t\tfprintf(cr, \"NOCERT\\n\");\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 cert is:\\n\", getpid(), name);\n#if HAVE_X509_PRINT_EX_FP\n\t\t\tX509_print_ex_fp(stderr, x, 0, XN_FLAG_MULTILINE);\n#endif\n\t\t\tif (cr != NULL) {\n#if HAVE_X509_PRINT_EX_FP\n\t\t\t\tX509_print_ex_fp(cr, x, 0, XN_FLAG_MULTILINE);\n#else\n\t\t\t\trfbLog(\"** not compiled with libssl X509_print_ex_fp() function **\\n\");\n\t\t\t\tif (users_list && strstr(users_list, \"sslpeer=\")) {\n\t\t\t\t\trfbLog(\"** -users sslpeer= will not work! **\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t}\n\t}\n\tfree(name);\n\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define SSL_ERROR_NONE 0"
    ],
    "globals_used": [
      "char *openssl_last_ip = NULL;",
      "static char *certret = NULL;",
      "void raw_xfer(int csock, int s_in, int s_out);",
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "cr"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"** -users sslpeer= will not work! **\\n\""
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "users_list",
            "\"sslpeer=\""
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"** not compiled with libssl X509_print_ex_fp() function **\\n\""
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_print_ex_fp",
          "args": [
            "cr",
            "x",
            "0",
            "XN_FLAG_MULTILINE"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_print_ex_fp",
          "args": [
            "stderr",
            "x",
            "0",
            "XN_FLAG_MULTILINE"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: accepted client %s x509 cert is:\\n\"",
            "getpid()",
            "name"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "cr"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "cr",
            "\"NOCERT\\n\""
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: accepted client %s x509 peer cert is null\\n\"",
            "getpid()",
            "name"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_peer_certificate",
          "args": [
            "ssl"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "certret",
            "\"w\""
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_verify_result",
          "args": [
            "ssl"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_ssl_info",
          "args": [
            "0"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "pr_ssl_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1959-1997",
          "snippet": "static void pr_ssl_info(int verb) {\n\tSSL_CIPHER *c;\n\tSSL_SESSION *s;\n\tchar *proto = \"unknown\";\n\tint ssl_version;\n\n\tif (verb) {}\n\n\tif (ssl == NULL) {\n\t\treturn;\n\t}\n\tc = SSL_get_current_cipher(ssl);\n\ts = SSL_get_session(ssl);\n\n\tif (s) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tssl_version = SSL_SESSION_get_protocol_version(s);\n#else\n\t\tssl_version = s->ssl_version;\n#endif\n\t}\n\n\tif (s == NULL) {\n\t\tproto = \"nosession\";\n\t} else if (ssl_version == SSL2_VERSION) {\n\t\tproto = \"SSLv2\";\n\t} else if (ssl_version == SSL3_VERSION) {\n\t\tproto = \"SSLv3\";\n\t} else if (ssl_version == TLS1_VERSION) {\n\t\tproto = \"TLSv1\";\n\t}\n\tif (c != NULL) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Cipher: %s %s Proto: %s\\n\", getpid(),\n\t\t    SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c), proto);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Proto: %s\\n\", getpid(),\n\t\t    proto);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void pr_ssl_info(int verb) {\n\tSSL_CIPHER *c;\n\tSSL_SESSION *s;\n\tchar *proto = \"unknown\";\n\tint ssl_version;\n\n\tif (verb) {}\n\n\tif (ssl == NULL) {\n\t\treturn;\n\t}\n\tc = SSL_get_current_cipher(ssl);\n\ts = SSL_get_session(ssl);\n\n\tif (s) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tssl_version = SSL_SESSION_get_protocol_version(s);\n#else\n\t\tssl_version = s->ssl_version;\n#endif\n\t}\n\n\tif (s == NULL) {\n\t\tproto = \"nosession\";\n\t} else if (ssl_version == SSL2_VERSION) {\n\t\tproto = \"SSLv2\";\n\t} else if (ssl_version == SSL3_VERSION) {\n\t\tproto = \"SSLv3\";\n\t} else if (ssl_version == TLS1_VERSION) {\n\t\tproto = \"TLSv1\";\n\t}\n\tif (c != NULL) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Cipher: %s %s Proto: %s\\n\", getpid(),\n\t\t    SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c), proto);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Proto: %s\\n\", getpid(),\n\t\t    proto);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: SSL_accept() succeeded for: %s:%d\\n\"",
            "getpid()",
            "name",
            "peerport"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: SSL_connect() succeeded for: %s:%d\\n\"",
            "getpid()",
            "name",
            "peerport"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: ssl BIO is EOF. \"\n\t\t\t\t    \"fatal.\\n\"",
            "getpid()"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_eof",
          "args": [
            "bio"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: ssl BIO is null. \"\n\t\t\t\t    \"fatal.\\n\"",
            "getpid()"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_rbio",
          "args": [
            "ssl"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: timeout looping %s() \"\n\t\t\t    \"fatal.\\n\"",
            "getpid()",
            "ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\""
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: %s\\n\"",
            "ERR_error_string(err, NULL)"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_error_string",
          "args": [
            "err",
            "NULL"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: %s() *FATAL: %d SSL FAILED\\n\"",
            "getpid()",
            "ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\"",
            "rc"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 4\\n\"",
            "getpid()",
            "ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\"",
            "name",
            "peerport"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"got SSL_ERROR_ZERO_RETURN\\n\""
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 3\\n\"",
            "getpid()",
            "ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\"",
            "name",
            "peerport"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"got SSL_ERROR_SYSCALL\\n\""
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 2\\n\"",
            "getpid()",
            "ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\"",
            "name",
            "peerport"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"got SSL_ERROR_WANT_WRITE\\n\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 1\\n\"",
            "getpid()",
            "ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\"",
            "name",
            "peerport"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"got SSL_ERROR_WANT_READ\\n\""
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_accept %d/%d\\n\"",
            "rc",
            "err"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_connect %d/%d\\n\"",
            "rc",
            "err"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "SIG_DFL"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm",
          "args": [
            "0"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSL_get_error",
          "args": [
            "ssl",
            "rc"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_accept",
          "args": [
            "ssl"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"calling SSL_accept...\\n\""
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_connect",
          "args": [
            "ssl"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"calling SSL_connect...\\n\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGALRM",
            "ssl_timeout"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl_init: 4\\n\""
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "openssl_last_ip"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"0.0.0.0\""
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_remote_port",
          "args": [
            "ssock"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "226-228",
          "snippet": "int get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nint get_remote_port(int sock) {\n\treturn get_port(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_remote_host",
          "args": [
            "ssock"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "get_remote_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/inet.c",
          "lines": "258-260",
          "snippet": "char *get_remote_host(int sock) {\n\treturn get_host(sock, 1);\n}",
          "includes": [
            "#include <sys/un.h>",
            "#include \"sslhelper.h\"",
            "#include \"unixpw.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int get_remote_port(int sock);",
            "int get_local_port(int sock);",
            "char *get_remote_host(int sock);",
            "char *get_local_host(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/un.h>\n#include \"sslhelper.h\"\n#include \"unixpw.h\"\n#include \"x11vnc.h\"\n\nint get_remote_port(int sock);\nint get_local_port(int sock);\nchar *get_remote_host(int sock);\nchar *get_local_host(int sock);\n\nchar *get_remote_host(int sock) {\n\treturn get_host(sock, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl_init: 3\\n\""
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_accept_state",
          "args": [
            "ssl"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_connect_state",
          "args": [
            "ssl"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl_init: 2\\n\""
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_set_wfd failed\\n\""
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_wfd",
          "args": [
            "ssl",
            "s_out"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_set_rfd failed\\n\""
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_rfd",
          "args": [
            "ssl",
            "s_in"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_set_fd failed\\n\""
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_fd",
          "args": [
            "ssl",
            "ssock"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_session_id_context",
          "args": [
            "ssl",
            "sid",
            "strlen((char *)sid)"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(char *)sid"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl_init: 1\\n\""
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_new failed\\n\""
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_new",
          "args": [
            "ctx"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_init[%d]: %d/%d initialization timeout: %d secs.\\n\"",
            "getpid()",
            "s_in",
            "s_out",
            "timeout"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_vnc_tls_mode",
          "args": [
            "s_in",
            "s_out",
            "last_https"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "check_vnc_tls_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1794-1957",
          "snippet": "static int check_vnc_tls_mode(int s_in, int s_out, double last_https) {\n\tdouble waited = 0.0, waitmax = 1.4, dt = 0.01, start = dnow();\n\tstruct timeval tv;\n\tint input = 0, i, n, ok;\n\tint major, minor, sectype = -1;\n\tchar *proto = \"RFB 003.008\\n\";\n\tchar *stype = \"unknown\";\n\tchar buf[256];\n\t\n\tvencrypt_selected = 0;\n\tanontls_selected = 0;\n\n\tif (vencrypt_mode == VENCRYPT_NONE && anontls_mode == ANONTLS_NONE) {\n\t\t/* only normal SSL */\n\t\treturn 1;\n\t}\n\tif (ssl_client_mode) {\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE in client\\n\");\n\t\t\trfbLog(\"check_vnc_tls_mode: connect mode.\\n\");\n\t\t\t/* this is OK, continue on below for dialog. */\n\t\t} else {\n\t\t\t/* otherwise we must assume normal SSL (we send client hello) */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (ssl_verify && vencrypt_mode != VENCRYPT_FORCE && anontls_mode == ANONTLS_FORCE) {\n\t\trfbLog(\"check_vnc_tls_mode: Cannot use ANONTLS_FORCE with -sslverify (Anon DH only)\\n\");\n\t\t/* fallback to normal SSL */\n\t\treturn 1;\n\t}\n\n\tif (last_https > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_https + 5.0) {\n\t\t\twaitmax = 20.0;\n\t\t} else if (now < last_https + 15.0) {\n\t\t\twaitmax = 10.0;\n\t\t} else if (now < last_https + 30.0) {\n\t\t\twaitmax = 5.0;\n\t\t} else if (now < last_https + 60.0) {\n\t\t\twaitmax = 2.5;\n\t\t}\n\t}\n\n\twhile (waited < waitmax) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(s_in, &rfds);\n\t\ttv.tv_sec = 0; \n\t\ttv.tv_usec = 0; \n\t\tselect(s_in+1, &rfds, NULL, NULL, &tv);\n\t\tif (FD_ISSET(s_in, &rfds)) {\n\t\t\tinput = 1;\n\t\t\tbreak;\n\t\t}\n\t\tusleep((int) (1000 * 1000 * dt));\n\t\twaited += dt;\n\t}\n\trfbLog(\"check_vnc_tls_mode: waited: %f / %.2f input: %s\\n\",\n\t    dnow() - start, waitmax, input ? \"SSL Handshake\" : \"(future) RFB Handshake\");\n\n\tif (input) {\n\t\t/* got SSL client hello, can only assume normal SSL */\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE prevents normal SSL\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* send RFB 003.008 -- there is no turning back from this point... */\n\tif (!write_exact(s_out, proto, strlen(proto))) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 12)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (sscanf(buf, \"RFB %03d.%03d\\n\", &major, &minor) != 2) {\n\t\tint i;\n\t\trfbLog(\"check_vnc_tls_mode: abnormal handshake: '%s'\\nbytes: \", buf);\n\t\tfor (i=0; i < 12; i++) {\n\t\t\tfprintf(stderr, \"%d.\", (unsigned char) buf[i]);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"check_vnc_tls_mode: version: %d.%d\\n\", major, minor);\n\tif (major != 3 || minor < 8) {\n\t\trfbLog(\"check_vnc_tls_mode: invalid version: '%s'\\n\", buf);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tn = 1;\n\tif (vencrypt_mode == VENCRYPT_FORCE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_FORCE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else if (vencrypt_mode == VENCRYPT_SOLE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_SOLE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else {\n\t\tif (vencrypt_mode == VENCRYPT_SUPPORT) {\n\t\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t\t}\n\t\tif (anontls_mode == ANONTLS_SUPPORT && !ssl_verify) {\n\t\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t\t}\n\t}\n\n\tn--;\n\tbuf[0] = (char) n;\n\tif (!write_exact(s_out, buf, n+1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"wrote[%d] %d %d %d\\n\", n, buf[0], buf[1], buf[2]);\n\n\tbuf[0] = 0;\n\tif (!read_exact(s_in, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (buf[0] == rfbSecTypeVencrypt) stype = \"VeNCrypt\";\n\tif (buf[0] == rfbSecTypeAnonTls)  stype = \"ANONTLS\";\n\n\trfbLog(\"check_vnc_tls_mode: reply: %d (%s)\\n\", (int) buf[0], stype);\n\n\tok = 0;\n\tfor (i=1; i < n+1; i++) {\n\t\tif (buf[0] == buf[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tchar *msg = \"check_vnc_tls_mode: invalid security-type\";\n\t\tint len = strlen(msg);\n\t\trfbLog(\"%s: %d\\n\", msg, (int) buf[0]);\n\t\t((uint32_t *)buf)[0] = Swap32IfLE(len);\n\t\twrite_exact(s_out, buf, 4);\n\t\twrite_exact(s_out, msg, strlen(msg));\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tsectype = (int) buf[0];\n\n\tif (sectype == rfbSecTypeVencrypt) {\n\t\treturn vencrypt_dialog(s_in, s_out);\n\t} else if (sectype == rfbSecTypeAnonTls) {\n\t\treturn anontls_dialog(s_in, s_out);\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define rfbSecTypeVencrypt 19",
            "#define rfbSecTypeAnonTls  18"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define rfbSecTypeVencrypt 19\n#define rfbSecTypeAnonTls  18\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\n\nstatic int check_vnc_tls_mode(int s_in, int s_out, double last_https) {\n\tdouble waited = 0.0, waitmax = 1.4, dt = 0.01, start = dnow();\n\tstruct timeval tv;\n\tint input = 0, i, n, ok;\n\tint major, minor, sectype = -1;\n\tchar *proto = \"RFB 003.008\\n\";\n\tchar *stype = \"unknown\";\n\tchar buf[256];\n\t\n\tvencrypt_selected = 0;\n\tanontls_selected = 0;\n\n\tif (vencrypt_mode == VENCRYPT_NONE && anontls_mode == ANONTLS_NONE) {\n\t\t/* only normal SSL */\n\t\treturn 1;\n\t}\n\tif (ssl_client_mode) {\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE in client\\n\");\n\t\t\trfbLog(\"check_vnc_tls_mode: connect mode.\\n\");\n\t\t\t/* this is OK, continue on below for dialog. */\n\t\t} else {\n\t\t\t/* otherwise we must assume normal SSL (we send client hello) */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (ssl_verify && vencrypt_mode != VENCRYPT_FORCE && anontls_mode == ANONTLS_FORCE) {\n\t\trfbLog(\"check_vnc_tls_mode: Cannot use ANONTLS_FORCE with -sslverify (Anon DH only)\\n\");\n\t\t/* fallback to normal SSL */\n\t\treturn 1;\n\t}\n\n\tif (last_https > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_https + 5.0) {\n\t\t\twaitmax = 20.0;\n\t\t} else if (now < last_https + 15.0) {\n\t\t\twaitmax = 10.0;\n\t\t} else if (now < last_https + 30.0) {\n\t\t\twaitmax = 5.0;\n\t\t} else if (now < last_https + 60.0) {\n\t\t\twaitmax = 2.5;\n\t\t}\n\t}\n\n\twhile (waited < waitmax) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(s_in, &rfds);\n\t\ttv.tv_sec = 0; \n\t\ttv.tv_usec = 0; \n\t\tselect(s_in+1, &rfds, NULL, NULL, &tv);\n\t\tif (FD_ISSET(s_in, &rfds)) {\n\t\t\tinput = 1;\n\t\t\tbreak;\n\t\t}\n\t\tusleep((int) (1000 * 1000 * dt));\n\t\twaited += dt;\n\t}\n\trfbLog(\"check_vnc_tls_mode: waited: %f / %.2f input: %s\\n\",\n\t    dnow() - start, waitmax, input ? \"SSL Handshake\" : \"(future) RFB Handshake\");\n\n\tif (input) {\n\t\t/* got SSL client hello, can only assume normal SSL */\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE prevents normal SSL\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* send RFB 003.008 -- there is no turning back from this point... */\n\tif (!write_exact(s_out, proto, strlen(proto))) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 12)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (sscanf(buf, \"RFB %03d.%03d\\n\", &major, &minor) != 2) {\n\t\tint i;\n\t\trfbLog(\"check_vnc_tls_mode: abnormal handshake: '%s'\\nbytes: \", buf);\n\t\tfor (i=0; i < 12; i++) {\n\t\t\tfprintf(stderr, \"%d.\", (unsigned char) buf[i]);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"check_vnc_tls_mode: version: %d.%d\\n\", major, minor);\n\tif (major != 3 || minor < 8) {\n\t\trfbLog(\"check_vnc_tls_mode: invalid version: '%s'\\n\", buf);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tn = 1;\n\tif (vencrypt_mode == VENCRYPT_FORCE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_FORCE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else if (vencrypt_mode == VENCRYPT_SOLE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_SOLE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else {\n\t\tif (vencrypt_mode == VENCRYPT_SUPPORT) {\n\t\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t\t}\n\t\tif (anontls_mode == ANONTLS_SUPPORT && !ssl_verify) {\n\t\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t\t}\n\t}\n\n\tn--;\n\tbuf[0] = (char) n;\n\tif (!write_exact(s_out, buf, n+1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"wrote[%d] %d %d %d\\n\", n, buf[0], buf[1], buf[2]);\n\n\tbuf[0] = 0;\n\tif (!read_exact(s_in, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (buf[0] == rfbSecTypeVencrypt) stype = \"VeNCrypt\";\n\tif (buf[0] == rfbSecTypeAnonTls)  stype = \"ANONTLS\";\n\n\trfbLog(\"check_vnc_tls_mode: reply: %d (%s)\\n\", (int) buf[0], stype);\n\n\tok = 0;\n\tfor (i=1; i < n+1; i++) {\n\t\tif (buf[0] == buf[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tchar *msg = \"check_vnc_tls_mode: invalid security-type\";\n\t\tint len = strlen(msg);\n\t\trfbLog(\"%s: %d\\n\", msg, (int) buf[0]);\n\t\t((uint32_t *)buf)[0] = Swap32IfLE(len);\n\t\twrite_exact(s_out, buf, 4);\n\t\twrite_exact(s_out, msg, strlen(msg));\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tsectype = (int) buf[0];\n\n\tif (sectype == rfbSecTypeVencrypt) {\n\t\treturn vencrypt_dialog(s_in, s_out);\n\t} else if (sectype == rfbSecTypeAnonTls) {\n\t\treturn anontls_dialog(s_in, s_out);\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: HTTPS mode, skipping check_vnc_tls_mode()\\n\"",
            "getpid()"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: may timeout before your setting due to other reasons.\\n\""
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: however note that with Windows UltraVNC repeater it\\n\""
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: use that option to set a different timeout value,\\n\""
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: setting timeout to 1 hour: -env SSL_INIT_TIMEOUT=3600\\n\""
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_init[%d]: detected 'repeater' in connect string.\\n\"",
            "getpid()"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "client_connect",
            "\"repeater\""
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"SSL_INIT_TIMEOUT\")"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSL_INIT_TIMEOUT\""
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSL_INIT_TIMEOUT\""
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "100 * 1000"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"SSL_DEBUG\")"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSL_DEBUG\""
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SSL_DEBUG\""
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define SSL_ERROR_NONE 0\n\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\n\nstatic int ssl_init(int s_in, int s_out, int skip_vnc_tls, double last_https) {\n\tunsigned char *sid = (unsigned char *) \"x11vnc SID\";\n\tchar *name = NULL;\n\tint peerport = 0;\n\tint db = 0, rc, err;\n\tint ssock = s_in;\n\tdouble start = dnow();\n\tint timeout = 20;\n\n\tif (enc_str != NULL) {\n\t\treturn 1;\n\t}\n\tif (getenv(\"SSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"SSL_DEBUG\"));\n\t}\n\tusleep(100 * 1000);\n\tif (getenv(\"SSL_INIT_TIMEOUT\")) {\n\t\ttimeout = atoi(getenv(\"SSL_INIT_TIMEOUT\"));\n\t} else if (client_connect != NULL && strstr(client_connect, \"repeater\")) {\n\t\trfbLog(\"SSL: ssl_init[%d]: detected 'repeater' in connect string.\\n\", getpid());\n\t\trfbLog(\"SSL: setting timeout to 1 hour: -env SSL_INIT_TIMEOUT=3600\\n\");\n\t\trfbLog(\"SSL: use that option to set a different timeout value,\\n\");\n\t\trfbLog(\"SSL: however note that with Windows UltraVNC repeater it\\n\");\n\t\trfbLog(\"SSL: may timeout before your setting due to other reasons.\\n\");\n\t\ttimeout = 3600;\n\t}\n\n\tif (skip_vnc_tls) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: HTTPS mode, skipping check_vnc_tls_mode()\\n\",\n\t\t    getpid());\n\t} else if (!check_vnc_tls_mode(s_in, s_out, last_https)) {\n\t\treturn 0;\n\t}\n\trfbLog(\"SSL: ssl_init[%d]: %d/%d initialization timeout: %d secs.\\n\",\n\t    getpid(), s_in, s_out, timeout);\n\n\tssl = SSL_new(ctx);\n\tif (ssl == NULL) {\n\t\tfprintf(stderr, \"SSL_new failed\\n\");\n\t\treturn 0;\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 1\\n\");\n\n\tSSL_set_session_id_context(ssl, sid, strlen((char *)sid));\n\n\tif (s_in == s_out) {\n\t\tif (! SSL_set_fd(ssl, ssock)) {\n\t\t\tfprintf(stderr, \"SSL_set_fd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (! SSL_set_rfd(ssl, s_in)) {\n\t\t\tfprintf(stderr, \"SSL_set_rfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (! SSL_set_wfd(ssl, s_out)) {\n\t\t\tfprintf(stderr, \"SSL_set_wfd failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (db > 1) fprintf(stderr, \"ssl_init: 2\\n\");\n\n\tif (ssl_client_mode) {\n\t\tSSL_set_connect_state(ssl);\n\t} else {\n\t\tSSL_set_accept_state(ssl);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 3\\n\");\n\n\tname = get_remote_host(ssock);\n\tpeerport = get_remote_port(ssock);\n\n\tif (!strcmp(name, \"0.0.0.0\") && openssl_last_ip != NULL) {\n\t\tname = strdup(openssl_last_ip);\n\t}\n\n\tif (db > 1) fprintf(stderr, \"ssl_init: 4\\n\");\n\n\twhile (1) {\n\n\t\tsignal(SIGALRM, ssl_timeout);\n\t\talarm(timeout);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_connect...\\n\");\n\t\t\trc = SSL_connect(ssl);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"calling SSL_accept...\\n\");\n\t\t\trc = SSL_accept(ssl);\n\t\t}\n\t\terr = SSL_get_error(ssl, rc);\n\n\t\talarm(0);\n\t\tsignal(SIGALRM, SIG_DFL);\n\n\t\tif (ssl_client_mode) {\n\t\t\tif (db) fprintf(stderr, \"SSL_connect %d/%d\\n\", rc, err);\n\t\t} else {\n\t\t\tif (db) fprintf(stderr, \"SSL_accept %d/%d\\n\", rc, err);\n\t\t}\n\t\tif (err == SSL_ERROR_NONE) {\n\t\t\tbreak;\n\t\t} else if (err == SSL_ERROR_WANT_READ) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_READ\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 1\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\t\t\t\n\t\t} else if (err == SSL_ERROR_WANT_WRITE) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_WANT_WRITE\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 2\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_SYSCALL) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_SYSCALL\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 3\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (err == SSL_ERROR_ZERO_RETURN) {\n\n\t\t\tif (db) fprintf(stderr, \"got SSL_ERROR_ZERO_RETURN\\n\");\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() failed for: %s:%d 4\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", name, peerport);\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (rc < 0) {\n\t\t\tunsigned long err;\n\t\t\tint cnt = 0;\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: %s() *FATAL: %d SSL FAILED\\n\",\n\t\t\t    getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\", rc);\n\t\t\twhile ((err = ERR_get_error()) != 0) {\n\t\t\t\trfbLog(\"SSL: %s\\n\", ERR_error_string(err, NULL));\n\t\t\t\tif (cnt++ > 100) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else if (dnow() > start + 3.0) {\n\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: timeout looping %s() \"\n\t\t\t    \"fatal.\\n\", getpid(), ssl_client_mode ? \"SSL_connect\" : \"SSL_accept\");\n\t\t\tpr_ssl_info(1);\n\t\t\treturn 0;\n\n\t\t} else {\n\t\t\tBIO *bio = SSL_get_rbio(ssl);\n\t\t\tif (bio == NULL) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is null. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (BIO_eof(bio)) {\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: ssl BIO is EOF. \"\n\t\t\t\t    \"fatal.\\n\", getpid());\n\t\t\t\tpr_ssl_info(1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tusleep(10 * 1000);\n\t}\n\n\tif (ssl_client_mode) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_connect() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: SSL_accept() succeeded for: %s:%d\\n\", getpid(), name, peerport);\n\t}\n\n\tpr_ssl_info(0);\n\n\tif (SSL_get_verify_result(ssl) == X509_V_OK) {\n\t\tX509 *x;\n\t\tFILE *cr = NULL;\n\t\tif (certret != NULL) {\n\t\t\tcr = fopen(certret, \"w\");\n\t\t}\n\t\t\n\t\tx = SSL_get_peer_certificate(ssl);\t\n\t\tif (x == NULL) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 peer cert is null\\n\", getpid(), name);\n\t\t\tif (cr != NULL) {\n\t\t\t\tfprintf(cr, \"NOCERT\\n\");\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t} else {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: accepted client %s x509 cert is:\\n\", getpid(), name);\n#if HAVE_X509_PRINT_EX_FP\n\t\t\tX509_print_ex_fp(stderr, x, 0, XN_FLAG_MULTILINE);\n#endif\n\t\t\tif (cr != NULL) {\n#if HAVE_X509_PRINT_EX_FP\n\t\t\t\tX509_print_ex_fp(cr, x, 0, XN_FLAG_MULTILINE);\n#else\n\t\t\t\trfbLog(\"** not compiled with libssl X509_print_ex_fp() function **\\n\");\n\t\t\t\tif (users_list && strstr(users_list, \"sslpeer=\")) {\n\t\t\t\t\trfbLog(\"** -users sslpeer= will not work! **\\n\");\n\t\t\t\t}\n#endif\n\t\t\t\tfclose(cr);\n\t\t\t}\n\t\t}\n\t}\n\tfree(name);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ssl_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1999-2008",
    "snippet": "static void ssl_timeout (int sig) {\n\tint i;\n\trfbLog(\"sig: %d, ssl_init[%d] timed out.\\n\", sig, getpid());\n\trfbLog(\"To increase the SSL initialization timeout use, e.g.:\\n\");\n\trfbLog(\"   -env SSL_INIT_TIMEOUT=120        (for 120 seconds)\\n\");\n\tfor (i=0; i < 256; i++) {\n\t\tclose(i);\n\t}\n\texit(1);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "i"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"   -env SSL_INIT_TIMEOUT=120        (for 120 seconds)\\n\""
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"To increase the SSL initialization timeout use, e.g.:\\n\""
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sig: %d, ssl_init[%d] timed out.\\n\"",
            "sig",
            "getpid()"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void ssl_timeout (int sig) {\n\tint i;\n\trfbLog(\"sig: %d, ssl_init[%d] timed out.\\n\", sig, getpid());\n\trfbLog(\"To increase the SSL initialization timeout use, e.g.:\\n\");\n\trfbLog(\"   -env SSL_INIT_TIMEOUT=120        (for 120 seconds)\\n\");\n\tfor (i=0; i < 256; i++) {\n\t\tclose(i);\n\t}\n\texit(1);\n}"
  },
  {
    "function_name": "pr_ssl_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1959-1997",
    "snippet": "static void pr_ssl_info(int verb) {\n\tSSL_CIPHER *c;\n\tSSL_SESSION *s;\n\tchar *proto = \"unknown\";\n\tint ssl_version;\n\n\tif (verb) {}\n\n\tif (ssl == NULL) {\n\t\treturn;\n\t}\n\tc = SSL_get_current_cipher(ssl);\n\ts = SSL_get_session(ssl);\n\n\tif (s) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tssl_version = SSL_SESSION_get_protocol_version(s);\n#else\n\t\tssl_version = s->ssl_version;\n#endif\n\t}\n\n\tif (s == NULL) {\n\t\tproto = \"nosession\";\n\t} else if (ssl_version == SSL2_VERSION) {\n\t\tproto = \"SSLv2\";\n\t} else if (ssl_version == SSL3_VERSION) {\n\t\tproto = \"SSLv3\";\n\t} else if (ssl_version == TLS1_VERSION) {\n\t\tproto = \"TLSv1\";\n\t}\n\tif (c != NULL) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Cipher: %s %s Proto: %s\\n\", getpid(),\n\t\t    SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c), proto);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Proto: %s\\n\", getpid(),\n\t\t    proto);\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: Proto: %s\\n\"",
            "getpid()",
            "proto"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"SSL: ssl_helper[%d]: Cipher: %s %s Proto: %s\\n\"",
            "getpid()",
            "SSL_CIPHER_get_version(c)",
            "SSL_CIPHER_get_name(c)",
            "proto"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CIPHER_get_name",
          "args": [
            "c"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CIPHER_get_version",
          "args": [
            "c"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_SESSION_get_protocol_version",
          "args": [
            "s"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_session",
          "args": [
            "ssl"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_current_cipher",
          "args": [
            "ssl"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void pr_ssl_info(int verb) {\n\tSSL_CIPHER *c;\n\tSSL_SESSION *s;\n\tchar *proto = \"unknown\";\n\tint ssl_version;\n\n\tif (verb) {}\n\n\tif (ssl == NULL) {\n\t\treturn;\n\t}\n\tc = SSL_get_current_cipher(ssl);\n\ts = SSL_get_session(ssl);\n\n\tif (s) {\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\tssl_version = SSL_SESSION_get_protocol_version(s);\n#else\n\t\tssl_version = s->ssl_version;\n#endif\n\t}\n\n\tif (s == NULL) {\n\t\tproto = \"nosession\";\n\t} else if (ssl_version == SSL2_VERSION) {\n\t\tproto = \"SSLv2\";\n\t} else if (ssl_version == SSL3_VERSION) {\n\t\tproto = \"SSLv3\";\n\t} else if (ssl_version == TLS1_VERSION) {\n\t\tproto = \"TLSv1\";\n\t}\n\tif (c != NULL) {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Cipher: %s %s Proto: %s\\n\", getpid(),\n\t\t    SSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c), proto);\n\t} else {\n\t\trfbLog(\"SSL: ssl_helper[%d]: Proto: %s\\n\", getpid(),\n\t\t    proto);\n\t}\n}"
  },
  {
    "function_name": "check_vnc_tls_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1794-1957",
    "snippet": "static int check_vnc_tls_mode(int s_in, int s_out, double last_https) {\n\tdouble waited = 0.0, waitmax = 1.4, dt = 0.01, start = dnow();\n\tstruct timeval tv;\n\tint input = 0, i, n, ok;\n\tint major, minor, sectype = -1;\n\tchar *proto = \"RFB 003.008\\n\";\n\tchar *stype = \"unknown\";\n\tchar buf[256];\n\t\n\tvencrypt_selected = 0;\n\tanontls_selected = 0;\n\n\tif (vencrypt_mode == VENCRYPT_NONE && anontls_mode == ANONTLS_NONE) {\n\t\t/* only normal SSL */\n\t\treturn 1;\n\t}\n\tif (ssl_client_mode) {\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE in client\\n\");\n\t\t\trfbLog(\"check_vnc_tls_mode: connect mode.\\n\");\n\t\t\t/* this is OK, continue on below for dialog. */\n\t\t} else {\n\t\t\t/* otherwise we must assume normal SSL (we send client hello) */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (ssl_verify && vencrypt_mode != VENCRYPT_FORCE && anontls_mode == ANONTLS_FORCE) {\n\t\trfbLog(\"check_vnc_tls_mode: Cannot use ANONTLS_FORCE with -sslverify (Anon DH only)\\n\");\n\t\t/* fallback to normal SSL */\n\t\treturn 1;\n\t}\n\n\tif (last_https > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_https + 5.0) {\n\t\t\twaitmax = 20.0;\n\t\t} else if (now < last_https + 15.0) {\n\t\t\twaitmax = 10.0;\n\t\t} else if (now < last_https + 30.0) {\n\t\t\twaitmax = 5.0;\n\t\t} else if (now < last_https + 60.0) {\n\t\t\twaitmax = 2.5;\n\t\t}\n\t}\n\n\twhile (waited < waitmax) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(s_in, &rfds);\n\t\ttv.tv_sec = 0; \n\t\ttv.tv_usec = 0; \n\t\tselect(s_in+1, &rfds, NULL, NULL, &tv);\n\t\tif (FD_ISSET(s_in, &rfds)) {\n\t\t\tinput = 1;\n\t\t\tbreak;\n\t\t}\n\t\tusleep((int) (1000 * 1000 * dt));\n\t\twaited += dt;\n\t}\n\trfbLog(\"check_vnc_tls_mode: waited: %f / %.2f input: %s\\n\",\n\t    dnow() - start, waitmax, input ? \"SSL Handshake\" : \"(future) RFB Handshake\");\n\n\tif (input) {\n\t\t/* got SSL client hello, can only assume normal SSL */\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE prevents normal SSL\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* send RFB 003.008 -- there is no turning back from this point... */\n\tif (!write_exact(s_out, proto, strlen(proto))) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 12)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (sscanf(buf, \"RFB %03d.%03d\\n\", &major, &minor) != 2) {\n\t\tint i;\n\t\trfbLog(\"check_vnc_tls_mode: abnormal handshake: '%s'\\nbytes: \", buf);\n\t\tfor (i=0; i < 12; i++) {\n\t\t\tfprintf(stderr, \"%d.\", (unsigned char) buf[i]);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"check_vnc_tls_mode: version: %d.%d\\n\", major, minor);\n\tif (major != 3 || minor < 8) {\n\t\trfbLog(\"check_vnc_tls_mode: invalid version: '%s'\\n\", buf);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tn = 1;\n\tif (vencrypt_mode == VENCRYPT_FORCE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_FORCE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else if (vencrypt_mode == VENCRYPT_SOLE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_SOLE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else {\n\t\tif (vencrypt_mode == VENCRYPT_SUPPORT) {\n\t\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t\t}\n\t\tif (anontls_mode == ANONTLS_SUPPORT && !ssl_verify) {\n\t\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t\t}\n\t}\n\n\tn--;\n\tbuf[0] = (char) n;\n\tif (!write_exact(s_out, buf, n+1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"wrote[%d] %d %d %d\\n\", n, buf[0], buf[1], buf[2]);\n\n\tbuf[0] = 0;\n\tif (!read_exact(s_in, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (buf[0] == rfbSecTypeVencrypt) stype = \"VeNCrypt\";\n\tif (buf[0] == rfbSecTypeAnonTls)  stype = \"ANONTLS\";\n\n\trfbLog(\"check_vnc_tls_mode: reply: %d (%s)\\n\", (int) buf[0], stype);\n\n\tok = 0;\n\tfor (i=1; i < n+1; i++) {\n\t\tif (buf[0] == buf[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tchar *msg = \"check_vnc_tls_mode: invalid security-type\";\n\t\tint len = strlen(msg);\n\t\trfbLog(\"%s: %d\\n\", msg, (int) buf[0]);\n\t\t((uint32_t *)buf)[0] = Swap32IfLE(len);\n\t\twrite_exact(s_out, buf, 4);\n\t\twrite_exact(s_out, msg, strlen(msg));\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tsectype = (int) buf[0];\n\n\tif (sectype == rfbSecTypeVencrypt) {\n\t\treturn vencrypt_dialog(s_in, s_out);\n\t} else if (sectype == rfbSecTypeAnonTls) {\n\t\treturn anontls_dialog(s_in, s_out);\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define rfbSecTypeVencrypt 19",
      "#define rfbSecTypeAnonTls  18"
    ],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);",
      "static char *get_input(char *tag, char **in);",
      "static int vencrypt_selected = 0;",
      "static int anontls_selected = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anontls_dialog",
          "args": [
            "s_in",
            "s_out"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "anontls_dialog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1623-1635",
          "snippet": "static int anontls_dialog(int s_in, int s_out) {\n\n\tif (s_in || s_out) {}\n\tanontls_selected = 1;\n\n\tif (!switch_to_anon_dh()) {\n\t\trfbLog(\"anontls: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\treturn 0;\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static int anontls_selected = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic int anontls_selected = 0;\n\nstatic int anontls_dialog(int s_in, int s_out) {\n\n\tif (s_in || s_out) {}\n\tanontls_selected = 1;\n\n\tif (!switch_to_anon_dh()) {\n\t\trfbLog(\"anontls: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\treturn 0;\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vencrypt_dialog",
          "args": [
            "s_in",
            "s_out"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "vencrypt_dialog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1641-1792",
          "snippet": "static int vencrypt_dialog(int s_in, int s_out) {\n\tchar buf[256], buf2[256];\n\tint subtypes[16];\n\tint n, i, ival, ok, nsubtypes = 0;\n\n\tvencrypt_selected = 0;\n\n\t/* send version 0.2 */\n\tbuf[0] = 0;\n\tbuf[1] = 2;\n\n\tif (!write_exact(s_out, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client version 0.2 */\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"vencrypt: received %d.%d client version.\\n\", (int) buf[0], (int) buf[1]);\n\n\t/* close 0.0 */\n\tif (buf[0] == 0 && buf[1] == 0) {\n\t\trfbLog(\"vencrypt: received 0.0 version, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* accept only 0.2 */\n\tif (buf[0] != 0 || buf[1] != 2) {\n\t\trfbLog(\"vencrypt: unsupported VeNCrypt version, closing connection.\\n\");\n\t\tbuf[0] = (char) 255;\n\t\twrite_exact(s_out, buf, 1);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* tell them OK */\n\tbuf[0] = 0;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\")) {\n\t\tvencrypt_enable_plain_login = atoi(getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\"));\n\t}\n\n\t/* load our list of sub-types: */\n\tn = 0;\n\tif (!ssl_verify && vencrypt_kx != VENCRYPT_NODH) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptTlsVnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsPlain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsNone;\n\t\t\t}\n\t\t}\n\t}\n\tif (vencrypt_kx != VENCRYPT_NOX509) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptX509Vnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509Plain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509None;\n\t\t\t}\n\t\t}\n\t}\n\n\tnsubtypes = n;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\t((uint32_t *)buf)[i] = Swap32IfLE(subtypes[i]);\n\t}\n\n\t/* send number first: */\n\tbuf2[0] = (char) nsubtypes;\n\tif (!write_exact(s_out, buf2, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\t/* and now the list: */\n\tif (!write_exact(s_out, buf, 4*n)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client's selection: */\n\tif (!read_exact(s_in, (char *)&ival, 4)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tival = Swap32IfLE(ival);\n\n\t/* zero means no dice: */\n\tif (ival == 0) {\n\t\trfbLog(\"vencrypt: client selected no sub-type, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* check if he selected a valid one: */\n\tok = 0;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\tif (ival == subtypes[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\trfbLog(\"vencrypt: client selected invalid sub-type: %d\\n\", ival);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t} else {\n\t\tchar *st = \"unknown!!\";\n\t\tif (ival == rfbVencryptTlsNone)\t  st = \"rfbVencryptTlsNone\";\n\t\tif (ival == rfbVencryptTlsVnc)    st = \"rfbVencryptTlsVnc\";\n\t\tif (ival == rfbVencryptTlsPlain)  st = \"rfbVencryptTlsPlain\";\n\t\tif (ival == rfbVencryptX509None)  st = \"rfbVencryptX509None\";\n\t\tif (ival == rfbVencryptX509Vnc)   st = \"rfbVencryptX509Vnc\";\n\t\tif (ival == rfbVencryptX509Plain) st = \"rfbVencryptX509Plain\";\n\t\trfbLog(\"vencrypt: client selected sub-type: %d (%s)\\n\", ival, st);\n\t}\n\n\tvencrypt_selected = ival;\n\n\t/* not documented in spec, send OK: */\n\tbuf[0] = 1;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (vencrypt_selected == rfbVencryptTlsNone ||\n\t    vencrypt_selected == rfbVencryptTlsVnc  ||\n\t    vencrypt_selected == rfbVencryptTlsPlain) {\n\t\t/* these modes are Anonymous Diffie-Hellman */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"vencrypt: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define rfbVencryptX509Plain\t262",
            "#define rfbVencryptX509Vnc\t261",
            "#define rfbVencryptX509None\t260",
            "#define rfbVencryptTlsPlain\t259",
            "#define rfbVencryptTlsVnc\t258",
            "#define rfbVencryptTlsNone\t257"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "static int vencrypt_selected = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define rfbVencryptX509Plain\t262\n#define rfbVencryptX509Vnc\t261\n#define rfbVencryptX509None\t260\n#define rfbVencryptTlsPlain\t259\n#define rfbVencryptTlsVnc\t258\n#define rfbVencryptTlsNone\t257\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nstatic int vencrypt_selected = 0;\n\nstatic int vencrypt_dialog(int s_in, int s_out) {\n\tchar buf[256], buf2[256];\n\tint subtypes[16];\n\tint n, i, ival, ok, nsubtypes = 0;\n\n\tvencrypt_selected = 0;\n\n\t/* send version 0.2 */\n\tbuf[0] = 0;\n\tbuf[1] = 2;\n\n\tif (!write_exact(s_out, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client version 0.2 */\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"vencrypt: received %d.%d client version.\\n\", (int) buf[0], (int) buf[1]);\n\n\t/* close 0.0 */\n\tif (buf[0] == 0 && buf[1] == 0) {\n\t\trfbLog(\"vencrypt: received 0.0 version, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* accept only 0.2 */\n\tif (buf[0] != 0 || buf[1] != 2) {\n\t\trfbLog(\"vencrypt: unsupported VeNCrypt version, closing connection.\\n\");\n\t\tbuf[0] = (char) 255;\n\t\twrite_exact(s_out, buf, 1);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* tell them OK */\n\tbuf[0] = 0;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\")) {\n\t\tvencrypt_enable_plain_login = atoi(getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\"));\n\t}\n\n\t/* load our list of sub-types: */\n\tn = 0;\n\tif (!ssl_verify && vencrypt_kx != VENCRYPT_NODH) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptTlsVnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsPlain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsNone;\n\t\t\t}\n\t\t}\n\t}\n\tif (vencrypt_kx != VENCRYPT_NOX509) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptX509Vnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509Plain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509None;\n\t\t\t}\n\t\t}\n\t}\n\n\tnsubtypes = n;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\t((uint32_t *)buf)[i] = Swap32IfLE(subtypes[i]);\n\t}\n\n\t/* send number first: */\n\tbuf2[0] = (char) nsubtypes;\n\tif (!write_exact(s_out, buf2, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\t/* and now the list: */\n\tif (!write_exact(s_out, buf, 4*n)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client's selection: */\n\tif (!read_exact(s_in, (char *)&ival, 4)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tival = Swap32IfLE(ival);\n\n\t/* zero means no dice: */\n\tif (ival == 0) {\n\t\trfbLog(\"vencrypt: client selected no sub-type, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* check if he selected a valid one: */\n\tok = 0;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\tif (ival == subtypes[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\trfbLog(\"vencrypt: client selected invalid sub-type: %d\\n\", ival);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t} else {\n\t\tchar *st = \"unknown!!\";\n\t\tif (ival == rfbVencryptTlsNone)\t  st = \"rfbVencryptTlsNone\";\n\t\tif (ival == rfbVencryptTlsVnc)    st = \"rfbVencryptTlsVnc\";\n\t\tif (ival == rfbVencryptTlsPlain)  st = \"rfbVencryptTlsPlain\";\n\t\tif (ival == rfbVencryptX509None)  st = \"rfbVencryptX509None\";\n\t\tif (ival == rfbVencryptX509Vnc)   st = \"rfbVencryptX509Vnc\";\n\t\tif (ival == rfbVencryptX509Plain) st = \"rfbVencryptX509Plain\";\n\t\trfbLog(\"vencrypt: client selected sub-type: %d (%s)\\n\", ival, st);\n\t}\n\n\tvencrypt_selected = ival;\n\n\t/* not documented in spec, send OK: */\n\tbuf[0] = 1;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (vencrypt_selected == rfbVencryptTlsNone ||\n\t    vencrypt_selected == rfbVencryptTlsVnc  ||\n\t    vencrypt_selected == rfbVencryptTlsPlain) {\n\t\t/* these modes are Anonymous Diffie-Hellman */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"vencrypt: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s_out"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_exact",
          "args": [
            "s_out",
            "msg",
            "strlen(msg)"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32IfLE",
          "args": [
            "len"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"%s: %d\\n\"",
            "msg",
            "(int) buf[0]"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: reply: %d (%s)\\n\"",
            "(int) buf[0]",
            "stype"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_exact",
          "args": [
            "s_in",
            "buf",
            "1"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"wrote[%d] %d %d %d\\n\"",
            "n",
            "buf[0]",
            "buf[1]",
            "buf[2]"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: invalid version: '%s'\\n\"",
            "buf"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: version: %d.%d\\n\"",
            "major",
            "minor"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%d.\"",
            "(unsigned char) buf[i]"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: abnormal handshake: '%s'\\nbytes: \"",
            "buf"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"RFB %03d.%03d\\n\"",
            "&major",
            "&minor"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "proto"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE prevents normal SSL\\n\""
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: waited: %f / %.2f input: %s\\n\"",
            "dnow() - start",
            "waitmax",
            "input ? \"SSL Handshake\" : \"(future) RFB Handshake\""
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "(int) (1000 * 1000 * dt)"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "s_in",
            "&rfds"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "s_in+1",
            "&rfds",
            "NULL",
            "NULL",
            "&tv"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "s_in",
            "&rfds"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&rfds"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: Cannot use ANONTLS_FORCE with -sslverify (Anon DH only)\\n\""
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: connect mode.\\n\""
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE in client\\n\""
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define rfbSecTypeVencrypt 19\n#define rfbSecTypeAnonTls  18\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\n\nstatic int check_vnc_tls_mode(int s_in, int s_out, double last_https) {\n\tdouble waited = 0.0, waitmax = 1.4, dt = 0.01, start = dnow();\n\tstruct timeval tv;\n\tint input = 0, i, n, ok;\n\tint major, minor, sectype = -1;\n\tchar *proto = \"RFB 003.008\\n\";\n\tchar *stype = \"unknown\";\n\tchar buf[256];\n\t\n\tvencrypt_selected = 0;\n\tanontls_selected = 0;\n\n\tif (vencrypt_mode == VENCRYPT_NONE && anontls_mode == ANONTLS_NONE) {\n\t\t/* only normal SSL */\n\t\treturn 1;\n\t}\n\tif (ssl_client_mode) {\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE in client\\n\");\n\t\t\trfbLog(\"check_vnc_tls_mode: connect mode.\\n\");\n\t\t\t/* this is OK, continue on below for dialog. */\n\t\t} else {\n\t\t\t/* otherwise we must assume normal SSL (we send client hello) */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (ssl_verify && vencrypt_mode != VENCRYPT_FORCE && anontls_mode == ANONTLS_FORCE) {\n\t\trfbLog(\"check_vnc_tls_mode: Cannot use ANONTLS_FORCE with -sslverify (Anon DH only)\\n\");\n\t\t/* fallback to normal SSL */\n\t\treturn 1;\n\t}\n\n\tif (last_https > 0.0) {\n\t\tdouble now = dnow();\n\t\tif (now < last_https + 5.0) {\n\t\t\twaitmax = 20.0;\n\t\t} else if (now < last_https + 15.0) {\n\t\t\twaitmax = 10.0;\n\t\t} else if (now < last_https + 30.0) {\n\t\t\twaitmax = 5.0;\n\t\t} else if (now < last_https + 60.0) {\n\t\t\twaitmax = 2.5;\n\t\t}\n\t}\n\n\twhile (waited < waitmax) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(s_in, &rfds);\n\t\ttv.tv_sec = 0; \n\t\ttv.tv_usec = 0; \n\t\tselect(s_in+1, &rfds, NULL, NULL, &tv);\n\t\tif (FD_ISSET(s_in, &rfds)) {\n\t\t\tinput = 1;\n\t\t\tbreak;\n\t\t}\n\t\tusleep((int) (1000 * 1000 * dt));\n\t\twaited += dt;\n\t}\n\trfbLog(\"check_vnc_tls_mode: waited: %f / %.2f input: %s\\n\",\n\t    dnow() - start, waitmax, input ? \"SSL Handshake\" : \"(future) RFB Handshake\");\n\n\tif (input) {\n\t\t/* got SSL client hello, can only assume normal SSL */\n\t\tif (vencrypt_mode == VENCRYPT_FORCE || anontls_mode == ANONTLS_FORCE) {\n\t\t\trfbLog(\"check_vnc_tls_mode: VENCRYPT_FORCE/ANONTLS_FORCE prevents normal SSL\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* send RFB 003.008 -- there is no turning back from this point... */\n\tif (!write_exact(s_out, proto, strlen(proto))) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 12)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (sscanf(buf, \"RFB %03d.%03d\\n\", &major, &minor) != 2) {\n\t\tint i;\n\t\trfbLog(\"check_vnc_tls_mode: abnormal handshake: '%s'\\nbytes: \", buf);\n\t\tfor (i=0; i < 12; i++) {\n\t\t\tfprintf(stderr, \"%d.\", (unsigned char) buf[i]);\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"check_vnc_tls_mode: version: %d.%d\\n\", major, minor);\n\tif (major != 3 || minor < 8) {\n\t\trfbLog(\"check_vnc_tls_mode: invalid version: '%s'\\n\", buf);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tn = 1;\n\tif (vencrypt_mode == VENCRYPT_FORCE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_FORCE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else if (vencrypt_mode == VENCRYPT_SOLE) {\n\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t} else if (anontls_mode == ANONTLS_SOLE && !ssl_verify) {\n\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t} else {\n\t\tif (vencrypt_mode == VENCRYPT_SUPPORT) {\n\t\t\tbuf[n++] = rfbSecTypeVencrypt;\n\t\t}\n\t\tif (anontls_mode == ANONTLS_SUPPORT && !ssl_verify) {\n\t\t\tbuf[n++] = rfbSecTypeAnonTls;\n\t\t}\n\t}\n\n\tn--;\n\tbuf[0] = (char) n;\n\tif (!write_exact(s_out, buf, n+1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tif (0) fprintf(stderr, \"wrote[%d] %d %d %d\\n\", n, buf[0], buf[1], buf[2]);\n\n\tbuf[0] = 0;\n\tif (!read_exact(s_in, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (buf[0] == rfbSecTypeVencrypt) stype = \"VeNCrypt\";\n\tif (buf[0] == rfbSecTypeAnonTls)  stype = \"ANONTLS\";\n\n\trfbLog(\"check_vnc_tls_mode: reply: %d (%s)\\n\", (int) buf[0], stype);\n\n\tok = 0;\n\tfor (i=1; i < n+1; i++) {\n\t\tif (buf[0] == buf[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tchar *msg = \"check_vnc_tls_mode: invalid security-type\";\n\t\tint len = strlen(msg);\n\t\trfbLog(\"%s: %d\\n\", msg, (int) buf[0]);\n\t\t((uint32_t *)buf)[0] = Swap32IfLE(len);\n\t\twrite_exact(s_out, buf, 4);\n\t\twrite_exact(s_out, msg, strlen(msg));\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tsectype = (int) buf[0];\n\n\tif (sectype == rfbSecTypeVencrypt) {\n\t\treturn vencrypt_dialog(s_in, s_out);\n\t} else if (sectype == rfbSecTypeAnonTls) {\n\t\treturn anontls_dialog(s_in, s_out);\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "vencrypt_dialog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1641-1792",
    "snippet": "static int vencrypt_dialog(int s_in, int s_out) {\n\tchar buf[256], buf2[256];\n\tint subtypes[16];\n\tint n, i, ival, ok, nsubtypes = 0;\n\n\tvencrypt_selected = 0;\n\n\t/* send version 0.2 */\n\tbuf[0] = 0;\n\tbuf[1] = 2;\n\n\tif (!write_exact(s_out, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client version 0.2 */\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"vencrypt: received %d.%d client version.\\n\", (int) buf[0], (int) buf[1]);\n\n\t/* close 0.0 */\n\tif (buf[0] == 0 && buf[1] == 0) {\n\t\trfbLog(\"vencrypt: received 0.0 version, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* accept only 0.2 */\n\tif (buf[0] != 0 || buf[1] != 2) {\n\t\trfbLog(\"vencrypt: unsupported VeNCrypt version, closing connection.\\n\");\n\t\tbuf[0] = (char) 255;\n\t\twrite_exact(s_out, buf, 1);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* tell them OK */\n\tbuf[0] = 0;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\")) {\n\t\tvencrypt_enable_plain_login = atoi(getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\"));\n\t}\n\n\t/* load our list of sub-types: */\n\tn = 0;\n\tif (!ssl_verify && vencrypt_kx != VENCRYPT_NODH) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptTlsVnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsPlain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsNone;\n\t\t\t}\n\t\t}\n\t}\n\tif (vencrypt_kx != VENCRYPT_NOX509) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptX509Vnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509Plain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509None;\n\t\t\t}\n\t\t}\n\t}\n\n\tnsubtypes = n;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\t((uint32_t *)buf)[i] = Swap32IfLE(subtypes[i]);\n\t}\n\n\t/* send number first: */\n\tbuf2[0] = (char) nsubtypes;\n\tif (!write_exact(s_out, buf2, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\t/* and now the list: */\n\tif (!write_exact(s_out, buf, 4*n)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client's selection: */\n\tif (!read_exact(s_in, (char *)&ival, 4)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tival = Swap32IfLE(ival);\n\n\t/* zero means no dice: */\n\tif (ival == 0) {\n\t\trfbLog(\"vencrypt: client selected no sub-type, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* check if he selected a valid one: */\n\tok = 0;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\tif (ival == subtypes[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\trfbLog(\"vencrypt: client selected invalid sub-type: %d\\n\", ival);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t} else {\n\t\tchar *st = \"unknown!!\";\n\t\tif (ival == rfbVencryptTlsNone)\t  st = \"rfbVencryptTlsNone\";\n\t\tif (ival == rfbVencryptTlsVnc)    st = \"rfbVencryptTlsVnc\";\n\t\tif (ival == rfbVencryptTlsPlain)  st = \"rfbVencryptTlsPlain\";\n\t\tif (ival == rfbVencryptX509None)  st = \"rfbVencryptX509None\";\n\t\tif (ival == rfbVencryptX509Vnc)   st = \"rfbVencryptX509Vnc\";\n\t\tif (ival == rfbVencryptX509Plain) st = \"rfbVencryptX509Plain\";\n\t\trfbLog(\"vencrypt: client selected sub-type: %d (%s)\\n\", ival, st);\n\t}\n\n\tvencrypt_selected = ival;\n\n\t/* not documented in spec, send OK: */\n\tbuf[0] = 1;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (vencrypt_selected == rfbVencryptTlsNone ||\n\t    vencrypt_selected == rfbVencryptTlsVnc  ||\n\t    vencrypt_selected == rfbVencryptTlsPlain) {\n\t\t/* these modes are Anonymous Diffie-Hellman */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"vencrypt: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define rfbVencryptX509Plain\t262",
      "#define rfbVencryptX509Vnc\t261",
      "#define rfbVencryptX509None\t260",
      "#define rfbVencryptTlsPlain\t259",
      "#define rfbVencryptTlsVnc\t258",
      "#define rfbVencryptTlsNone\t257"
    ],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);",
      "static char *get_input(char *tag, char **in);",
      "static int vencrypt_selected = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vencrypt: Anonymous Diffie-Hellman failed.\\n\""
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_to_anon_dh",
          "args": [],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "switch_to_anon_dh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1580-1621",
          "snippet": "static int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s_out"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_exact",
          "args": [
            "s_out",
            "buf",
            "1"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vencrypt: client selected sub-type: %d (%s)\\n\"",
            "ival",
            "st"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vencrypt: client selected invalid sub-type: %d\\n\"",
            "ival"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vencrypt: client selected no sub-type, closing connection.\\n\""
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32IfLE",
          "args": [
            "ival"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_exact",
          "args": [
            "s_in",
            "(char *)&ival",
            "4"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Swap32IfLE",
          "args": [
            "subtypes[i]"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\")"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\""
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\""
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vencrypt: unsupported VeNCrypt version, closing connection.\\n\""
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vencrypt: received 0.0 version, closing connection.\\n\""
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"vencrypt: received %d.%d client version.\\n\"",
            "(int) buf[0]",
            "(int) buf[1]"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(buf)"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define rfbVencryptX509Plain\t262\n#define rfbVencryptX509Vnc\t261\n#define rfbVencryptX509None\t260\n#define rfbVencryptTlsPlain\t259\n#define rfbVencryptTlsVnc\t258\n#define rfbVencryptTlsNone\t257\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nstatic int vencrypt_selected = 0;\n\nstatic int vencrypt_dialog(int s_in, int s_out) {\n\tchar buf[256], buf2[256];\n\tint subtypes[16];\n\tint n, i, ival, ok, nsubtypes = 0;\n\n\tvencrypt_selected = 0;\n\n\t/* send version 0.2 */\n\tbuf[0] = 0;\n\tbuf[1] = 2;\n\n\tif (!write_exact(s_out, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client version 0.2 */\n\tmemset(buf, 0, sizeof(buf));\n\tif (!read_exact(s_in, buf, 2)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\trfbLog(\"vencrypt: received %d.%d client version.\\n\", (int) buf[0], (int) buf[1]);\n\n\t/* close 0.0 */\n\tif (buf[0] == 0 && buf[1] == 0) {\n\t\trfbLog(\"vencrypt: received 0.0 version, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* accept only 0.2 */\n\tif (buf[0] != 0 || buf[1] != 2) {\n\t\trfbLog(\"vencrypt: unsupported VeNCrypt version, closing connection.\\n\");\n\t\tbuf[0] = (char) 255;\n\t\twrite_exact(s_out, buf, 1);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* tell them OK */\n\tbuf[0] = 0;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\")) {\n\t\tvencrypt_enable_plain_login = atoi(getenv(\"X11VNC_ENABLE_VENCRYPT_PLAIN_LOGIN\"));\n\t}\n\n\t/* load our list of sub-types: */\n\tn = 0;\n\tif (!ssl_verify && vencrypt_kx != VENCRYPT_NODH) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptTlsVnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsPlain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptTlsNone;\n\t\t\t}\n\t\t}\n\t}\n\tif (vencrypt_kx != VENCRYPT_NOX509) {\n\t\tif (screen->authPasswdData != NULL) {\n\t\t\tsubtypes[n++] = rfbVencryptX509Vnc;\n\t\t} else {\n\t\t\tif (vencrypt_enable_plain_login && unixpw) {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509Plain;\n\t\t\t} else {\n\t\t\t\tsubtypes[n++] = rfbVencryptX509None;\n\t\t\t}\n\t\t}\n\t}\n\n\tnsubtypes = n;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\t((uint32_t *)buf)[i] = Swap32IfLE(subtypes[i]);\n\t}\n\n\t/* send number first: */\n\tbuf2[0] = (char) nsubtypes;\n\tif (!write_exact(s_out, buf2, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\t/* and now the list: */\n\tif (!write_exact(s_out, buf, 4*n)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* read client's selection: */\n\tif (!read_exact(s_in, (char *)&ival, 4)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\tival = Swap32IfLE(ival);\n\n\t/* zero means no dice: */\n\tif (ival == 0) {\n\t\trfbLog(\"vencrypt: client selected no sub-type, closing connection.\\n\");\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\t/* check if he selected a valid one: */\n\tok = 0;\n\tfor (i = 0; i < nsubtypes; i++) {\n\t\tif (ival == subtypes[i]) {\n\t\t\tok = 1;\n\t\t}\n\t}\n\n\tif (!ok) {\n\t\trfbLog(\"vencrypt: client selected invalid sub-type: %d\\n\", ival);\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t} else {\n\t\tchar *st = \"unknown!!\";\n\t\tif (ival == rfbVencryptTlsNone)\t  st = \"rfbVencryptTlsNone\";\n\t\tif (ival == rfbVencryptTlsVnc)    st = \"rfbVencryptTlsVnc\";\n\t\tif (ival == rfbVencryptTlsPlain)  st = \"rfbVencryptTlsPlain\";\n\t\tif (ival == rfbVencryptX509None)  st = \"rfbVencryptX509None\";\n\t\tif (ival == rfbVencryptX509Vnc)   st = \"rfbVencryptX509Vnc\";\n\t\tif (ival == rfbVencryptX509Plain) st = \"rfbVencryptX509Plain\";\n\t\trfbLog(\"vencrypt: client selected sub-type: %d (%s)\\n\", ival, st);\n\t}\n\n\tvencrypt_selected = ival;\n\n\t/* not documented in spec, send OK: */\n\tbuf[0] = 1;\n\tif (!write_exact(s_out, buf, 1)) {\n\t\tclose(s_in); close(s_out);\n\t\treturn 0;\n\t}\n\n\tif (vencrypt_selected == rfbVencryptTlsNone ||\n\t    vencrypt_selected == rfbVencryptTlsVnc  ||\n\t    vencrypt_selected == rfbVencryptTlsPlain) {\n\t\t/* these modes are Anonymous Diffie-Hellman */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"vencrypt: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}"
  },
  {
    "function_name": "anontls_dialog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1623-1635",
    "snippet": "static int anontls_dialog(int s_in, int s_out) {\n\n\tif (s_in || s_out) {}\n\tanontls_selected = 1;\n\n\tif (!switch_to_anon_dh()) {\n\t\trfbLog(\"anontls: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\treturn 0;\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);",
      "static int anontls_selected = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"anontls: Anonymous Diffie-Hellman failed.\\n\""
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_to_anon_dh",
          "args": [],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "switch_to_anon_dh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1580-1621",
          "snippet": "static int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic int anontls_selected = 0;\n\nstatic int anontls_dialog(int s_in, int s_out) {\n\n\tif (s_in || s_out) {}\n\tanontls_selected = 1;\n\n\tif (!switch_to_anon_dh()) {\n\t\trfbLog(\"anontls: Anonymous Diffie-Hellman failed.\\n\");\t\n\t\treturn 0;\n\t}\n\n\t/* continue with SSL/TLS */\n\treturn 1;\n}"
  },
  {
    "function_name": "switch_to_anon_dh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1580-1621",
    "snippet": "static int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SSL_CTX_set_verify",
          "args": [
            "ctx",
            "SSL_VERIFY_NONE",
            "NULL"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_default_passwd_cb",
          "args": [
            "ctx",
            "pem_passwd_callback"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_timeout",
          "args": [
            "ctx",
            "300"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_session_cache_mode",
          "args": [
            "ctx",
            "SSL_SESS_CACHE_BOTH"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_mode",
          "args": [
            "ctx",
            "mode"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_anon_dh",
          "args": [],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "add_anon_dh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1446-1578",
          "snippet": "static int add_anon_dh(void) {\n\tpid_t pid, pidw;\n\tchar cnf[] = \"/tmp/x11vnc-dh.XXXXXX\";\n\tchar *infile = NULL;\n\tint status, cnf_fd;\n\tDH *dh;\n\tBIO *bio;\n\tFILE *in;\n\tdouble ds;\n\t/*\n\t * These are dh parameters (prime, generator), not dh keys.\n\t * Evidently it is ok for them to be publicly known.\n\t * openssl dhparam -out dh.out 1024\n\t */\n\tchar *fixed_dh_params = \n\"-----BEGIN DH PARAMETERS-----\\n\"\n\"MIGHAoGBAL28w69ZnLYBvp8R2OeqtAIms+oatY19iBL4WhGI/7H1OMmkJjIe+OHs\\n\"\n\"PXoJfe5ucrnvno7Xm+HJZYa1jnPGQuWoa/VJKXdVjYdJVNzazJKM2daKKcQA4GDc\\n\"\n\"msFS5DxLbzUR5jy1n12K3EcbvpyFqDYVTJJXm7NuNuiWRfz3wTozAgEC\\n\"\n\"-----END DH PARAMETERS-----\\n\";\n\n\tif (dhparams_file != NULL) {\n\t\tinfile = dhparams_file;\n\t\trfbLog(\"add_anon_dh: using %s\\n\", dhparams_file);\n\t\tgoto readin;\n\t}\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn 0;\n\t}\n\tinfile = cnf;\n\n\tif (create_fresh_dhparams) {\n\n\t\tif (new_dh_params != NULL) {\n\t\t\twrite(cnf_fd, new_dh_params, strlen(new_dh_params));\n\t\t\tclose(cnf_fd);\n\t\t} else {\n\t\t\tchar *exe = find_openssl_bin();\n\t\t\tstruct stat sbuf;\n\n\t\t\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\t\t\trfbLog(\"add_anon_dh: cannot run external commands.\\n\");\t\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tclose(cnf_fd);\n\t\t\tif (exe == NULL) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tds = dnow();\n\t\t\tpid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (pid == 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tif (i == 2) continue;\n\t\t\t\t\tclose(i);\n\t\t\t\t}\n\t\t\t\t/* rather slow at 1024 */\n\t\t\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"1024\", (char *)0);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tpidw = waitpid(pid, &status, 0); \n\t\t\tif (pidw != pid) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trfbLog(\"add_anon_dh: created new DH params in %.3f secs\\n\", dnow() - ds);\n\n\t\t\tif (stat(cnf, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\t\t/* save it to reuse during our process's lifetime: */\n\t\t\t\tint d = open(cnf, O_RDONLY);\n\t\t\t\tif (d >= 0) {\n\t\t\t\t\tint n, len = sbuf.st_size;\n\t\t\t\t\tnew_dh_params = (char *) calloc(len+1, 1);\n\t\t\t\t\tn = read(d, new_dh_params, len);\n\t\t\t\t\tclose(d);\n\t\t\t\t\tif (n != len) {\n\t\t\t\t\t\tfree(new_dh_params);\n\t\t\t\t\t\tnew_dh_params = NULL;\n\t\t\t\t\t} else if (dhret != NULL) {\n\t\t\t\t\t\td = open(dhret, O_WRONLY);\n\t\t\t\t\t\tif (d >= 0) {\n\t\t\t\t\t\t\twrite(d, new_dh_params, strlen(new_dh_params));\n\t\t\t\t\t\t\tclose(d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\twrite(cnf_fd, fixed_dh_params, strlen(fixed_dh_params));\n\t\tclose(cnf_fd);\n\t}\n\n\treadin:\n\n\tds = dnow();\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLogPerror(\"fopen\");\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\tif (! bio) {\n\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tif (dh == NULL) {\n\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\tBIO_free(bio);\n\t\treturn 0;\n\t}\n\tBIO_free(bio);\n\tSSL_CTX_set_tmp_dh(ctx, dh);\n\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\", 8*DH_size(dh), dnow()-ds);\n\tDH_free(dh);\n\n\tunlink(cnf);\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *dhret = NULL;",
            "char *new_dh_params = NULL;",
            "char *find_openssl_bin(void);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *dhret = NULL;\nchar *new_dh_params = NULL;\nchar *find_openssl_bin(void);\nstatic char *get_input(char *tag, char **in);\n\nstatic int add_anon_dh(void) {\n\tpid_t pid, pidw;\n\tchar cnf[] = \"/tmp/x11vnc-dh.XXXXXX\";\n\tchar *infile = NULL;\n\tint status, cnf_fd;\n\tDH *dh;\n\tBIO *bio;\n\tFILE *in;\n\tdouble ds;\n\t/*\n\t * These are dh parameters (prime, generator), not dh keys.\n\t * Evidently it is ok for them to be publicly known.\n\t * openssl dhparam -out dh.out 1024\n\t */\n\tchar *fixed_dh_params = \n\"-----BEGIN DH PARAMETERS-----\\n\"\n\"MIGHAoGBAL28w69ZnLYBvp8R2OeqtAIms+oatY19iBL4WhGI/7H1OMmkJjIe+OHs\\n\"\n\"PXoJfe5ucrnvno7Xm+HJZYa1jnPGQuWoa/VJKXdVjYdJVNzazJKM2daKKcQA4GDc\\n\"\n\"msFS5DxLbzUR5jy1n12K3EcbvpyFqDYVTJJXm7NuNuiWRfz3wTozAgEC\\n\"\n\"-----END DH PARAMETERS-----\\n\";\n\n\tif (dhparams_file != NULL) {\n\t\tinfile = dhparams_file;\n\t\trfbLog(\"add_anon_dh: using %s\\n\", dhparams_file);\n\t\tgoto readin;\n\t}\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn 0;\n\t}\n\tinfile = cnf;\n\n\tif (create_fresh_dhparams) {\n\n\t\tif (new_dh_params != NULL) {\n\t\t\twrite(cnf_fd, new_dh_params, strlen(new_dh_params));\n\t\t\tclose(cnf_fd);\n\t\t} else {\n\t\t\tchar *exe = find_openssl_bin();\n\t\t\tstruct stat sbuf;\n\n\t\t\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\t\t\trfbLog(\"add_anon_dh: cannot run external commands.\\n\");\t\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tclose(cnf_fd);\n\t\t\tif (exe == NULL) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tds = dnow();\n\t\t\tpid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (pid == 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tif (i == 2) continue;\n\t\t\t\t\tclose(i);\n\t\t\t\t}\n\t\t\t\t/* rather slow at 1024 */\n\t\t\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"1024\", (char *)0);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tpidw = waitpid(pid, &status, 0); \n\t\t\tif (pidw != pid) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trfbLog(\"add_anon_dh: created new DH params in %.3f secs\\n\", dnow() - ds);\n\n\t\t\tif (stat(cnf, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\t\t/* save it to reuse during our process's lifetime: */\n\t\t\t\tint d = open(cnf, O_RDONLY);\n\t\t\t\tif (d >= 0) {\n\t\t\t\t\tint n, len = sbuf.st_size;\n\t\t\t\t\tnew_dh_params = (char *) calloc(len+1, 1);\n\t\t\t\t\tn = read(d, new_dh_params, len);\n\t\t\t\t\tclose(d);\n\t\t\t\t\tif (n != len) {\n\t\t\t\t\t\tfree(new_dh_params);\n\t\t\t\t\t\tnew_dh_params = NULL;\n\t\t\t\t\t} else if (dhret != NULL) {\n\t\t\t\t\t\td = open(dhret, O_WRONLY);\n\t\t\t\t\t\tif (d >= 0) {\n\t\t\t\t\t\t\twrite(d, new_dh_params, strlen(new_dh_params));\n\t\t\t\t\t\t\tclose(d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\twrite(cnf_fd, fixed_dh_params, strlen(fixed_dh_params));\n\t\tclose(cnf_fd);\n\t}\n\n\treadin:\n\n\tds = dnow();\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLogPerror(\"fopen\");\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\tif (! bio) {\n\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tif (dh == NULL) {\n\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\tBIO_free(bio);\n\t\treturn 0;\n\t}\n\tBIO_free(bio);\n\tSSL_CTX_set_tmp_dh(ctx, dh);\n\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\", 8*DH_size(dh), dnow()-ds);\n\tDH_free(dh);\n\n\tunlink(cnf);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_cipher_list",
          "args": [
            "ctx",
            "\"ADH:@SECLEVEL=0\""
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_security_level",
          "args": [
            "ctx",
            "0"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_new",
          "args": [
            "method"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSLv23_server_method",
          "args": [],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSLv23_client_method",
          "args": [],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLS_server_method",
          "args": [],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLS_client_method",
          "args": [],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\""
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\""
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Using Anonymous Diffie-Hellman mode.\\n\""
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "add_anon_dh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1446-1578",
    "snippet": "static int add_anon_dh(void) {\n\tpid_t pid, pidw;\n\tchar cnf[] = \"/tmp/x11vnc-dh.XXXXXX\";\n\tchar *infile = NULL;\n\tint status, cnf_fd;\n\tDH *dh;\n\tBIO *bio;\n\tFILE *in;\n\tdouble ds;\n\t/*\n\t * These are dh parameters (prime, generator), not dh keys.\n\t * Evidently it is ok for them to be publicly known.\n\t * openssl dhparam -out dh.out 1024\n\t */\n\tchar *fixed_dh_params = \n\"-----BEGIN DH PARAMETERS-----\\n\"\n\"MIGHAoGBAL28w69ZnLYBvp8R2OeqtAIms+oatY19iBL4WhGI/7H1OMmkJjIe+OHs\\n\"\n\"PXoJfe5ucrnvno7Xm+HJZYa1jnPGQuWoa/VJKXdVjYdJVNzazJKM2daKKcQA4GDc\\n\"\n\"msFS5DxLbzUR5jy1n12K3EcbvpyFqDYVTJJXm7NuNuiWRfz3wTozAgEC\\n\"\n\"-----END DH PARAMETERS-----\\n\";\n\n\tif (dhparams_file != NULL) {\n\t\tinfile = dhparams_file;\n\t\trfbLog(\"add_anon_dh: using %s\\n\", dhparams_file);\n\t\tgoto readin;\n\t}\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn 0;\n\t}\n\tinfile = cnf;\n\n\tif (create_fresh_dhparams) {\n\n\t\tif (new_dh_params != NULL) {\n\t\t\twrite(cnf_fd, new_dh_params, strlen(new_dh_params));\n\t\t\tclose(cnf_fd);\n\t\t} else {\n\t\t\tchar *exe = find_openssl_bin();\n\t\t\tstruct stat sbuf;\n\n\t\t\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\t\t\trfbLog(\"add_anon_dh: cannot run external commands.\\n\");\t\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tclose(cnf_fd);\n\t\t\tif (exe == NULL) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tds = dnow();\n\t\t\tpid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (pid == 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tif (i == 2) continue;\n\t\t\t\t\tclose(i);\n\t\t\t\t}\n\t\t\t\t/* rather slow at 1024 */\n\t\t\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"1024\", (char *)0);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tpidw = waitpid(pid, &status, 0); \n\t\t\tif (pidw != pid) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trfbLog(\"add_anon_dh: created new DH params in %.3f secs\\n\", dnow() - ds);\n\n\t\t\tif (stat(cnf, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\t\t/* save it to reuse during our process's lifetime: */\n\t\t\t\tint d = open(cnf, O_RDONLY);\n\t\t\t\tif (d >= 0) {\n\t\t\t\t\tint n, len = sbuf.st_size;\n\t\t\t\t\tnew_dh_params = (char *) calloc(len+1, 1);\n\t\t\t\t\tn = read(d, new_dh_params, len);\n\t\t\t\t\tclose(d);\n\t\t\t\t\tif (n != len) {\n\t\t\t\t\t\tfree(new_dh_params);\n\t\t\t\t\t\tnew_dh_params = NULL;\n\t\t\t\t\t} else if (dhret != NULL) {\n\t\t\t\t\t\td = open(dhret, O_WRONLY);\n\t\t\t\t\t\tif (d >= 0) {\n\t\t\t\t\t\t\twrite(d, new_dh_params, strlen(new_dh_params));\n\t\t\t\t\t\t\tclose(d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\twrite(cnf_fd, fixed_dh_params, strlen(fixed_dh_params));\n\t\tclose(cnf_fd);\n\t}\n\n\treadin:\n\n\tds = dnow();\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLogPerror(\"fopen\");\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\tif (! bio) {\n\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tif (dh == NULL) {\n\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\tBIO_free(bio);\n\t\treturn 0;\n\t}\n\tBIO_free(bio);\n\tSSL_CTX_set_tmp_dh(ctx, dh);\n\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\", 8*DH_size(dh), dnow()-ds);\n\tDH_free(dh);\n\n\tunlink(cnf);\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *dhret = NULL;",
      "char *new_dh_params = NULL;",
      "char *find_openssl_bin(void);",
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "cnf"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DH_free",
          "args": [
            "dh"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"loaded Diffie Hellman %d bits, %.3fs\\n\"",
            "8*DH_size(dh)",
            "dnow()-ds"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DH_size",
          "args": [
            "dh"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_tmp_dh",
          "args": [
            "ctx",
            "dh"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "bio"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "bio"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "cnf"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: PEM_read_bio_DHparams() failed.\\n\""
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_read_bio_DHparams",
          "args": [
            "bio",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "cnf"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: BIO_new_fp() failed.\\n\""
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new_fp",
          "args": [
            "in",
            "BIO_CLOSE|BIO_FP_TEXT"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "cnf"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "infile",
            "\"r\""
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "cnf_fd"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "cnf_fd",
            "fixed_dh_params",
            "strlen(fixed_dh_params)"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fixed_dh_params"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "new_dh_params"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "dhret",
            "O_WRONLY"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "accept_openssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "3302-4284",
          "snippet": "void accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define HAVE_LIBSSL 0",
            "#define LIBVNCSERVER_HAVE_LIBSSL 0",
            "#define ABSIZE 16384",
            "#define OPENSSL_REVERSE 6",
            "#define OPENSSL_HTTPS6  5",
            "#define OPENSSL_HTTPS   4",
            "#define OPENSSL_VNC6    3",
            "#define OPENSSL_VNC     2",
            "#define OPENSSL_INETD   1"
          ],
          "globals_used": [
            "int openssl_sock = -1;",
            "int openssl_sock6 = -1;",
            "int https_sock = -1;",
            "int https_sock6 = -1;",
            "pid_t openssl_last_helper_pid = 0;",
            "char *openssl_last_ip = NULL;",
            "static char *certret = NULL;",
            "static int certret_fd = -1;",
            "static mode_t omode;",
            "char *certret_str = NULL;",
            "static char *dhret = NULL;",
            "static int dhret_fd = -1;",
            "char *dhret_str = NULL;",
            "char *new_dh_params = NULL;",
            "void raw_xfer(int csock, int s_in, int s_out);",
            "static char *get_input(char *tag, char **in);",
            "void ssl_helper_pid(pid_t pid, int sock);",
            "void accept_openssl(int mode, int presock);",
            "static void lose_ram(void);",
            "static int vencrypt_selected = 0;",
            "static int anontls_selected = 0;",
            "static int csock_timeout_sock = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define HAVE_LIBSSL 0\n#define LIBVNCSERVER_HAVE_LIBSSL 0\n#define ABSIZE 16384\n#define OPENSSL_REVERSE 6\n#define OPENSSL_HTTPS6  5\n#define OPENSSL_HTTPS   4\n#define OPENSSL_VNC6    3\n#define OPENSSL_VNC     2\n#define OPENSSL_INETD   1\n\nint openssl_sock = -1;\nint openssl_sock6 = -1;\nint https_sock = -1;\nint https_sock6 = -1;\npid_t openssl_last_helper_pid = 0;\nchar *openssl_last_ip = NULL;\nstatic char *certret = NULL;\nstatic int certret_fd = -1;\nstatic mode_t omode;\nchar *certret_str = NULL;\nstatic char *dhret = NULL;\nstatic int dhret_fd = -1;\nchar *dhret_str = NULL;\nchar *new_dh_params = NULL;\nvoid raw_xfer(int csock, int s_in, int s_out);\nstatic char *get_input(char *tag, char **in);\nvoid ssl_helper_pid(pid_t pid, int sock);\nvoid accept_openssl(int mode, int presock);\nstatic void lose_ram(void);\nstatic int vencrypt_selected = 0;\nstatic int anontls_selected = 0;\nstatic int csock_timeout_sock = -1;\n\nvoid accept_openssl(int mode, int presock) {\n\tint sock = -1, listen = -1, cport, csock, vsock;\t\n\tint peerport = 0;\n\tint status, n, i, db = 0;\n\tstruct sockaddr_in addr;\n#ifdef __hpux\n\tint addrlen = sizeof(addr);\n#else\n\tsocklen_t addrlen = sizeof(addr);\n#endif\n\trfbClientPtr client;\n\tpid_t pid;\n\tchar uniq[] = \"_evilrats_\";\n\tchar cookie[256], rcookie[256], *name = NULL;\n\tint vencrypt_sel = 0;\n\tint anontls_sel = 0;\n\tchar *ipv6_name = NULL;\n\tstatic double last_https = 0.0;\n\tstatic char last_get[256];\n\tstatic int first = 1;\n\tunsigned char *rb;\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL  \n\tif (enc_str == NULL || strcmp(enc_str, \"none\")) {\n\t\tbadnews(\"0 accept_openssl\");\n\t}\n#endif\n\n\topenssl_last_helper_pid = 0;\n\n\t/* zero buffers for use below. */\n\tfor (i=0; i<256; i++) {\n\t\tif (first) {\n\t\t\tlast_get[i] = '\\0';\n\t\t}\n\t\tcookie[i]  = '\\0';\n\t\trcookie[i] = '\\0';\n\t}\n\tfirst = 0;\n\n\tif (getenv(\"ACCEPT_OPENSSL_DEBUG\")) {\n\t\tdb = atoi(getenv(\"ACCEPT_OPENSSL_DEBUG\"));\n\t}\n\n\t/* do INETD, VNC, or HTTPS cases (result is client socket or pipe) */\n\tif (mode == OPENSSL_INETD) {\n\t\tssl_initialized = 1;\n\n\t} else if (mode == OPENSSL_VNC) {\n\t\tsock = accept(openssl_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = openssl_sock;\n\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n#if X11VNC_IPV6\n\t\tstruct sockaddr_in6 a6;\n\t\tsocklen_t a6len = sizeof(a6);\n\t\tint fd = (mode == OPENSSL_VNC6 ? openssl_sock6 : https_sock6); \n\n\t\tsock = accept(fd, (struct sockaddr *)&a6, &a6len);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tipv6_name = ipv6_getipaddr((struct sockaddr *)&a6, a6len);\n\t\tif (!ipv6_name) ipv6_name = strdup(\"unknown\");\n\t\tlisten = fd;\n#endif\n\t} else if (mode == OPENSSL_REVERSE) {\n\t\tsock = presock;\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: connection failed\\n\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (getenv(\"OPENSSL_REVERSE_DEBUG\")) fprintf(stderr, \"OPENSSL_REVERSE: ipv6_client_ip_str: %s\\n\", ipv6_client_ip_str);\n\t\tif (ipv6_client_ip_str != NULL) {\n\t\t\tipv6_name = strdup(ipv6_client_ip_str);\n\t\t}\n\t\tlisten = -1;\n\n\t} else if (mode == OPENSSL_HTTPS) {\n\t\tsock = accept(https_sock, (struct sockaddr *)&addr, &addrlen);\n\t\tif (sock < 0)  {\n\t\t\trfbLog(\"SSL: accept_openssl: accept connection failed\\n\");\n\t\t\trfbLogPerror(\"accept\");\n\t\t\tif (ssl_no_fail) {\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlisten = https_sock;\n\t}\n\tif (db) fprintf(stderr, \"SSL: accept_openssl: sock: %d\\n\", sock);\n\n\tif (openssl_last_ip) {\n\t\tfree(openssl_last_ip);\n\t\topenssl_last_ip = NULL;\n\t}\n\tif (mode == OPENSSL_INETD) {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t} else if (mode == OPENSSL_VNC6 || mode == OPENSSL_HTTPS6) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\topenssl_last_ip = ipv6_name;\n\t} else {\n\t\topenssl_last_ip = get_remote_host(sock);\n\t}\n\n\tif (!check_ssl_access(openssl_last_ip)) {\n\t\trfbLog(\"SSL: accept_openssl: denying client %s\\n\", openssl_last_ip);\n\t\trfbLog(\"SSL: accept_openssl: does not match -allow or other reason.\\n\");\n\t\tclose(sock);\n\t\tsock = -1;\n\t\tif (ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* now make a listening socket for child to connect back to us by: */\n\n\tcport = find_free_port(20000, 22000);\n\tif (! cport && ipv6_listen) {\n\t\trfbLog(\"SSL: accept_openssl: seeking IPv6 port.\\n\");\n\t\tcport = find_free_port6(20000, 22000);\n\t\trfbLog(\"SSL: accept_openssl: IPv6 port: %d\\n\", cport);\n\t}\n\tif (! cport) {\n\t\trfbLog(\"SSL: accept_openssl: could not find open port.\\n\");\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: cport: %d\\n\", cport);\n\n\tcsock = listen_tcp(cport, htonl(INADDR_LOOPBACK), 1);\n\n\tif (csock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not listen on port %d.\\n\",\n\t\t    cport);\n\t\tclose(sock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: csock: %d\\n\", csock);\n\n\tfflush(stderr);\n\n\t/*\n\t * make a simple cookie to id the child socket, not foolproof\n\t * but hard to guess exactly (just worrying about local lusers\n\t * here, since we use INADDR_LOOPBACK).\n\t */\n\trb = (unsigned char *) calloc(6, 1);\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\tRAND_bytes(rb, 6);\n#endif\n\tsprintf(cookie, \"RB=%d%d%d%d%d%d/%f%f/%p\",\n\t    rb[0], rb[1], rb[2], rb[3], rb[4], rb[5],\n            dnow() - x11vnc_start, x11vnc_start, (void *)rb);\n\n\tif (mode == OPENSSL_VNC6) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL) {\n\t\tname = strdup(ipv6_name);\n\t\tpeerport = get_remote_port(sock);\n\t} else if (mode != OPENSSL_INETD) {\n\t\tname = get_remote_host(sock);\n\t\tpeerport = get_remote_port(sock);\n\t} else {\n\t\topenssl_last_ip = get_remote_host(fileno(stdin));\n\t\tpeerport = get_remote_port(fileno(stdin));\n\t\tif (openssl_last_ip) {\n\t\t\tname = strdup(openssl_last_ip);\n\t\t} else {\n\t\t\tname = strdup(\"unknown\");\n\t\t}\n\t}\n\tif (name) {\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\trfbLog(\"SSL: (inetd) spawning helper process \"\n\t\t\t    \"to handle: %s:%d\\n\", name, peerport);\n\t\t} else {\n\t\t\trfbLog(\"SSL: spawning helper process to handle: \"\n\t\t\t    \"%s:%d\\n\", name, peerport);\n\t\t}\n\t\tfree(name);\n\t\tname = NULL;\n\t}\n\n\tif (certret) {\n\t\tfree(certret);\n\t}\n\tif (certret_str) {\n\t\tfree(certret_str);\n\t\tcertret_str = NULL;\n\t}\n\tcertret = strdup(\"/tmp/x11vnc-certret.XXXXXX\");\n\tomode = umask(077);\n\tcertret_fd = mkstemp(certret);\n\tumask(omode);\n\tif (certret_fd < 0) {\n\t\tfree(certret);\n\t\tcertret = NULL;\n\t\tcertret_fd = -1;\n\t}\n\n\tif (dhret) {\n\t\tfree(dhret);\n\t}\n\tif (dhret_str) {\n\t\tfree(dhret_str);\n\t\tdhret_str = NULL;\n\t}\n\tdhret = strdup(\"/tmp/x11vnc-dhret.XXXXXX\");\n\tomode = umask(077);\n\tdhret_fd = mkstemp(dhret);\n\tumask(omode);\n\tif (dhret_fd < 0) {\n\t\tfree(dhret);\n\t\tdhret = NULL;\n\t\tdhret_fd = -1;\n\t}\n\n\t/* now fork the child to handle the SSL: */\n\tpid = fork();\n\n\tif (pid > 0) {\n\t\trfbLog(\"SSL: helper for peerport %d is pid %d: \\n\",\n\t\t    peerport, (int) pid);\n\t}\n\n\tif (pid < 0) {\n\t\trfbLog(\"SSL: accept_openssl: could not fork.\\n\");\n\t\trfbLogPerror(\"fork\");\n\t\tclose(sock);\n\t\tclose(csock);\n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\n\t} else if (pid == 0) {\n\t\tint s_in, s_out, httpsock = -1;\n\t\tint vncsock;\n\t\tint i, have_httpd = 0;\n\t\tint f_in  = fileno(stdin);\n\t\tint f_out = fileno(stdout);\n\t\tint skip_vnc_tls = mode == OPENSSL_HTTPS ? 1 : 0;\n\n\t\tif (db) fprintf(stderr, \"helper pid in: %d %d %d %d\\n\", f_in, f_out, sock, listen);\n\n\t\t/* reset all handlers to default (no interrupted() calls) */\n\t\tunset_signals();\n\n\t\t/* close all non-essential fd's */\n\t\tfor (i=0; i<256; i++) {\n\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\tif (i == f_in || i == f_out) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == sock) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == 2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclose(i);\n\t\t}\n\n\t\t/*\n\t\t * sadly, we are a long lived child and so the large\n\t\t * framebuffer memory areas will soon differ from parent.\n\t\t * try to free as much as possible.\n\t\t */\n\t\tlose_ram();\n\n\t\t/* now connect back to parent socket: */\n\t\tvncsock = connect_tcp(\"127.0.0.1\", cport);\n\t\tif (vncsock < 0) {\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: could not connect\"\n\t\t\t    \" back to: %d\\n\", getpid(), cport);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 1 (no local vncsock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\t\tif (db) fprintf(stderr, \"vncsock %d\\n\", vncsock);\n\n\t\t/* try to initialize SSL with the remote client */\n\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\ts_in  = fileno(stdin);\n\t\t\ts_out = fileno(stdout);\n\t\t} else {\n\t\t\ts_in = s_out = sock;\n\t\t}\n\n\t\tif (! ssl_init(s_in, s_out, skip_vnc_tls, last_https)) {\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 2 (ssl_init failed)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (vencrypt_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,VENCRYPT=%d,%s\", uniq, vencrypt_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t} else if (anontls_selected != 0) {\n\t\t\tchar *tbuf;\n\t\t\ttbuf = (char *) malloc(strlen(cookie) + 100);\n\t\t\tsprintf(tbuf, \"%s,ANONTLS=%d,%s\", uniq, anontls_selected, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(cookie));\n\t\t\tgoto wrote_cookie;\n\t\t}\n\n\t\t/*\n\t\t * things get messy below since we are trying to do\n\t\t * *both* VNC and Java applet httpd through the same\n\t\t * SSL socket.\n\t\t */\n\n\t\tif (! screen) {\n\t\t\tclose(vncsock);\n\t\t\texit(1);\n\t\t}\n\t\tif (screen->httpListenSock >= 0 && screen->httpPort > 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (ipv6_http_fd >= 0) {\n\t\t\thave_httpd = 1;\n\t\t} else if (screen->httpListenSock == -2) {\n\t\t\thave_httpd = 1;\n\t\t}\n\t\tif (mode == OPENSSL_HTTPS && ! have_httpd) {\n\t\t\trfbLog(\"SSL: accept_openssl[%d]: no httpd socket for \"\n\t\t\t    \"-https mode\\n\", getpid());\n\t\t\tclose(vncsock);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 3 (no httpd sock)\\n\", getpid());\n\t\t\texit(1);\n\t\t}\n\n\t\tif (have_httpd) {\n\t\t\tint n = 0, is_http = 0;\n\t\t\tint hport = screen->httpPort; \n\t\t\tchar *iface = NULL;\n\t\t\tchar *buf, *tbuf;\n\n\t\t\tbuf  = (char *) calloc((ABSIZE+1), 1);\n\t\t\ttbuf = (char *) calloc((2*ABSIZE+1), 1);\n\n\t\t\tif (mode == OPENSSL_HTTPS) {\n\t\t\t\t/*\n\t\t\t\t * for this mode we know it is HTTP traffic\n\t\t\t\t * so we skip trying to guess.\n\t\t\t\t */\n\t\t\t\tis_http = 1;\n\t\t\t\tn = 0;\n\t\t\t\tgoto connect_to_httpd;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if there is stuff to read from remote end\n\t\t\t * if so it is likely a GET or HEAD.\n\t\t\t */\n\t\t\tif (! is_ssl_readable(s_in, last_https, last_get,\n\t\t\t    mode)) {\n\t\t\t\tgoto write_cookie;\n\t\t\t}\n\t\n\t\t\t/* \n\t\t\t * read first 2 bytes to try to guess.  sadly,\n\t\t\t * the user is often pondering a \"non-verified\n\t\t\t * cert\" dialog for a long time before the GET\n\t\t\t * is ever sent.  So often we timeout here.\n\t\t\t */\n\n\t\t\tif (db) fprintf(stderr, \"watch_for_http_traffic\\n\");\n\n\t\t\tis_http = watch_for_http_traffic(buf, &n, s_in);\n\n\t\t\tif (is_http < 0 || is_http == 0) {\n\t\t\t\t/*\n\t\t\t\t * error or http not detected, fall back\n\t\t\t\t * to normal VNC socket.\n\t\t\t\t */\n\t\t\t\tif (db) fprintf(stderr, \"is_http err: %d n: %d\\n\", is_http, n);\n\t\t\t\twrite(vncsock, cookie, strlen(cookie));\n\t\t\t\tif (n > 0) {\n\t\t\t\t\twrite(vncsock, buf, n);\n\t\t\t\t}\n\t\t\t\tgoto wrote_cookie;\n\t\t\t}\n\n\t\t\tif (db) fprintf(stderr, \"is_http: %d n: %d\\n\",\n\t\t\t    is_http, n);\n\t\t\tif (db) fprintf(stderr, \"buf: '%s'\\n\", buf);\n\n\t\t\tif (strstr(buf, \"/request.https.vnc.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"Connection: Keep-Alive\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\t\t\t\t/*\n\t\t\t\t * special case proxy coming thru https\n\t\t\t\t * instead of a direct SSL connection.\n\t\t\t\t */\n\t\t\t\trfbLog(\"Handling VNC request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n\t\t\t\tif (strstr(buf, \"/reverse.proxy\")) {\n\t\t\t\t\tchar *buf2;\n\t\t\t\t\tint n, ptr;\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n#endif\n\t\t\t\t\n\t\t\t\t\tbuf2  = (char *) calloc((8192+1), 1);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tptr = 0;\n\t\t\t\t\twhile (ptr < 8192) {\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\t\t\tn = read(s_in, buf2 + ptr, 1);\n#else\n\t\t\t\t\t\tn = SSL_read(ssl, buf2 + ptr, 1);\n#endif\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tptr += n;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (db) fprintf(stderr, \"buf2: '%s'\\n\", buf2);\n\n\t\t\t\t\t\tif (strstr(buf2, \"\\r\\n\\r\\n\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(buf2);\n\t\t\t\t}\n\t\t\t\tgoto write_cookie;\n\n\t\t\t} else if (strstr(buf, \"/check.https.proxy.connection\")) {\n\t\t\t\tchar reply[] = \"HTTP/1.0 200 OK\\r\\n\"\n\t\t\t\t    \"Connection: close\\r\\n\"\n\t\t\t\t    \"Content-Type: octet-stream\\r\\n\"\n\t\t\t\t    \"VNC-Server: x11vnc\\r\\n\"\n\t\t\t\t    \"Pragma: no-cache\\r\\n\\r\\n\";\n\n\t\t\t\trfbLog(\"Handling Check HTTPS request via https GET. [%d]\\n\", getpid());\n\t\t\t\trfbLog(\"-- %s\\n\", buf);\n\n#if !LIBVNCSERVER_HAVE_LIBSSL && !HAVE_LIBSSL \n\t\t\t\twrite(s_out, reply, strlen(reply));\n#else\n\t\t\t\tSSL_write(ssl, reply, strlen(reply));\n\t\t\t\tSSL_shutdown(ssl);\n#endif\n\n\t\t\t\tstrcpy(tbuf, uniq);\n\t\t\t\tstrcat(tbuf, cookie);\n\t\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\t\t\t\tclose(vncsock);\n\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 4 (check.https.proxy.connection)\\n\", getpid());\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tconnect_to_httpd:\n\n\t\t\t/*\n\t\t\t * Here we go... no turning back.  we have to\n\t\t\t * send failure to parent and close socket to have\n\t\t\t * http processed at all in a timely fashion...\n\t\t\t */\n\n\t\t\t/* send the failure tag: */\n\t\t\tstrcpy(tbuf, uniq);\n\n\t\t\tif (https_port_redir < 0 || (strstr(buf, \"PORT=\") || strstr(buf, \"port=\"))) {\n\t\t\t\tchar *q = strstr(buf, \"Host:\");\n\t\t\t\tint fport = 443, match = 0;\n\t\t\t\tchar num[16];\n\n\t\t\t\tif (q && strstr(q, \"\\n\")) {\n\t\t\t\t    q += strlen(\"Host:\") + 1;\n\t\t\t\t    while (*q != '\\n') {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (*q == ':' && sscanf(q, \":%d\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t\tmatch = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq++;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!match || !https_port_redir) {\n\t\t\t\t\tint p;\n\t\t\t\t\tif (sscanf(buf, \"PORT=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sscanf(buf, \"port=%d,\", &p) == 1) {\n\t\t\t\t\t\tif (p > 0 && p < 65536) {\n\t\t\t\t\t\t\tfport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(num, \"HP=%d,\", fport);\n\t\t\t\tstrcat(tbuf, num);\n\t\t\t}\n\n\t\t\tif (strstr(buf, \"HTTP/\") != NULL)  {\n\t\t\t\tchar *q, *str;\n\t\t\t\t/*\n\t\t\t\t * Also send back the GET line for heuristics.\n\t\t\t\t * (last_https, get file).\n\t\t\t\t */\n\t\t\t\tstr = strdup(buf);\n\t\t\t\tq = strstr(str, \"HTTP/\");\n\t\t\t\tif (q != NULL) {\n\t\t\t\t\t*q = '\\0';\t\n\t\t\t\t\tstrcat(tbuf, str);\n\t\t\t\t}\n\t\t\t\tfree(str);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Also send the cookie to pad out the number of\n\t\t\t * bytes to more than the parent wants to read.\n\t\t\t * Since this is the failure case, it does not\n\t\t\t * matter that we send more than strlen(cookie).\n\t\t\t */\n\t\t\tstrcat(tbuf, cookie);\n\t\t\twrite(vncsock, tbuf, strlen(tbuf));\n\n\t\t\tusleep(150*1000);\n\t\t\tif (db) fprintf(stderr, \"close vncsock: %d\\n\", vncsock);\n\t\t\tclose(vncsock);\n\n\t\t\t/* now, finally, connect to the libvncserver httpd: */\n\t\t\tif (screen->listenInterface == htonl(INADDR_ANY) ||\n\t\t\t    screen->listenInterface == htonl(INADDR_NONE)) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t} else {\n\t\t\t\tstruct in_addr in;\n\t\t\t\tin.s_addr = screen->listenInterface;\n\t\t\t\tiface = inet_ntoa(in);\n\t\t\t}\n\t\t\tif (iface == NULL || !strcmp(iface, \"\")) {\n\t\t\t\tiface = \"127.0.0.1\";\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"iface: %s:%d\\n\", iface, hport);\n\t\t\tusleep(150*1000);\n\n\t\t\thttpsock = connect_tcp(iface, hport);\n\n\t\t\tif (httpsock < 0) {\n\t\t\t\t/* UGH, after all of that! */\n\t\t\t\trfbLog(\"Could not connect to httpd socket!\\n\");\n\t\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 5.\\n\", getpid());\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (db) fprintf(stderr, \"ssl_helper[%d]: httpsock: %d %d\\n\",\n\t\t\t    getpid(), httpsock, n);\n\n\t\t\t/*\n\t\t\t * send what we read to httpd, and then connect\n\t\t\t * the rest of the SSL session to it:\n\t\t\t */\n\t\t\tif (n > 0) {\n\t\t\t\tchar *s = getenv(\"X11VNC_EXTRA_HTTPS_PARAMS\");\n\t\t\t\tint did_extra = 0;\n\n\t\t\t\tif (db) fprintf(stderr, \"sending http buffer httpsock: %d n=%d\\n'%s'\\n\", httpsock, n, buf);\n\t\t\t\tif (s != NULL) {\n\t\t\t\t\tchar *q = strstr(buf, \" HTTP/\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\t*q = '\\0';\n\t\t\t\t\t\tm = strlen(buf);\n\t\t\t\t\t\twrite(httpsock, buf, m);\n\t\t\t\t\t\twrite(httpsock, s, strlen(s));\n\t\t\t\t\t\t*q = ' ';\n\t\t\t\t\t\twrite(httpsock, q, n-m);\n\t\t\t\t\t\tdid_extra = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!did_extra) {\n\t\t\t\t\twrite(httpsock, buf, n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl_xfer(httpsock, s_in, s_out, is_http);\n\t\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 6 (https ssl_xfer done)\\n\", getpid());\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * ok, back from the above https mess, simply send the\n\t\t * cookie back to the parent (who will attach us to\n\t\t * libvncserver), and connect the rest of the SSL session\n\t\t * to it.\n\t\t */\n\t\twrite_cookie:\n\t\twrite(vncsock, cookie, strlen(cookie));\n\n\t\twrote_cookie:\n\t\tssl_xfer(vncsock, s_in, s_out, 0);\n\t\trfbLog(\"SSL: ssl_helper[%d]: exit case 7 (ssl_xfer done)\\n\", getpid());\n\t\tif (0) usleep(50 * 1000);\n\t\texit(0);\n\t}\n\t/* parent here */\n\n\tif (mode != OPENSSL_INETD) {\n\t\tclose(sock);\n\t}\n\tif (db) fprintf(stderr, \"helper process is: %d\\n\", pid);\n\n\t/* accept connection from our child.  */\n\tsignal(SIGALRM, csock_timeout);\n\tcsock_timeout_sock = csock;\n\talarm(20);\n\n\tvsock = accept(csock, (struct sockaddr *)&addr, &addrlen);\n\n\talarm(0);\n\tsignal(SIGALRM, SIG_DFL);\n\tclose(csock);\n\n\n\tif (vsock < 0) {\n\t\trfbLog(\"SSL: accept_openssl: connection from ssl_helper[%d] FAILED.\\n\", pid);\n\t\trfbLogPerror(\"accept\");\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret) {\n\t\t\tunlink(certret);\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret) {\n\t\t\tunlink(dhret);\n\t\t}\n\t\treturn;\n\t}\n\tif (db) fprintf(stderr, \"accept_openssl: vsock: %d\\n\", vsock);\n\n\tn = read(vsock, rcookie, strlen(cookie));\n\tif (n < 0 && errno != 0) {\n\t\trfbLogPerror(\"read\");\n\t}\n\n\tif (certret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (certret_fd >= 0 && stat(certret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tcertret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(certret_fd, certret_str, sbuf.st_size);\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tif (certret_fd >= 0) {\n\t\t\tclose(certret_fd);\n\t\t\tcertret_fd = -1;\n\t\t}\n\t\tunlink(certret);\n\t\tif (certret_str && strstr(certret_str, \"NOCERT\") == certret_str) {\n\t\t\tfree(certret_str);\n\t\t\tcertret_str = NULL;\n\t\t}\n\t\tif (0 && certret_str) {\n\t\t\tfprintf(stderr, \"certret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, certret_str);\n\t\t}\n\t}\n\n\tif (dhret) {\n\t\tstruct stat sbuf;\n\t\tsbuf.st_size = 0;\n\t\tif (dhret_fd >= 0 && stat(dhret, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\tdhret_str = (char *) calloc(sbuf.st_size+1, 1);\n\t\t\tread(dhret_fd, dhret_str, sbuf.st_size);\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tif (dhret_fd >= 0) {\n\t\t\tclose(dhret_fd);\n\t\t\tdhret_fd = -1;\n\t\t}\n\t\tunlink(dhret);\n\t\tif (dhret_str && strstr(dhret_str, \"NOCERT\") == dhret_str) {\n\t\t\tfree(dhret_str);\n\t\t\tdhret_str = NULL;\n\t\t}\n\t\tif (dhret_str) {\n\t\t\tif (new_dh_params == NULL) {\n\t\t\t\tfprintf(stderr, \"dhret_str[%d]:\\n%s\\n\", (int) sbuf.st_size, dhret_str);\n\t\t\t\tnew_dh_params = strdup(dhret_str);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (0) {\n\t\tfprintf(stderr, \"rcookie: %s\\n\", rcookie);\n\t\tfprintf(stderr, \"cookie:  %s\\n\", cookie);\n\t}\n\n\tif (strstr(rcookie, uniq) == rcookie) {\n\t\tchar *q = strstr(rcookie, \"RB=\");\n\t\tif (q && strstr(cookie, q) == cookie) {\n\t\t\tvencrypt_sel = 0;\n\t\t\tanontls_sel = 0;\n\t\t\tq = strstr(rcookie, \"VENCRYPT=\");\n\t\t\tif (q && sscanf(q, \"VENCRYPT=%d,\", &vencrypt_sel) == 1) {\n\t\t\t\tif (vencrypt_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: VENCRYPT mode=%d accepted. helper[%d]\\n\", vencrypt_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = strstr(rcookie, \"ANONTLS=\");\n\t\t\tif (q && sscanf(q, \"ANONTLS=%d,\", &anontls_sel) == 1) {\n\t\t\t\tif (anontls_sel != 0) {\n\t\t\t\t\trfbLog(\"SSL: ANONTLS mode=%d accepted. helper[%d]\\n\", anontls_sel, pid);\n\t\t\t\t\tgoto accept_client;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n != (int) strlen(cookie) || strncmp(cookie, rcookie, n)) {\n\t\trfbLog(\"SSL: accept_openssl: cookie from ssl_helper[%d] FAILED. %d\\n\", pid, n);\n\t\tif (db) fprintf(stderr, \"'%s'\\n'%s'\\n\", cookie, rcookie);\n\t\tclose(vsock);\n\n\t\tif (strstr(rcookie, uniq) == rcookie) {\n\t\t\tint i;\n\t\t\tdouble https_download_wait_time = 15.0;\n\n\t\t\tif (getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\")) {\n\t\t\t\thttps_download_wait_time = atof(getenv(\"X11VNC_HTTPS_DOWNLOAD_WAIT_TIME\"));\n\t\t\t}\n\n\t\t\trfbLog(\"SSL: BUT WAIT! HTTPS for helper process[%d] succeeded. Good.\\n\", pid);\n\t\t\tif (mode != OPENSSL_HTTPS) {\n\t\t\t\tlast_https = dnow();\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tlast_get[i] = '\\0';\n\t\t\t\t}\n\t\t\t\tstrncpy(last_get, rcookie, 100);\n\t\t\t\tif (db) fprintf(stderr, \"last_get: '%s'\\n\", last_get);\n\t\t\t}\n\t\t\tif (rcookie && strstr(rcookie, \"VncViewer.class\")) {\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t\trfbLog(\"helper[%d]:\\n\", pid);\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"SSL: WARNING CLIENT ASKED FOR NONEXISTENT 'VncViewer.class'\\n\");\n\t\t\t\trfbLog(\"SSL: USER NEEDS TO MAKE SURE THE JAVA PLUGIN IS INSTALLED\\n\");\n\t\t\t\trfbLog(\"SSL: AND WORKING PROPERLY (e.g. a test-java-plugin page.)\\n\");\n\t\t\t\trfbLog(\"SSL: AND/OR USER NEEDS TO **RESTART** HIS WEB BROWSER.\\n\");\n\t\t\t\trfbLog(\"SSL: SOMETIMES THE BROWSER 'REMEMBERS' FAILED APPLET DOWN-\\n\");\n\t\t\t\trfbLog(\"SSL: LOADS AND RESTARTING IT IS THE ONLY WAY TO FIX THINGS.\\n\");\n\t\t\t\trfbLog(\"***********************************************************\\n\");\n\t\t\t\trfbLog(\"\\n\");\n\t\t\t}\n\t\t\tssl_helper_pid(pid, -2);\n\n\t\t\tif (https_port_redir) {\n\t\t\t\tdouble start;\n\t\t\t\tint origport = screen->port;\n\t\t\t\tint useport = screen->port;\n\t\t\t\tint saw_httpsock = 0;\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (https_port_redir < 0) {\n\t\t\t\t\tchar *q = strstr(rcookie, \"HP=\");\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tif (sscanf(q, \"HP=%d,\", &p) == 1) {\n\t\t\t\t\t\t\tuseport = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuseport = https_port_redir;\n\t\t\t\t}\n\t\t\t\tscreen->port = useport;\n\t\t\t\tif (origport != useport) {\n\t\t\t\t\trfbLog(\"SSL: -httpsredir guess port: %d  helper[%d]\\n\", screen->port, pid);\n\t\t\t\t}\n\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: guessing child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tscreen->port = origport;\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tif (mode == OPENSSL_INETD) {\n\t\t\t\t\tclean_up_exit(1);\n\t\t\t\t}\n\t\t\t} else if (mode == OPENSSL_INETD) {\n\t\t\t\tdouble start;\n\t\t\t\tint saw_httpsock = 0;\n\n\t\t\t\t/* to expand $PORT correctly in index.vnc */\n\t\t\t\tif (screen->port == 0) {\n\t\t\t\t\tint fd = fileno(stdin);\n\t\t\t\t\tif (getenv(\"X11VNC_INETD_PORT\")) {\n\t\t\t\t\t\t/* mutex */\n\t\t\t\t\t\tscreen->port = atoi(getenv(\n\t\t\t\t\t\t    \"X11VNC_INETD_PORT\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint tport = get_local_port(fd);\n\t\t\t\t\t\tif (tport > 0) {\n\t\t\t\t\t\t\tscreen->port = tport;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: screen->port %d for helper[%d]\\n\", screen->port, pid);\n\n\t\t\t\t/* kludge for https fetch via inetd */\n\t\t\t\tstart = dnow();\n\t\t\t\twhile (dnow() < start + https_download_wait_time) {\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\trfbPE(10000);\n\t\t\t\t\tusleep(10000);\n\t\t\t\t\tif (screen->httpSock >= 0) saw_httpsock = 1;\n\t\t\t\t\twaitpid(pid, &status, WNOHANG); \n\t\t\t\t\tif (kill(pid, 0) != 0) {\n\t\t\t\t\t\trfbLog(\"SSL: helper[%d] pid finished\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (0 && saw_httpsock && screen->httpSock < 0) {\n\t\t\t\t\t\t/* this check can kill the helper too soon. */\n\t\t\t\t\t\trfbLog(\"SSL: httpSock for helper[%d] went away\\n\", pid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trfbLog(\"SSL: OPENSSL_INETD guessing \"\n\t\t\t\t    \"child helper[%d] https finished. dt=%.6f\\n\",\n\t\t\t\t    pid, dnow() - start);\n\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\t\t\t\trfbPE(10000);\n\n\t\t\t\tssl_helper_pid(0, -2);\n\t\t\t\tclean_up_exit(1);\n\t\t\t}\n\t\t\t/* this will actually only get earlier https */\n\t\t\tssl_helper_pid(0, -2);\n\t\t\treturn;\n\t\t}\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n\n\taccept_client:\n\n\tif (db) fprintf(stderr, \"accept_openssl: cookie good: %s\\n\", cookie);\n\n\trfbLog(\"SSL: handshake with helper process[%d] succeeded.\\n\", pid);\n\n\topenssl_last_helper_pid = pid;\n\tssl_helper_pid(pid, vsock);\n\n\tif (vnc_redirect) {\n\t\tvnc_redirect_sock = vsock;\n\t\topenssl_last_helper_pid = 0;\n\t\treturn;\n\t}\n\n\tclient = create_new_client(vsock, 0);\n\topenssl_last_helper_pid = 0;\n\n\tif (client) {\n\t\tint swt = 0;\n\t\tif (mode == OPENSSL_VNC6 && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t} else if (mode == OPENSSL_REVERSE && ipv6_name != NULL && openssl_last_ip != NULL) {\n\t\t\tswt = 1;\n\t\t}\n\t\tif (swt) {\n\t\t\tif (client->host) {\n\t\t\t\tfree(client->host);\n\t\t\t}\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (db) fprintf(stderr, \"accept_openssl: client %p\\n\", (void *) client);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) screen->newClientHook);\n\t\tif (db) fprintf(stderr, \"accept_openssl: new_client %p\\n\", (void *) new_client);\n\t\tif (mode == OPENSSL_INETD) {\n\t\t\tinetd_client = client;\n\t\t\tclient->clientGoneHook = client_gone;\n\t\t}\n\t\tif (openssl_last_ip &&\n\t\t    strpbrk(openssl_last_ip, \"0123456789\") == openssl_last_ip) {\n\t\t\tclient->host = strdup(openssl_last_ip);\n\t\t}\n\t\tif (vencrypt_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n#if LIBVNCSERVER_HAVE_LIBSSL || HAVE_LIBSSL \n\t\t\tif (!finish_vencrypt_auth(client, vencrypt_sel)) {\n\t\t\t\trfbCloseClient(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n#else\n\t\t\tbadnews(\"3 accept_openssl\");\n#endif\n\t\t} else if (anontls_sel != 0) {\n\t\t\tclient->protocolMajorVersion = 3;\n\t\t\tclient->protocolMinorVersion = 8;\n\t\t\trfbAuthNewClient(client);\n\t\t}\n\t\tif (use_threads && client != NULL) {\n\t\t\trfbStartOnHoldClient(client);\n\t\t}\n\t\t/* try to get RFB proto done now. */\n\t\tprogress_client();\n\t} else {\n\t\trfbLog(\"SSL: accept_openssl: rfbNewClient failed.\\n\");\n\t\tclose(vsock);\n\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (mode == OPENSSL_INETD || ssl_no_fail) {\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_dh_params"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "d",
            "new_dh_params",
            "len"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "len+1",
            "1"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cnf",
            "&sbuf"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"add_anon_dh: created new DH params in %.3f secs\\n\"",
            "dnow() - ds"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "exe",
            "exe",
            "\"dhparam\"",
            "\"-out\"",
            "cnf",
            "\"1024\"",
            "(char *)0"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"add_anon_dh: cannot run external commands.\\n\""
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"ssl\""
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openssl_bin",
          "args": [],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "find_openssl_bin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "194-234",
          "snippet": "char *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *find_openssl_bin(void);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *find_openssl_bin(void);\nstatic char *get_input(char *tag, char **in);\n\nchar *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "new_dh_params"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "cnf"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"add_anon_dh: using %s\\n\"",
            "dhparams_file"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *dhret = NULL;\nchar *new_dh_params = NULL;\nchar *find_openssl_bin(void);\nstatic char *get_input(char *tag, char **in);\n\nstatic int add_anon_dh(void) {\n\tpid_t pid, pidw;\n\tchar cnf[] = \"/tmp/x11vnc-dh.XXXXXX\";\n\tchar *infile = NULL;\n\tint status, cnf_fd;\n\tDH *dh;\n\tBIO *bio;\n\tFILE *in;\n\tdouble ds;\n\t/*\n\t * These are dh parameters (prime, generator), not dh keys.\n\t * Evidently it is ok for them to be publicly known.\n\t * openssl dhparam -out dh.out 1024\n\t */\n\tchar *fixed_dh_params = \n\"-----BEGIN DH PARAMETERS-----\\n\"\n\"MIGHAoGBAL28w69ZnLYBvp8R2OeqtAIms+oatY19iBL4WhGI/7H1OMmkJjIe+OHs\\n\"\n\"PXoJfe5ucrnvno7Xm+HJZYa1jnPGQuWoa/VJKXdVjYdJVNzazJKM2daKKcQA4GDc\\n\"\n\"msFS5DxLbzUR5jy1n12K3EcbvpyFqDYVTJJXm7NuNuiWRfz3wTozAgEC\\n\"\n\"-----END DH PARAMETERS-----\\n\";\n\n\tif (dhparams_file != NULL) {\n\t\tinfile = dhparams_file;\n\t\trfbLog(\"add_anon_dh: using %s\\n\", dhparams_file);\n\t\tgoto readin;\n\t}\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn 0;\n\t}\n\tinfile = cnf;\n\n\tif (create_fresh_dhparams) {\n\n\t\tif (new_dh_params != NULL) {\n\t\t\twrite(cnf_fd, new_dh_params, strlen(new_dh_params));\n\t\t\tclose(cnf_fd);\n\t\t} else {\n\t\t\tchar *exe = find_openssl_bin();\n\t\t\tstruct stat sbuf;\n\n\t\t\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\t\t\trfbLog(\"add_anon_dh: cannot run external commands.\\n\");\t\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tclose(cnf_fd);\n\t\t\tif (exe == NULL) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tds = dnow();\n\t\t\tpid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\treturn 0;\n\t\t\t} else if (pid == 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i=0; i<256; i++) {\n\t\t\t\t\tif (i == 2) continue;\n\t\t\t\t\tclose(i);\n\t\t\t\t}\n\t\t\t\t/* rather slow at 1024 */\n\t\t\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"1024\", (char *)0);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tpidw = waitpid(pid, &status, 0); \n\t\t\tif (pidw != pid) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trfbLog(\"add_anon_dh: created new DH params in %.3f secs\\n\", dnow() - ds);\n\n\t\t\tif (stat(cnf, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\t\t\t/* save it to reuse during our process's lifetime: */\n\t\t\t\tint d = open(cnf, O_RDONLY);\n\t\t\t\tif (d >= 0) {\n\t\t\t\t\tint n, len = sbuf.st_size;\n\t\t\t\t\tnew_dh_params = (char *) calloc(len+1, 1);\n\t\t\t\t\tn = read(d, new_dh_params, len);\n\t\t\t\t\tclose(d);\n\t\t\t\t\tif (n != len) {\n\t\t\t\t\t\tfree(new_dh_params);\n\t\t\t\t\t\tnew_dh_params = NULL;\n\t\t\t\t\t} else if (dhret != NULL) {\n\t\t\t\t\t\td = open(dhret, O_WRONLY);\n\t\t\t\t\t\tif (d >= 0) {\n\t\t\t\t\t\t\twrite(d, new_dh_params, strlen(new_dh_params));\n\t\t\t\t\t\t\tclose(d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\twrite(cnf_fd, fixed_dh_params, strlen(fixed_dh_params));\n\t\tclose(cnf_fd);\n\t}\n\n\treadin:\n\n\tds = dnow();\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLogPerror(\"fopen\");\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\tif (! bio) {\n\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\treturn 0;\n\t}\n\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\tif (dh == NULL) {\n\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\tunlink(cnf);\n\t\tBIO_free(bio);\n\t\treturn 0;\n\t}\n\tBIO_free(bio);\n\tSSL_CTX_set_tmp_dh(ctx, dh);\n\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\", 8*DH_size(dh), dnow()-ds);\n\tDH_free(dh);\n\n\tunlink(cnf);\n\treturn 1;\n}"
  },
  {
    "function_name": "finish_vencrypt_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1431-1443",
    "snippet": "static int finish_vencrypt_auth(rfbClientPtr client, int subtype) {\n\n\tif (subtype == rfbVencryptTlsNone || subtype == rfbVencryptX509None) {\n\t\treturn finish_auth(client, \"None\");\n\t} else if (subtype == rfbVencryptTlsVnc || subtype == rfbVencryptX509Vnc) {\n\t\treturn finish_auth(client, \"Vnc\");\n\t} else if (subtype == rfbVencryptTlsPlain || subtype == rfbVencryptX509Plain) {\n\t\treturn finish_auth(client, \"Plain\");\n\t} else {\n\t\trfbLog(\"finish_vencrypt_auth: unknown sub-type: %d\\n\", subtype);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define rfbVencryptX509Plain\t262",
      "#define rfbVencryptX509Vnc\t261",
      "#define rfbVencryptX509None\t260",
      "#define rfbVencryptTlsPlain\t259",
      "#define rfbVencryptTlsVnc\t258",
      "#define rfbVencryptTlsNone\t257"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"finish_vencrypt_auth: unknown sub-type: %d\\n\"",
            "subtype"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_auth",
          "args": [
            "client",
            "\"Plain\""
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "finish_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1349-1429",
          "snippet": "static int finish_auth(rfbClientPtr client, char *type) {\n\tint security_result, ret;\n\n\tret = 0;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"finish_auth type=%s\\n\", type);\n\n\tif (!strcmp(type, \"None\")) {\n\t\tsecurity_result = 0;\t/* success */\n\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'None'\\n\");\n\t\tclient->state = RFB_INITIALISATION;\n\n\t} else if (!strcmp(type, \"Vnc\")) {\n\t\tRAND_bytes(client->authChallenge, CHALLENGESIZE);\n\t\tif (write_exact(client->sock, (char *) &client->authChallenge, CHALLENGESIZE)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'Vnc', sent challenge.\\n\");\n\t\tclient->state = RFB_AUTHENTICATION;\n\n\t} else if (!strcmp(type, \"Plain\")) {\n\t\tif (!unixpw) {\n\t\t\trfbLog(\"finish_auth: *Plain not allowed outside unixpw mode.\\n\");\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tchar *un, *pw;\n\t\t\tint unlen, pwlen;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain begin: onHold=%d client=%p unixpw_client=%p\\n\", client->onHold, (void *) client, (void *) unixpw_client);\n\n\t\t\tif (!read_exact(client->sock, (char *)&unlen, 4)) goto fail;\n\t\t\tunlen = Swap32IfLE(unlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"unlen: %d\\n\", unlen);\n\n\t\t\tif (!read_exact(client->sock, (char *)&pwlen, 4)) goto fail;\n\t\t\tpwlen = Swap32IfLE(pwlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"pwlen: %d\\n\", pwlen);\n\n\t\t\tun = (char *) malloc(unlen+1);\n\t\t\tmemset(un, 0, unlen+1);\n\n\t\t\tpw = (char *) malloc(pwlen+2);\n\t\t\tmemset(pw, 0, pwlen+2);\n\n\t\t\tif (!read_exact(client->sock, un, unlen)) goto fail;\n\t\t\tif (!read_exact(client->sock, pw, pwlen)) goto fail;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain: %d %d '%s' ... \\n\", unlen, pwlen, un);\n\t\t\tstrcat(pw, \"\\n\");\n\n\t\t\tif (unixpw_verify(un, pw)) {\n\t\t\t\tsecurity_result = 0;\t/* success */\n\t\t\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tunixpw_verify_screen(un, pw);\n\t\t\t\t}\n\t\t\t\tclient->onHold = FALSE;\n\t\t\t\tclient->state = RFB_INITIALISATION;\n\t\t\t}\n\t\t\tif (ret == 0) {\n\t\t\t\trfbClientSendString(client, \"unixpw failed\");\n\t\t\t}\n\n\t\t\tmemset(un, 0, unlen+1);\n\t\t\tmemset(pw, 0, pwlen+2);\n\t\t\tfree(un);\n\t\t\tfree(pw);\n\t\t}\n\t} else {\n\t\trfbLog(\"finish_auth: unknown sub-type: %s\\n\", type);\n\t\tret = 0;\n\t}\n\n\tfail:\n\treturn ret;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int finish_auth(rfbClientPtr client, char *type) {\n\tint security_result, ret;\n\n\tret = 0;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"finish_auth type=%s\\n\", type);\n\n\tif (!strcmp(type, \"None\")) {\n\t\tsecurity_result = 0;\t/* success */\n\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'None'\\n\");\n\t\tclient->state = RFB_INITIALISATION;\n\n\t} else if (!strcmp(type, \"Vnc\")) {\n\t\tRAND_bytes(client->authChallenge, CHALLENGESIZE);\n\t\tif (write_exact(client->sock, (char *) &client->authChallenge, CHALLENGESIZE)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'Vnc', sent challenge.\\n\");\n\t\tclient->state = RFB_AUTHENTICATION;\n\n\t} else if (!strcmp(type, \"Plain\")) {\n\t\tif (!unixpw) {\n\t\t\trfbLog(\"finish_auth: *Plain not allowed outside unixpw mode.\\n\");\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tchar *un, *pw;\n\t\t\tint unlen, pwlen;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain begin: onHold=%d client=%p unixpw_client=%p\\n\", client->onHold, (void *) client, (void *) unixpw_client);\n\n\t\t\tif (!read_exact(client->sock, (char *)&unlen, 4)) goto fail;\n\t\t\tunlen = Swap32IfLE(unlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"unlen: %d\\n\", unlen);\n\n\t\t\tif (!read_exact(client->sock, (char *)&pwlen, 4)) goto fail;\n\t\t\tpwlen = Swap32IfLE(pwlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"pwlen: %d\\n\", pwlen);\n\n\t\t\tun = (char *) malloc(unlen+1);\n\t\t\tmemset(un, 0, unlen+1);\n\n\t\t\tpw = (char *) malloc(pwlen+2);\n\t\t\tmemset(pw, 0, pwlen+2);\n\n\t\t\tif (!read_exact(client->sock, un, unlen)) goto fail;\n\t\t\tif (!read_exact(client->sock, pw, pwlen)) goto fail;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain: %d %d '%s' ... \\n\", unlen, pwlen, un);\n\t\t\tstrcat(pw, \"\\n\");\n\n\t\t\tif (unixpw_verify(un, pw)) {\n\t\t\t\tsecurity_result = 0;\t/* success */\n\t\t\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tunixpw_verify_screen(un, pw);\n\t\t\t\t}\n\t\t\t\tclient->onHold = FALSE;\n\t\t\t\tclient->state = RFB_INITIALISATION;\n\t\t\t}\n\t\t\tif (ret == 0) {\n\t\t\t\trfbClientSendString(client, \"unixpw failed\");\n\t\t\t}\n\n\t\t\tmemset(un, 0, unlen+1);\n\t\t\tmemset(pw, 0, pwlen+2);\n\t\t\tfree(un);\n\t\t\tfree(pw);\n\t\t}\n\t} else {\n\t\trfbLog(\"finish_auth: unknown sub-type: %s\\n\", type);\n\t\tret = 0;\n\t}\n\n\tfail:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define rfbVencryptX509Plain\t262\n#define rfbVencryptX509Vnc\t261\n#define rfbVencryptX509None\t260\n#define rfbVencryptTlsPlain\t259\n#define rfbVencryptTlsVnc\t258\n#define rfbVencryptTlsNone\t257\n\nstatic int finish_vencrypt_auth(rfbClientPtr client, int subtype) {\n\n\tif (subtype == rfbVencryptTlsNone || subtype == rfbVencryptX509None) {\n\t\treturn finish_auth(client, \"None\");\n\t} else if (subtype == rfbVencryptTlsVnc || subtype == rfbVencryptX509Vnc) {\n\t\treturn finish_auth(client, \"Vnc\");\n\t} else if (subtype == rfbVencryptTlsPlain || subtype == rfbVencryptX509Plain) {\n\t\treturn finish_auth(client, \"Plain\");\n\t} else {\n\t\trfbLog(\"finish_vencrypt_auth: unknown sub-type: %d\\n\", subtype);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "finish_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1349-1429",
    "snippet": "static int finish_auth(rfbClientPtr client, char *type) {\n\tint security_result, ret;\n\n\tret = 0;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"finish_auth type=%s\\n\", type);\n\n\tif (!strcmp(type, \"None\")) {\n\t\tsecurity_result = 0;\t/* success */\n\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'None'\\n\");\n\t\tclient->state = RFB_INITIALISATION;\n\n\t} else if (!strcmp(type, \"Vnc\")) {\n\t\tRAND_bytes(client->authChallenge, CHALLENGESIZE);\n\t\tif (write_exact(client->sock, (char *) &client->authChallenge, CHALLENGESIZE)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'Vnc', sent challenge.\\n\");\n\t\tclient->state = RFB_AUTHENTICATION;\n\n\t} else if (!strcmp(type, \"Plain\")) {\n\t\tif (!unixpw) {\n\t\t\trfbLog(\"finish_auth: *Plain not allowed outside unixpw mode.\\n\");\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tchar *un, *pw;\n\t\t\tint unlen, pwlen;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain begin: onHold=%d client=%p unixpw_client=%p\\n\", client->onHold, (void *) client, (void *) unixpw_client);\n\n\t\t\tif (!read_exact(client->sock, (char *)&unlen, 4)) goto fail;\n\t\t\tunlen = Swap32IfLE(unlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"unlen: %d\\n\", unlen);\n\n\t\t\tif (!read_exact(client->sock, (char *)&pwlen, 4)) goto fail;\n\t\t\tpwlen = Swap32IfLE(pwlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"pwlen: %d\\n\", pwlen);\n\n\t\t\tun = (char *) malloc(unlen+1);\n\t\t\tmemset(un, 0, unlen+1);\n\n\t\t\tpw = (char *) malloc(pwlen+2);\n\t\t\tmemset(pw, 0, pwlen+2);\n\n\t\t\tif (!read_exact(client->sock, un, unlen)) goto fail;\n\t\t\tif (!read_exact(client->sock, pw, pwlen)) goto fail;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain: %d %d '%s' ... \\n\", unlen, pwlen, un);\n\t\t\tstrcat(pw, \"\\n\");\n\n\t\t\tif (unixpw_verify(un, pw)) {\n\t\t\t\tsecurity_result = 0;\t/* success */\n\t\t\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tunixpw_verify_screen(un, pw);\n\t\t\t\t}\n\t\t\t\tclient->onHold = FALSE;\n\t\t\t\tclient->state = RFB_INITIALISATION;\n\t\t\t}\n\t\t\tif (ret == 0) {\n\t\t\t\trfbClientSendString(client, \"unixpw failed\");\n\t\t\t}\n\n\t\t\tmemset(un, 0, unlen+1);\n\t\t\tmemset(pw, 0, pwlen+2);\n\t\t\tfree(un);\n\t\t\tfree(pw);\n\t\t}\n\t} else {\n\t\trfbLog(\"finish_auth: unknown sub-type: %s\\n\", type);\n\t\tret = 0;\n\t}\n\n\tfail:\n\treturn ret;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ssl_helper_pid(pid_t pid, int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"finish_auth: unknown sub-type: %s\\n\"",
            "type"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pw"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pw",
            "0",
            "pwlen+2"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "un",
            "0",
            "unlen+1"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbClientSendString",
          "args": [
            "client",
            "\"unixpw failed\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unixpw_verify_screen",
          "args": [
            "un",
            "pw"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "unixpw_verify_screen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "1568-1657",
          "snippet": "void unixpw_verify_screen(char *user, char *pass) {\n\tint x, y;\n\tchar li[] = \"Login incorrect\";\n\tchar ls[] = \"Login succeeded\";\n\tchar log[] = \"login: \";\n\tchar *colon = NULL;\n\tClientData *cd = NULL;\n\tint ok;\n\nif (db) fprintf(stderr, \"unixpw_verify: '%s' '%s'\\n\", user, db > 1 ? pass : \"********\");\n\trfbLog(\"unixpw_verify: '%s'\\n\", user ? user : \"(null)\");\n\n\tif (user) {\n\t\tcolon = strchr(user, ':');\n\t}\n\tif (colon) {\n\t\t*colon = '\\0';\n\t\trfbLog(\"unixpw_verify: colon: '%s'\\n\", user);\n\t}\n\tfflush(stderr);\n\tif (unixpw_client) {\n\t\tcd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tchar *str = (char *)malloc(strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1);\n\t\t\tsprintf(str, \"UNIX:%s\", user);\t\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = str;\n\t\t}\n\t}\n\n\tok = unixpw_verify(user, pass);\n\n\tif (ok) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, ls, white_pixel());\n\t\tunixpw_mark();\n\n\t\tprogress_skippy();\n\n\t\tunixpw_accept(user);\n\n\t\tif (keep_unixpw) {\n\t\t\tkeep_unixpw_user = strdup(user);\n\t\t\tkeep_unixpw_pass = strdup(pass);\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\n\t\tif (colon) *colon = ':';\n\n\t\treturn;\n\t}\n\tif (colon) *colon = ':';\n\n\tif (tries < 2) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, li, white_pixel());\n\n\t\tchar_row += 2;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_col = strlen(log);\n\n\t\tunixpw_mark();\n\n\t\tunixpw_last_try_time = time(NULL);\n\t\tunixpw_keystroke(0, 0, 2);\n\t\ttries++;\n\t} else {\n\t\tunixpw_deny();\n\t}\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int white_pixel(void);",
            "void unixpw_accept(char *user);",
            "void unixpw_deny(void);",
            "int unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);",
            "int crypt_verify(char *user, char *pass);",
            "int cmd_verify(char *user, char *pass);",
            "void unixpw_verify_screen(char *user, char *pass);",
            "static int text_x(void);",
            "static int text_y(void);",
            "time_t unixpw_last_try_time = 0;",
            "rfbClientPtr unixpw_client = NULL;",
            "int keep_unixpw = 0;",
            "char *keep_unixpw_user = NULL;",
            "char *keep_unixpw_pass = NULL;",
            "char *keep_unixpw_opts = NULL;",
            "static int char_row = 0, char_col = 0;",
            "static int db = 0;",
            "static rfbScreenInfoPtr pscreen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nint white_pixel(void);\nvoid unixpw_accept(char *user);\nvoid unixpw_deny(void);\nint unixpw_cmd_run(char *user, char *pass, char *cmd, char *line, int *n);\nint crypt_verify(char *user, char *pass);\nint cmd_verify(char *user, char *pass);\nvoid unixpw_verify_screen(char *user, char *pass);\nstatic int text_x(void);\nstatic int text_y(void);\ntime_t unixpw_last_try_time = 0;\nrfbClientPtr unixpw_client = NULL;\nint keep_unixpw = 0;\nchar *keep_unixpw_user = NULL;\nchar *keep_unixpw_pass = NULL;\nchar *keep_unixpw_opts = NULL;\nstatic int char_row = 0, char_col = 0;\nstatic int db = 0;\nstatic rfbScreenInfoPtr pscreen;\n\nvoid unixpw_verify_screen(char *user, char *pass) {\n\tint x, y;\n\tchar li[] = \"Login incorrect\";\n\tchar ls[] = \"Login succeeded\";\n\tchar log[] = \"login: \";\n\tchar *colon = NULL;\n\tClientData *cd = NULL;\n\tint ok;\n\nif (db) fprintf(stderr, \"unixpw_verify: '%s' '%s'\\n\", user, db > 1 ? pass : \"********\");\n\trfbLog(\"unixpw_verify: '%s'\\n\", user ? user : \"(null)\");\n\n\tif (user) {\n\t\tcolon = strchr(user, ':');\n\t}\n\tif (colon) {\n\t\t*colon = '\\0';\n\t\trfbLog(\"unixpw_verify: colon: '%s'\\n\", user);\n\t}\n\tfflush(stderr);\n\tif (unixpw_client) {\n\t\tcd = (ClientData *) unixpw_client->clientData;\n\t\tif (cd) {\n\t\t\tchar *str = (char *)malloc(strlen(\"UNIX:\") +\n\t\t\t    strlen(user) + 1);\n\t\t\tsprintf(str, \"UNIX:%s\", user);\t\n\t\t\tif (cd->username) {\n\t\t\t\tfree(cd->username);\n\t\t\t}\n\t\t\tcd->username = str;\n\t\t}\n\t}\n\n\tok = unixpw_verify(user, pass);\n\n\tif (ok) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, ls, white_pixel());\n\t\tunixpw_mark();\n\n\t\tprogress_skippy();\n\n\t\tunixpw_accept(user);\n\n\t\tif (keep_unixpw) {\n\t\t\tkeep_unixpw_user = strdup(user);\n\t\t\tkeep_unixpw_pass = strdup(pass);\n\t\t\tif (colon) {\n\t\t\t\tkeep_unixpw_opts = strdup(colon+1);\n\t\t\t} else {\n\t\t\t\tkeep_unixpw_opts = strdup(\"\");\n\t\t\t}\n\t\t\tcheck_unixpw_userprefs();\n\t\t}\n\n\t\tif (colon) *colon = ':';\n\n\t\treturn;\n\t}\n\tif (colon) *colon = ':';\n\n\tif (tries < 2) {\n\t\tchar_row++;\n\t\tchar_col = 0;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, li, white_pixel());\n\n\t\tchar_row += 2;\n\n\t\tx = text_x();\n\t\ty = text_y();\n\t\trfbDrawString(pscreen, &default8x16Font, x, y, log, white_pixel());\n\n\t\tchar_col = strlen(log);\n\n\t\tunixpw_mark();\n\n\t\tunixpw_last_try_time = time(NULL);\n\t\tunixpw_keystroke(0, 0, 2);\n\t\ttries++;\n\t} else {\n\t\tunixpw_deny();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_exact",
          "args": [
            "client->sock",
            "(char *) &security_result",
            "4"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "pw",
            "\"\\n\""
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*Plain: %d %d '%s' ... \\n\"",
            "unlen",
            "pwlen",
            "un"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_TLSPLAIN\""
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_exact",
          "args": [
            "client->sock",
            "pw",
            "pwlen"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pw",
            "0",
            "pwlen+2"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "pwlen+2"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "un",
            "0",
            "unlen+1"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "unlen+1"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"pwlen: %d\\n\"",
            "pwlen"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_TLSPLAIN\""
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32IfLE",
          "args": [
            "pwlen"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unlen: %d\\n\"",
            "unlen"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_TLSPLAIN\""
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Swap32IfLE",
          "args": [
            "unlen"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"*Plain begin: onHold=%d client=%p unixpw_client=%p\\n\"",
            "client->onHold",
            "(void *) client",
            "(void *) unixpw_client"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_TLSPLAIN\""
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"finish_auth: *Plain not allowed outside unixpw mode.\\n\""
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"Plain\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"finish_auth: using auth 'Vnc', sent challenge.\\n\""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "client->authChallenge",
            "CHALLENGESIZE"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"Vnc\""
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"finish_auth: using auth 'None'\\n\""
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"None\""
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"finish_auth type=%s\\n\"",
            "type"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_DEBUG_TLSPLAIN\""
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int finish_auth(rfbClientPtr client, char *type) {\n\tint security_result, ret;\n\n\tret = 0;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"finish_auth type=%s\\n\", type);\n\n\tif (!strcmp(type, \"None\")) {\n\t\tsecurity_result = 0;\t/* success */\n\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'None'\\n\");\n\t\tclient->state = RFB_INITIALISATION;\n\n\t} else if (!strcmp(type, \"Vnc\")) {\n\t\tRAND_bytes(client->authChallenge, CHALLENGESIZE);\n\t\tif (write_exact(client->sock, (char *) &client->authChallenge, CHALLENGESIZE)) {\n\t\t\tret = 1;\n\t\t}\n\t\trfbLog(\"finish_auth: using auth 'Vnc', sent challenge.\\n\");\n\t\tclient->state = RFB_AUTHENTICATION;\n\n\t} else if (!strcmp(type, \"Plain\")) {\n\t\tif (!unixpw) {\n\t\t\trfbLog(\"finish_auth: *Plain not allowed outside unixpw mode.\\n\");\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tchar *un, *pw;\n\t\t\tint unlen, pwlen;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain begin: onHold=%d client=%p unixpw_client=%p\\n\", client->onHold, (void *) client, (void *) unixpw_client);\n\n\t\t\tif (!read_exact(client->sock, (char *)&unlen, 4)) goto fail;\n\t\t\tunlen = Swap32IfLE(unlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"unlen: %d\\n\", unlen);\n\n\t\t\tif (!read_exact(client->sock, (char *)&pwlen, 4)) goto fail;\n\t\t\tpwlen = Swap32IfLE(pwlen);\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"pwlen: %d\\n\", pwlen);\n\n\t\t\tun = (char *) malloc(unlen+1);\n\t\t\tmemset(un, 0, unlen+1);\n\n\t\t\tpw = (char *) malloc(pwlen+2);\n\t\t\tmemset(pw, 0, pwlen+2);\n\n\t\t\tif (!read_exact(client->sock, un, unlen)) goto fail;\n\t\t\tif (!read_exact(client->sock, pw, pwlen)) goto fail;\n\nif (getenv(\"X11VNC_DEBUG_TLSPLAIN\")) fprintf(stderr, \"*Plain: %d %d '%s' ... \\n\", unlen, pwlen, un);\n\t\t\tstrcat(pw, \"\\n\");\n\n\t\t\tif (unixpw_verify(un, pw)) {\n\t\t\t\tsecurity_result = 0;\t/* success */\n\t\t\t\tif (write_exact(client->sock, (char *) &security_result, 4)) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tunixpw_verify_screen(un, pw);\n\t\t\t\t}\n\t\t\t\tclient->onHold = FALSE;\n\t\t\t\tclient->state = RFB_INITIALISATION;\n\t\t\t}\n\t\t\tif (ret == 0) {\n\t\t\t\trfbClientSendString(client, \"unixpw failed\");\n\t\t\t}\n\n\t\t\tmemset(un, 0, unlen+1);\n\t\t\tmemset(pw, 0, pwlen+2);\n\t\t\tfree(un);\n\t\t\tfree(pw);\n\t\t}\n\t} else {\n\t\trfbLog(\"finish_auth: unknown sub-type: %s\\n\", type);\n\t\tret = 0;\n\t}\n\n\tfail:\n\treturn ret;\n}"
  },
  {
    "function_name": "write_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1319-1344",
    "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ssl_helper_pid(pid_t pid, int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10*1000"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "read_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1292-1317",
    "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ssl_helper_pid(pid_t pid, int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10*1000"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "read_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1292-1317",
          "snippet": "static int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int read_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = read(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "openssl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "1004-1290",
    "snippet": "void openssl_init(int isclient) {\n\tint db = 0, tmp_pem = 0, do_dh;\n\tconst SSL_METHOD *method;\n\tchar *method_name;\n\tFILE *in;\n\tdouble ds;\n\tlong mode;\n\tstatic int first = 1;\n\n\tdo_dh = DO_DH;\n\n\tif (enc_str != NULL) {\n\t\tif (first) {\n\t\t\tinit_prng();\n\t\t}\n\t\tfirst = 0;\n\t\treturn;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Initializing SSL (%s connect mode).\\n\", isclient ? \"client\":\"server\");\n\t}\n\tif (first) {\n\t\tif (db) fprintf(stderr, \"\\nSSL_load_error_strings()\\n\");\n\n\t\tSSL_load_error_strings();\n\n\t\tif (db) fprintf(stderr, \"SSL_library_init()\\n\");\n\n\t\tSSL_library_init();\n\n\t\tif (db) fprintf(stderr, \"init_prng()\\n\");\n\n\t\tinit_prng();\n\n\t\tfirst = 0;\n\t}\n\n\tif (isclient) {\n\t\tssl_client_mode = 1;\n\t} else {\n\t\tssl_client_mode = 0;\n\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"TLS_client_method()\" : \"TLS_server_method()\";\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"SSLv23_client_method()\" : \"SSLv23_server_method()\";\n#endif\n\tif (db) fprintf(stderr, \"%s\\n\", method_name);\n\tctx = SSL_CTX_new(method);\n\n\tif (ctx == NULL) {\n\t\trfbLog(\"openssl_init: SSL_CTX_new failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tds = dnow();\n\trsa_512 = RSA_generate_key(512, RSA_F4, NULL, NULL);\n\tif (rsa_512 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(512) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created  512 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tds = dnow();\n\trsa_1024 = RSA_generate_key(1024, RSA_F4, NULL, NULL);\n\tif (rsa_1024 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created 1024 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tif (db) fprintf(stderr, \"SSL_CTX_set_tmp_rsa()\\n\");\n\n\tif (! SSL_CTX_set_tmp_rsa(ctx, rsa_1024)) {\n\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n#define ssl_cache 0\n#if ssl_cache\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n#else\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\n\tSSL_CTX_set_timeout(ctx, 1);\n#endif\n\n\tds = dnow();\n\tif (! openssl_pem) {\n\t\topenssl_pem = create_tmp_pem(NULL, 0);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\n\t} else if (!strcmp(openssl_pem, \"ANON\")) {\n\t\tif (ssl_verify) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslverify mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslCRL mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* n.b. new ctx */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman setup\"\n\t\t\t    \" failed.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (strstr(openssl_pem, \"SAVE\") == openssl_pem) {\n\t\topenssl_pem = get_saved_pem(openssl_pem, 1);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create or open\"\n\t\t\t    \" saved PEM: %s\\n\", openssl_pem);\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 0;\n\t}\n\n\trfbLog(\"using PEM %s  %.3fs\\n\", openssl_pem, dnow() - ds);\n\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\n\tif (do_dh) {\n\t\tDH *dh;\n\t\tBIO *bio;\n\n\t\tds = dnow();\n\t\tin = fopen(openssl_pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\t\tif (! bio) {\n\t\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\t\tif (dh == NULL) {\n\t\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\t\tBIO_free(bio);\n\t\t\tsslerrexit();\n\t\t}\n\t\tBIO_free(bio);\n\t\tSSL_CTX_set_tmp_dh(ctx, dh);\n\t\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\",\n\t\t    8*DH_size(dh), dnow()-ds);\n\t\tDH_free(dh);\n\t}\n\n\tif (strcmp(openssl_pem, \"ANON\")) {\n\t\tif (! SSL_CTX_use_certificate_chain_file(ctx, openssl_pem)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_use_certificate_chain_file() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_use_RSAPrivateKey_file(ctx, openssl_pem,\n\t\t    SSL_FILETYPE_PEM)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_check_private_key(ctx)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t}\n\n\tif (tmp_pem && ! getenv(\"X11VNC_KEEP_TMP_PEM\")) {\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(openssl_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, 128, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\tunlink(openssl_pem);\n\t\tfree(openssl_pem);\n\t\topenssl_pem = NULL;\n\t}\n\n\tif (ssl_crl) {\n\t\tstruct stat sbuf;\n\t\tX509_LOOKUP *lookup;\n\n\t\tif (stat(ssl_crl, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslCRL does not exist %s.\\n\",\n\t\t\t    ssl_crl ? ssl_crl : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\trevocation_store = X509_STORE_new();\n\t\tif (!revocation_store) {\n\t\t\trfbLog(\"openssl_init: X509_STORE_new failed.\\n\");\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_file());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_load_file(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_load_file failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_hash_dir());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_add_dir(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_add_dir failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\t\trfbLog(\"loaded CRL file: %s\\n\", ssl_crl);\n\t}\n\n\tif (ssl_verify) {\n\t\tstruct stat sbuf;\n\t\tchar *file;\n\t\tint lvl;\n\n\t\tfile = get_ssl_verify_file(ssl_verify);\n\n\t\tif (!file || stat(file, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslverify does not exist %s.\\n\",\n\t\t\t    file ? file : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, file, NULL)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, NULL, file)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\n\t\tlvl = SSL_VERIFY_FAIL_IF_NO_PEER_CERT|SSL_VERIFY_PEER;\n\t\tif (ssl_crl == NULL) {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, verify_callback);\n\t\t}\n\t\tif (strstr(file, \"/sslverify-tmp-load-\")) {\n\t\t\t/* temporary file */\n\t\t\tunlink(file);\n\t\t}\n\t} else {\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\trfbLog(\"\\n\");\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define ssl_cache 0",
      "#define DO_DH 0"
    ],
    "globals_used": [
      "char *get_saved_pem(char *string, int create);",
      "static char *get_input(char *tag, char **in);",
      "void openssl_init(int isclient);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_verify",
          "args": [
            "ctx",
            "SSL_VERIFY_NONE",
            "NULL"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "file"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "file",
            "\"/sslverify-tmp-load-\""
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_verify",
          "args": [
            "ctx",
            "lvl",
            "verify_callback"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_verify",
          "args": [
            "ctx",
            "lvl",
            "NULL"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslerrexit",
          "args": [],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "sslerrexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "758-767",
          "snippet": "static void sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\t\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stderr, \"ssl error: %s\\n\", str);\n\t}\n\tclean_up_exit(1);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\t\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stderr, \"ssl error: %s\\n\", str);\n\t}\n\tclean_up_exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\""
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_load_verify_locations",
          "args": [
            "ctx",
            "NULL",
            "file"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_load_verify_locations",
          "args": [
            "ctx",
            "file",
            "NULL"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"stat\""
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: -sslverify does not exist %s.\\n\"",
            "file ? file : \"null\""
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file",
            "&sbuf"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ssl_verify_file",
          "args": [
            "ssl_verify"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "get_ssl_verify_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "547-664",
          "snippet": "char *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_ssl_verify_file(char *str_in);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_ssl_verify_file(char *str_in);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"loaded CRL file: %s\\n\"",
            "ssl_crl"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: X509_LOOKUP_add_dir failed.\\n\""
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_LOOKUP_add_dir",
          "args": [
            "lookup",
            "ssl_crl",
            "X509_FILETYPE_PEM"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: X509_STORE_add_lookup failed.\\n\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_add_lookup",
          "args": [
            "revocation_store",
            "X509_LOOKUP_hash_dir()"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_LOOKUP_hash_dir",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: X509_LOOKUP_load_file failed.\\n\""
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_LOOKUP_load_file",
          "args": [
            "lookup",
            "ssl_crl",
            "X509_FILETYPE_PEM"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: X509_STORE_add_lookup failed.\\n\""
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_add_lookup",
          "args": [
            "revocation_store",
            "X509_LOOKUP_file()"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_LOOKUP_file",
          "args": [],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: X509_STORE_new failed.\\n\""
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_new",
          "args": [],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"stat\""
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: -sslCRL does not exist %s.\\n\"",
            "ssl_crl ? ssl_crl : \"null\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "openssl_pem"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "openssl_pem"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "line"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "128",
            "in"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "openssl_pem",
            "\"r\""
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SHOW_TMP_PEM\""
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_KEEP_TMP_PEM\""
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\""
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_check_private_key",
          "args": [
            "ctx"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\""
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_use_RSAPrivateKey_file",
          "args": [
            "ctx",
            "openssl_pem",
            "SSL_FILETYPE_PEM"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: SSL_CTX_use_certificate_chain_file() failed.\\n\""
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_use_certificate_chain_file",
          "args": [
            "ctx",
            "openssl_pem"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "openssl_pem",
            "\"ANON\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DH_free",
          "args": [
            "dh"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"loaded Diffie Hellman %d bits, %.3fs\\n\"",
            "8*DH_size(dh)",
            "dnow()-ds"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DH_size",
          "args": [
            "dh"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_tmp_dh",
          "args": [
            "ctx",
            "dh"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "bio"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "bio"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: PEM_read_bio_DHparams() failed.\\n\""
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_read_bio_DHparams",
          "args": [
            "bio",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: BIO_new_fp() failed.\\n\""
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new_fp",
          "args": [
            "in",
            "BIO_CLOSE|BIO_FP_TEXT"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "openssl_pem",
            "\"r\""
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_default_passwd_cb",
          "args": [
            "ctx",
            "pem_passwd_callback"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"using PEM %s  %.3fs\\n\"",
            "openssl_pem",
            "dnow() - ds"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: could not create or open\"\n\t\t\t    \" saved PEM: %s\\n\"",
            "openssl_pem"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_saved_pem",
          "args": [
            "openssl_pem",
            "1"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "get_saved_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "88-168",
          "snippet": "char *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_saved_pem(char *string, int create);",
            "char *create_tmp_pem(char *path, int prompt);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_saved_pem(char *string, int create);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "openssl_pem",
            "\"SAVE\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: Anonymous Diffie-Hellman setup\"\n\t\t\t    \" failed.\\n\""
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_to_anon_dh",
          "args": [],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "switch_to_anon_dh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1580-1621",
          "snippet": "static int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int switch_to_anon_dh(void) {\n\tconst SSL_METHOD *method;\n\tlong mode;\n\t\n\trfbLog(\"Using Anonymous Diffie-Hellman mode.\\n\");\n\trfbLog(\"WARNING: Anonymous Diffie-Hellman uses encryption but is\\n\");\n\trfbLog(\"WARNING: susceptible to a Man-In-The-Middle attack.\\n\");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n#endif\n\tctx = SSL_CTX_new(method);\n\tif (ctx == NULL) {\n\t\treturn 0;\n\t}\n\tif (ssl_client_mode) {\n\t\treturn 1;\n\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t/* Security level must be set to 0 for unauthenticated suites. */\n\tSSL_CTX_set_security_level(ctx, 0);\n#endif\n\tif (!SSL_CTX_set_cipher_list(ctx, \"ADH:@SECLEVEL=0\")) {\n\t\treturn 0;\n\t}\n\tif (!add_anon_dh()) {\n\t\treturn 0;\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslCRL mode.\\n\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslverify mode.\\n\""
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "openssl_pem",
            "\"ANON\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\""
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_tmp_pem",
          "args": [
            "NULL",
            "0"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "create_tmp_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "238-517",
          "snippet": "char *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK",
            "#define DO_DH 0"
          ],
          "globals_used": [
            "char *get_saved_pem(char *string, int create);",
            "char *find_openssl_bin(void);",
            "char *create_tmp_pem(char *path, int prompt);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n#define DO_DH 0\n\nchar *get_saved_pem(char *string, int create);\nchar *find_openssl_bin(void);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_timeout",
          "args": [
            "ctx",
            "1"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_session_cache_mode",
          "args": [
            "ctx",
            "SSL_SESS_CACHE_OFF"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_timeout",
          "args": [
            "ctx",
            "300"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_session_cache_mode",
          "args": [
            "ctx",
            "SSL_SESS_CACHE_BOTH"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_mode",
          "args": [
            "ctx",
            "mode"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\""
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_set_tmp_rsa",
          "args": [
            "ctx",
            "rsa_1024"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_CTX_set_tmp_rsa()\\n\""
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"created 1024 bit temporary RSA key: %.3fs\\n\"",
            "dnow() - ds"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: RSA_generate_key(1024) failed.\\n\""
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_generate_key",
          "args": [
            "1024",
            "RSA_F4",
            "NULL",
            "NULL"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"created  512 bit temporary RSA key: %.3fs\\n\"",
            "dnow() - ds"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: RSA_generate_key(512) failed.\\n\""
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_generate_key",
          "args": [
            "512",
            "RSA_F4",
            "NULL",
            "NULL"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: SSL_CTX_new failed.\\n\""
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_new",
          "args": [
            "method"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "method_name"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSLv23_server_method",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSLv23_client_method",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLS_server_method",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLS_client_method",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_prng",
          "args": [],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "init_prng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "2631-2685",
          "snippet": "static void init_prng(void) {\n\tint db = 0, bytes, ubytes, fd;\n\tchar file[MSZ], dtmp[100];\n\tunsigned int sr;\n\n\tRAND_file_name(file, MSZ);\n\n\trfbLog(\"RAND_file_name: %s\\n\", file);\n\n\tbytes = RAND_load_file(file, -1);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\t\n\tubytes = RAND_load_file(\"/dev/urandom\", 64);\n\tbytes += ubytes;\n\tif (db) fprintf(stderr, \"bytes read: %d / %d\\n\", bytes, ubytes);\n\n\t/* mix in more predictable stuff as well for fallback */\n\tsprintf(dtmp, \"/tmp/p%.8f.XXXXXX\", dnow());\n\tfd = mkstemp(dtmp);\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t\tunlink(dtmp);\n\t}\n\tsprintf(dtmp, \"%d-%.8f\", (int) getpid(), dnow());\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\n\tif (!RAND_status()) {\n\t\tubytes = -1;\n\t\trfbLog(\"calling RAND_poll()\\n\");\n\t\tRAND_poll();\n\t}\n\t\n\tRAND_bytes((unsigned char *)&sr, 4);\n\tsrand(sr);\n\n\tif (bytes > 0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\",\n\t\t\t    bytes);\n\t\t}\n\t\tif (ubytes > 32 && rnow() < 0.25) {\n\t\t\tRAND_write_file(file);\n\t\t}\n\t\treturn;\n\t}\n\n\tbytes += RAND_load_file(\"/dev/random\", 8);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\tRAND_poll();\n\n\tif (! quiet) {\n\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\", bytes);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define MSZ 4096"
          ],
          "globals_used": [
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define MSZ 4096\n\nstatic char *get_input(char *tag, char **in);\n\nstatic void init_prng(void) {\n\tint db = 0, bytes, ubytes, fd;\n\tchar file[MSZ], dtmp[100];\n\tunsigned int sr;\n\n\tRAND_file_name(file, MSZ);\n\n\trfbLog(\"RAND_file_name: %s\\n\", file);\n\n\tbytes = RAND_load_file(file, -1);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\t\n\tubytes = RAND_load_file(\"/dev/urandom\", 64);\n\tbytes += ubytes;\n\tif (db) fprintf(stderr, \"bytes read: %d / %d\\n\", bytes, ubytes);\n\n\t/* mix in more predictable stuff as well for fallback */\n\tsprintf(dtmp, \"/tmp/p%.8f.XXXXXX\", dnow());\n\tfd = mkstemp(dtmp);\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\tif (fd >= 0) {\n\t\tclose(fd);\n\t\tunlink(dtmp);\n\t}\n\tsprintf(dtmp, \"%d-%.8f\", (int) getpid(), dnow());\n\tRAND_add(dtmp, strlen(dtmp), 0);\n\n\tif (!RAND_status()) {\n\t\tubytes = -1;\n\t\trfbLog(\"calling RAND_poll()\\n\");\n\t\tRAND_poll();\n\t}\n\t\n\tRAND_bytes((unsigned char *)&sr, 4);\n\tsrand(sr);\n\n\tif (bytes > 0) {\n\t\tif (! quiet) {\n\t\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\",\n\t\t\t    bytes);\n\t\t}\n\t\tif (ubytes > 32 && rnow() < 0.25) {\n\t\t\tRAND_write_file(file);\n\t\t}\n\t\treturn;\n\t}\n\n\tbytes += RAND_load_file(\"/dev/random\", 8);\n\tif (db) fprintf(stderr, \"bytes read: %d\\n\", bytes);\n\tRAND_poll();\n\n\tif (! quiet) {\n\t\trfbLog(\"initialized PRNG with %d random bytes.\\n\", bytes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"init_prng()\\n\""
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_library_init",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SSL_library_init()\\n\""
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_load_error_strings",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nSSL_load_error_strings()\\n\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Initializing SSL (%s connect mode).\\n\"",
            "isclient ? \"client\":\"server\""
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define ssl_cache 0\n#define DO_DH 0\n\nchar *get_saved_pem(char *string, int create);\nstatic char *get_input(char *tag, char **in);\nvoid openssl_init(int isclient);\n\nvoid openssl_init(int isclient) {\n\tint db = 0, tmp_pem = 0, do_dh;\n\tconst SSL_METHOD *method;\n\tchar *method_name;\n\tFILE *in;\n\tdouble ds;\n\tlong mode;\n\tstatic int first = 1;\n\n\tdo_dh = DO_DH;\n\n\tif (enc_str != NULL) {\n\t\tif (first) {\n\t\t\tinit_prng();\n\t\t}\n\t\tfirst = 0;\n\t\treturn;\n\t}\n\n\tif (! quiet) {\n\t\trfbLog(\"\\n\");\n\t\trfbLog(\"Initializing SSL (%s connect mode).\\n\", isclient ? \"client\":\"server\");\n\t}\n\tif (first) {\n\t\tif (db) fprintf(stderr, \"\\nSSL_load_error_strings()\\n\");\n\n\t\tSSL_load_error_strings();\n\n\t\tif (db) fprintf(stderr, \"SSL_library_init()\\n\");\n\n\t\tSSL_library_init();\n\n\t\tif (db) fprintf(stderr, \"init_prng()\\n\");\n\n\t\tinit_prng();\n\n\t\tfirst = 0;\n\t}\n\n\tif (isclient) {\n\t\tssl_client_mode = 1;\n\t} else {\n\t\tssl_client_mode = 0;\n\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\tmethod = ssl_client_mode ? TLS_client_method() : TLS_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"TLS_client_method()\" : \"TLS_server_method()\";\n#else\n\tmethod = ssl_client_mode ? SSLv23_client_method() : SSLv23_server_method();\n\tif (db)\n\t\tmethod_name = ssl_client_mode ? \"SSLv23_client_method()\" : \"SSLv23_server_method()\";\n#endif\n\tif (db) fprintf(stderr, \"%s\\n\", method_name);\n\tctx = SSL_CTX_new(method);\n\n\tif (ctx == NULL) {\n\t\trfbLog(\"openssl_init: SSL_CTX_new failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tds = dnow();\n\trsa_512 = RSA_generate_key(512, RSA_F4, NULL, NULL);\n\tif (rsa_512 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(512) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created  512 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tds = dnow();\n\trsa_1024 = RSA_generate_key(1024, RSA_F4, NULL, NULL);\n\tif (rsa_1024 == NULL) {\n\t\trfbLog(\"openssl_init: RSA_generate_key(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\trfbLog(\"created 1024 bit temporary RSA key: %.3fs\\n\", dnow() - ds);\n\n\tif (db) fprintf(stderr, \"SSL_CTX_set_tmp_rsa()\\n\");\n\n\tif (! SSL_CTX_set_tmp_rsa(ctx, rsa_1024)) {\n\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\tsslerrexit();\n\t}\n\n\tmode = 0;\n\tmode |= SSL_MODE_ENABLE_PARTIAL_WRITE;\n\tmode |= SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\n\tSSL_CTX_set_mode(ctx, mode);\n\n#define ssl_cache 0\n#if ssl_cache\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_BOTH);\n\tSSL_CTX_set_timeout(ctx, 300);\n#else\n\tSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\n\tSSL_CTX_set_timeout(ctx, 1);\n#endif\n\n\tds = dnow();\n\tif (! openssl_pem) {\n\t\topenssl_pem = create_tmp_pem(NULL, 0);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create temporary,\"\n\t\t\t    \" self-signed PEM.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 1;\n\n\t} else if (!strcmp(openssl_pem, \"ANON\")) {\n\t\tif (ssl_verify) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslverify mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (ssl_crl) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman cannot\"\n\t\t\t    \" be used in -sslCRL mode.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\t/* n.b. new ctx */\n\t\tif (!switch_to_anon_dh()) {\n\t\t\trfbLog(\"openssl_init: Anonymous Diffie-Hellman setup\"\n\t\t\t    \" failed.\\n\");\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t} else if (strstr(openssl_pem, \"SAVE\") == openssl_pem) {\n\t\topenssl_pem = get_saved_pem(openssl_pem, 1);\n\t\tif (! openssl_pem) {\n\t\t\trfbLog(\"openssl_init: could not create or open\"\n\t\t\t    \" saved PEM: %s\\n\", openssl_pem);\t\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\ttmp_pem = 0;\n\t}\n\n\trfbLog(\"using PEM %s  %.3fs\\n\", openssl_pem, dnow() - ds);\n\n\tSSL_CTX_set_default_passwd_cb(ctx, pem_passwd_callback);\n\n\tif (do_dh) {\n\t\tDH *dh;\n\t\tBIO *bio;\n\n\t\tds = dnow();\n\t\tin = fopen(openssl_pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tbio = BIO_new_fp(in, BIO_CLOSE|BIO_FP_TEXT);\n\t\tif (! bio) {\n\t\t\trfbLog(\"openssl_init: BIO_new_fp() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tdh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\n\t\tif (dh == NULL) {\n\t\t\trfbLog(\"openssl_init: PEM_read_bio_DHparams() failed.\\n\");\t\n\t\t\tBIO_free(bio);\n\t\t\tsslerrexit();\n\t\t}\n\t\tBIO_free(bio);\n\t\tSSL_CTX_set_tmp_dh(ctx, dh);\n\t\trfbLog(\"loaded Diffie Hellman %d bits, %.3fs\\n\",\n\t\t    8*DH_size(dh), dnow()-ds);\n\t\tDH_free(dh);\n\t}\n\n\tif (strcmp(openssl_pem, \"ANON\")) {\n\t\tif (! SSL_CTX_use_certificate_chain_file(ctx, openssl_pem)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_use_certificate_chain_file() failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_use_RSAPrivateKey_file(ctx, openssl_pem,\n\t\t    SSL_FILETYPE_PEM)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! SSL_CTX_check_private_key(ctx)) {\n\t\t\trfbLog(\"openssl_init: SSL_CTX_set_tmp_rsa(1024) failed.\\n\");\t\n\t\t\tsslerrexit();\n\t\t}\n\t}\n\n\tif (tmp_pem && ! getenv(\"X11VNC_KEEP_TMP_PEM\")) {\n\t\tif (getenv(\"X11VNC_SHOW_TMP_PEM\")) {\n\t\t\tFILE *in = fopen(openssl_pem, \"r\");\n\t\t\tif (in != NULL) {\n\t\t\t\tchar line[128];\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\twhile (fgets(line, 128, in) != NULL) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tfclose(in);\n\t\t\t}\n\t\t}\n\t\tunlink(openssl_pem);\n\t\tfree(openssl_pem);\n\t\topenssl_pem = NULL;\n\t}\n\n\tif (ssl_crl) {\n\t\tstruct stat sbuf;\n\t\tX509_LOOKUP *lookup;\n\n\t\tif (stat(ssl_crl, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslCRL does not exist %s.\\n\",\n\t\t\t    ssl_crl ? ssl_crl : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\n\t\trevocation_store = X509_STORE_new();\n\t\tif (!revocation_store) {\n\t\t\trfbLog(\"openssl_init: X509_STORE_new failed.\\n\");\n\t\t\tsslerrexit();\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_file());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_load_file(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_load_file failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tlookup = X509_STORE_add_lookup(revocation_store, X509_LOOKUP_hash_dir());\n\t\t\tif (!lookup) {\n\t\t\t\trfbLog(\"openssl_init: X509_STORE_add_lookup failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t\tif (!X509_LOOKUP_add_dir(lookup, ssl_crl, X509_FILETYPE_PEM))  {\n\t\t\t\trfbLog(\"openssl_init: X509_LOOKUP_add_dir failed.\\n\");\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\t\trfbLog(\"loaded CRL file: %s\\n\", ssl_crl);\n\t}\n\n\tif (ssl_verify) {\n\t\tstruct stat sbuf;\n\t\tchar *file;\n\t\tint lvl;\n\n\t\tfile = get_ssl_verify_file(ssl_verify);\n\n\t\tif (!file || stat(file, &sbuf) != 0) {\n\t\t\trfbLog(\"openssl_init: -sslverify does not exist %s.\\n\",\n\t\t\t    file ? file : \"null\");\t\n\t\t\trfbLogPerror(\"stat\");\n\t\t\tclean_up_exit(1);\n\t\t}\n\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, file, NULL)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t} else {\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, NULL, file)) {\n\t\t\t\trfbLog(\"openssl_init: SSL_CTX_load_verify_\"\n\t\t\t\t    \"locations() failed.\\n\");\t\n\t\t\t\tsslerrexit();\n\t\t\t}\n\t\t}\n\n\t\tlvl = SSL_VERIFY_FAIL_IF_NO_PEER_CERT|SSL_VERIFY_PEER;\n\t\tif (ssl_crl == NULL) {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, NULL);\n\t\t} else {\n\t\t\tSSL_CTX_set_verify(ctx, lvl, verify_callback);\n\t\t}\n\t\tif (strstr(file, \"/sslverify-tmp-load-\")) {\n\t\t\t/* temporary file */\n\t\t\tunlink(file);\n\t\t}\n\t} else {\n\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\trfbLog(\"\\n\");\n}"
  },
  {
    "function_name": "verify_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "963-987",
    "snippet": "static int verify_callback(int ok, X509_STORE_CTX *callback_ctx) {\n\tif (!ssl_verify) {\n\t\trfbLog(\"CRL_check: skipped.\\n\");\n\t\treturn ok;\n\t}\n\tif (!ssl_crl) {\n\t\trfbLog(\"CRL_check: skipped.\\n\");\n\t\treturn ok;\n\t}\n\tif (!ok) {\n\t\trfbLog(\"CRL_check: client cert is already rejected.\\n\");\n\t\treturn ok;\n\t}\n\tif (revocation_store) {\n\t\tif (crl_callback(callback_ctx)) {\n\t\t\trfbLog(\"CRL_check: succeeded.\\n\");\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"CRL_check: did not pass.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* NOTREACHED */\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"CRL_check: did not pass.\\n\""
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"CRL_check: succeeded.\\n\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crl_callback",
          "args": [
            "callback_ctx"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "crl_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "803-961",
          "snippet": "static int crl_callback(X509_STORE_CTX *callback_ctx) {\n\tconst ASN1_INTEGER *revoked_serial;\n\tX509_STORE_CTX *store_ctx;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tX509_OBJECT *obj;\n#else\n\tX509_OBJECT obj;\n#endif\n\tX509_NAME *subject;\n\tX509_NAME *issuer;\n\tX509 *xs;\n\tX509_CRL *crl;\n\tX509_REVOKED *revoked;\n\tEVP_PKEY *pubkey;\n\tlong serial;\n\tBIO *bio;\n\tint i, n, rc;\n\tchar *cp, *cp2;\n\tASN1_TIME *t;\n\t\n\t/* Determine certificate ingredients in advance */\n\txs      = X509_STORE_CTX_get_current_cert(callback_ctx);\n\tsubject = X509_get_subject_name(xs);\n\tissuer  = X509_get_issuer_name(xs);\n\t\n\t/* Try to retrieve a CRL corresponding to the _subject_ of\n\t* the current certificate in order to verify it's integrity. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Log information about CRL\n\t\t * (A little bit complicated because of ASN.1 and BIOs...) */\n\t\tbio=BIO_new(BIO_s_mem());\n\t\tBIO_printf(bio, \"lastUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_lastUpdate(crl));\n\t\tBIO_printf(bio, \", nextUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_nextUpdate(crl));\n\t\tn=BIO_pending(bio);\n\t\tcp=malloc(n+1);\n\t\tn=BIO_read(bio, cp, n);\n\t\tcp[n]='\\0';\n\t\tBIO_free(bio);\n\t\tcp2=X509_NAME_oneline(subject, NULL, 0);\n\t\trfbLog(\"CA CRL: Issuer: %s, %s\\n\", cp2, cp);\n\t\tOPENSSL_free(cp2);\n\t\tfree(cp);\n\n\t\t/* Verify the signature on this CRL */\n\t\tpubkey=X509_get_pubkey(xs);\n\t\tif(X509_CRL_verify(crl, pubkey)<=0) {\n\t\t\trfbLog(\"Invalid signature on CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_CRL_SIGNATURE_FAILURE);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\tif(pubkey)\n\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(pubkey)\n\t\t\tEVP_PKEY_free(pubkey);\n\n\t\t/* Check date of CRL to make sure it's not expired */\n\t\tt=X509_CRL_get_nextUpdate(crl);\n\t\tif(!t) {\n\t\t\trfbLog(\"Found CRL has invalid nextUpdate field\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(X509_cmp_current_time(t)<0) {\n\t\t\trfbLog(\"Found CRL is expired - \"\n\t\t\t\t\"revoking all certificates until you get updated CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\t/* Try to retrieve a CRL corresponding to the _issuer_ of\n\t * the current certificate in order to check for revocation. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Check if the current certificate is revoked by this CRL */\n\t\tn=sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n\t\tfor(i=0; i<n; i++) {\n\t\t\trevoked=sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), i);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\trevoked_serial = X509_REVOKED_get0_serialNumber(revoked);\n#else\n\t\t\trevoked_serial = revoked->serialNumber;\n#endif\n\t\t\tif(ASN1_INTEGER_cmp(revoked_serial,\n\t\t\t\t\tX509_get_serialNumber(xs)) == 0) {\n\t\t\t\tserial=ASN1_INTEGER_get(revoked_serial);\n\t\t\t\tcp=X509_NAME_oneline(issuer, NULL, 0);\n\t\t\t\trfbLog(\"Certificate with serial %ld (0x%lX) \"\n\t\t\t\t\t\"revoked per CRL from issuer %s\\n\", serial, serial, cp);\n\t\t\t\tOPENSSL_free(cp);\n\t\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CERT_REVOKED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\t\treturn 0; /* Reject connection */\n\t\t\t}\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\treturn 1; /* Accept connection */\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_input(char *tag, char **in);\n\nstatic int crl_callback(X509_STORE_CTX *callback_ctx) {\n\tconst ASN1_INTEGER *revoked_serial;\n\tX509_STORE_CTX *store_ctx;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tX509_OBJECT *obj;\n#else\n\tX509_OBJECT obj;\n#endif\n\tX509_NAME *subject;\n\tX509_NAME *issuer;\n\tX509 *xs;\n\tX509_CRL *crl;\n\tX509_REVOKED *revoked;\n\tEVP_PKEY *pubkey;\n\tlong serial;\n\tBIO *bio;\n\tint i, n, rc;\n\tchar *cp, *cp2;\n\tASN1_TIME *t;\n\t\n\t/* Determine certificate ingredients in advance */\n\txs      = X509_STORE_CTX_get_current_cert(callback_ctx);\n\tsubject = X509_get_subject_name(xs);\n\tissuer  = X509_get_issuer_name(xs);\n\t\n\t/* Try to retrieve a CRL corresponding to the _subject_ of\n\t* the current certificate in order to verify it's integrity. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Log information about CRL\n\t\t * (A little bit complicated because of ASN.1 and BIOs...) */\n\t\tbio=BIO_new(BIO_s_mem());\n\t\tBIO_printf(bio, \"lastUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_lastUpdate(crl));\n\t\tBIO_printf(bio, \", nextUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_nextUpdate(crl));\n\t\tn=BIO_pending(bio);\n\t\tcp=malloc(n+1);\n\t\tn=BIO_read(bio, cp, n);\n\t\tcp[n]='\\0';\n\t\tBIO_free(bio);\n\t\tcp2=X509_NAME_oneline(subject, NULL, 0);\n\t\trfbLog(\"CA CRL: Issuer: %s, %s\\n\", cp2, cp);\n\t\tOPENSSL_free(cp2);\n\t\tfree(cp);\n\n\t\t/* Verify the signature on this CRL */\n\t\tpubkey=X509_get_pubkey(xs);\n\t\tif(X509_CRL_verify(crl, pubkey)<=0) {\n\t\t\trfbLog(\"Invalid signature on CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_CRL_SIGNATURE_FAILURE);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\tif(pubkey)\n\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(pubkey)\n\t\t\tEVP_PKEY_free(pubkey);\n\n\t\t/* Check date of CRL to make sure it's not expired */\n\t\tt=X509_CRL_get_nextUpdate(crl);\n\t\tif(!t) {\n\t\t\trfbLog(\"Found CRL has invalid nextUpdate field\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(X509_cmp_current_time(t)<0) {\n\t\t\trfbLog(\"Found CRL is expired - \"\n\t\t\t\t\"revoking all certificates until you get updated CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\t/* Try to retrieve a CRL corresponding to the _issuer_ of\n\t * the current certificate in order to check for revocation. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Check if the current certificate is revoked by this CRL */\n\t\tn=sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n\t\tfor(i=0; i<n; i++) {\n\t\t\trevoked=sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), i);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\trevoked_serial = X509_REVOKED_get0_serialNumber(revoked);\n#else\n\t\t\trevoked_serial = revoked->serialNumber;\n#endif\n\t\t\tif(ASN1_INTEGER_cmp(revoked_serial,\n\t\t\t\t\tX509_get_serialNumber(xs)) == 0) {\n\t\t\t\tserial=ASN1_INTEGER_get(revoked_serial);\n\t\t\t\tcp=X509_NAME_oneline(issuer, NULL, 0);\n\t\t\t\trfbLog(\"Certificate with serial %ld (0x%lX) \"\n\t\t\t\t\t\"revoked per CRL from issuer %s\\n\", serial, serial, cp);\n\t\t\t\tOPENSSL_free(cp);\n\t\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CERT_REVOKED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\t\treturn 0; /* Reject connection */\n\t\t\t}\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\treturn 1; /* Accept connection */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"CRL_check: client cert is already rejected.\\n\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"CRL_check: skipped.\\n\""
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"CRL_check: skipped.\\n\""
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int verify_callback(int ok, X509_STORE_CTX *callback_ctx) {\n\tif (!ssl_verify) {\n\t\trfbLog(\"CRL_check: skipped.\\n\");\n\t\treturn ok;\n\t}\n\tif (!ssl_crl) {\n\t\trfbLog(\"CRL_check: skipped.\\n\");\n\t\treturn ok;\n\t}\n\tif (!ok) {\n\t\trfbLog(\"CRL_check: client cert is already rejected.\\n\");\n\t\treturn ok;\n\t}\n\tif (revocation_store) {\n\t\tif (crl_callback(callback_ctx)) {\n\t\t\trfbLog(\"CRL_check: succeeded.\\n\");\n\t\t\treturn 1;\n\t\t} else {\n\t\t\trfbLog(\"CRL_check: did not pass.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* NOTREACHED */\n\treturn 1;\n}"
  },
  {
    "function_name": "crl_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "803-961",
    "snippet": "static int crl_callback(X509_STORE_CTX *callback_ctx) {\n\tconst ASN1_INTEGER *revoked_serial;\n\tX509_STORE_CTX *store_ctx;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tX509_OBJECT *obj;\n#else\n\tX509_OBJECT obj;\n#endif\n\tX509_NAME *subject;\n\tX509_NAME *issuer;\n\tX509 *xs;\n\tX509_CRL *crl;\n\tX509_REVOKED *revoked;\n\tEVP_PKEY *pubkey;\n\tlong serial;\n\tBIO *bio;\n\tint i, n, rc;\n\tchar *cp, *cp2;\n\tASN1_TIME *t;\n\t\n\t/* Determine certificate ingredients in advance */\n\txs      = X509_STORE_CTX_get_current_cert(callback_ctx);\n\tsubject = X509_get_subject_name(xs);\n\tissuer  = X509_get_issuer_name(xs);\n\t\n\t/* Try to retrieve a CRL corresponding to the _subject_ of\n\t* the current certificate in order to verify it's integrity. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Log information about CRL\n\t\t * (A little bit complicated because of ASN.1 and BIOs...) */\n\t\tbio=BIO_new(BIO_s_mem());\n\t\tBIO_printf(bio, \"lastUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_lastUpdate(crl));\n\t\tBIO_printf(bio, \", nextUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_nextUpdate(crl));\n\t\tn=BIO_pending(bio);\n\t\tcp=malloc(n+1);\n\t\tn=BIO_read(bio, cp, n);\n\t\tcp[n]='\\0';\n\t\tBIO_free(bio);\n\t\tcp2=X509_NAME_oneline(subject, NULL, 0);\n\t\trfbLog(\"CA CRL: Issuer: %s, %s\\n\", cp2, cp);\n\t\tOPENSSL_free(cp2);\n\t\tfree(cp);\n\n\t\t/* Verify the signature on this CRL */\n\t\tpubkey=X509_get_pubkey(xs);\n\t\tif(X509_CRL_verify(crl, pubkey)<=0) {\n\t\t\trfbLog(\"Invalid signature on CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_CRL_SIGNATURE_FAILURE);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\tif(pubkey)\n\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(pubkey)\n\t\t\tEVP_PKEY_free(pubkey);\n\n\t\t/* Check date of CRL to make sure it's not expired */\n\t\tt=X509_CRL_get_nextUpdate(crl);\n\t\tif(!t) {\n\t\t\trfbLog(\"Found CRL has invalid nextUpdate field\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(X509_cmp_current_time(t)<0) {\n\t\t\trfbLog(\"Found CRL is expired - \"\n\t\t\t\t\"revoking all certificates until you get updated CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\t/* Try to retrieve a CRL corresponding to the _issuer_ of\n\t * the current certificate in order to check for revocation. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Check if the current certificate is revoked by this CRL */\n\t\tn=sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n\t\tfor(i=0; i<n; i++) {\n\t\t\trevoked=sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), i);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\trevoked_serial = X509_REVOKED_get0_serialNumber(revoked);\n#else\n\t\t\trevoked_serial = revoked->serialNumber;\n#endif\n\t\t\tif(ASN1_INTEGER_cmp(revoked_serial,\n\t\t\t\t\tX509_get_serialNumber(xs)) == 0) {\n\t\t\t\tserial=ASN1_INTEGER_get(revoked_serial);\n\t\t\t\tcp=X509_NAME_oneline(issuer, NULL, 0);\n\t\t\t\trfbLog(\"Certificate with serial %ld (0x%lX) \"\n\t\t\t\t\t\"revoked per CRL from issuer %s\\n\", serial, serial, cp);\n\t\t\t\tOPENSSL_free(cp);\n\t\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CERT_REVOKED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\t\treturn 0; /* Reject connection */\n\t\t\t}\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\treturn 1; /* Accept connection */\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "X509_OBJECT_free_contents",
          "args": [
            "&obj"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free",
          "args": [
            "obj"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free_contents",
          "args": [
            "&obj"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free",
          "args": [
            "obj"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_set_error",
          "args": [
            "callback_ctx",
            "X509_V_ERR_CERT_REVOKED"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPENSSL_free",
          "args": [
            "cp"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Certificate with serial %ld (0x%lX) \"\n\t\t\t\t\t\"revoked per CRL from issuer %s\\n\"",
            "serial",
            "serial",
            "cp"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_NAME_oneline",
          "args": [
            "issuer",
            "NULL",
            "0"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_get",
          "args": [
            "revoked_serial"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_cmp",
          "args": [
            "revoked_serial",
            "X509_get_serialNumber(xs)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_serialNumber",
          "args": [
            "xs"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_REVOKED_get0_serialNumber",
          "args": [
            "revoked"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_X509_REVOKED_value",
          "args": [
            "X509_CRL_get_REVOKED(crl)",
            "i"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_CRL_get_REVOKED",
          "args": [
            "crl"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_X509_REVOKED_num",
          "args": [
            "X509_CRL_get_REVOKED(crl)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_CRL_get_REVOKED",
          "args": [
            "crl"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_free",
          "args": [
            "store_ctx"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_cleanup",
          "args": [
            "store_ctx"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_get_by_subject",
          "args": [
            "store_ctx",
            "X509_LU_CRL",
            "issuer",
            "&obj"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&obj",
            "0",
            "sizeof(obj)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_get0_X509_CRL",
          "args": [
            "obj"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_get_by_subject",
          "args": [
            "store_ctx",
            "X509_LU_CRL",
            "issuer",
            "obj"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_new",
          "args": [],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_init",
          "args": [
            "store_ctx",
            "revocation_store",
            "NULL",
            "NULL"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_new",
          "args": [],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free_contents",
          "args": [
            "&obj"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free",
          "args": [
            "obj"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free_contents",
          "args": [
            "&obj"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free",
          "args": [
            "obj"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_set_error",
          "args": [
            "callback_ctx",
            "X509_V_ERR_CRL_HAS_EXPIRED"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Found CRL is expired - \"\n\t\t\t\t\"revoking all certificates until you get updated CRL\\n\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_cmp_current_time",
          "args": [
            "t"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free_contents",
          "args": [
            "&obj"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free",
          "args": [
            "obj"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_set_error",
          "args": [
            "callback_ctx",
            "X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Found CRL has invalid nextUpdate field\\n\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_CRL_get_nextUpdate",
          "args": [
            "crl"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "pubkey"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "pubkey"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free_contents",
          "args": [
            "&obj"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_free",
          "args": [
            "obj"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_set_error",
          "args": [
            "callback_ctx",
            "X509_V_ERR_CRL_SIGNATURE_FAILURE"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Invalid signature on CRL\\n\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_CRL_verify",
          "args": [
            "crl",
            "pubkey"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_pubkey",
          "args": [
            "xs"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cp"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OPENSSL_free",
          "args": [
            "cp2"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"CA CRL: Issuer: %s, %s\\n\"",
            "cp2",
            "cp"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_NAME_oneline",
          "args": [
            "subject",
            "NULL",
            "0"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "bio"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_read",
          "args": [
            "bio",
            "cp",
            "n"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "n+1"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_pending",
          "args": [
            "bio"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_UTCTIME_print",
          "args": [
            "bio",
            "X509_CRL_get_nextUpdate(crl)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_CRL_get_nextUpdate",
          "args": [
            "crl"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\", nextUpdate: \""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_UTCTIME_print",
          "args": [
            "bio",
            "X509_CRL_get_lastUpdate(crl)"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_CRL_get_lastUpdate",
          "args": [
            "crl"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_printf",
          "args": [
            "bio",
            "\"lastUpdate: \""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_free",
          "args": [
            "store_ctx"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_cleanup",
          "args": [
            "store_ctx"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_get_by_subject",
          "args": [
            "store_ctx",
            "X509_LU_CRL",
            "subject",
            "&obj"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&obj",
            "0",
            "sizeof(obj)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_get0_X509_CRL",
          "args": [
            "obj"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_get_by_subject",
          "args": [
            "store_ctx",
            "X509_LU_CRL",
            "subject",
            "obj"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_OBJECT_new",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_init",
          "args": [
            "store_ctx",
            "revocation_store",
            "NULL",
            "NULL"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_new",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_issuer_name",
          "args": [
            "xs"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_get_subject_name",
          "args": [
            "xs"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_STORE_CTX_get_current_cert",
          "args": [
            "callback_ctx"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_input(char *tag, char **in);\n\nstatic int crl_callback(X509_STORE_CTX *callback_ctx) {\n\tconst ASN1_INTEGER *revoked_serial;\n\tX509_STORE_CTX *store_ctx;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tX509_OBJECT *obj;\n#else\n\tX509_OBJECT obj;\n#endif\n\tX509_NAME *subject;\n\tX509_NAME *issuer;\n\tX509 *xs;\n\tX509_CRL *crl;\n\tX509_REVOKED *revoked;\n\tEVP_PKEY *pubkey;\n\tlong serial;\n\tBIO *bio;\n\tint i, n, rc;\n\tchar *cp, *cp2;\n\tASN1_TIME *t;\n\t\n\t/* Determine certificate ingredients in advance */\n\txs      = X509_STORE_CTX_get_current_cert(callback_ctx);\n\tsubject = X509_get_subject_name(xs);\n\tissuer  = X509_get_issuer_name(xs);\n\t\n\t/* Try to retrieve a CRL corresponding to the _subject_ of\n\t* the current certificate in order to verify it's integrity. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, subject, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Log information about CRL\n\t\t * (A little bit complicated because of ASN.1 and BIOs...) */\n\t\tbio=BIO_new(BIO_s_mem());\n\t\tBIO_printf(bio, \"lastUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_lastUpdate(crl));\n\t\tBIO_printf(bio, \", nextUpdate: \");\n\t\tASN1_UTCTIME_print(bio, X509_CRL_get_nextUpdate(crl));\n\t\tn=BIO_pending(bio);\n\t\tcp=malloc(n+1);\n\t\tn=BIO_read(bio, cp, n);\n\t\tcp[n]='\\0';\n\t\tBIO_free(bio);\n\t\tcp2=X509_NAME_oneline(subject, NULL, 0);\n\t\trfbLog(\"CA CRL: Issuer: %s, %s\\n\", cp2, cp);\n\t\tOPENSSL_free(cp2);\n\t\tfree(cp);\n\n\t\t/* Verify the signature on this CRL */\n\t\tpubkey=X509_get_pubkey(xs);\n\t\tif(X509_CRL_verify(crl, pubkey)<=0) {\n\t\t\trfbLog(\"Invalid signature on CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_CRL_SIGNATURE_FAILURE);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\tif(pubkey)\n\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(pubkey)\n\t\t\tEVP_PKEY_free(pubkey);\n\n\t\t/* Check date of CRL to make sure it's not expired */\n\t\tt=X509_CRL_get_nextUpdate(crl);\n\t\tif(!t) {\n\t\t\trfbLog(\"Found CRL has invalid nextUpdate field\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx,\n\t\t\t\tX509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n\t\tif(X509_cmp_current_time(t)<0) {\n\t\t\trfbLog(\"Found CRL is expired - \"\n\t\t\t\t\"revoking all certificates until you get updated CRL\\n\");\n\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\treturn 0; /* Reject connection */\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\t/* Try to retrieve a CRL corresponding to the _issuer_ of\n\t * the current certificate in order to check for revocation. */\n\tstore_ctx = X509_STORE_CTX_new();\n\tX509_STORE_CTX_init(store_ctx, revocation_store, NULL, NULL);\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n\tobj = X509_OBJECT_new();\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, obj);\n\tcrl = X509_OBJECT_get0_X509_CRL(obj);\n#else\n\tmemset((char *)&obj, 0, sizeof(obj));\n\trc=X509_STORE_get_by_subject(store_ctx, X509_LU_CRL, issuer, &obj);\n\tcrl=obj.data.crl;\n#endif\n\tX509_STORE_CTX_cleanup(store_ctx);\n\tX509_STORE_CTX_free(store_ctx);\n\n\tif(rc>0 && crl) {\n\t\t/* Check if the current certificate is revoked by this CRL */\n\t\tn=sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n\t\tfor(i=0; i<n; i++) {\n\t\t\trevoked=sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), i);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\trevoked_serial = X509_REVOKED_get0_serialNumber(revoked);\n#else\n\t\t\trevoked_serial = revoked->serialNumber;\n#endif\n\t\t\tif(ASN1_INTEGER_cmp(revoked_serial,\n\t\t\t\t\tX509_get_serialNumber(xs)) == 0) {\n\t\t\t\tserial=ASN1_INTEGER_get(revoked_serial);\n\t\t\t\tcp=X509_NAME_oneline(issuer, NULL, 0);\n\t\t\t\trfbLog(\"Certificate with serial %ld (0x%lX) \"\n\t\t\t\t\t\"revoked per CRL from issuer %s\\n\", serial, serial, cp);\n\t\t\t\tOPENSSL_free(cp);\n\t\t\t\tX509_STORE_CTX_set_error(callback_ctx, X509_V_ERR_CERT_REVOKED);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t\t\t\treturn 0; /* Reject connection */\n\t\t\t}\n\t\t}\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\t\t\tX509_OBJECT_free(obj);\n#else\n\t\t\tX509_OBJECT_free_contents(&obj);\n#endif\n\t}\n\n\treturn 1; /* Accept connection */\n}"
  },
  {
    "function_name": "pem_passwd_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "769-800",
    "snippet": "static int pem_passwd_callback(char *buf, int size, int rwflag,\n    void *userdata) {\n\tchar *q, line[1024];\n\n\tif (! buf) {\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"\\nA passphrase is needed to unlock an OpenSSL \"\n\t    \"private key (PEM file).\\n\");\n\tfprintf(stderr, \"Enter passphrase> \");\n\tsystem(\"stty -echo\");\n\tif(fgets(line, 1024, stdin) == NULL) {\n\t\tfprintf(stdout, \"\\n\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tsystem(\"stty echo\");\n\tfprintf(stdout, \"\\n\\n\");\n\tq = strrchr(line, '\\n');\n\tif (q) {\n\t\t*q = '\\0';\n\t}\n\tline[1024 - 1] = '\\0';\n\tstrncpy(buf, line, size);                                  \n\tbuf[size - 1] = '\\0';\n\n\tif (0) rwflag = 0;\t/* compiler warning. */\n\tif (0) userdata = 0;\t/* compiler warning. */\n\n\treturn strlen(buf);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "line",
            "size"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\\n\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty echo\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty echo\""
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "stdin"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"stty -echo\""
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Enter passphrase> \""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nA passphrase is needed to unlock an OpenSSL \"\n\t    \"private key (PEM file).\\n\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic int pem_passwd_callback(char *buf, int size, int rwflag,\n    void *userdata) {\n\tchar *q, line[1024];\n\n\tif (! buf) {\n\t\texit(1);\n\t}\n\n\tfprintf(stderr, \"\\nA passphrase is needed to unlock an OpenSSL \"\n\t    \"private key (PEM file).\\n\");\n\tfprintf(stderr, \"Enter passphrase> \");\n\tsystem(\"stty -echo\");\n\tif(fgets(line, 1024, stdin) == NULL) {\n\t\tfprintf(stdout, \"\\n\");\n\t\tsystem(\"stty echo\");\n\t\texit(1);\n\t}\n\tsystem(\"stty echo\");\n\tfprintf(stdout, \"\\n\\n\");\n\tq = strrchr(line, '\\n');\n\tif (q) {\n\t\t*q = '\\0';\n\t}\n\tline[1024 - 1] = '\\0';\n\tstrncpy(buf, line, size);                                  \n\tbuf[size - 1] = '\\0';\n\n\tif (0) rwflag = 0;\t/* compiler warning. */\n\tif (0) userdata = 0;\t/* compiler warning. */\n\n\treturn strlen(buf);\n}"
  },
  {
    "function_name": "sslerrexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "758-767",
    "snippet": "static void sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\t\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stderr, \"ssl error: %s\\n\", str);\n\t}\n\tclean_up_exit(1);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ssl error: %s\\n\"",
            "str"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_error_string",
          "args": [
            "err",
            "str"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_get_error",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void sslerrexit(void) {\n\tunsigned long err = ERR_get_error();\n\t\n\tif (err) {\n\t\tchar str[256];\n\t\tERR_error_string(err, str);\n\t\tfprintf(stderr, \"ssl error: %s\\n\", str);\n\t}\n\tclean_up_exit(1);\n}"
  },
  {
    "function_name": "openssl_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "756-756",
    "snippet": "int openssl_present(void) {return 1;}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int openssl_present(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint openssl_present(void);\n\nint openssl_present(void) {return 1;}"
  },
  {
    "function_name": "openssl_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "752-752",
    "snippet": "int openssl_present(void) {return 0;}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int openssl_present(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint openssl_present(void);\n\nint openssl_present(void) {return 0;}"
  },
  {
    "function_name": "openssl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "747-751",
    "snippet": "void openssl_init(int isclient) {\n\trfbLog(\"openssl_init: fork is not supported. cannot create\"\n\t    \" ssl helper process.\\n\");\n\tclean_up_exit(1);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_saved_pem(char *string, int create);",
      "void openssl_init(int isclient);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"openssl_init: fork is not supported. cannot create\"\n\t    \" ssl helper process.\\n\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_saved_pem(char *string, int create);\nvoid openssl_init(int isclient);\n\nvoid openssl_init(int isclient) {\n\trfbLog(\"openssl_init: fork is not supported. cannot create\"\n\t    \" ssl helper process.\\n\");\n\tclean_up_exit(1);\n}"
  },
  {
    "function_name": "ssl_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "711-719",
    "snippet": "static void ssl_xfer(int csock, int s_in, int s_out, int is_https) {\n\tif (enc_str != NULL && !strcmp(enc_str, \"none\")) {\n\t\tusleep(250*1000);\n\t\trfbLog(\"doing '-enc none' raw transfer (no encryption)\\n\"); \n\t\traw_xfer(csock, s_in, s_out);\n\t} else {\n\t\tbadnews(\"ssl_xfer\");\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "badnews",
          "args": [
            "\"ssl_xfer\""
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "badnews",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "691-696",
          "snippet": "static void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_xfer",
          "args": [
            "csock",
            "s_in",
            "s_out"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "raw_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "4286-4373",
          "snippet": "void raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK"
          ],
          "globals_used": [
            "void raw_xfer(int csock, int s_in, int s_out);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nvoid raw_xfer(int csock, int s_in, int s_out) {\n\tchar buf0[8192];\n\tint sz = 8192, n, m, status, db = 1;\n\tchar *buf;\n#ifdef FORK_OK\n\tpid_t par = getpid();\n\tpid_t pid = fork();\n\n\tbuf = buf0;\n\tif (vnc_redirect) {\n\t\t/* change buf size some direction. */\n\t}\n\n\tif (getenv(\"X11VNC_DEBUG_RAW_XFER\")) {\n\t\tdb = atoi(getenv(\"X11VNC_DEBUG_RAW_XFER\"));\n\t}\n\tif (pid < 0) {\n\t\texit(1);\n\t}\n\t/* this is for testing or special helper usage, no SSL just socket redir */\n\tif (pid) {\n\t\tif (db) rfbLog(\"raw_xfer start: %d -> %d/%d\\n\", csock, s_in, s_out);\n\n\t\twhile (1) {\n\t\t\tn = read(csock, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(s_out, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\nif (db) rfbLog(\"raw_xfer bad write:  %d -> %d | %d/%d  errno=%d\\n\", csock, s_out, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(pid, SIGTERM);\n\t\twaitpid(pid, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d -> %d\\n\", csock, s_out);\n\n\t} else {\n\t\tif (db) usleep(50*1000);\n\t\tif (db) rfbLog(\"raw_xfer start: %d <- %d\\n\", csock, s_in);\n\n\t\twhile (1) {\n\t\t\tn = read(s_in, buf, sz);\n\t\t\tif (n == 0 || (n < 0 && errno != EINTR) ) {\n\t\t\t\tbreak;\n\t\t\t} else if (n > 0) {\n\t\t\t\tint len = n;\n\t\t\t\tchar *src = buf;\n\t\t\t\tif (db > 1) write(2, buf, n);\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tm = write(csock, src, len);\n\t\t\t\t\tif (m > 0) {\n\t\t\t\t\t\tsrc += m;\n\t\t\t\t\t\tlen -= m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (m < 0 && (errno == EINTR || errno == EAGAIN)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\tif (db) rfbLog(\"raw_xfer bad write:  %d <- %d | %d/%d errno=%d\\n\", csock, s_in, m, n, errno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusleep(250*1000);\n\t\tkill(par, SIGTERM);\n\t\twaitpid(par, &status, WNOHANG); \n\t\tif (db) rfbLog(\"raw_xfer done:  %d <- %d\\n\", csock, s_in);\n\t}\n\tclose(csock);\n\tclose(s_in);\n\tclose(s_out);\n#endif\t/* FORK_OK */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"doing '-enc none' raw transfer (no encryption)\\n\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "250*1000"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "enc_str",
            "\"none\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nstatic void ssl_xfer(int csock, int s_in, int s_out, int is_https) {\n\tif (enc_str != NULL && !strcmp(enc_str, \"none\")) {\n\t\tusleep(250*1000);\n\t\trfbLog(\"doing '-enc none' raw transfer (no encryption)\\n\"); \n\t\traw_xfer(csock, s_in, s_out);\n\t} else {\n\t\tbadnews(\"ssl_xfer\");\n\t}\n}"
  },
  {
    "function_name": "ssl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "703-709",
    "snippet": "static int ssl_init(int s_in, int s_out, int skip_vnc_tls, double last_https) {\n\tif (enc_str != NULL) {\n\t\treturn 1;\n\t}\n\tbadnews(\"ssl_init\");\n\treturn 0;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void raw_xfer(int csock, int s_in, int s_out);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "badnews",
          "args": [
            "\"ssl_init\""
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "badnews",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "691-696",
          "snippet": "static void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid raw_xfer(int csock, int s_in, int s_out);\n\nstatic int ssl_init(int s_in, int s_out, int skip_vnc_tls, double last_https) {\n\tif (enc_str != NULL) {\n\t\treturn 1;\n\t}\n\tbadnews(\"ssl_init\");\n\treturn 0;\n}"
  },
  {
    "function_name": "openssl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "699-699",
    "snippet": "void openssl_init(int isclient) {badnews(\"openssl_init\");}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void openssl_init(int isclient);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "badnews",
          "args": [
            "\"openssl_init\""
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "badnews",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "691-696",
          "snippet": "static void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid openssl_init(int isclient);\n\nvoid openssl_init(int isclient) {badnews(\"openssl_init\");}"
  },
  {
    "function_name": "openssl_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "698-698",
    "snippet": "int openssl_present(void) {return 0;}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int openssl_present(void);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nint openssl_present(void);\n\nint openssl_present(void) {return 0;}"
  },
  {
    "function_name": "badnews",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "691-696",
    "snippet": "static void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"** %s: not compiled with libssl OpenSSL support **\\n\"",
            "name ? name : \"???\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic void badnews(char *name) {\n\tuse_openssl = 0;\n\tuse_stunnel = 0;\n\trfbLog(\"** %s: not compiled with libssl OpenSSL support **\\n\", name ? name : \"???\");\n\tclean_up_exit(1);\n}"
  },
  {
    "function_name": "get_ssl_verify_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "547-664",
    "snippet": "char *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_ssl_verify_file(char *str_in);",
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslverify: %s\\n\"",
            "tfile"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslverify: using %d client certs in\\n\"",
            "count"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslverify: loaded %s\\n\"",
            "tfile2"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tfile"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendfile",
          "args": [
            "file",
            "tfile2"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "appendfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "519-545",
          "snippet": "static int appendfile(FILE *out, char *infile) {\n\tchar line[1024];\n\tFILE *in;\n\n\tif (! infile) {\n\t\trfbLog(\"appendfile: null infile.\\n\");\n\t\treturn 0;\n\t}\n\tif (! out) {\n\t\trfbLog(\"appendfile: null out handle.\\n\");\n\t\treturn 0;\n\t}\n\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLog(\"appendfile: %s\\n\", infile);\n\t\trfbLogPerror(\"fopen\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\treturn 1;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_input(char *tag, char **in);\n\nstatic int appendfile(FILE *out, char *infile) {\n\tchar line[1024];\n\tFILE *in;\n\n\tif (! infile) {\n\t\trfbLog(\"appendfile: null infile.\\n\");\n\t\treturn 0;\n\t}\n\tif (! out) {\n\t\trfbLog(\"appendfile: null out handle.\\n\");\n\t\treturn 0;\n\t}\n\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLog(\"appendfile: %s\\n\", infile);\n\t\trfbLogPerror(\"fopen\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tfile2",
            "\"%s/clients/%s\"",
            "cdir",
            "p"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "tfile2",
            "&sbuf"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tfile2",
            "\"%s/clients/%s.crt\"",
            "cdir",
            "p"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tfile"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslverify: loaded %s\\n\"",
            "tfile2"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tfile"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tfile2",
            "\"%s/clients/%s\"",
            "cdir",
            "n"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "n"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\".crt\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "q"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "n",
            "\".crt\""
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tfile"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"opendir\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_ssl_verify_file: %s\\n\"",
            "tfile2"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "tfile2"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tfile2",
            "\"%s/clients\"",
            "cdir"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"clients\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sslverify: loaded %s\\n\"",
            "tfile2"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tfile"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tfile2",
            "\"%s/CA/cacert.pem\"",
            "cdir"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"CA\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "str",
            "\",\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "str_in"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_ssl_verify_file: %s\\n\"",
            "tfile"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "tfile",
            "0600"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "tfile",
            "\"w\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"mkstemp\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_ssl_verify_file: %s\\n\"",
            "tfile"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tfile"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tfile",
            "\"%s/sslverify-tmp-load-%d.crts.XXXXXX\"",
            "tmp",
            "getpid()"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(tmp) + 1024"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(tmp) + 1024"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_ssl_verify_file: invalid cert-dir.\\n\""
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_Cert_dir",
          "args": [
            "NULL",
            "&tmp"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "get_Cert_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "482-543",
          "snippet": "char *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_Cert_dir(char *cdir_in, char **tmp_in);",
            "void sslGenCA(char *cdir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in);\nvoid sslGenCA(char *cdir);\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_ssl_verify_file: no filename\\n\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_ssl_verify_file(char *str_in);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_ssl_verify_file(char *str_in) {\n\tchar *p, *str, *cdir, *tmp;\n\tchar *tfile, *tfile2;\n\tFILE *file;\n\tstruct stat sbuf;\n\tint count = 0, fd;\n\n\tif (! str_in) {\n\t\trfbLog(\"get_ssl_verify_file: no filename\\n\");\n\t\texit(1);\n\t}\n\n\tif (stat(str_in, &sbuf) == 0) {\n\t\t/* assume he knows what he is doing. */\n\t\treturn str_in;\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_ssl_verify_file: invalid cert-dir.\\n\");\n\t\texit(1);\n\t}\n\n\ttfile  = (char *) malloc(strlen(tmp) + 1024);\n\ttfile2 = (char *) malloc(strlen(tmp) + 1024);\n\n\tsprintf(tfile, \"%s/sslverify-tmp-load-%d.crts.XXXXXX\", tmp, getpid());\n\n\tfd = mkstemp(tfile);\n\tif (fd < 0) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"mkstemp\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\n\tfile = fopen(tfile, \"w\");\n\tchmod(tfile, 0600);\n\tif (file == NULL) {\n\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile);\n\t\trfbLogPerror(\"fopen\");\n\t\texit(1);\n\t}\n\n\tstr = strdup(str_in);\n\tp = strtok(str, \",\");\n\n\twhile (p) {\n\t\tif (!strcmp(p, \"CA\")) {\n\t\t\tsprintf(tfile2, \"%s/CA/cacert.pem\", cdir);\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\n\t\t} else if (!strcmp(p, \"clients\")) {\n\t\t\tDIR *dir;\n\t\t\tstruct dirent *dp;\n\n\t\t\tsprintf(tfile2, \"%s/clients\", cdir);\n\t\t\tdir = opendir(tfile2);\n\t\t\tif (! dir) {\n\t\t\t\trfbLog(\"get_ssl_verify_file: %s\\n\", tfile2);\n\t\t\t\trfbLogPerror(\"opendir\");\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\twhile ( (dp = readdir(dir)) != NULL) {\n\t\t\t\tchar *n = dp->d_name;\n\t\t\t\tchar *q = strstr(n, \".crt\");\n\n\t\t\t\tif (! q || strlen(q) != strlen(\".crt\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strlen(n) > 512) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, n);\n\t\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\t\tunlink(tfile);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\trfbLog(\"sslverify: loaded %s\\n\",\n\t\t\t\t    tfile2);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\t\n\t\t} else {\n\t\t\tif (strlen(p) > 512) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsprintf(tfile2, \"%s/clients/%s.crt\", cdir, p);\n\t\t\tif (stat(tfile2, &sbuf) != 0) {\n\t\t\t\tsprintf(tfile2, \"%s/clients/%s\", cdir, p);\n\t\t\t}\n\t\t\tif (! appendfile(file, tfile2)) {\n\t\t\t\tunlink(tfile);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\trfbLog(\"sslverify: loaded %s\\n\", tfile2);\n\t\t\tcount++;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfclose(file);\n\tfree(tfile2);\n\tfree(str);\n\n\trfbLog(\"sslverify: using %d client certs in\\n\", count);\n\trfbLog(\"sslverify: %s\\n\", tfile);\n\n\treturn tfile;\n}"
  },
  {
    "function_name": "appendfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "519-545",
    "snippet": "static int appendfile(FILE *out, char *infile) {\n\tchar line[1024];\n\tFILE *in;\n\n\tif (! infile) {\n\t\trfbLog(\"appendfile: null infile.\\n\");\n\t\treturn 0;\n\t}\n\tif (! out) {\n\t\trfbLog(\"appendfile: null out handle.\\n\");\n\t\treturn 0;\n\t}\n\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLog(\"appendfile: %s\\n\", infile);\n\t\trfbLogPerror(\"fopen\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\treturn 1;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "out",
            "\"%s\"",
            "line"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "in"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"appendfile: %s\\n\"",
            "infile"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "infile",
            "\"r\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"appendfile: null out handle.\\n\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"appendfile: null infile.\\n\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_input(char *tag, char **in);\n\nstatic int appendfile(FILE *out, char *infile) {\n\tchar line[1024];\n\tFILE *in;\n\n\tif (! infile) {\n\t\trfbLog(\"appendfile: null infile.\\n\");\n\t\treturn 0;\n\t}\n\tif (! out) {\n\t\trfbLog(\"appendfile: null out handle.\\n\");\n\t\treturn 0;\n\t}\n\n\tin = fopen(infile, \"r\");\n\n\tif (in == NULL) {\n\t\trfbLog(\"appendfile: %s\\n\", infile);\n\t\trfbLogPerror(\"fopen\");\n\t\treturn 0;\n\t}\n\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\treturn 1;\n}"
  },
  {
    "function_name": "create_tmp_pem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "238-517",
    "snippet": "char *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [
      "#define FORK_OK",
      "#define DO_DH 0"
    ],
    "globals_used": [
      "char *get_saved_pem(char *string, int create);",
      "char *find_openssl_bin(void);",
      "char *create_tmp_pem(char *path, int prompt);",
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pem"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pathin"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pem"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "exe"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "cmd"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s x509 -text -in '%s'\"",
            "exe",
            "pem"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "cmd",
            "\"%s x509 -text -in '%s' 1>&2\"",
            "exe",
            "pem"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "exe"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pem"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"openssl\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_openssl_bin",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "find_openssl_bin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "194-234",
          "snippet": "char *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *find_openssl_bin(void);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *find_openssl_bin(void);\nstatic char *get_input(char *tag, char **in);\n\nchar *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "crt"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"PRIVATE KEY\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"END CERTIFICATE\""
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "line"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "crt",
            "\"%s\"",
            "line"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "out",
            "\"%s\"",
            "line"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"BEGIN CERTIFICATE\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "in"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pathcrt"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pathin"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "crt"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not open: %s\\n\"",
            "pem"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pem",
            "\"r\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "crt"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not open: %s\\n\"",
            "pathin"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "pathin",
            "0600"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pathin",
            "\"w\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fopen\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not open: %s\\n\"",
            "pathcrt"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pathcrt",
            "\"w\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "q",
            "\".pem\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "pathcrt",
            "'/'"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pathin"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "cnf"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "out"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "out",
            "\"%s\"",
            "line"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "in"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pem",
            "\"a\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "cnf",
            "\"r\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "exe",
            "exe",
            "\"dhparam\"",
            "\"-out\"",
            "cnf",
            "\"512\"",
            "(char *)0"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "i"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "close_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/unixpw.c",
          "lines": "666-672",
          "snippet": "static void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}",
          "includes": [
            "#include <sys/stropts.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <shadow.h>",
            "#include \"default8x16.h\"",
            "#include \"rates.h\"",
            "#include \"cursor.h\"",
            "#include \"sslhelper.h\"",
            "#include \"connections.h\"",
            "#include \"user.h\"",
            "#include \"connections.h\"",
            "#include \"xinerama.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int slave_fd = -1, alarm_fired = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stropts.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <shadow.h>\n#include \"default8x16.h\"\n#include \"rates.h\"\n#include \"cursor.h\"\n#include \"sslhelper.h\"\n#include \"connections.h\"\n#include \"user.h\"\n#include \"connections.h\"\n#include \"xinerama.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"x11vnc.h\"\n\nstatic int slave_fd = -1, alarm_fired = 0;\n\nstatic void close_alarm (int sig) {\n\tif (slave_fd >= 0) {\n\t\tclose(slave_fd);\n\t}\n\talarm_fired = 1;\n\tif (0) sig = 0;\t/* compiler warning */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "pid",
            "&status",
            "0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "exe",
            "exe",
            "\"req\"",
            "\"-new\"",
            "\"-x509\"",
            "\"-nodes\"",
            "\"-days\"",
            "days",
            "\"-config\"",
            "cnf",
            "\"-out\"",
            "pem",
            "\"-keyout\"",
            "pem",
            "(char *)0"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"not compiled with fork(2)\\n\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "cnf_fd",
            "str",
            "strlen(str)"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "write_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "1319-1344",
          "snippet": "static int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ssl_helper_pid(pid_t pid, int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid ssl_helper_pid(pid_t pid, int sock);\n\nstatic int write_exact(int sock, char *buf, int len) {\n\tint n, fail = 0;\n\tif (sock < 0) {\n\t\treturn 0;\n\t}\n\twhile (len > 0) {\n\t\tn = write(sock, buf, len);\n\t\tif (n > 0) {\n\t\t\tbuf += n;\n\t\t\tlen -= n;\n\t\t} else if (n == 0) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t} else if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n\t\t\tusleep(10*1000);\n\t\t} else if (n < 0 && errno != EINTR) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fail) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "pem"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "cnf"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "tmpl",
            "C",
            "L",
            "OU",
            "O",
            "CN",
            "EM"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_input",
          "args": [
            "\"EmailAddress\"",
            "&EM"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "get_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "170-192",
          "snippet": "static char *get_input(char *tag, char **in) {\n\tchar line[1024], *str;\n\n\tif (! tag || ! in || ! *in) {\n\t\treturn NULL;\n\t}\n\n\tfprintf(stderr, \"%s:\\n     [%s] \", tag, *in);\n\tif (fgets(line, 1024, stdin) == NULL) {\n\t\trfbLog(\"could not read stdin!\\n\");\n\t\trfbLogPerror(\"fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tif ((str = strrchr(line, '\\n')) != NULL) {\n\t\t*str = '\\0';\n\t}\n\tstr = lblanks(line);\n\tif (!strcmp(str, \"\")) {\n\t\treturn *in;\n\t} else {\n\t\treturn strdup(line);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_input(char *tag, char **in);\n\nstatic char *get_input(char *tag, char **in) {\n\tchar line[1024], *str;\n\n\tif (! tag || ! in || ! *in) {\n\t\treturn NULL;\n\t}\n\n\tfprintf(stderr, \"%s:\\n     [%s] \", tag, *in);\n\tif (fgets(line, 1024, stdin) == NULL) {\n\t\trfbLog(\"could not read stdin!\\n\");\n\t\trfbLogPerror(\"fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tif ((str = strrchr(line, '\\n')) != NULL) {\n\t\t*str = '\\0';\n\t}\n\tstr = lblanks(line);\n\tif (!strcmp(str, \"\")) {\n\t\treturn *in;\n\t} else {\n\t\treturn strdup(line);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"server certificate.\\n\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"help output and the FAQ for how to create a permanent\\n\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"authenticate this server for this session.  See the -ssl\\n\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"printed below may be used on the VNC viewer-side to\\n\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"                -----END CERTIFICATE-----\\n\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"                           ....\\n\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"The cert inside -----BEGIN CERTIFICATE-----\\n\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"sniffing.\\n\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"with a CA key. However, it will prevent passive network\\n\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"tunnel configuration or you take the extra steps to sign it\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get the certificate information to the VNC viewers SSL\\n\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Creating a temporary, self-signed PEM certificate...\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Creating a self-signed PEM certificate...\\n\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"create_tmp_pem: cannot run external commands.\\n\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ok",
          "args": [
            "\"ssl\""
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "436-460",
          "snippet": "int cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void close_clients(char *str);",
            "void set_client_input(char *str);",
            "int cmd_ok(char *cmd);",
            "void reverse_connect(char *str);",
            "void set_vnc_connect_prop(char *str);",
            "void set_x11vnc_remote_prop(char *str);",
            "void send_client_info(char *str);",
            "static rfbClientPtr *client_match(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid close_clients(char *str);\nvoid set_client_input(char *str);\nint cmd_ok(char *cmd);\nvoid reverse_connect(char *str);\nvoid set_vnc_connect_prop(char *str);\nvoid set_x11vnc_remote_prop(char *str);\nvoid send_client_info(char *str);\nstatic rfbClientPtr *client_match(char *str);\n\nint cmd_ok(char *cmd) {\n\tchar *p, *str;\n\tif (no_external_cmds) {\n\t\treturn 0;\n\t}\n\tif (! cmd || cmd[0] == '\\0') {\n\t\treturn 0;\n\t}\n\tif (! allowed_external_cmds) {\n\t\t/* default, allow any (overridden by -nocmds) */\n\t\treturn 1;\n\t}\n\n\tstr = strdup(allowed_external_cmds);\n\tp = strtok(str, \",\");\n\twhile (p) {\n\t\tif (!strcmp(p, cmd)) {\n\t\t\tfree(str);\n\t\t\treturn 1;\n\t\t}\n\t\tp = strtok(NULL, \",\");\n\t}\n\tfree(str);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"x11vnc@server.nowhere\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "line",
            "sizeof line",
            "\"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\"",
            "getpid()"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "line",
            "sizeof line",
            "\"x11vnc-SELF-SIGNED-CERT-%d\"",
            "getpid()"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"x11vnc\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "line",
            "sizeof line",
            "\"%s-%f\"",
            "UT.nodename ? UT.nodename :\n\t    \"unknown-node\"",
            "dnow()"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnow",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "dnowx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "439-441",
          "snippet": "double dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "double dnow(void);",
            "double dnowx(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\ndouble dnow(void);\ndouble dnowx(void);\n\ndouble dnowx(void) {\n\treturn dnow() - x11vnc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "UT.sysname ? UT.sysname : \"unknown-os\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"AU\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n#define DO_DH 0\n\nchar *get_saved_pem(char *string, int create);\nchar *find_openssl_bin(void);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}"
  },
  {
    "function_name": "find_openssl_bin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "194-234",
    "snippet": "char *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *find_openssl_bin(void);",
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"(also checked: %s)\\n\"",
            "extra"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"PATH=%s\\n\"",
            "gp"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not find openssl(1) program in PATH.\\n\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "free_rect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/userinput.c",
          "lines": "6200-6247",
          "snippet": "int free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}",
          "includes": [
            "#include \"default8x16.h\"",
            "#include \"connections.h\"",
            "#include \"screen.h\"",
            "#include \"cursor.h\"",
            "#include \"macosxCGS.h\"",
            "#include \"macosx.h\"",
            "#include \"unixpw.h\"",
            "#include \"8to24.h\"",
            "#include \"xrandr.h\"",
            "#include \"solid.h\"",
            "#include \"keyboard.h\"",
            "#include \"rates.h\"",
            "#include \"pointer.h\"",
            "#include \"cleanup.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"xevents.h\"",
            "#include \"win_utils.h\"",
            "#include \"xinerama.h\"",
            "#include \"xrecord.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void mark_for_xdamage(int x, int y, int w, int h);",
            "void set_xdamage_mark(int x, int y, int w, int h);",
            "int find_rect(int idx, int x, int y, int w, int h);",
            "winattr_t *cache_list;",
            "int clipped(int idx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"default8x16.h\"\n#include \"connections.h\"\n#include \"screen.h\"\n#include \"cursor.h\"\n#include \"macosxCGS.h\"\n#include \"macosx.h\"\n#include \"unixpw.h\"\n#include \"8to24.h\"\n#include \"xrandr.h\"\n#include \"solid.h\"\n#include \"keyboard.h\"\n#include \"rates.h\"\n#include \"pointer.h\"\n#include \"cleanup.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"xevents.h\"\n#include \"win_utils.h\"\n#include \"xinerama.h\"\n#include \"xrecord.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid mark_for_xdamage(int x, int y, int w, int h);\nvoid set_xdamage_mark(int x, int y, int w, int h);\nint find_rect(int idx, int x, int y, int w, int h);\nwinattr_t *cache_list;\nint clipped(int idx);\n\nint free_rect(int idx) {\n\tint n, ok = 0;\n\tsraRegionPtr r1, r2;\n\tint x, y, w, h;\n\n\tif (idx < 0 || idx >= cache_list_num) {\nif (0) fprintf(stderr, \"free_rect: bad index: %d\\n\", idx);\n\t\tclean_up_exit(1);\n\t}\n\n\tx = cache_list[idx].bs_x;\n\ty = cache_list[idx].bs_y;\n\tw = cache_list[idx].bs_w;\n\th = cache_list[idx].bs_h;\n\n\tif (x < 0) {\n\t\tCLEAR(idx);\nif (dnow() > last_client + 5 && ncdb) fprintf(stderr, \"free_rect: already bs_x invalidated: %d bs_x: %d\\n\", idx, x);\n\t\treturn 1;\n\t}\n\n\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\n\tn = get_bs_n(y);\n\tif (n >= 0) {\n\t\tr1 = rect_reg[n];\n\t\tsraRgnOr(r1, r2);\n\t\tok = 1;\n\t}\n\n\tif (zero_rects) {\n\t\tsraRgnOr(zero_rects, r2);\n\t\tx = cache_list[idx].su_x;\n\t\ty = cache_list[idx].su_y;\n\t\tw = cache_list[idx].su_w;\n\t\th = cache_list[idx].su_h;\n\t\tif (x >= 0) {\n\t\t\tsraRgnDestroy(r2);\n\t\t\tr2 = sraRgnCreateRect(x, y, x+w, y+h);\n\t\t\tsraRgnOr(zero_rects, r2);\n\t\t}\n\t}\n\tsraRgnDestroy(r2);\n\n\tCLEAR(idx);\nif (! ok && ncdb) fprintf(stderr, \"**** free_rect: not-found %d\\n\", idx);\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sbuf.st_mode"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "exe",
            "&sbuf"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "exe",
            "\"%s/openssl\"",
            "p"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path",
            "\":\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(path) + strlen(\"/openssl\") + 1"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/openssl\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "path",
            "extra"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "path",
            "gp"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(gp) + strlen(extra) + 1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "extra"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gp"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"could not find openssl(1) program in PATH. (null)\\n\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *find_openssl_bin(void);\nstatic char *get_input(char *tag, char **in);\n\nchar *find_openssl_bin(void) {\n\tchar *path, *exe, *p, *gp;\n\tstruct stat sbuf;\n\tint found_openssl = 0;\n\tchar extra[] = \":/usr/bin:/bin:/usr/sbin:/usr/local/bin\"\n\t    \":/usr/local/sbin:/usr/sfw/bin\";\n\t\n\tgp = getenv(\"PATH\");\n\tif (! gp) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH. (null)\\n\");\n\t\treturn NULL;\n\t}\n\n\tpath = (char *) malloc(strlen(gp) + strlen(extra) + 1);\n\tstrcpy(path, gp);\n\tstrcat(path, extra);\n\n\t/* find openssl binary: */\n\texe = (char *) malloc(strlen(path) + strlen(\"/openssl\") + 1);\n\tp = strtok(path, \":\");\n\n\twhile (p) {\n\t\tsprintf(exe, \"%s/openssl\", p);\n\t\tif (stat(exe, &sbuf) == 0) {\n\t\t\tif (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\tfound_openssl = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = strtok(NULL, \":\");\n\t}\n\tfree(path);\n\n\tif (! found_openssl) {\n\t\tfprintf(stderr, \"could not find openssl(1) program in PATH.\\n\");\n\t\tfprintf(stderr, \"PATH=%s\\n\", gp);\n\t\tfprintf(stderr, \"(also checked: %s)\\n\", extra);\n\t\treturn NULL;\n\t}\n\treturn exe;\n}"
  },
  {
    "function_name": "get_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "170-192",
    "snippet": "static char *get_input(char *tag, char **in) {\n\tchar line[1024], *str;\n\n\tif (! tag || ! in || ! *in) {\n\t\treturn NULL;\n\t}\n\n\tfprintf(stderr, \"%s:\\n     [%s] \", tag, *in);\n\tif (fgets(line, 1024, stdin) == NULL) {\n\t\trfbLog(\"could not read stdin!\\n\");\n\t\trfbLogPerror(\"fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tif ((str = strrchr(line, '\\n')) != NULL) {\n\t\t*str = '\\0';\n\t}\n\tstr = lblanks(line);\n\tif (!strcmp(str, \"\")) {\n\t\treturn *in;\n\t} else {\n\t\treturn strdup(line);\n\t}\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "line"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lblanks",
          "args": [
            "line"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "lblanks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "160-169",
          "snippet": "char *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\n\nchar *lblanks(char *str) {\n\tchar *p = str;\n\twhile (*p != '\\0') {\n\t\tif (! isspace((unsigned char) (*p))) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLogPerror",
          "args": [
            "\"fgets\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"could not read stdin!\\n\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "stdin"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s:\\n     [%s] \"",
            "tag",
            "*in"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nstatic char *get_input(char *tag, char **in);\n\nstatic char *get_input(char *tag, char **in) {\n\tchar line[1024], *str;\n\n\tif (! tag || ! in || ! *in) {\n\t\treturn NULL;\n\t}\n\n\tfprintf(stderr, \"%s:\\n     [%s] \", tag, *in);\n\tif (fgets(line, 1024, stdin) == NULL) {\n\t\trfbLog(\"could not read stdin!\\n\");\n\t\trfbLogPerror(\"fgets\");\n\t\tclean_up_exit(1);\n\t}\n\tif ((str = strrchr(line, '\\n')) != NULL) {\n\t\t*str = '\\0';\n\t}\n\tstr = lblanks(line);\n\tif (!strcmp(str, \"\")) {\n\t\treturn *in;\n\t} else {\n\t\treturn strdup(line);\n\t}\n}"
  },
  {
    "function_name": "get_saved_pem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
    "lines": "88-168",
    "snippet": "char *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <openssl/err.h>",
      "#include <openssl/ssl.h>",
      "#include \"user.h\"",
      "#include \"unixpw.h\"",
      "#include \"sslcmds.h\"",
      "#include \"connections.h\"",
      "#include \"scan.h\"",
      "#include \"screen.h\"",
      "#include \"cleanup.h\"",
      "#include \"inet.h\"",
      "#include \"x11vnc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char *get_saved_pem(char *string, int create);",
      "char *create_tmp_pem(char *path, int prompt);",
      "static char *get_input(char *tag, char **in);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "in"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"PRIVATE KEY\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"END CERTIFICATE\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "line"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"BEGIN CERTIFICATE\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "1024",
            "in"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\n\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"Using SSL Certificate:\\n\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"\\n\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"r\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sslEncKey",
          "args": [
            "new_name",
            "0"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "sslEncKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "647-907",
          "snippet": "void sslEncKey(char *path, int mode) {\n\tchar *openssl = find_openssl_bin();\n\tchar *scr, *cert = NULL, *tca, *cdir = NULL;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tint tmp_fd, incert, info_only = 0, delete_only = 0, listlong = 0;\n\tstruct stat sbuf;\n\tFILE *file;\n\tstatic int depth = 0;\n\n\tif (depth > 0) {\n\t\t/* get_saved_pem may call us back. */\n\t\treturn;\n\t}\n\n\tif (! path) {\n\t\treturn;\n\t}\n\n\tdepth++;\n\n\tif (mode == 1) {\n\t\tinfo_only = 1;\n\t} else if (mode == 2) {\n\t\tdelete_only = 1;\n\t}\n\n\tif (! openssl) {\n\t\texit(1);\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tca);\n\tif (! cdir || ! tca) {\n\t\tfprintf(stderr, \"could not find Cert dir\\n\");\n\t\texit(1);\n\t}\n\n\tif (!strcasecmp(path, \"LL\") || !strcasecmp(path, \"LISTL\")) {\n\t\tlistlong = 1;\n\t\tpath = \"LIST\";\n\t}\n\n\tif (strstr(path, \"SAVE\") == path) {\n\t\tchar *p = get_saved_pem(path, 0);\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"could not find saved pem \"\n\t\t\t    \"matching: %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tpath = p;\n\n\t} else if (!strcmp(path, \"CA\")) {\n\t\ttca = (char *) malloc(strlen(cdir)+strlen(\"/CA/cacert.pem\")+1);\n\t\tsprintf(tca, \"%s/CA/cacert.pem\", cdir);\n\t\tpath = tca;\n\n\t} else if (info_only && (!strcasecmp(path, \"LIST\") ||\n\t    !strcasecmp(path, \"LS\") || !strcasecmp(path, \"ALL\"))) {\n\n\t\tif (! program_name || strchr(program_name, ' ')) {\n\t\t\tfprintf(stderr, \"bad program name.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (strchr(cdir, '\\'')) {\n\t\t\tfprintf(stderr, \"bad certdir char: %s\\n\", cdir);\n\t\t\texit(1);\n\t\t}\n\n\t\ttca = (char *) malloc(2*strlen(cdir)+strlen(program_name)+1000);\n\n\t\tsprintf(tca, \"find '%s' | egrep '/(CA|tmp|clients)$|\"\n\t\t    \"\\\\.(crt|pem|key|req)$' | grep -v CA/newcerts\", cdir);\n\n\t\tif (!strcasecmp(path, \"ALL\")) {\n\t\t\t/* ugh.. */\n\t\t\tstrcat(tca, \" | egrep -v 'private/cakey.pem|\"\n\t\t\t    \"(CA|tmp|clients)$' | xargs -n1 \");\n\t\t\tstrcat(tca, program_name);\n\t\t\tstrcat(tca, \" -ssldir '\");\n\t\t\tstrcat(tca, cdir);\n\t\t\tstrcat(tca, \"' -sslCertInfo 2>&1 \");\n\t\t} else if (listlong) {\n\t\t\tstrcat(tca, \" | xargs ls -ld \");\n\t\t}\n\t\tsystem(tca);\n\t\tfree(tca);\n\n\t\tdepth--;\n\t\treturn;\n\n\t} else if (info_only && (!strcasecmp(path, \"HASHON\")\n\t    || !strcasecmp(path, \"HASHOFF\"))) {\n\n\t\ttmp_fd = mkstemp(tmp);\n\t\tif (tmp_fd < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\twrite(tmp_fd, genCert, strlen(genCert));\n\t\tclose(tmp_fd);\n\n\t\tscr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\t\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\t\tset_env(\"BASE_DIR\", cdir);\n\t\tset_env(\"OPENSSL\", openssl);\n\t\tset_env(\"TYPE\", \"server\");\n\t\tif (!strcasecmp(path, \"HASHON\")) {\n\t\t\tset_env(\"HASHON\", \"1\");\n\t\t} else {\n\t\t\tset_env(\"HASHOFF\", \"1\");\n\t\t}\n\t\tsystem(scr);\n\t\tunlink(tmp);\n\t\tfree(scr);\n\n\t\tdepth--;\n\t\treturn;\n\t}\n\n\n\tif (stat(path, &sbuf) != 0) {\n\t    if (strstr(path, \"client\") || strchr(path, '/') == NULL) {\n\t\tint i;\n\t\ttca = (char *) malloc(strlen(cdir) + strlen(path) + 100);\n\t\tfor (i = 1; i <= 15; i++)  {\n\t\t\ttca[0] = '\\0';\n\t\t\tif (       i == 1) {\n\t\t\t    sprintf(tca, \"%s/%s\", cdir, path); \n\t\t\t} else if (i == 2 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/%s.crt\", cdir, path); \n\t\t\t} else if (i == 3) {\n\t\t\t    sprintf(tca, \"%s/%s.pem\", cdir, path); \n\t\t\t} else if (i == 4 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.req\", cdir, path); \n\t\t\t} else if (i == 5 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.key\", cdir, path); \n\t\t\t} else if (i == 6) {\n\t\t\t    sprintf(tca, \"%s/clients/%s\", cdir, path); \n\t\t\t} else if (i == 7 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.crt\", cdir, path); \n\t\t\t} else if (i == 8) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.pem\", cdir, path); \n\t\t\t} else if (i == 9 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.req\", cdir, path); \n\t\t\t} else if (i == 10 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.key\", cdir, path); \n\t\t\t} else if (i == 11) {\n\t\t\t    sprintf(tca, \"%s/server-%s\", cdir, path); \n\t\t\t} else if (i == 12 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/server-%s.crt\", cdir, path); \n\t\t\t} else if (i == 13) {\n\t\t\t    sprintf(tca, \"%s/server-%s.pem\", cdir, path); \n\t\t\t} else if (i == 14 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.req\", cdir, path); \n\t\t\t} else if (i == 15 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.key\", cdir, path); \n\t\t\t}\n\t\t\tif (tca[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(tca, &sbuf) == 0) {\n\t\t\t\tpath = tca;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\tif (stat(path, &sbuf) != 0) {\n\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\trfbLogPerror(\"stat\");\n\t\texit(1);\n\t}\n\n\tif (! info_only) {\n\t\tcert = (char *) malloc(2*(sbuf.st_size + 1024));\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\tincert = 0;\n\t\tcert[0] = '\\0';\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 1;\n\t\t\t}\n\t\t\tif (incert) {\n\t\t\t\tif (strlen(cert)+strlen(line) <\n\t\t\t\t    2 * (size_t) sbuf.st_size) {\n\t\t\t\t\tstrcat(cert, line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\texit(1);\n\t}\n\n\twrite(tmp_fd, genCert, strlen(genCert));\n\tclose(tmp_fd);\n\n        scr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\tset_env(\"BASE_DIR\", \"/no/such/dir\");\n\tset_env(\"OPENSSL\", openssl);\n\tset_env(\"TYPE\", \"server\");\n\tif (info_only) {\n\t\tset_env(\"INFO_ONLY\", path);\n\t} else if (delete_only) {\n\t\tset_env(\"DELETE_ONLY\", path);\n\t} else {\n\t\tset_env(\"ENCRYPT_ONLY\", path);\n\t}\n\tsystem(scr);\n\tunlink(tmp);\n\n\tif (! mode && cert && cert[0] != '\\0') {\n\t\tint got_cert = 0;\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t\tif (got_cert < 2) {\n\t\t\tfile = fopen(path, \"a\");\n\t\t\tif (file == NULL) {\n\t\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfprintf(file, \"%s\", cert);\n\t\t\tfclose(file);\n\t\t}\n\t\tfree(cert);\n\t}\n\n\tdepth--;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sslGenCA(char *cdir);",
            "void sslEncKey(char *path, int info_only);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid sslGenCA(char *cdir);\nvoid sslEncKey(char *path, int info_only);\n\nvoid sslEncKey(char *path, int mode) {\n\tchar *openssl = find_openssl_bin();\n\tchar *scr, *cert = NULL, *tca, *cdir = NULL;\n\tchar line[1024], tmp[] = \"/tmp/x11vnc-tmp.XXXXXX\";\n\tint tmp_fd, incert, info_only = 0, delete_only = 0, listlong = 0;\n\tstruct stat sbuf;\n\tFILE *file;\n\tstatic int depth = 0;\n\n\tif (depth > 0) {\n\t\t/* get_saved_pem may call us back. */\n\t\treturn;\n\t}\n\n\tif (! path) {\n\t\treturn;\n\t}\n\n\tdepth++;\n\n\tif (mode == 1) {\n\t\tinfo_only = 1;\n\t} else if (mode == 2) {\n\t\tdelete_only = 1;\n\t}\n\n\tif (! openssl) {\n\t\texit(1);\n\t}\n\n\tcdir = get_Cert_dir(NULL, &tca);\n\tif (! cdir || ! tca) {\n\t\tfprintf(stderr, \"could not find Cert dir\\n\");\n\t\texit(1);\n\t}\n\n\tif (!strcasecmp(path, \"LL\") || !strcasecmp(path, \"LISTL\")) {\n\t\tlistlong = 1;\n\t\tpath = \"LIST\";\n\t}\n\n\tif (strstr(path, \"SAVE\") == path) {\n\t\tchar *p = get_saved_pem(path, 0);\n\t\tif (p == NULL) {\n\t\t\tfprintf(stderr, \"could not find saved pem \"\n\t\t\t    \"matching: %s\\n\", path);\n\t\t\texit(1);\n\t\t}\n\t\tpath = p;\n\n\t} else if (!strcmp(path, \"CA\")) {\n\t\ttca = (char *) malloc(strlen(cdir)+strlen(\"/CA/cacert.pem\")+1);\n\t\tsprintf(tca, \"%s/CA/cacert.pem\", cdir);\n\t\tpath = tca;\n\n\t} else if (info_only && (!strcasecmp(path, \"LIST\") ||\n\t    !strcasecmp(path, \"LS\") || !strcasecmp(path, \"ALL\"))) {\n\n\t\tif (! program_name || strchr(program_name, ' ')) {\n\t\t\tfprintf(stderr, \"bad program name.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (strchr(cdir, '\\'')) {\n\t\t\tfprintf(stderr, \"bad certdir char: %s\\n\", cdir);\n\t\t\texit(1);\n\t\t}\n\n\t\ttca = (char *) malloc(2*strlen(cdir)+strlen(program_name)+1000);\n\n\t\tsprintf(tca, \"find '%s' | egrep '/(CA|tmp|clients)$|\"\n\t\t    \"\\\\.(crt|pem|key|req)$' | grep -v CA/newcerts\", cdir);\n\n\t\tif (!strcasecmp(path, \"ALL\")) {\n\t\t\t/* ugh.. */\n\t\t\tstrcat(tca, \" | egrep -v 'private/cakey.pem|\"\n\t\t\t    \"(CA|tmp|clients)$' | xargs -n1 \");\n\t\t\tstrcat(tca, program_name);\n\t\t\tstrcat(tca, \" -ssldir '\");\n\t\t\tstrcat(tca, cdir);\n\t\t\tstrcat(tca, \"' -sslCertInfo 2>&1 \");\n\t\t} else if (listlong) {\n\t\t\tstrcat(tca, \" | xargs ls -ld \");\n\t\t}\n\t\tsystem(tca);\n\t\tfree(tca);\n\n\t\tdepth--;\n\t\treturn;\n\n\t} else if (info_only && (!strcasecmp(path, \"HASHON\")\n\t    || !strcasecmp(path, \"HASHOFF\"))) {\n\n\t\ttmp_fd = mkstemp(tmp);\n\t\tif (tmp_fd < 0) {\n\t\t\texit(1);\n\t\t}\n\n\t\twrite(tmp_fd, genCert, strlen(genCert));\n\t\tclose(tmp_fd);\n\n\t\tscr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\t\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\t\tset_env(\"BASE_DIR\", cdir);\n\t\tset_env(\"OPENSSL\", openssl);\n\t\tset_env(\"TYPE\", \"server\");\n\t\tif (!strcasecmp(path, \"HASHON\")) {\n\t\t\tset_env(\"HASHON\", \"1\");\n\t\t} else {\n\t\t\tset_env(\"HASHOFF\", \"1\");\n\t\t}\n\t\tsystem(scr);\n\t\tunlink(tmp);\n\t\tfree(scr);\n\n\t\tdepth--;\n\t\treturn;\n\t}\n\n\n\tif (stat(path, &sbuf) != 0) {\n\t    if (strstr(path, \"client\") || strchr(path, '/') == NULL) {\n\t\tint i;\n\t\ttca = (char *) malloc(strlen(cdir) + strlen(path) + 100);\n\t\tfor (i = 1; i <= 15; i++)  {\n\t\t\ttca[0] = '\\0';\n\t\t\tif (       i == 1) {\n\t\t\t    sprintf(tca, \"%s/%s\", cdir, path); \n\t\t\t} else if (i == 2 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/%s.crt\", cdir, path); \n\t\t\t} else if (i == 3) {\n\t\t\t    sprintf(tca, \"%s/%s.pem\", cdir, path); \n\t\t\t} else if (i == 4 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.req\", cdir, path); \n\t\t\t} else if (i == 5 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/%s.key\", cdir, path); \n\t\t\t} else if (i == 6) {\n\t\t\t    sprintf(tca, \"%s/clients/%s\", cdir, path); \n\t\t\t} else if (i == 7 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.crt\", cdir, path); \n\t\t\t} else if (i == 8) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.pem\", cdir, path); \n\t\t\t} else if (i == 9 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.req\", cdir, path); \n\t\t\t} else if (i == 10 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/clients/%s.key\", cdir, path); \n\t\t\t} else if (i == 11) {\n\t\t\t    sprintf(tca, \"%s/server-%s\", cdir, path); \n\t\t\t} else if (i == 12 && mode > 0) {\n\t\t\t    sprintf(tca, \"%s/server-%s.crt\", cdir, path); \n\t\t\t} else if (i == 13) {\n\t\t\t    sprintf(tca, \"%s/server-%s.pem\", cdir, path); \n\t\t\t} else if (i == 14 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.req\", cdir, path); \n\t\t\t} else if (i == 15 && mode > 1) {\n\t\t\t    sprintf(tca, \"%s/server-%s.key\", cdir, path); \n\t\t\t}\n\t\t\tif (tca[0] == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(tca, &sbuf) == 0) {\n\t\t\t\tpath = tca;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\tif (stat(path, &sbuf) != 0) {\n\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\trfbLogPerror(\"stat\");\n\t\texit(1);\n\t}\n\n\tif (! info_only) {\n\t\tcert = (char *) malloc(2*(sbuf.st_size + 1024));\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\tincert = 0;\n\t\tcert[0] = '\\0';\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 1;\n\t\t\t}\n\t\t\tif (incert) {\n\t\t\t\tif (strlen(cert)+strlen(line) <\n\t\t\t\t    2 * (size_t) sbuf.st_size) {\n\t\t\t\t\tstrcat(cert, line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tincert = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t}\n\n\ttmp_fd = mkstemp(tmp);\n\tif (tmp_fd < 0) {\n\t\texit(1);\n\t}\n\n\twrite(tmp_fd, genCert, strlen(genCert));\n\tclose(tmp_fd);\n\n        scr = (char *) malloc(strlen(\"/bin/sh \") + strlen(tmp) + 1);\n\tsprintf(scr, \"/bin/sh %s\", tmp);\n\n\tset_env(\"BASE_DIR\", \"/no/such/dir\");\n\tset_env(\"OPENSSL\", openssl);\n\tset_env(\"TYPE\", \"server\");\n\tif (info_only) {\n\t\tset_env(\"INFO_ONLY\", path);\n\t} else if (delete_only) {\n\t\tset_env(\"DELETE_ONLY\", path);\n\t} else {\n\t\tset_env(\"ENCRYPT_ONLY\", path);\n\t}\n\tsystem(scr);\n\tunlink(tmp);\n\n\tif (! mode && cert && cert[0] != '\\0') {\n\t\tint got_cert = 0;\n\t\tfile = fopen(path, \"r\");\n\t\tif (file == NULL) {\n\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\texit(1);\n\t\t}\n\t\twhile (fgets(line, sizeof line, file) != NULL) {\n\t\t\tif (strstr(line, \"-----BEGIN CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t\tif (strstr(line, \"-----END CERTIFICATE-----\")\n\t\t\t    == line) {\n\t\t\t\tgot_cert++;\n\t\t\t}\n\t\t}\n\t\tfclose(file);\n\t\tif (got_cert < 2) {\n\t\t\tfile = fopen(path, \"a\");\n\t\t\tif (file == NULL) {\n\t\t\t\trfbLog(\"sslEncKey: %s\\n\", path);\n\t\t\t\trfbLogPerror(\"fopen\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfprintf(file, \"%s\", cert);\n\t\t\tfclose(file);\n\t\t}\n\t\tfree(cert);\n\t}\n\n\tdepth--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"X11VNC_SSL_NO_PASSPHRASE\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_tmp_pem",
          "args": [
            "path",
            "prompt"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "create_tmp_pem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslhelper.c",
          "lines": "238-517",
          "snippet": "char *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <openssl/err.h>",
            "#include <openssl/ssl.h>",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"sslcmds.h\"",
            "#include \"connections.h\"",
            "#include \"scan.h\"",
            "#include \"screen.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [
            "#define FORK_OK",
            "#define DO_DH 0"
          ],
          "globals_used": [
            "char *get_saved_pem(char *string, int create);",
            "char *find_openssl_bin(void);",
            "char *create_tmp_pem(char *path, int prompt);",
            "static char *get_input(char *tag, char **in);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\n#define FORK_OK\n#define DO_DH 0\n\nchar *get_saved_pem(char *string, int create);\nchar *find_openssl_bin(void);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *create_tmp_pem(char *pathin, int prompt) {\n\tpid_t pid, pidw;\n\tFILE *in, *out;\n\tchar cnf[] = \"/tmp/x11vnc-cnf.XXXXXX\";\n\tchar pem[] = \"/tmp/x11vnc-pem.XXXXXX\";\n\tchar str[8*1024], line[1024], *exe;\n\tint cnf_fd, pem_fd, status, show_cert = 1;\n\tchar *days;\n\tchar *C, *L, *OU, *O, *CN, *EM;\n\tchar tmpl[] = \n\"[ req ]\\n\"\n\"prompt = no\\n\"\n\"default_bits = 2048\\n\"\n\"encrypt_key = yes\\n\"\n\"distinguished_name = req_dn\\n\"\n\"x509_extensions = cert_type\\n\"\n\"\\n\"\n\"[ req_dn ]\\n\"\n\"countryName=%s\\n\"\n\"localityName=%s\\n\"\n\"organizationalUnitName=%s\\n\"\n\"organizationName=%s\\n\"\n\"commonName=%s\\n\"\n\"emailAddress=%s\\n\"\n\"\\n\"\n\"[ cert_type ]\\n\"\n\"nsCertType = server\\n\"\n;\n\n\tC = strdup(\"AU\");\n\tL = strdup(UT.sysname ? UT.sysname : \"unknown-os\");\n\tsnprintf(line, sizeof line, \"%s-%f\", UT.nodename ? UT.nodename :\n\t    \"unknown-node\", dnow());\n\tline[1024-1] = '\\0';\n\n\tOU = strdup(line);\n\tO = strdup(\"x11vnc\");\n\tif (pathin) {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-CERT-%d\", getpid());\n\t} else {\n\t\tsnprintf(line, sizeof line, \"x11vnc-SELF-SIGNED-TEMPORARY-CERT-%d\",\n\t\t    getpid());\n\t}\n\tline[1024-1] = '\\0';\n\tCN = strdup(line);\n\tEM = strdup(\"x11vnc@server.nowhere\");\n\n\t/* ssl */\n\tif (no_external_cmds || !cmd_ok(\"ssl\")) {\n\t\trfbLog(\"create_tmp_pem: cannot run external commands.\\n\");\t\n\t\treturn NULL;\n\t}\n\n\trfbLog(\"\\n\");\t\n\tif (pathin) {\n\t\trfbLog(\"Creating a self-signed PEM certificate...\\n\");\t\n\t} else {\n\t\trfbLog(\"Creating a temporary, self-signed PEM certificate...\\n\");\t\n\t}\n\n\trfbLog(\"\\n\");\t\n\trfbLog(\"This will NOT prevent Man-In-The-Middle attacks UNLESS you\\n\");\t\n\trfbLog(\"get the certificate information to the VNC viewers SSL\\n\");\t\n\trfbLog(\"tunnel configuration or you take the extra steps to sign it\\n\");\n\trfbLog(\"with a CA key. However, it will prevent passive network\\n\");\n\trfbLog(\"sniffing.\\n\");\t\n\trfbLog(\"\\n\");\t\n\trfbLog(\"The cert inside -----BEGIN CERTIFICATE-----\\n\");\t\n\trfbLog(\"                           ....\\n\");\t\n\trfbLog(\"                -----END CERTIFICATE-----\\n\");\t\n\trfbLog(\"printed below may be used on the VNC viewer-side to\\n\");\t\n\trfbLog(\"authenticate this server for this session.  See the -ssl\\n\");\n\trfbLog(\"help output and the FAQ for how to create a permanent\\n\");\n\trfbLog(\"server certificate.\\n\");\t\n\trfbLog(\"\\n\");\t\n\n\texe = find_openssl_bin();\n\tif (! exe) {\n\t\treturn NULL;\n\t}\n\n\t/* create template file with our made up stuff: */\n\tif (prompt) {\n\t\tfprintf(stderr, \"\\nReply to the following prompts to set\"\n\t\t    \" your Certificate parameters.\\n\");\n\t\tfprintf(stderr, \"(press Enter to accept the default in [...], \"\n\t\t    \"or type in the value you want)\\n\\n\");\n\t\tC = get_input(\"CountryName\", &C);\n\t\tL = get_input(\"LocalityName\", &L);\n\t\tOU = get_input(\"OrganizationalUnitName\", &OU);\n\t\tO = get_input(\"OrganizationalName\", &O);\n\t\tCN = get_input(\"CommonName\", &CN);\n\t\tEM = get_input(\"EmailAddress\", &EM);\n\t}\n\tsprintf(str, tmpl, C, L, OU, O, CN, EM);\n\n\tcnf_fd = mkstemp(cnf);\n\tif (cnf_fd < 0) {\n\t\treturn NULL;\n\t}\n\tpem_fd = mkstemp(pem);\n\tif (pem_fd < 0) {\n\t\tclose(cnf_fd);\n\t\treturn NULL;\n\t}\n\n\tclose(pem_fd);\n\n\twrite(cnf_fd, str, strlen(str));\n\tclose(cnf_fd);\n\n\tif (pathin) {\n\t\tdays = \"365\";\n\t} else {\n\t\tdays = \"30\";\n\t}\n\n#ifndef FORK_OK\n\trfbLog(\"not compiled with fork(2)\\n\");\n\tclean_up_exit(1);\n#else\n\t/* make RSA key */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\texeclp(exe, exe, \"req\", \"-new\", \"-x509\", \"-nodes\",\n\t\t    \"-days\", days, \"-config\", cnf, \"-out\", pem,\n\t\t    \"-keyout\", pem, (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if DO_DH\n\t/* make DH parameters */\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn NULL;\n\t} else if (pid == 0) {\n\t\tint i;\n\t\tfor (i=0; i<256; i++) {\n\t\t\tclose(i);\n\t\t}\n\t\t/* rather slow at 1024 */\n\t\texeclp(exe, exe, \"dhparam\", \"-out\", cnf, \"512\", (char *)0);\n\t\texit(1);\n\t}\n\tpidw = waitpid(pid, &status, 0); \n\tif (pidw != pid) {\n\t\treturn NULL;\n\t}\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\t/* append result: */\n\tin = fopen(cnf, \"r\");\n\tif (in == NULL) {\n\t\treturn NULL;\n\t}\n\tout = fopen(pem, \"a\");\n\tif (out == NULL) {\n\t\tfclose(in);\n\t\treturn NULL;\n\t}\n\twhile (fgets(line, 1024, in) != NULL) {\n\t\tfprintf(out, \"%s\", line);\n\t}\n\tfclose(in);\n\tfclose(out);\n#endif\n\n#endif\t/* FORK_OK */\n\n\tunlink(cnf);\n\tfree(exe);\n\n\tif (pathin != NULL) {\n\t\tchar *q, *pathcrt = strdup(pathin);\n\t\tFILE *crt = NULL;\n\t\tint on = 0;\n\n\t\tq = strrchr(pathcrt, '/');\n\t\tif (q) {\n\t\t\tq = strstr(q, \".pem\");\n\t\t\tif (q) {\n\t\t\t\t*(q+1) = 'c';\n\t\t\t\t*(q+2) = 'r';\n\t\t\t\t*(q+3) = 't';\n\t\t\t\tcrt = fopen(pathcrt, \"w\");\n\t\t\t}\n\t\t}\n\t\tif (crt == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathcrt);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tout = fopen(pathin, \"w\");\n\t\tchmod(pathin,  0600);\n\t\tif (out == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pathin);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(crt);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tin = fopen(pem, \"r\");\n\t\tif (in == NULL) {\n\t\t\trfbLog(\"could not open: %s\\n\", pem);\n\t\t\trfbLogPerror(\"fopen\");\n\t\t\tfclose(out);\n\t\t\tfclose(crt);\n\t\t\tunlink(pathin);\n\t\t\tunlink(pathcrt);\n\t\t\treturn NULL;\n\t\t}\n\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\ton = 1;\n\t\t\t}\n\t\t\tfprintf(out, \"%s\", line);\n\t\t\tif (on) {\n\t\t\t\tfprintf(crt, \"%s\", line);\n\t\t\t\tif (!quiet) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\ton = 0;\n\t\t\t}\n\t\t}\n\t\tfclose(in);\n\t\tfclose(out);\n\t\tfclose(crt);\n\t}\n\n\tif (show_cert) {\n\t\texe = find_openssl_bin();\n\t\tif (!exe) {\n\t\t\texe = strdup(\"openssl\");\n\t\t}\n\t\tif (strlen(pem) + strlen(exe) < 4000) {\n\t\t\tchar cmd[5000];\n\t\t\tif (inetd) {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s' 1>&2\", exe, pem);\n\t\t\t} else {\n\t\t\t\tsprintf(cmd, \"%s x509 -text -in '%s'\", exe, pem);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tsystem(cmd);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfree(exe);\n\t}\n\n\tif (pathin) {\n\t\tunlink(pem);\n\t\treturn strdup(pathin);\n\t} else {\n\t\treturn strdup(pem);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_env",
          "args": [
            "\"GENCERT_NOPROMPT\"",
            "\"1\""
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "set_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/util.c",
          "lines": "239-249",
          "snippet": "void set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"unixpw.h\"",
            "#include \"win_utils.h\"",
            "#include \"cleanup.h\"",
            "#include \"x11vnc.h\"",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void lowercase(char *str);",
            "void uppercase(char *str);",
            "char *lblanks(char *str);",
            "void strzero(char *str);",
            "void set_env(char *name, char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"unixpw.h\"\n#include \"win_utils.h\"\n#include \"cleanup.h\"\n#include \"x11vnc.h\"\n#include <stdlib.h>\n\nvoid lowercase(char *str);\nvoid uppercase(char *str);\nchar *lblanks(char *str);\nvoid strzero(char *str);\nvoid set_env(char *name, char *value);\n\nvoid set_env(char *name, char *value) {\n\tchar *str;\n\tif (! name) {\n\t\treturn;\n\t}\n\tif (! value) {\n\t\tvalue = \"\";\n\t}\n\n\tsetenv(name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&sbuf"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "grab_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/connections.c",
          "lines": "3178-3224",
          "snippet": "void grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"xrandr.h\"",
            "#include \"pointer.h\"",
            "#include \"userinput.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"win_utils.h\"",
            "#include \"xevents.h\"",
            "#include \"xwrappers.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"scan.h\"",
            "#include \"user.h\"",
            "#include \"unixpw.h\"",
            "#include \"screen.h\"",
            "#include \"rates.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"cleanup.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void grab_state(int *ptr_grabbed, int *kbd_grabbed);",
            "extern int rc_npieces;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"xrandr.h\"\n#include \"pointer.h\"\n#include \"userinput.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"win_utils.h\"\n#include \"xevents.h\"\n#include \"xwrappers.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"scan.h\"\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"screen.h\"\n#include \"rates.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"cleanup.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed);\nextern int rc_npieces;\n\nvoid grab_state(int *ptr_grabbed, int *kbd_grabbed) {\n\tint rcp, rck;\n\tdouble t0, t1;\n\tdouble ta, tb, tc;\n\t*ptr_grabbed = -1;\n\t*kbd_grabbed = -1;\n\n\tif (!dpy) {\n\t\treturn;\n\t}\n\t*ptr_grabbed = 0;\n\t*kbd_grabbed = 0;\n\n#if !NO_X11\n\tX_LOCK;\n\n\tXSync(dpy, False);\n\n\tta = t0 = dnow();\n\n\trcp = XGrabPointer(dpy, window, False, 0, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);\n\tXUngrabPointer(dpy, CurrentTime);\n\n\ttb = dnow();\n\t\n\trck = XGrabKeyboard(dpy, window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n\tXUngrabKeyboard(dpy, CurrentTime);\n\n\ttc = dnow();\n\n\tXSync(dpy, False);\n\n\tt1 = dnow();\n\n\tX_UNLOCK;\n\tif (rcp == AlreadyGrabbed || rcp == GrabFrozen) {\n\t\t*ptr_grabbed = 1;\n\t}\n\tif (rck == AlreadyGrabbed || rck == GrabFrozen) {\n\t\t*kbd_grabbed = 1;\n\t}\n\tif (rc_npieces < 10) {\n\t\trfbLog(\"grab_state: checked %d,%d in %.6f sec (%.6f %.6f)\\n\",\n\t\t    *ptr_grabbed, *kbd_grabbed, t1-t0, tb-ta, tc-tb);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "path",
            "\"%s/server%s.pem\"",
            "cdir",
            "s"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/server.pem\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cdir"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_up_exit",
          "args": [
            "1"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "clean_up_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/cleanup.c",
          "lines": "151-266",
          "snippet": "void clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}",
          "includes": [
            "#include \"xi2_devices.h\"",
            "#include \"uinput.h\"",
            "#include \"xevents.h\"",
            "#include \"xrecord.h\"",
            "#include \"screen.h\"",
            "#include \"avahi.h\"",
            "#include \"macosxCG.h\"",
            "#include \"macosx.h\"",
            "#include \"connections.h\"",
            "#include \"sslhelper.h\"",
            "#include \"sslcmds.h\"",
            "#include \"unixpw.h\"",
            "#include \"solid.h\"",
            "#include \"gui.h\"",
            "#include \"scan.h\"",
            "#include \"keyboard.h\"",
            "#include \"remote.h\"",
            "#include \"xdamage.h\"",
            "#include \"xwrappers.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void clean_up_exit(int ret);",
            "int known_sigpipe_mode(char *s);",
            "static int exit_flag = 0;",
            "static void clean_icon_mode(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xi2_devices.h\"\n#include \"uinput.h\"\n#include \"xevents.h\"\n#include \"xrecord.h\"\n#include \"screen.h\"\n#include \"avahi.h\"\n#include \"macosxCG.h\"\n#include \"macosx.h\"\n#include \"connections.h\"\n#include \"sslhelper.h\"\n#include \"sslcmds.h\"\n#include \"unixpw.h\"\n#include \"solid.h\"\n#include \"gui.h\"\n#include \"scan.h\"\n#include \"keyboard.h\"\n#include \"remote.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"x11vnc.h\"\n\nvoid clean_up_exit(int ret);\nint known_sigpipe_mode(char *s);\nstatic int exit_flag = 0;\nstatic void clean_icon_mode(void);\n\nvoid clean_up_exit(int ret) {\n\tstatic int depth = 0;\n\texit_flag = 1;\n\n\tif (depth++ > 2) {\n\t\texit(ret);\n\t}\n\n\tif (icon_mode) {\n\t\tclean_icon_mode();\n\t}\n\n\t/* remove the shm areas: */\n\tclean_shm(0);\n\n\tstop_stunnel();\n\tif (use_openssl) {\n\t\tssl_helper_pid(0, 0);\t/* killall */\n\t}\n\n\tif (ssh_pid > 0) {\n\t\tkill(ssh_pid, SIGTERM);\n\t\tssh_pid = 0;\n\t}\n\n#ifdef MACOSX\n\tif (client_connect_file) {\n\t\tif (strstr(client_connect_file, \"/tmp/x11vnc-macosx-remote\")\n\t\t    == client_connect_file) {\n\t\t\tunlink(client_connect_file);\n\t\t}\n\t}\n\tif (macosx_console) {\n\t\tmacosxCG_fini();\n\t}\n#endif\n\n\tif (pipeinput_fh != NULL) {\n\t\tpclose(pipeinput_fh);\n\t\tpipeinput_fh = NULL;\n\t}\n\n\tshutdown_uinput();\n\n\tif (unix_sock) {\n\t\tif (unix_sock_fd >= 0) {\n\t\t\trfbLog(\"deleting unix sock: %s\\n\", unix_sock);\n\t\t\tclose(unix_sock_fd);\n\t\t\tunix_sock_fd = -1;\n\t\t\tunlink(unix_sock);\n\t\t}\n\t}\n\n\tif (! dpy) {\t/* raw_rb hack */\n\t\tif (rm_flagfile) {\n\t\t\tunlink(rm_flagfile);\n\t\t\trm_flagfile = NULL;\n\t\t}\n\t\texit(ret);\n\t}\n\n\t/* X keyboard cleanups */\n\tdelete_added_keycodes(0);\n\n\t/* remove all created XInput2 devices */\n\tif(use_multipointer)\n\t    removeAllMDs(dpy);\n\n\tif (clear_mods == 1) {\n\t\tclear_modifiers(0);\n\t} else if (clear_mods == 2) {\n\t\tclear_keys();\n\t} else if (clear_mods == 3) {\n\t\tclear_keys();\n\t\tclear_locks();\n\t}\n\n\tif (no_autorepeat) {\n\t\tautorepeat(1, 0);\n\t}\n\tif (use_solid_bg) {\n\t\tsolid_bg(1);\n\t}\n\tif (ncache || ncache0) {\n\t\tkde_no_animate(1);\n\t}\n\tX_LOCK;\n\tXTestDiscard_wr(dpy);\n#if HAVE_LIBXDAMAGE\n\tif (xdamage) {\n\t\tXDamageDestroy(dpy, xdamage);\n\t}\n#endif\n#if HAVE_LIBXTRAP\n\tif (trap_ctx) {\n\t\tXEFreeTC(trap_ctx);\n\t}\n#endif\n\t/* XXX rdpy_ctrl, etc. cannot close w/o blocking */\n\tXCloseDisplay_wr(dpy);\n\tX_UNLOCK;\n\n\tfflush(stderr);\n\n\tif (rm_flagfile) {\n\t\tunlink(rm_flagfile);\n\t\trm_flagfile = NULL;\n\t}\n\n\tif (avahi) {\n\t\tavahi_cleanup();\n\t\tfflush(stderr);\n\t}\n\n\texit(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_saved_pem: could not find Cert dir.\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_Cert_dir",
          "args": [
            "NULL",
            "&tmp"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "get_Cert_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/sslcmds.c",
          "lines": "482-543",
          "snippet": "char *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}",
          "includes": [
            "#include \"connections.h\"",
            "#include \"ssltools.h\"",
            "#include \"sslhelper.h\"",
            "#include \"cleanup.h\"",
            "#include \"inet.h\"",
            "#include \"x11vnc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char *get_Cert_dir(char *cdir_in, char **tmp_in);",
            "void sslGenCA(char *cdir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"connections.h\"\n#include \"ssltools.h\"\n#include \"sslhelper.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in);\nvoid sslGenCA(char *cdir);\n\nchar *get_Cert_dir(char *cdir_in, char **tmp_in) {\n\tchar *cdir, *home, *tmp;\n\tstruct stat sbuf;\n\tint i;\n\tchar *cases1[] = {\"/.vnc\", \"/.vnc/certs\", \"/.vnc/certs/CA\"};\n\tchar *cases2[] = {\"\", \"/CA\", \"/tmp\"};\n\n\tif (cdir_in != NULL) {\n\t\tcdir = cdir_in;\n\t} else {\n\t\tcdir = ssl_certs_dir;\n\t}\n\n\tif (cdir == NULL) {\n\t\thome = get_home_dir();\n\t\tif (! home) {\n\t\t\treturn NULL;\n\t\t}\n\t\tcdir = (char *) malloc(strlen(home) + strlen(\"/.vnc/certs/CA\") + 1);\n\t\tfor (i=0; i<3; i++) {\n\t\t\tsprintf(cdir, \"%s%s\", home, cases1[i]);\n\t\t\tif (stat(cdir, &sbuf) != 0) {\n\t\t\t\trfbLog(\"creating dir: %s\\n\", cdir);\n\t\t\t\tif (mkdir(cdir, 0755) != 0) {\n\t\t\t\t\trfbLog(\"could not create directory %s\\n\", cdir);\n\t\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\t\trfbLog(\"not a directory: %s\\n\", cdir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsprintf(cdir, \"%s%s\", home, cases1[1]);\n\t}\n\n\ttmp = (char *) malloc(strlen(cdir) + strlen(\"/tmp\") + 1);\n\tfor (i=0; i<3; i++) {\n\t\tint ret;\n\t\tsprintf(tmp, \"%s%s\", cdir, cases2[i]);\n\t\tif (stat(tmp, &sbuf) != 0) {\n\t\t\trfbLog(\"creating dir: %s\\n\", tmp);\n\t\t\tif (! strcmp(cases2[i], \"/tmp\")) {\n\t\t\t\tret = mkdir(tmp, 0700);\n\t\t\t} else {\n\t\t\t\tret = mkdir(tmp, 0755);\n\t\t\t}\n\t\t\t\t\n\t\t\tif (ret != 0) {\n\t\t\t\trfbLog(\"could not create directory %s\\n\", tmp);\n\t\t\t\trfbLogPerror(\"mkdir\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (! S_ISDIR(sbuf.st_mode)) {\n\t\t\trfbLog(\"not a directory: %s\\n\", tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tsprintf(tmp, \"%s/tmp\", cdir);\n\t*tmp_in = tmp;\n\treturn cdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_saved_pem: invalid save string: %s\\n\"",
            "s"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "s",
            "'/'"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_saved_pem: invalid save string: %s\\n\"",
            "save"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"SAVE\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "save",
            "\"SAVE\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"SAVE_NOPROMPT\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "save",
            "\"SAVE_NOPROMPT\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"SAVE_PROMPT\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "save",
            "\"SAVE_PROMPT\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rfbLog",
          "args": [
            "\"get_saved_pem: save string is null.\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n#include \"user.h\"\n#include \"unixpw.h\"\n#include \"sslcmds.h\"\n#include \"connections.h\"\n#include \"scan.h\"\n#include \"screen.h\"\n#include \"cleanup.h\"\n#include \"inet.h\"\n#include \"x11vnc.h\"\n\nchar *get_saved_pem(char *string, int create);\nchar *create_tmp_pem(char *path, int prompt);\nstatic char *get_input(char *tag, char **in);\n\nchar *get_saved_pem(char *save, int create) {\n\tchar *s = NULL, *path, *cdir, *tmp;\n\tint prompt = 0, len;\n\tstruct stat sbuf;\n\n\tif (! save) {\n\t\trfbLog(\"get_saved_pem: save string is null.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tif (strstr(save, \"SAVE_PROMPT\") == save) {\n\t\tprompt = 1;\n\t\ts = save + strlen(\"SAVE_PROMPT\");\n\t} else if (strstr(save, \"SAVE_NOPROMPT\") == save) {\n\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\ts = save + strlen(\"SAVE_NOPROMPT\");\n\t} else if (strstr(save, \"SAVE\") == save) {\n\t\ts = save + strlen(\"SAVE\");\n\t} else {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", save);\n\t\tclean_up_exit(1);\n\t}\n\tif (strchr(s, '/')) {\n\t\trfbLog(\"get_saved_pem: invalid save string: %s\\n\", s);\n\t\tclean_up_exit(1);\n\t}\n\n\n\tcdir = get_Cert_dir(NULL, &tmp);\n\tif (! cdir || ! tmp) {\n\t\trfbLog(\"get_saved_pem: could not find Cert dir.\\n\");\n\t\tclean_up_exit(1);\n\t}\n\n\tlen = strlen(cdir) + strlen(\"/server.pem\") + strlen(s) + 1;\n\n\tpath = (char *) malloc(len);\n\tsprintf(path, \"%s/server%s.pem\", cdir, s);\n\n\tif (stat(path, &sbuf) != 0) {\n\t\tchar *new_name = NULL;\n\t\tif (create) {\n\t\t\tif (inetd || opts_bg) {\n\t\t\t\tset_env(\"GENCERT_NOPROMPT\", \"1\");\n\t\t\t}\n\t\t\tnew_name = create_tmp_pem(path, prompt);\n\t\t\tif (!getenv(\"X11VNC_SSL_NO_PASSPHRASE\") && !inetd && !opts_bg) {\n\t\t\t\tsslEncKey(new_name, 0);\n\t\t\t}\n\t\t}\n\t\treturn new_name;\n\t}\n\n\tif (! quiet) {\n\t\tchar line[1024];\n\t\tint on = 0;\n\t\tFILE *in = fopen(path, \"r\");\n\t\tif (in != NULL) {\n\t\t\trfbLog(\"\\n\");\n\t\t\trfbLog(\"Using SSL Certificate:\\n\");\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\twhile (fgets(line, 1024, in) != NULL) {\n\t\t\t\tif (strstr(line, \"BEGIN CERTIFICATE\")) {\n\t\t\t\t\ton = 1;\n\t\t\t\t}\n\t\t\t\tif (on) {\n\t\t\t\t\tfprintf(stderr, \"%s\", line);\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"END CERTIFICATE\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t\tif (strstr(line, \"PRIVATE KEY\")) {\n\t\t\t\t\ton = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tfclose(in);\n\t\t}\n\t}\n\treturn strdup(path);\n}"
  }
]